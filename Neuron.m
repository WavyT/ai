function varargout = Neuron(varargin)
% NEURON MATLAB code for Neuron.fig
%      NEURON, by itself, creates a new NEURON or raises the existing
%      singleton*.
%
%      H = NEURON returns the handle to a new NEURON or the handle to
%      the existing singleton*.
%
%      NEURON('CALLBACK',hObject,eventData,handles,...) calls the local
%      function named CALLBACK in NEURON.M with the given input arguments.
%
%      NEURON('Property','Value',...) creates a new NEURON or raises the
%      existing singleton*.  Starting from the left, property value pairs are
%      applied to the GUI before Neuron_OpeningFcn gets called.  An
%      unrecognized property name or invalid value makes property application
%      stop.  All inputs are passed to Neuron_OpeningFcn via varargin.
%
%      *See GUI Options on GUIDE's Tools menu.  Choose "GUI allows only one
%      instance to run (singleton)".
%
% See also: GUIDE, GUIDATA, GUIHANDLES

% Edit the above text to modify the response to help Neuron

% Begin initialization code - DO NOT EDIT
gui_Singleton = 1;
gui_State = struct('gui_Name',       mfilename, ...
                   'gui_Singleton',  gui_Singleton, ...
                   'gui_OpeningFcn', @Neuron_OpeningFcn, ...
                   'gui_OutputFcn',  @Neuron_OutputFcn, ...
                   'gui_LayoutFcn',  [] , ...
                   'gui_Callback',   []);
if nargin && ischar(varargin{1})
    gui_State.gui_Callback = str2func(varargin{1});
end
if nargout
    [varargout{1:nargout}] = gui_mainfcn(gui_State, varargin{:});
else
    gui_mainfcn(gui_State, varargin{:});
end
% End initialization code - DO NOT EDIT

function varargout = Neuron_OutputFcn(~,~,handles) 
varargout{1} = handles.output;

function Neuron_OpeningFcn(hObject,~,handles,varargin)
global panels Key video
addpath([pwd filesep 'mysubs']);
handles.output = hObject;
guidata(hObject, handles);
tic;
panels = [];
panels.root = handles.figure1;
set(panels.root,'Position',[0.0 0.0317 1 0.9375]);
set(panels.root,'KeyReleaseFcn',       {@MyKeyRelease});
set(panels.root,'WindowScrollWheelFcn',{@Timeklik,'scroller'});
set(panels.root,'KeyPressFcn',         {@MyKeyPress});
set(panels.root,'WindowButtonDownFcn', {@MyButton});
set(panels.root,'CloseRequestFcn',     {@MyExit});
Key = struct('shift',false,'alt',false,'control',false,'mouse','','last','');
%
panels.online      = true;
panels.mouse       = [];
panels.duur        = [];
panels.myboolean   = false;
panels.neversave   = false;
panels.filenr      = 0;
panels.segnr       = 0;
panels.camera      = 0;
panels.skipfit     = false;
panels.abort       = false;
panels.alwaysabort = false;
panels.NRNabort    = false;
panels.NRNbusy     = false;
panels.inconfig    = false;
panels.SpikeStatMode = 1;
%
panels.position  = [];
panels.wh        = [];
panels.h         = [];
panels.location  = [];
panels.slots     = [];
%
panels.lines     = [];
panels.linecolor = 'k';
%
panels.timegain  = 1;
panels.timefrmt  = '%9.2f';
panels.timetxt   = 'ms';
%
panels.PCAcomp   = [];
panels.informule = false;
panels.blankeron = false;
panels.selection = [];
panels.mainfig   = [];
panels.asktim{1} = 'dd-mmm-yyyy HH:MM:SSS';
panels.amplifier = 'AXON1';
panels.firststim = 50;
%
panels.run   = struct('select1',1,'select2',1);
panels.zoom  = struct('pnts',0,'rate',1,'tnul',0,'tend',0,'tbgn',0,'tlst',0);
panels.color = struct('zwart', [0 0 0],...
                      'wit',   [1 1 1],...
                      'blauw', [0 0 1],...
                      'groen', [0 1 0],...
                      'rood',  [1 0 0],...
                      'geel',  [1 1 0],...
                      'grey',  [1 1 1]*0.85,...
                      'dark',  [1,1,1]*0.75,...
                      'red',   [1 0.8 0.8],...
                      'blue',  [0.5 1 1],...
                      'yellow',[0.5 0.5 0],...
                      'green', [0.5 1 0.5]);
%
panels.fig.nr   = 2;
panels.fig.sub  = [1,1];
panels.fig.idx  = 0;
panels.fig.mar  = 0.0125;
%
panels.astrocam.use = false;
panels.astrocam.ask = false;
%
panels.video.cage   = 0;
panels.video.name   = [];
panels.video.time   = 0;
panels.video.segnr  = 0;
panels.video.zoom   = [];
panels.video.VLCpos = [];
%
panels.timer.delay  = 0.020;
%
panels.super.ans    = 0;
panels.super.abort  = false;
%
panels.cursor         = [];
panels.cursor.absnul  = 0;
panels.cursor.handle3 = [];
panels.cursor.cross   = [];
panels.cursor.crossset   = [];
panels.cursor.crosslines = [];
panels.cursor.times   = [0 0];
panels.cursor.index   = [0 0];
panels.cursor.rate    = 0;
panels.cursor.text1   = [];
panels.cursor.text2   = [];
panels.cursor.text3   = [];
panels.cursor.channel = 1;
panels.cursor.cpy     = 0;
panels.cursor.hhh     = [];
panels.cursor.femke   = [];
panels.cursor.fline   = [];
panels.cursor.smooth  = true;
%
panels.snap.on      = false;
panels.snap.nr      = 0;
panels.snap.dir     = false;
panels.snap.dirname = [];
%
panels.file.name   = 'C:\NRNdata\*.mat';
panels.file.scale  = 1000;
panels.file.unit   = 'mV';
panels.file.txtmax = 900;
panels.file.savepath = [];
panels.file.dir    = [];
panels.file.segdir = [];
panels.file.video  = [];
panels.file.root   = 'C:\NRNdata\';
panels.file.script = [fullfile(cd,'scripts')   filesep];
panels.file.proto  = [fullfile(cd,'protocols') filesep];
panels.file.mcc    = [panels.file.proto 'MCC'  filesep];
%
panels.stack.file = '*.mat';
panels.stacker(1).win   = {'9';'0';'0';'0'};
panels.stacker(1).valid = {1; 1; 1; 1;};
panels.stacker(1).txt   = {'adc';'adc';'dac';'dac'};
%
% panels.spectra.pcanode  = [];
% panels.spectra.pcaindex = [];
% panels.spectra.ncomp    = 3;
% panels.spectra.coefs    = [1 2];
% panels.spectra.coefscale = [-inf inf -inf inf];
%
video = struct('on',false,'resume',false,'run',false,'first',true,'nr',0,'frames',1,'size',[]);
Monitors;
set(gcf,'WindowState','maximize');
Resetall(false);

function [PANEL,handle] = getPANEL(panelname)
handle = findobj(1,'-depth',1,'Tag',panelname);
if isempty(handle), PANEL = []; else, PANEL = handle.UserData; end

function Resetall(ask)
global panels Memoryset Meting events minis mea cache graf timeline axon
if ~isempty(timerfindall)
    stop   (timerfindall);
    delete (timerfindall);
end
Error("clear",'Initialize');
if ask
    button = {'Yes';'Cancel'};
    if strcmp(questdlg('Reset DAQ?','Confirm',button{1},button{2},button{2}),button{2}), return; end
    WindowClear;
end
CMD = getPANEL('CMDpanel');
if isempty(CMD)
    CMD = Openpanel('CMDpanel',@CMD_Callback);
    set(CMD.protocol,'Visible','On');
end
KnobGrey([CMD.Prevfile,  CMD.Loaddata, CMD.Nextfile, CMD.super, CMD.hide,...
          CMD.startknob, CMD.eindknob, CMD.EEGrunL,  CMD.EEGrunR]);
timeline = struct('red',[],'blue',[],'green',[],...
                  'boundery',[-inf,inf],'left',true,...
                  'kxy',[],'kpar',[],'kidx',[],'par',[],'idx',[],'xy',[]);
SetMenu('version');
graf     = [];
axon     = struct('input',[],'output',[],'stim',[],'monitor',0,'interval',0.1,'disprate',0.5,'show',0);
axon.SEA = struct('tetamp',0,'inc',0,'min',zeros(20,1),'max',zeros(20,1),'sgn',ones(20,1));
axon.MCC = struct('chn',[], 'val',[]);
axon.ELS = struct('elec',[],'grp',[]);
axon.CAM = [];
minis    = [];
mea      = [];
cache    = [];
cache.status = false;
set(panels.root,'Pointer','arrow');
%
panels.online   = false;
panels.NRNabort = false;
panels.NRNbusy  = false;
panels.abort    = false;
panels.alwaysabort = false;
panels.slots = [];
panels.pars  = [];
panels.axon  = struct('Vh1',NaN,'Ih1',NaN,'Vs1',NaN,'Vr1',NaN,'gm1',NaN,'Vh2',NaN,'Ih2',NaN,'Vs2',NaN,'Vr2',NaN,'gm2',NaN,'Int1',NaN,'Int2',NaN);
%
events            = [];
events.dbase      = [];
events.segdir1    = [];
events.segdir2    = [];
events.files.name = [];
events.tmp.first  = NaN;
events.tmp.last   = NaN;
events.tmp.kanaal = 1;
Meting    = [];
Memoryset = {};
DAQdefine;
Error("box");
showdaqs;
DAQini(CMD,'swp');
DAQini(CMD,'eeg');
if ask
    if panels.online, Protocol_Test; end
    DoMusic(0);
end
NRNtimeline;
IMGini(true);
SpikeIni;
TriggerIni;
TemplateIni;
LoggerClear;
ClearFormula(CMD);
setplotter('basic',Meting,1,1,1);
Error("box");
drawnow;

function [versionnr] = getversion
versionnr = 1020000;

function SetMenu(txt)
global error
if strcmp(txt,'version')
    txt = sprintf('    Neuron (%04.1f) %s',getversion/1000);
elseif strcmp(txt,'error')
    txt = sprintf('    Neuron error: %s',error.text);
    DoMusic(0);
else
    txt = ['    ' txt];
end
set(gcf,'Name',txt);

function Message(txt)
uiwait(msgbox(sprintf('%s\n%s',txt,blanks(60)),'Message','none','modal'));

function Waitbar(CMD,modus,fraction,txt)
panel = CMD.waitbar.Parent;
if strcmp(modus,"hide"), panel.Visible = 'Off'; else
    if strcmpi(panel.Visible,'Off')
        tops = get(gcf,'Children');
        set(gcf,'Children',[panel; tops(tops~=panel)]);
        panel.Visible = 'On';
    end
    CMD.waitbar.Value   = min(fraction,1-CMD.waitbar.SliderStep(1));
    CMD.waittext.String = txt;
    pause(0.001);
end
%

function kleur = spkcolor(index)
hlp = [0.8 0.95 0.95;...
       0.95 0.8 0.95;...
       0.95 0.95 0.8;...
       0.8 0.80 0.95;...
       0.95 0.8 0.80;...
       0.8 0.95 0.80];
kleur = hlp(1+mod(index-1,6),1:3);

function correctorder(handle)
hhh = get(handle,'Children');
txt = get(hhh,'Type');
set(handle,'Children',[hhh(strcmp(txt,'line')); hhh(strcmp(txt,'text')); hhh(strcmp(txt,'patch'))]);

function Monitors
global panels
screen  = round(get(0,'MonitorPosition'));
panels.primair   = screen(1,:);
units = get(0,'Units');
set(0,'Units','characters');
tmp = get(0,'ScreenSize');
set(0,'Units',units);
panels.chars = tmp(3:4);
panels.secondair = panels.primair;
fprintf('\nPrimary monitor %d x %d\n',screen(1,3),screen(1,4));
if size(screen,1)>1
    fprintf(' Second monitor %d x %d\n',screen(2,3)-screen(2,1)-1, screen(2,4));
    if size(screen,1)>2
        fprintf('  Third monitor %d x %d\n',screen(3,3)-screen(3,1)+1, screen(3,4));
    end
    drawnow;
end
tmpunits = get(panels.root,'Units');
set(panels.root,'Units','pixels');
set(panels.root,'Position',panels.primair);
set(panels.root,'Units',tmpunits);
set(0,'DefaultFigurePosition',panels.primair);

function Blanker(txt)
persistent blanker ticker
switch txt
    case 'delete'
        delete(ticker);
        delete(blanker);
    case 'activate'
        drawnow();
        pos = get(0,'Screensize');
        blanker = figure  ('Toolbar','none','IntegerHandle','off','Menubar','none','NumberTitle','Off',...
                           'Units','pixels','Visible','off','Color',[0 0 0],'Position',pos);
        ticker  = uicontrol('String',' 00.00 ','ForegroundColor',[0.5 0 0],'BackgroundColor',[0 0 0],'Units','pixels',...
                           'FontUnits','Normalized','Fontsize',0.9,'Position',[pos(3)/3 pos(4)/2 pos(3)/4 pos(4)/5],'Style','text');
    case{'on';'off'}
        set(blanker,'Visible',txt);
    otherwise
        set(ticker,'String',txt);
end

function str = Unquote(str)
while true
    if isempty(str)
        return
    elseif str(1)==' '
        str(1) =[];
    elseif str(end)==' '
        str(end)=[];
    else
        break
    end
end
if (str(1)==char(39))&&(str(end)==char(39)), str([1 end]) = []; end


function strout = unifile(strin)
if ismac, strout = strrep(strin,'\','/'); else, strout = strrep(strin,'/','\'); end
%
%
function ToggleRed_Callback(hObject)
global panels
if isequal(get(hObject,'BackgroundColor'), panels.color.red), clr = panels.color.grey; else, clr = panels.color.red; end
set(hObject,'BackgroundColor',clr); 
drawnow;

function ToggleBlue_Callback(hObject)
global panels
if isequal(get(hObject,'BackgroundColor'), panels.color.blue), clr = panels.color.grey; else, clr = panels.color.blue; end
set(hObject,'BackgroundColor',clr); 
drawnow;

function status = KnobIsColor(hObjects,color)
status = false;
for jj =1:length(hObjects)
    if isequal(get(hObjects(jj),'BackgroundColor'),color), status = true; return; end
end

function KnobWhite(hObjects)
global panels
set(hObjects,'BackgroundColor',panels.color.wit); drawnow;

function KnobGrey(hObjects)
global panels
set(hObjects,'BackgroundColor',panels.color.grey); drawnow;

function KnobDark(hObjects)
global panels
set(hObjects,'BackgroundColor',panels.color.dark); drawnow;

function KnobRed(hObjects)
global panels
set(hObjects,'BackgroundColor',panels.color.red); drawnow;

function KnobBlue(hObjects)
global panels
set(hObjects,'BackgroundColor',panels.color.blue); drawnow;

function KnobGreen(hObjects)
global panels
set(hObjects,'BackgroundColor',panels.color.green); drawnow;

function KnobYellow(hObjects)
global panels
set(hObjects,'BackgroundColor',panels.color.geel); drawnow;

function status = KnobIsGrey(hObjects)
global panels
status = KnobIsColor(hObjects,panels.color.grey);

function status = KnobIsDark(hObjects)
global panels
status = KnobIsColor(hObjects,panels.color.dark);

function status = KnobIsRed(hObjects)
global panels
status = KnobIsColor(hObjects,panels.color.red);

function status = KnobIsBlue(hObjects)
global panels
status = KnobIsColor(hObjects,panels.color.blue);

function status = KnobIsGreen(hObjects)
global panels
status = KnobIsColor(hObjects,panels.color.green);

function status = KnobIsYellow(hObjects)
global panels
status = KnobIsColor(hObjects,panels.color.geel);

function MyKeyRelease(~,~)
global panels Key
Key.shift   = false;
Key.alt     = false;
Key.control = false;
set(panels.root,'KeyPressFcn',{@MyKeyPress})

function MyKeyPress(~,evt)
global panels Key SEL
CMD = getPANEL('CMDpanel');
switch evt.Key
    case 'shift',   Key.shift   = true;
    case 'alt',     Key.alt     = true;
    case 'control', Key.control = true;
    case 'rightarrow', CMDeeg(CMD,CMD.EEGforward1);
    case 'leftarrow',  CMDeeg(CMD,CMD.EEGbackward1);
    case 'uparrow',    chn = str2double(get(SEL.select3,'String')); set(SEL.select3,sprintf('%u',chn-1)); Redraw(1);
    case 'downarrow',  chn = str2double(get(SEL.select3,'String')); set(SEL.select3,sprintf('%u',chn-1)); Redraw(1);
end
set(panels.root,'KeyPressFcn','');

function MyButton(~,~)

function MyExit(~,~)
global panels
CMD = getPANEL('CMDpanel');
if ishandle(panels.h)
    delete(panels.h);
    panels.h = [];
end
if KnobIsBlue(CMD.ScriptSave)
    [filename,filepath] = uiputfile('*.txt','You have an unsaved Script!',panels.file.script);
    if filename~=0
        panels.file.script = fullfile(filepath,filename);
        Script_Save(CMD);
    end
end
if KnobIsBlue(CMD.ProtocolSave)
    [filename,filepath] = uiputfile('*.txt','You have an unsaved protocol!',panels.file.proto);
    if filename~=0
        panels.file.proto = fullfile(filepath,filename);
        Protocol_Save(CMD);
    end
end
delete(panels.root)
%

function TemplateIni
global spikes 
spikes.err      = [];
spikes.gain     = [];
spikes.off      = [];
spikes.fact     = [];
spikes.template = [];
spikes.tmpnul   = [];
spikes.tmprng   = [];

function TriggerIni
global spikes
spikes.trg.trg1    = [];
spikes.trg.trg2    = [];
spikes.trg.lvl     = [];
spikes.trg.source  = 'none';

function SpikeIni
global spikes
spikes.spktlvl = [];
spikes.spklvl  = [];
spikes.spktmax = [];
spikes.spkmax  = [];
spikes.spktmin = [];
spikes.spkmin  = [];
spikes.minis   = [];
spikes.times   = [];
spikes.class   = [];
spikes.mask    = [];
spikes.nlvl    = [];
spikes.nspk    = [];
spikes.adcchan = [];
spikes.adcrate = [];
spikes.adcdrmp = [];
spikes.adcunit = [];
spikes.sync    = [];
spikes.method  = [];
spikes.xydata  = [];
spikes.xyname  = [];
spikes.classname = [];
spikes.maskname  = [];
spikes.abstime = 0;
spikes.classname{1,1} = 'spike';
spikes.maskname{1,1}  = 'none';

function Timescale(CMD,mode)
global panels
handles = [CMD.ms, CMD.sec, CMD.min, CMD.hrs];
switch mode
    case 'ms',  on = 1; off = [2,3,4]; panels.timefrmt = '%9.2f'; panels.timegain = 1;
    case 'sec', on = 2; off = [1,3,4]; panels.timefrmt = '%9.3f'; panels.timegain = 1000;
    case 'min', on = 3; off = [1,2,4]; panels.timefrmt = '%9.3f'; panels.timegain = 60000;
    case 'hrs', on = 4; off = [1,2,3]; panels.timefrmt = '%9.5f'; panels.timegain = 3600000;
end
set(handles(on), 'Value',1);
set(handles(off),'Value',0);
panels.timetxt = mode;
showdaqpars;
if ~panels.online
    DB = getPANEL('DBpanel');
    if ~isempty(DB)
        set(DB.left, 'String',sprintf(panels.timefrmt,DB.left.Value/panels.timegain));
        set(DB.right,'String',sprintf(panels.timefrmt,DB.right.Value/panels.timegain));
        if ~contains(DB.marlft.String,'%')
            DB.marlft.String = sprintf(panels.timefrmt,DB.marlft.Value/panels.timegain);
        end
        if ~contains(DB.marrgt.String,'%')
            DB.marrgt.String = sprintf(panels.timefrmt,DB.marrgt.Value/panels.timegain);
        end
    end
end
drawnow;

function DoTestwait(wait,varargin)
global panels
CMD = getPANEL('CMDpanel');
if get(CMD.scriptstep,'Value')
    if nargin>1, txt = varargin{1}; else, txt = panels.last.cmd; end
    button1 = 'Next Step';
    button2 = 'Continue - W';
    button3 = 'Continue + W';
    button = questdlg(txt,'Step execute',button1,button2,button3,button2);
    switch button
        case button1
        case button2, set(CMD.scriptstep,'Value',0); set(CMD.scriptwait,'Value',1);
        case button3, set(CMD.scriptstep,'Value',0); set(CMD.scriptwait,'Value',0);
    end
else
    waitstr = get(CMD.pause,'String'); if isempty(wait), wait = str2double(waitstr); end
    if get(CMD.scriptwait,'value') || (wait==0), return; end
    set(CMD.pause,'BackgroundColor',[1.0 0.8 0.8]);
    while wait>0
        set(CMD.pause,'String',sprintf('%4.1f',wait));
        pause(0.1);
        wait = wait-0.1;
    end
    set(CMD.pause,'String',waitstr,'BackgroundColor',[1 1 0]);
end
%
%
function handle = getplothandle(parms,clearem)
global panels graf timeline
if isnumeric(parms), wnr = abs(parms); else, wnr = nsingle(parms); end
%   
grafnr = [];
if ~isempty(graf), grafnr = find([graf.window]==wnr,1); end
set(0,'CurrentFigure',panels.root);
if isempty(grafnr)
    grafnr = length(graf)+1;
    handle = axes(panels.root,'Position',getwindow(wnr),'FontSize',8,'Units','Normalized');
    graf(grafnr,1).handle = handle;
    graf(grafnr,1).window = wnr;
    graf(grafnr,1).cursor = 0;
    graf(grafnr,1).fig = panels.root;
    graf(grafnr,1).bld = 0;
    graf(grafnr,1).eeg = false;
    graf(grafnr,1).swp = false;
    text(0,1,'','Color','k','Tag','TOPLFT','Units','Normalized',...
                'HorizontalAlignment','Left','VerticalAlignment','Top',...
                'Fontsize',12,'Fontname','Courier');
    text(1,1,'','Color','k','Tag','TOPRGT','Units','Normalized',...
                'HorizontalAlignment','Right','VerticalAlignment','Top',...
                'Fontsize',12,'Fontname','Courier','Interpreter','none');
    text(0,0,'','Color','k','Tag','BOTLFT','Units','Normalized',...
                'HorizontalAlignment','Left','VerticalAlignment','Bottom',...
                'Fontsize',12,'Fontname','Courier','Interpreter','none');
    text(1,0,'','Color','k','Tag','BOTRGT','Units','Normalized',...
                'HorizontalAlignment','Right','VerticalAlignment','Bottom',...
                'Fontsize',12,'Fontname','Courier','Interpreter','none');
    text(0,0.55,'','Color','k','Tag','LEGYAS','Units','Normalized',...
                'HorizontalAlignment','Right','VerticalAlignment','Bottom',...
                'Fontsize',12,'Fontname','Courier','Interpreter','none');
else
    handle = graf(grafnr).handle;
    set(handle,'Visible','on','Units','Normalized');
    if clearem
        chld = get(handle,'Children');
        tags = get(chld,'Tag');
        todel = true(length(chld),1);
        todel(strcmp(tags,'LEGYAS')) = false;
        todel(strcmp(tags,'TOPLFT')) = false;
        todel(strcmp(tags,'TOPRGT')) = false;
        todel(strcmp(tags,'BOTLFT')) = false;
        todel(strcmp(tags,'BOTRGT')) = false;
        delete(chld(todel))
        if ~isempty(timeline.par), timeline.par(timeline.par(:,4)==wnr,4)=0; end
    end
end
set(panels.root,'CurrentAxes',handle);

function WindowClear(varargin)
global graf panels timeline
CMD = getPANEL('CMDpanel');
Waitbar(CMD,'hide');
if isempty(graf), return; end
if (nargin==0) || isempty(varargin{1}) 
    nrs = 1:length(graf);
elseif strcmp(varargin{1},'eeg')
    nrs = [graf.eeg];
elseif strcmp(varargin{1},'swp')
    nrs = [graf.swp];
elseif isnumeric(varargin{1})
    [~,nrs] = intersect([graf.window],varargin{1});
end
doit = false;
nrs = sort(nrs,'descend');
for die = nrs(:)'
    if ~isempty(timeline.par)
        timeline.par(timeline.par(:,4)==graf(die).window,4)=0;
        doit = true;
    end
    delete(graf(die).handle);
    graf(die) = [];
end
if doit, rodestippen; end
panels.NRNabort  = false;
panels.NRNbusy   = false;
%
%
function [device,local,unichans] = ADCdev(unichans)
global DAQ
adcs = [];
adcd = [];
devs = [];
for jj = find(strcmp({DAQ.type},'nidaq'))
    adcmax = length(DAQ(jj).ADC.HWchn);
    adcs = [adcs (1:adcmax)+DAQ(jj).ADC.HWoff];
    adcd = [adcd (1:adcmax)];
    devs = [devs jj+0*(1:adcmax)];
end
[~,index] = intersect(adcs,unichans);
local  = adcd(index);
device = devs(index);

function [device,local,unichans] = DACdev(unichans)
global DAQ
dacs = [];
dacd = [];
devs = [];
for jj = find(strcmp({DAQ.type},'nidaq'))
    dacmax = length(DAQ(jj).DAC.HWchn);
    dacs = [dacs (1:dacmax)+DAQ(jj).DAC.HWoff];
    dacd = [dacd (1:dacmax)];
    devs = [devs jj+0*(1:dacmax)];
end
[~,index] = intersect(dacs,unichans);
local  = dacd(index);
device = devs(index);

function DAQ_ADC_scaling(adcs,adcgain,usermax,name,unit,junction,kleur)
global DAQ
for jj = 1:length(adcs)
    [device,ladc] = ADCdev(adcs(jj));
    if isempty(device) || isempty(ladc) || ~ismember(ladc,1:length(DAQ(device).ADC.HWchn))
        Error('Define nonexisting ADCs'); return
    else
        if ~isempty(name), DAQ(device).ADC.scale(ladc,1).Name = name; end
        DAQ(device).ADC.scale(ladc,1).Hardware = [-10 10] /adcgain;
        DAQ(device).ADC.scale(ladc,1).User     = usermax / adcgain;
        DAQ(device).ADC.scale(ladc,1).Units    = unit;
        DAQ(device).ADC.scale(ladc,1).junction = junction;
        if ~isempty(kleur), DAQ(device).ADC.scale(ladc,1).Color = kleur; end
    end
end

function DAQ_DAC_scaling(dacs,usermax,name,unit,junction,kleur)
global DAQ
for jj = 1:length(dacs)
    [device,ldac] = DACdev(dacs(jj));
    if isempty(device) || isempty(ldac) || ~ismember(ldac,1:length(DAQ(device).DAC.HWchn))
        Error('Define nonexisting DACs'); return;
    else
        DAQ(device).DAC.scale(ldac,1).Name     = name;
        DAQ(device).DAC.scale(ldac,1).User     = usermax;
        DAQ(device).DAC.scale(ldac,1).Units    = unit;
        DAQ(device).DAC.scale(ldac,1).junction = junction;
        DAQ(device).DAC.scale(ldac,1).Color    = kleur;
    end
end

function fout = ADCchannels(device,adcs)
global DAQ
fout = false;
remake = false;
channels = [DAQ(device).adc.Channel.HwChannel]';
if length(channels)>1, channels = cell2mat(channels); end
if ~isequal(adcs-1,channels)
	delete(DAQ(device).adc.Channel);
    try
        addchannel(DAQ(device).adc,adcs-1);
        remake = true;
    catch
        questdlg('Channel does not exist','Use Reset to continue','Reset','Wrong channel','Reset');
        fout = true;
        return
    end
end
hlp = [DAQ(device).ADC.scale(adcs).Hardware];
adcgain = hlp(1:2);
if length(unique(hlp(hlp>0)))>1
    Error('Hardware gain for all channels must be the same');
    fout = true;
    return
end
if ~isequal(DAQ(device).adc.Channel(1).InputRange,adcgain) || remake
    for jj = 1:length(adcs)
        DAQ(device).adc.Channel(jj).InputRange  = adcgain;
        DAQ(device).adc.Channel(jj).SensorRange = adcgain;
        DAQ(device).adc.Channel(jj).UnitsRange  = DAQ(device).ADC.ints * [-1 1];
    end
    getsample(DAQ(device).adc);
end

function DACchannels(device,dacs)
global DAQ
channels = [DAQ(device).dac.Channel.HwChannel]';
if length(channels)>1, channels = cell2mat(channels); end
if ~isequal(dacs-1,channels)
    delete(DAQ(device).dac.Channel);
	addchannel(DAQ(device).dac,dacs-1);
    for jj = 1:length(dacs)
        DAQ(device).dac.Channel(jj).UnitsRange  = DAQ(device).DAC.ints * [-1 1];
    end
end

function [adcdev,adcloc,adchwc,adcidx] = ADCinput(adcs)
global axon
[~,adcidx] = intersect([axon.input.channel],adcs);
adcdev = [axon.input(adcidx).device];
adcloc = [axon.input(adcidx).local];
adchwc = [axon.input(adcidx).channel];

function [dacdev,dacloc,dachwc,dacidx] = DACoutput(dacs)
global axon
[~,dacidx] = intersect([axon.output.channel],dacs);
dacdev = [axon.output(dacidx).device];
dacloc = [axon.output(dacidx).local];
dachwc = [axon.output(dacidx).channel];

function ADCini(infos,device,adctype)
global DAQ
is6009 = strcmp(infos.DeviceName,'USB-6009');
DAQ(device).adc.InputType = adctype;
if strcmp(adctype,'Differential')
    adcs = 1+infos.DifferentialIDs;
else
    adcs = 1+infos.SingleEndedIDs;
end
DAQ(device).ADC.bits = infos.Bits;
DAQ(device).ADC.ints = double(intmax('int16'));
if isempty(find(infos.InputRanges(:,2)==10, 1))
    Error(sprintf('Board %s does not have a adc scales[-10,10]',DAQ(device).BoardName));
    return
end
DAQ(device).ADC.HWchn = 1:length(adcs);
DAQ(device).ADC.HWoff = 0;
DAQ(device).ADC.ClockSource  = 'Internal';
DAQ(device).ADC.ClockChannel = [];
DAQ(device).ADC.ExternalScanClockSource = '';
DAQ(device).ADC.Gains = infos.Gains;
DAQ(device).ADC.scale = [];
delete(DAQ(device).adc.Channel);
addchannel(DAQ(device).adc,adcs-1);
for chn = DAQ(device).ADC.HWchn
    DAQ(device).ADC.scale(chn,1).Name     = '';
    DAQ(device).ADC.scale(chn,1).Hardware = [-10 10];
    DAQ(device).ADC.scale(chn,1).User     = DAQ(device).ADC.ints;
    DAQ(device).ADC.scale(chn,1).Units    = 'V';
    DAQ(device).ADC.scale(chn,1).HWchn    = chn;
	if is6009
        range = [-10 10];
        DAQ(device).ADC.scale(chn,1).Hardware = range;
        hlp = setverify(DAQ(device).adc.Channel(chn),'InputRange',range);
        if ~isequal(hlp,range), Error(sprintf('range [%0.1f %0.1f] does not exist',range)); return; end
        DAQ(device).adc.Channel(chn).SensorRange = range;
        DAQ(device).adc.Channel(chn).UnitsRange  = DAQ(device).ADC.ints * [-1 1];
    else
        DAQ(device).ADC.scale(chn,1).Hardware = [-10 10];
        DAQ(device).ADC.scale(chn,1).junction = 0;
        DAQ(device).ADC.scale(chn,1).Group    = 0;
        DAQ(device).ADC.scale(chn,1).Subgroup = 0;
        DAQ(device).ADC.scale(chn,1).Color    = 'k';
        hlp = setverify(DAQ(device).adc.Channel(chn),'InputRange',[-10 10]);
        if ~isequal(hlp,[-10 10]), Error('range [-10 10] does not exist'); return; end
        DAQ(device).adc.Channel(chn).SensorRange = [-10 10];
        DAQ(device).adc.Channel(chn).UnitsRange  = DAQ(device).ADC.ints * [-1 1];
	end
end

function DACini(infos,device)
global DAQ
dacs  = 1:infos.TotalChannels;
is6009 = strcmp(DAQ(device).BoardName,'USB-6009');
DAQ(device).DAC.bits   = infos.Bits;
DAQ(device).DAC.ints   = double(intmax('int16'));
DAQ(device).DAC.HWchn  = dacs;
DAQ(device).DAC.HWoff  = 0;
DAQ(device).DAC.repeat = 0;
DAQ(device).DAC.values = zeros(length(dacs),1);
if is6009
    outputrange = [0 5];
    dacrange    = [0 5];
elseif strcmp(DAQ(device).BoardName,'USB-3105')
    outputrange = [0 10];
    dacrange    = [0 1000];
    DAQ(device).MCC(dacs,1) = 0;
    DAQ(device).MCC(dacs,2) = 1000;
    DAQ(device).MCC(dacs,3) = 0;
else
    DAQ(device).MCC = [];
    if isempty(find(infos.OutputRanges(:,2)==10, 1))
        Error(sprintf('Board %s does not have a dacsscale [-10,10]',DAQ(device).BoardName));
    end
    outputrange = [-10 10];
    dacrange    = DAQ(device).DAC.ints*[-1 1];
end
delete(DAQ(device).dac.Channel);
if is6009, DAQ(device).dac.Samplerate=75; end
addchannel(DAQ(device).dac,dacs-1);
DAQ(device).DAC.scale = [];
for chn = dacs
    DAQ(device).DAC.scale(chn,1).Name     = '';    
    DAQ(device).DAC.scale(chn,1).Hardware = outputrange;
    DAQ(device).DAC.scale(chn,1).User     = dacrange(2);
    DAQ(device).DAC.scale(chn,1).Units    = 'V';
    DAQ(device).DAC.scale(chn,1).HWchn    = chn;
    if is6009
        hlp = setverify(DAQ(device).dac.Channel(chn),'OutputRange',outputrange);
        if ~isequal(hlp,outputrange), Error(sprintf('range [%0.1f, %0.1f] does not exist',outputrange)); return; end
        DAQ(device).dac.Channel(chn).UnitsRange = dacrange;
    else
        DAQ(device).DAC.scale(chn,1).junction = 0;
        DAQ(device).DAC.scale(chn,1).Group    = 0;
        DAQ(device).DAC.scale(chn,1).Subgroup = 0;
        DAQ(device).DAC.scale(chn,1).Color    = 'k';
        hlp = setverify(DAQ(device).dac.Channel(chn),'OutputRange',outputrange);
        if ~isequal(hlp,outputrange), Error(sprintf('range [%0.1f, %0.1f] does not exist',outputrange)); return; end
        DAQ(device).dac.Channel(chn).UnitsRange = dacrange;
    end
end

function DIOini(device)
global DAQ
infos = daqhwinfo(DAQ(device).dio);
DAQ(device).DIO.lines1   = [];
DAQ(device).DIO.lines2   = [];
DAQ(device).DIO.lines3   = [];
DAQ(device).DIO.lines4   = [];
DAQ(device).DIO.inlines  = [];
DAQ(device).DIO.outlines = [];
DAQ(device).DIO.digiout  = [];
DAQ(device).TRG.out      = [];
DAQ(device).TRG.in       = [];
switch length(infos.Port)
    case 4
        DAQ(device).DIO.lines1    = addline(DAQ(device).dio,0:(length(infos.Port(1).LineIDs)-1),0,'Out');
        DAQ(device).DIO.lines2    = addline(DAQ(device).dio,0:(length(infos.Port(2).LineIDs)-1),1,'Out');
        DAQ(device).DIO.lines3    = addline(DAQ(device).dio,0:(length(infos.Port(3).LineIDs)-1),2,'Out');
        DAQ(device).DIO.lines4    = addline(DAQ(device).dio,0:(length(infos.Port(4).LineIDs)-1),3,'Out');
        DAQ(device).DIO.outlines  = [DAQ(device).DIO.lines3; DAQ(device).DIO.lines4; DAQ(device).DIO.lines1; DAQ(device).DIO.lines2];
    case 3
        DAQ(device).DIO.lines1    = addline(DAQ(device).dio,0:(length(infos.Port(1).LineIDs)-1),0,'Out');
        DAQ(device).DIO.lines2    = addline(DAQ(device).dio,0:(length(infos.Port(2).LineIDs)-1),1,'In');
        DAQ(device).DIO.lines3    = addline(DAQ(device).dio,0:(length(infos.Port(3).LineIDs)-1),2,'Out');
        DAQ(device).DIO.inlines   = [DAQ(device).DIO.lines2]; 
        DAQ(device).DIO.outlines  = [DAQ(device).DIO.lines1; DAQ(device).DIO.lines3];
    case 2
        if strcmp(infos.Port(2).Direction,'in')
            DAQ(device).DIO.lines2 = addline(DAQ(device).dio,0:(length(infos.Port(2).LineIDs)-1),1,'In');
        elseif strcmp(infos.Port(2).Direction,'out')
            DAQ(device).DIO.lines3 = addline(DAQ(device).dio,0:(length(infos.Port(2).LineIDs)-1),1,'Out');
        else
            DAQ(device).DIO.lines2 = addline(DAQ(device).dio,0:(length(infos.Port(2).LineIDs)-1),1,'In');
        end
        if strcmp(infos.Port(1).Direction,'in')
            DAQ(device).DIO.lines2 = addline(DAQ(device).dio,0:(length(infos.Port(1).LineIDs)-1),0,'In');
        elseif strcmp(infos.Port(1).Direction,'out')
            DAQ(device).DIO.lines3 = addline(DAQ(device).dio,0:(length(infos.Port(1).LineIDs)-1),0,'Out');
        else
            DAQ(device).DIO.lines3 = addline(DAQ(device).dio,0:(length(infos.Port(1).LineIDs)-1),0,'Out');
        end
        DAQ(device).DIO.inlines  = [DAQ(device).DIO.lines2]; 
        DAQ(device).DIO.outlines = [DAQ(device).DIO.lines3];
    case 1
        DAQ(device).DIO.lines3   = addline(DAQ(device).dio,0:(length(infos.Port(1).LineIDs)-1),0,'Out');
        DAQ(device).DIO.inlines  = []; 
        DAQ(device).DIO.outlines = [DAQ(device).DIO.lines3];
    otherwise
end

function Setrelais
global DAQ SEL
dev1 = find([DAQ.bank]==1);
dev2 = find([DAQ.bank]==2);
els = cell2mat(get(SEL.sth,'Value'));
bank =zeros(24,1);
bank(1:2:16) = els(1:8);
bank(2:2:16) = els(1:8);
if ~isequal(bank,DAQ(dev2).DIO.digiout)
    putvalue(DAQ(dev2).DIO.outlines,bank);
    DAQ(dev2).DIO.digiout = bank;
end
bank(1:2:16) = els(9:16);
bank(2:2:16) = els(9:16);
if ~isequal(bank,DAQ(dev1).DIO.digiout)
    putvalue(DAQ(dev1).DIO.outlines,bank);
    DAQ(dev1).DIO.digiout = bank;
end

function showdaqs
global DAQ DAQrbp axon
if isempty(DAQ)
    disp('No hardware (NI or MCC) present');
    Setonlinemode(false);
else
    ninum = length(find(strcmp({DAQ.type},'nidaq')));
    for jj = 1:ninum
        if jj==axon.monitor
            naam = [DAQ(jj).BoardName ' (monitor)'];
        else
            naam = DAQ(jj).BoardName;
        end
        set(daqhandles(jj),'Visible','on','FontSize',0.7,'String',naam);
    end    
    num = length(DAQrbp);
    for jj = 1:num
        ninum = ninum + 1;
        set(daqhandles(ninum),'Visible','on','FontSize',0.7,'String',[DAQrbp(jj).BoardName ' for Raspberry']);
    end
    num = length(find(strcmp({DAQ.BoardName},'USB-ERB24')));
    if num>0
        ninum = ninum + 1;
        set(daqhandles(ninum),'Visible','on','FontSize',0.7,'String',sprintf('USB-ERB24 (%u)',num));
    end
    num = length(find(strcmp({DAQ.BoardName},'USB-3105')));
    if num>0
        ninum = ninum + 1;
        set(daqhandles(ninum),'Visible','on','FontSize',0.7,'String',sprintf('USB-3105 (%u)',num));
    end
    ninum = ninum + 1;
    set(daqhandles(ninum:end),'Visible','off');
end

function newrate = SetRate(device,modus,node)
global DAQ
if strcmp(modus,'adc')
    infos = propinfo(DAQ(device).adc,'SampleRate');
    numchan = length(DAQ(device).ADC.HWchn);
    rate = node.ADC.rate;
else
    infos = propinfo(DAQ(device).dac,'SampleRate');
    length(DAQ(device).DAC.HWchn);
    rate =  node.DAC.rate;
end
if rate>infos.ConstraintValue(2)
    Error(sprintf('DAQ %s device(%u) #channels(%u)\n\nSamplerate (%0.0f kHz) to high (max: %0.0f kHz)',...
              modus,device, numchan, rate,infos.ConstraintValue(2)));
    newrate = infos.ConstraintValue(2);
else
    newrate = rate;
end

function DAQdefine
global DAQ DAQrbp
try
    outmain = daqhwinfo;
catch
    return
end
Error("clear",'Hardware');
adcmodes = [];
if ~isempty(DAQ)
    for jj = 1:length(DAQ)
        if isempty(DAQ(jj).adc), adcmodes{jj} = ''; else,adcmodes{jj} = DAQ(jj).adc.InputType; end
    end
    try
        if ~isempty(daqfind)
            stop(daqfind);
            delete(daqfind);
            clear daqfind;
        end
    catch
    end
    DAQ = [];
end
adcs   = 0;
dacs   = 0;
device = 0;
bank   = 0;
soort = {'nidaq';'mcc'};
for kk = 1:2
    if isempty(find(strcmp(outmain.InstalledAdaptors,soort{kk}),1)), continue; end
    out = daqhwinfo(soort{kk});
    [~,numboards] = size(out.BoardNames);
    volgorde = 1:numboards;
    if strcmp(soort{kk},'nidaq')
        usb6009 = find(strcmp(out.BoardNames,'USB-6009'));
        anders = setdiff(volgorde,usb6009);
        [~,volgorde] = sort(out.BoardNames(anders));
        volgorde = [anders(volgorde(end:-1:1)),usb6009];
    end
    for ii = 1:numboards
        die = volgorde(ii);
        if isempty(out.ObjectConstructorName{die,1}) && ...
           isempty(out.ObjectConstructorName{die,2}) && ...
           isempty(out.ObjectConstructorName{die,3}), continue
        end
        device = device + 1;
        DAQ(device,1).type             = soort{kk};
        DAQ(device,1).BoardName        = char(out.BoardNames{1,die});
        DAQ(device,1).InstalledBoardId = char(out.InstalledBoardIds{1,die});
        if isempty(strfind(DAQ(device,1).BoardName,'ERB24'))
            DAQ(device,1).bank = 0;
        else
            bank = bank + 1;
            DAQ(device,1).bank = bank;
        end
        fprintf('\nBoard(%u):  %s\n',device,DAQ(device).BoardName);
        if isempty(out.ObjectConstructorName{die,1})
            DAQ(device).adc = [];
        else
            DAQ(device).adc = analoginput(DAQ(device).type,DAQ(device).InstalledBoardId);
            infos = daqhwinfo(DAQ(device).adc);
            if strcmp(DAQ(device).BoardName,'USB-6009')
                adctype = 'Differential';
            elseif isempty(adcmodes)
                adctype = 'NonReferencedSingleEnded';
            else
                adctype = adcmodes{device};
            end
            ADCini(infos,device,adctype);
            if Error, return; end
            DAQ(device).ADC.HWoff = adcs;
            adcs = adcs + length(DAQ(device).ADC.HWchn);
            fprintf('ADC configuration: %s\n',DAQ(device).adc.InputType);
            fprintf(['Gains ' sprintf(' %0.1f',10./infos.InputRanges(:,2)) '\n']);
            fprintf('ADC %02u channels, samplerate: %4.1f Hz - %6.1f kHz\n',length(DAQ(device).ADC.HWchn),infos.MinSampleRate,infos.MaxSampleRate/1000);
        end
        if isempty(out.ObjectConstructorName{die,2})
            DAQ(device).dac = [];
        else
            DAQ(device).dac = analogoutput(DAQ(device).type,DAQ(device).InstalledBoardId);
            infos = daqhwinfo(DAQ(device).dac);
            DACini(infos,device);
            if Error, return; end
            DAQ(device).DAC.HWoff = dacs; 
            dacs = dacs + length(DAQ(device).DAC.HWchn);
            fprintf('DAC %02u channels, samplerate: %4.1f Hz - %6.1f kHz\n',length(DAQ(device).DAC.HWchn), infos.MinSampleRate, infos.MaxSampleRate/1000);
        end
        if isempty(out.ObjectConstructorName{die,3})
            DAQ(device).dio = [];
        else
            DAQ(device).dio = digitalio(DAQ(device).type,DAQ(device).InstalledBoardId);
            DIOini(device);            
            fprintf('DIO-system %02u outlines   %02u inlines \n',length(DAQ(device).DIO.outlines),length(DAQ(device).DIO.inlines));
            if DAQ(device).bank>0, fprintf('Relais bank nr %u\n',DAQ(device).bank); end
        end
        if Error, return; end
    end
end
if isempty(DAQ), return; end
fprintf('\n');
nidaqs = find(strcmp({DAQ.type},'nidaq'));
for outdev = nidaqs
    if ~isempty(DAQ(outdev).DIO.outlines)
        ovec = zeros(1,length(DAQ(outdev).DIO.outlines));
        for indev = nidaqs
            if ~isempty(DAQ(indev).DIO.inlines)
                for jj = 1:length(DAQ(outdev).DIO.outlines)
                    ovec(jj) = 1;
                    putvalue(DAQ(outdev).DIO.outlines,ovec);
                    valA = getvalue(DAQ(indev).DIO.inlines);
                    ovec(jj) = 0;
                    putvalue(DAQ(outdev).DIO.outlines,ovec);
                    valB = getvalue(DAQ(indev).DIO.inlines);
                    daar = find(xor(valA,valB)==1);
                    if ~isempty(daar)
                        if isempty(DAQ(outdev).TRG.out)
                            d1 = 1;
                        else
                            d1 = 1+length(DAQ(outdev).TRG.out);
                        end
                        DAQ(outdev).TRG.out(d1,1).out = jj;
                        DAQ(outdev).TRG.out(d1,1).targetdev = indev;
                        DAQ(outdev).TRG.out(d1,1).targetbit = sprintf('PFI%u',daar-1);
                        if isempty(DAQ(indev).TRG.in)
                            d2 = 1;
                        else
                            d2 = 1+length(DAQ(indev).TRG.in);
                        end
                        DAQ(indev).TRG.in(d2,1).in = sprintf('PFI%u',daar-1);
                        DAQ(indev).TRG.in(d2,1).sourcedev = outdev;
                        DAQ(indev).TRG.in(d2,1).sourcebit = jj;
                        fprintf('DAQ(%u): %s has trigger out(%u) connected to trigger in %s on device %s\n',outdev,...
                                 DAQ(outdev).BoardName,...
                                 DAQ(outdev).TRG.out(d1).out,...
                                 DAQ(outdev).TRG.out(d1).targetbit,...
                                 DAQ(DAQ(outdev).TRG.out(d1).targetdev).BoardName);
                    end
                end
                DAQ(outdev).DIO.digiout = ovec';
            end
        end
        DAQ(outdev).ADC.ExternalScanClockSource = '';
        for jj = 1:length(DAQ(outdev).DAC.HWchn)
            odac = zeros(1,length(DAQ(outdev).DAC.HWchn));
            putsample(DAQ(outdev).dac,odac);
            valA = getvalue(DAQ(outdev).DIO.inlines);
            odac(jj) = 16384;
            putsample(DAQ(outdev).dac,odac);
            valB = getvalue(DAQ(outdev).DIO.inlines);
            daar = find(xor(valA,valB)==1);
            if ~isempty(daar)
                DAQ(outdev).ADC.ClockChannel = jj;
                DAQ(outdev).ADC.ExternalScanClockSource = sprintf('PFI%u',daar-1);
                fprintf('DAQ(%u): can use DAC channel %u as an external clock via %s\n',...
                         outdev,jj,DAQ(outdev).ADC.ExternalScanClockSource);
                continue;
            end
        end
        odac = zeros(1,length(DAQ(outdev).DAC.HWchn));
        putsample(DAQ(outdev).dac,odac);
    end
end
Setonlinemode(true);
fprintf('\n');
rbp = find(strcmp({DAQ.BoardName},'USB-6009'));
if ~isempty(rbp)
    [~,volgorde] = sort({DAQ(rbp).InstalledBoardId});
    DAQrbp = DAQ(rbp(volgorde));
    DAQ(rbp) = [];
    DAQrbp = rmfield(DAQrbp,'bank');
    DAQrbp = rmfield(DAQrbp,'MCC');
    DAQrbp = rmfield(DAQrbp,'TRG');
end

function writedigitalbits(device,bits,value)
global DAQ
if ~isempty(device) && ~isempty(bits) && ~isempty(DAQ(device).DIO.digiout)
    DAQ(device).DIO.digiout(bits) = value;
    putvalue(DAQ(device).DIO.outlines,DAQ(device).DIO.digiout);
end

function value = readbackdigital(device,bits)
global DAQ
value = [];
if ~isempty(device) && ~isempty(DAQ(device).DIO.digiout) && ~isempty(bits)
    value = DAQ(device).DIO.digiout(bits);
end
%
% ====== MCC functions
%
function MCC_show(die)
global DAQ panels
mccdev = find(strcmp({DAQ.BoardName},'USB-3105'));
if isempty(mccdev), return; end
select = str2double(get(handles.MCC_select,'String'));
device = mccdev(select);
if die==3, kleur = panels.color.blauw; else, kleur = panels.color.rood; end
for jj=1:length(panels.mcchandles)
    set(panels.mcchandles(jj),'ForeGroundColor',kleur,'String',sprintf('%.0f',DAQ(device).MCC(jj,die)));
end


function MCC_Callback(hObject,~)
global DAQ panels axon
mccdev = find(strcmp({DAQ.BoardName},'USB-3105')); if isempty(mccdev), return; end
select = str2double(get(handles.MCC_select,'String'));
device = mccdev(select);
idx = find([KnobIsRed(handles.MCC_Imin) KnobIsRed(handles.MCC_Imax) KnobIsBlue(handles.MCC_Ival)]);
switch hObject
    case handles.MCC_select
        if select==length(mccdev), select = 1; else, select = select+1; end
        set(hObject,'String',num2str(select));
        MCC_show(handles,idx)
    case {handles.MCC_percentage; handles.MCC_slider}
        slider = [];
        for jj = 1:length(axon.output)
            if axon.output(jj).mcc.slider
                slider = jj;
                break;
            end
        end
        if isempty(slider), return; end
        if hObject==handles.MCC_percentage
            value = str2double(get(handles.MCC_percentage,'String'));
        else
            value = 100*get(handles.MCC_slider,'Value');
        end
        set(handles.MCC_percentage,'String',sprintf('%0.0f',value));
        set(handles.MCC_slider,    'Value',min(1,max(0,value/100)));
        for jj = 1:length(axon.output(slider).mcc.chn)
            dev  = axon.output(slider).mcc.dev(jj);
            chan = axon.output(slider).mcc.loc(jj);
            DAQ(dev).MCC(chan,3) = DAQ(dev).MCC(chan,1) + (DAQ(dev).MCC(chan,2)-DAQ(dev).MCC(chan,1))*value/100;
        end
        putsample(DAQ(device).dac, DAQ(device).MCC(:,3)');
        MCC_show(handles,3)
        KnobGrey([handles.MCC_Imin handles.MCC_Imax]); KnobBlue(handles.MCC_Ival)
    case {handles.MCC_Imin; handles.MCC_Imax; handles.MCC_Ival}
        hlp = [handles.MCC_Imin handles.MCC_Imax handles.MCC_Ival];
        if hObject==handles.MCC_Ival; KnobBlue(hObject); else,KnobRed(hObject); end
        KnobGrey(hlp(hlp~=hObject));
        MCC_show(handles,find(hlp==hObject));
    case handles.MCC_Save
        writedir = makenewdir(panels.file.proto,'MCC');
        if isempty(panels.file.mcc), panels.file.mcc = [writedir '*.txt']; end
        [filename,filepath] = uiputfile('*.txt','Save mcc configuration',panels.file.mcc);
        if filename~=0
            panels.file.mcc = fullfile(filepath,filename);
            [fid,message] = fopen(panels.file.mcc,'w');
            if ~isempty(message), Error(sprintf('%s\n%s',message,panels.file.mcc)); return; end
            for ii = 1:length(mccdev)
                for jj = 1:size(DAQ(mccdev(ii)).MCC,1)
                    fprintf(fid,'channel (%u, %u, %u, %u)\n',(ii-1)*16+jj,round(DAQ(mccdev(ii)).MCC(jj,1:3)));
                end
            end
            fclose(fid);
        end
    case handles.MCC_Load
        [filename,filepath] = uigetfile('*.txt','Load mcc configuration',panels.file.mcc);
        if filename~=0
            set(handles.MCC_File,'String',filename);
            panels.file.mcc = fullfile(filepath,filename);
            [fid,message]  = fopen(panels.file.mcc);
            if ~isempty(message), Error(sprintf('%s\n%s',message,panels.file.mcc)); return; end
            locs  = [];
            chans = [];
            devs  = [];
            for jj = 1:length(mccdev)
                locs  = [locs 1:16];
                chans = [chans (jj-1)*16+(1:16)];
                devs  = [devs  mccdev(jj)+0*(1:16)];
            end
            while true
                str = fgetl(fid);
                if ~ischar(str), break; end
                [cmd,parms] = ParseCmd(str);
                if strcmp(cmd,'channel')
                    die = find(chans==nsingle(parms{1}));
                    if ~isempty(die)
                        DAQ(devs(die)).MCC(locs(die),1) = rsingle(parms{2});
                        DAQ(devs(die)).MCC(locs(die),2) = rsingle(parms{3});
                        DAQ(devs(die)).MCC(locs(die),3) = rsingle(parms{4});
                    end
                end
            end
            fclose(fid);
            MCC_show(handles,3);
        end
    otherwise
        die  = find(hObject==panels.mcchandles);
        val = str2double(get(hObject,'String'));
        if idx==3
            DAQ(mccdev(select)).MCC(die,3) = min(max(val,DAQ(mccdev(select)).MCC(die,1)),DAQ(mccdev(select)).MCC(die,2));
            set(hObject,'String',sprintf('%.0f',DAQ(mccdev(select)).MCC(die,3)));
        else
            DAQ(mccdev(select)).MCC(die,idx) = val;
        end
end

function rodestippen
global timeline
if isvalid(timeline.rhandle)
    set(timeline.rhandle,'XData',timeline.xy(timeline.par(:,4)>0,1),...
                         'YData',timeline.xy(timeline.par(:,4)>0,2));
end



function NRNtimeline
global panels Memoryset Meting EEG SWP timeline IMG events
CMD = getPANEL('CMDpanel');
MEA = getPANEL('MEApanel');
if CMD.zoom.UserData, visible = 'off'; else, visible = 'on'; end
ecolor = 'brrmkrrkkkbbbbrm';
fcolor = 'cwywwcgwbgygyygg';
shape  = 'ooooososoossoooo';
width  = [1 1 1 1 1 1 1.5 1 1 1 1 1 1 1 1 1];
if ~isempty(SWP) && ~isempty(SWP.Meting)
    DisMeting = SWP.Meting;
    soort = 2;
elseif ~isempty(EEG) && ~isempty(EEG.Meting)
    DisMeting = EEG.Meting;
    soort = 3;
elseif ~isempty(Meting)
    DisMeting = Meting;
    soort = 1;
else
    cla(CMD.timeline); return
end
figure(panels.root);
setnames = {};
settimes = [];
setnrs = cumsum([DisMeting.setnr])';
ttt    = [DisMeting.reltime];
xmin = min(ttt);
xmax = max(ttt);
if xmin==xmax
    ddx = 2/70;
	xmin = xmin - 1;
	xmax = xmax + 1;
else
    ddx = (xmax-xmin)/70;
    xmin = xmin - ddx;
    xmax = xmax + ddx;
end
timeline.xy  = [];
timeline.par = [];
timeline.idx = [];
for node = 1:length(DisMeting)
    setnr = setnrs(node);
    nodes = find(setnrs==setnr);
    metnr = find(nodes==node);
    curtime = DisMeting(node).reltime;
    if isnan(curtime), curtime = max(timeline.xy(:,1)) + 1.2 * ddx; end
    yval = 0;
    if DisMeting(node).setnr
        bgntime = curtime(1);
        timeline.xy (end+1,1:2) = [bgntime 0.5];
        timeline.par(end+1,1:4) = [1 soort node 0];
        timeline.idx(end+1,1:5) = [setnr 0 0 0 0];
        setnames{end+1,1} = sprintf('   %s',DisMeting(node).serienaam);
        settimes(end+1,1) = bgntime;
    end
    if ~isempty(DisMeting(node).SEGMENT.name)
        for segnr = 1:length(DisMeting(node).SEGMENT.name)
            if CMD.bloks.Value
                if segnr==1, curtime = 0; end
            else
                curtime = DisMeting(node).SEGMENT.start(segnr);
            end
            timeline.xy (end+1,1:2) = [curtime -1];
            timeline.par(end+1,1:4) = [11 soort node panels.segnr==segnr];
            timeline.idx(end+1,1:5) = [setnr metnr segnr 0 0];
            if CMD.bloks.Value, curtime = curtime + panels.timegain/1000; end
        end
        break;        
    end
    if ~isempty(DisMeting(node).adc)
        nswps = size(DisMeting(node).adc,3);
        if nswps==1
            ytop = -2;
            timeline.xy (end+1,1:2) = [curtime(1) ytop];
            timeline.par(end+1,1:4) = [2 soort node 0];
            timeline.idx(end+1,1:5) = [setnr metnr 0 0 0];
        else
            ytop = -1;
            timeline.xy (end+1,1:2) = [mean(curtime) ytop];
            timeline.par(end+1,1:4) = [3 soort node 0];
            timeline.idx(end+1,1:5) = [setnr metnr 0 0 0];
            for swpnr = 1:length(curtime)
                timeline.xy (end+1,1:2) = [curtime(swpnr) ytop-1];
                timeline.par(end+1,1:4) = [4 soort node 0];
                timeline.idx(end+1,1:5) = [setnr metnr swpnr 0 0];
            end
        end
    end
    if ~isempty(DisMeting(node).dac) || ~isempty(DisMeting(node).cdac)
        timeline.xy (end+1,1:2) = [mean(curtime) ytop+1];
        timeline.par(end+1,1:4) = [5 soort node 0];
        timeline.idx(end+1,1:5) = [setnr metnr 0 0 0];
    end
    if isstruct(DisMeting(node).result)
        if ~isempty(DisMeting(node).adc)
            bgntime = max(timeline.xy(:,1)) + 1.2*ddx;
        end
        resnames = fieldnames(DisMeting(node).result);
        for residx = 1:length(resnames)
            resname = resnames{residx};
            if iscell(DisMeting(node).result.(resname))
                startnode = DisMeting(node).result.(resname){1,1};
            else
                startnode = DisMeting(node).result.(resname);
            end
            if isfield(startnode.basis,'kanaal') && ~isempty(startnode.basis.kanaal) && isempty(MEA)
                maxloop = length(startnode.basis.kanaal);
            else
                maxloop = 1;
            end
            for loopnr = 1:maxloop
                if (residx>1) || (loopnr>1), bgntime = max(timeline.xy(:,1)) + 1.2*ddx; end
                timeline.xy (end+1,1:2) = [bgntime,yval-1];
                timeline.par(end+1,1:4) = [6,soort,node,0];
                timeline.idx(end+1,1:5) = [setnr,residx,0,0,loopnr];

                timeline.xy (end+1,1:2) = [bgntime yval-2];
                timeline.par(end+1,1:4) = [8 soort node 0];
                timeline.idx(end+1,1:5) = [setnr residx 0 0 loopnr];
            end
            subnames = fieldnames(startnode);
            for subidx = 2:length(subnames)
                subname = subnames{subidx};
                if strcmp(subname,'fitter') && ~isempty(startnode.fitter)
                    curtime = bgntime;
                    for idx2 = 1:size(startnode.fitter,1)
                        if ~isempty(startnode.fitter{idx2})
                            curtime = curtime + ddx;
                            timeline.xy (end+1,1:2) = [curtime yval-2];
                            timeline.par(end+1,1:4) = [7 soort node 0];
                            timeline.idx(end+1,1:5) = [setnr residx idx2 0 0];
                        end
                    end
                elseif strcmp(subname,'APs') && ~isempty(startnode.APs)
                    curtime = bgntime;
                    for idx2 = 1:size(startnode.APs,1)
                        if ~isempty(startnode.APs{idx2})
                            curtime = curtime + ddx;
                            timeline.xy (end+1,1:2) = [curtime yval-1];
                            timeline.par(end+1,1:4) = [13 soort node 0];
                            timeline.idx(end+1,1:5) = [setnr residx idx2 1 0];
                        end
                    end
                elseif strcmp(subname,'dynamic') &&  ~isempty(startnode.dynamic)
                    numset = unique(startnode.basis.metswp(:,1));
                    nummet = unique(startnode.basis.metswp(:,2));
                    names = fieldnames(DisMeting(node).result.(resname).dynamic);
                    for idx4 =1:length(names)-1
                        for idx2 = 1:length(nummet)
                            for idx3 = 1:length(numset)
                                timeline.xy (end+1,1:2) = [bgntime+((idx4-1)*(length(nummet)+1)+idx2)*ddx yval-0.9*idx3+0.5];
                                timeline.par(end+1,1:4) = [16 soort node 0];
                                timeline.idx(end+1,1:5) = [setnr residx idx2 idx3 idx4];
                            end
                        end
                    end
                elseif strcmp(subname,'spkstats') &&  ~isempty(startnode.spkstats) && ...
                       isfield(startnode.spkstats,'cluster')
                    curtime = bgntime;
                    [n1,n2] = size(startnode.spkstats.cluster);
                    for idx2 = 1:n1
                        curtime = curtime + ddx;
                        for idx3 = 1:n2
                            if ~isempty(startnode.spkstats.cluster(idx2,idx3).set)
                                timeline.xy (end+1,1:2) = [curtime yval-0.9*idx3+0.5];
                                timeline.par(end+1,1:4) = [15 soort node 0];
                                timeline.idx(end+1,1:5) = [setnr residx idx2 idx3 0];
                            end
                        end
                    end
                elseif strcmp(subname,'means') && ~isempty(startnode.means) && ~CMD.hidemeans.Value
                    meannames = fieldnames(startnode.means);
                    curtime = bgntime;
                    for meannr = 1:length(meannames)
                        metswp = startnode.basis.metswp;
                        if length(meannames)==1
                            lops = unique(metswp(metswp(:,3)==1,4));
                            numlop = length(lops);
                        else
                            numlop = 1;
                        end
                        for j6 = 1:numlop
                            if (length(meannames)==1)
                                hidx = lops(j6);
                            else
                                hidx = meannr;
                            end
                            hsets = unique(metswp(:,1));
                            hmets = unique(metswp(:,2));
                            for j4 = 1:length(hsets)
                                for j5 = 1:length(hmets)
                                    timeline.xy (end+1,1:2) = [curtime+(j5*ddx)  yval-0.75*(j4-1)];
                                    timeline.par(end+1,1:4) = [14 soort node 0];
                                    timeline.idx(end+1,1:5) = [setnr residx hidx hsets(j4) hmets(j5)];
                                end
                            end
                            curtime = curtime + (length(hmets)+1)*ddx;
                        end
                    end
                end
            end
        end
    end
end
middle = (max(timeline.xy(:,2)) + min(timeline.xy(:,2)))/2;
if CMD.bloks.Value
    [~,idx]  = sort(timeline.xy(:,1));
    timeline.xy  = timeline.xy (idx,:);
    timeline.par = timeline.par(idx,:);
    timeline.idx = timeline.idx(idx,:);
    cnt = 0;
    last = timeline.xy(1,1);
    for jj = 1:length(timeline.xy(:,1))
        if timeline.xy(jj,1)>last, cnt = cnt + 1; end
        last = timeline.xy(jj,1);
        timeline.xy(jj,1) = cnt;
    end
    settimes = timeline.xy(timeline.par(:,1)==1,1);
    xmin = 0;
    xmax = cnt;
    ddx = 1;
else
    timeline.xy(:,1) = timeline.xy(:,1)*1000/panels.timegain;
    ddx = ddx*1000/panels.timegain;
    xmin = xmin*1000/panels.timegain;
    xmax = xmax*1000/panels.timegain;
    settimes = settimes*1000/panels.timegain;
end
if (~isempty(EEG) && ~isempty(SWP)) && (~isempty(EEG.Meting) && ~isempty(SWP.Meting))
    xpos = max(timeline.xy(:,1))+ddx;
    xnod = max(timeline.par(:,3))+1;
    hlp = [1,1,1,0,0];
    if ~isempty(EEG.Meting.adc) && ~isempty(EEG.Meting.dac)
        timeline.xy (cnt+1,1:2) = [xpos,0];
        timeline.par(cnt+1,1:4) = [1,3,xnod,0];
        timeline.idx(cnt+1,1:5) = hlp;
        timeline.xy (cnt+2,1:2) = [xpos,-1];
        timeline.par(cnt+2,1:4) = [5,3,xnod,0];
        timeline.idx(cnt+2,1:5) = hlp;
        timeline.xy (cnt+3,1:2) = [xpos,-2];
        timeline.par(cnt+3,1:4) = [2,3,xnod,0];
        timeline.idx(cnt+3,1:5) = hlp;
    elseif ~isempty(EEG.Meting.adc)
        timeline.xy (cnt+1,1:2) = [xpos,0];
        timeline.par(cnt+1,1:4) = [1,3,xnod,0];
        timeline.idx(cnt+1,1:5) = hlp;
        timeline.xy (cnt+2,1:2) = [xpos,-1];
        timeline.par(cnt+2,1:4) = [2,3,xnod,0];
        timeline.idx(cnt+2,1:5) = hlp;
    elseif ~isempty(EEG.Meting.dac)
        timeline.xy (cnt+1,1:2) = [xpos,0];
        timeline.par(cnt+1,1:4) = [1,2,xnod,0];
        timeline.idx(cnt+1,1:5) = hlp;
        timeline.xy (cnt+2,1:2) = [xpos,-1];
        timeline.par(cnt+2,1:4) = [5,3,xnod,0];
        timeline.idx(cnt+2,1:5) = hlp;
    end
    setnames{end+1} = sprintf('   %s',EEG.Meting(1).serienaam);
    settimes(end+1) = xpos+1;
end
[~,idx] = sort(timeline.xy(:,1));
timeline.xy  = timeline.xy(idx,:);
timeline.par = timeline.par(idx,:);
timeline.idx = timeline.idx(idx,:);
if isfield(IMG,'bld')
    xhlp = min(timeline.xy(:,1));
    numbld = length(IMG.bld);
    for fotonr = 1:numbld
        xhlp = xhlp - ddx;
        timeline.xy (end+1,1:2) = [xhlp middle];
        timeline.par(end+1,1:4) = [10 soort 0 0];
        timeline.idx(end+1,1:5) = [0 numbld-fotonr+1 0 0 0];
    end
end
xmax = max(max(timeline.xy(:,1))+ddx,xmax);
xmin = min(min(timeline.xy(:,1))-ddx,xmin);
DB = getPANEL('DBpanel');
if ~isempty(Memoryset)
    filenrs = 1:length(Memoryset);
    if ~isempty(DB)
        ratnr = DB.select.UserData(DB.select.Value);
        if ~isempty(ratnr), filenrs = events.rats.filenrs{ratnr};  end
    end
    onder = filenrs(filenrs<panels.filenr);
    boven = filenrs(filenrs>panels.filenr);
    xmin = xmin - (length(onder))*ddx;
    for jj = 1:length(onder)
        timeline.xy (end+1,1:2) = [xmin+(jj-0.5)*ddx middle];
        timeline.par(end+1,1:4) = [9 soort onder(jj) 0];
        timeline.idx(end+1,1:5) = [0 onder(jj) 0 0 0];
    end
    for jj = 1:length(boven)
        if jj==1, xmax = xmax + 0.5*ddx; else, xmax = xmax + ddx; end
        timeline.xy (end+1,1:2) = [xmax middle];
        timeline.par(end+1,1:4) = [9 soort boven(jj) 0];
        timeline.idx(end+1,1:5) = [0 boven(jj) 0 0 0];
    end
end
xxmin = max(timeline.boundery(1),xmin)-ddx;
xxmax = min(timeline.boundery(2),xmax)+ddx;
xvals = [xmin xmax];
ymin = min(-1.25,min(timeline.xy(:,2)));
ymax = max(0,max(timeline.xy(:,2)));
ddy  = ymax - ymin;
if isempty(find(timeline.par(:,1)==11, 1))
    yvals = [-2 -2];
    for jj = -3:-1:ymin
        xvals = [xvals NaN xmin xmax];
        yvals = [yvals NaN jj jj ];
    end
else
    yvals = [-1 -1];
end
axes(CMD.timeline)
cla(CMD.timeline);
set(CMD.timeline,'XLim',[xxmin xxmax],'YLim',[ymin-0.5 ymax+0.5],'YTickLabel',{''});
line(xvals,yvals,'LineStyle','-','Linewidth',1,'Marker','none','Visible',visible,'ButtonDownFcn',{@Timeklik,'boundery'});
set(gca,'Units','points');
tmp = get(gca,'Position');
set(gca,'Units','Normalized');
gain = tmp(4)/(ymax-ymin+1);
mark               = round(1.10 * gain * ones(1,16));
mark([4,12])       = round(1.00 * gain * [1,1]);
mark([6,8])        = round(1.20 * gain * [1,1]);
mark([7,13,14,15,16]) = round(1.00 * gain * [1,1,1,1,1]);
if CMD.bloks.Value && ~isempty(DB)
    s1 = find((timeline.par(:,1)==9) & (timeline.xy(:,1)<0));
    s2 = find((timeline.par(:,1)==9) & (timeline.xy(:,1)>0));
    s3 = find (timeline.par(:,1)==11);
    smax1 = length(s1);
    smax2 = length(s2);
    smax3 = length(s3);
    timeline.xy(s1,1) = -length(s1):-1;
    timeline.xy(s2,1) =  length(s3)-1+(1:length(s2));
    rest =100-smax3;
    links = round(rest/2);
    rechts = links;
    if smax1<links
        links = smax1;
        rechts = rest - links;
    end
    if smax2<rechts
        rechts = smax2;
        links = rest - rechts;
    end
    mark = mark*0.7;
    grens = min(timeline.xy(:,1))-1 + max(0,smax1-links);
    set(CMD.timeline,'XLim',[grens grens+min(smax1+smax2+smax3+2,100)],'YLim',[ymin ymax+0.25])
end
if panels.primair(4)<1080, mark = mark - 2; end
for jj = 1:length(setnames)
    if jj==1
        xx = settimes(1)*[1 1];
        yy = [ymin-0.5 ymax+0.5];
    else
        xx = [xx NaN settimes(jj)*[1 1]];
        yy = [yy NaN ymin-0.5 ymax+0.5];
    end
end
line(xx,yy,'LineStyle','-','Linewidth',1,'Marker','none','Visible',visible,'ButtonDownFcn',{@Timeklik,'boundery'});
for jj = 1:length(setnames)
    text(settimes(jj),0.7,setnames{jj},'Interpreter','none','HorizontalAlignment','Left','VerticalAlignment','Middle',...
                                     'Color','b','Fontsize',mark(1)-2,'Fontname','Times New Roman','Visible',visible);
end
xx = timeline.xy(:,1);
yy = timeline.xy(:,2);
for jj = 1:16
	if jj==4
        dik = (timeline.par(:,1)==jj) & (timeline.idx(:,3)==1);
        line(xx(dik),yy(dik),'LineStyle','none','Linewidth',width(jj),...
             'MarkerFaceColor',fcolor(jj),'MarkerEdgeColor',ecolor(jj),...
             'Marker',shape(jj),'MarkerSize',mark(jj),'Visible',visible,'ButtonDownFcn',{@Timeklik,jj});
        dun = (timeline.par(:,1)==jj) & (timeline.idx(:,3)>1);
        line(xx(dun),yy(dun),'LineStyle','none','Linewidth',width(jj),...
             'MarkerFaceColor',fcolor(jj),'MarkerEdgeColor',ecolor(jj),...
             'Marker',shape(jj),'MarkerSize',mark(jj),'Visible',visible,'ButtonDownFcn',{@Timeklik,jj});
    else
        present = find( (timeline.par(:,1)==jj) & (xx>=timeline.boundery(1)) & (xx<=timeline.boundery(2)));
        if ~isempty(present)
            line(xx(present),yy(present),'LineStyle','none','Linewidth',width(jj),...
                 'MarkerFaceColor',fcolor(jj),'MarkerEdgeColor',ecolor(jj),...
                 'Marker',shape(jj),'MarkerSize',mark(jj),'Visible',visible,'ButtonDownFcn',{@Timeklik,jj});
        end
	end
end
active = find(timeline.par(:,4)>0);
if isempty(active), xred = -inf; yred = 0; else, xred = timeline.xy(active,1); yred = timeline.xy(active,2); end
timeline.rhandle = line(xred,yred,'LineStyle','none','Linewidth',1,'MarkerFaceColor','r','MarkerEdgeColor','r',...
                                  'Marker','o','MarkerSize',10-ddy,'Visible',visible,'ButtonDownFcn',{@Timeklik,999});
 
function Redraw(varargin)
global Meting
if isempty(Meting),return; end
if nargin>0
	CMD = getPANEL("CMDpanel");
    if (CMD.zoom.UserData==0), NRNtimeline; end
end
setplotter("last",Meting);
NRNshow(Meting);
%
%
function Mets = DACcompress(Mets)
for ii=1:length(Mets)
    if ~isempty(Mets(ii).dac) && isempty(Mets(ii).cdac) && Mets(ii).DAC.compress 
        [row,numdac] = size(Mets(ii).dac);
        for jj = 1:numdac
            ppp = find(diff(int32(Mets(ii).dac(:,jj)))~=0);
            res = [];
            if isempty(ppp)
                res(1,1) = row;
                res(1,2) = Mets(ii).dac(1,jj);
            else
                ppt = diff([0; ppp]);
                res(:,1) = int32(ppt);
                res(:,2) = int32(Mets(ii).dac(ppp,jj));
                if row>sum(ppt)  
                    len = length(res(:,1));
                    res(len+1,1) = int32(row-sum(ppt));
                    res(len+1,2) = int32(Mets(ii).dac(end,jj));
                end
            end
            Mets(ii).cdac{jj} = res;
        end
    end
end

function Mets = DACexpand(Mets)
for metnr=1:length(Mets)
    if isempty(Mets(metnr).dac) && ~isempty(Mets(metnr).cdac)
        numdac = length(Mets(metnr).cdac);
        daclen = sum(Mets(metnr).cdac{1,1}(:,1));
        Mets(metnr).dac = zeros(daclen,numdac,'int16');
        for ii = 1:numdac
            numrow = size(Mets(metnr).cdac{ii},1);
            p2 = 0;
            for jj = 1:numrow
                p1 = p2 + 1;
                p2 = p2 + Mets(metnr).cdac{ii}(jj,1);
                Mets(metnr).dac(p1:p2,ii) = int16(round(Mets(metnr).cdac{ii}(jj,2)));
            end
        end
    end
end

function result = Donotoverwrite(filenaam)
if isempty(dir(filenaam)), result = false; return; end
result = strcmp(questdlg(sprintf('File:\n %s\nexists, action?',filenaam),'File Exists','OverWrite','Cancel','OverWrite'),'Cancel');

function SaveHulp(filenaam,Meting,varargin)
if ~isempty(Meting)
    if nargin>2
        if strcmp(varargin{1},'noadc'), Meting.adc = []; end
    end
    save(filenaam,'Meting');
end

function SaveNeuron(Meting,filename,CMD)
Checksavedirectory;
Meting = DACcompress(Meting);
Meting = MeanIni(Meting);
filename = [filename '.mat'];
if Donotoverwrite(filename)
    KnobBlue(CMD.Savedata);
    set(CMD.Savedata,'Visible','on');
else
    try
        SaveHulp(filename,Meting);
        KnobGrey(CMD.Savedata);
        set(CMD.Savedata,'Visible','off');  
    catch
        Message(sprintf('%s\n could not be saved',filename));
        KnobBlue(CMD.Savedata); 
        set(CMD.Savedata,'Visible','on');
        return;
    end
end

function Checksavedirectory(varargin)
global panels
if nargin>0, doask = varargin{1}; else, doask = false; end
if doask || isempty(panels.file.savepath)
    hlp = uigetdir(cd,'Select directory to save datafiles');
    if hlp==0, panels.file.savepath = cd; else, panels.file.savepath = hlp; end
end

function filename = ClaimFilename
global panels
CMD = getPANEL('CMDpanel');
Checksavedirectory;
DD = round(clock); 
datum = sprintf('%02u%02u%02u',DD(1)-2000,DD(2),DD(3));
set(CMD.Filedate,'String',datum);
s1 = get(CMD.Prefix,'String');
s2 = get(CMD.Fileindex,'String');
s3 = get(CMD.Filenummer,'String');
filename = [panels.file.savepath filesep s1 datum s2 s3];
set(CMD.Filenummer,'String',sprintf('%04u',1+str2double(get(CMD.Filenummer,'String'))));

function CMD_wait(txt)
CMD = getPANEL('CMDpanel'); set(CMD.wait,'String',txt);

function CMDscale(CMD,hObject)
switch hObject
    case CMD.join
        if strcmp(get(hObject,'String'),'===')
            set(hObject,'String','=#=');
            return
        else
            set(hObject,'String','===');
            set(CMD.DACgainnum,'String',get(CMD.ADCgainnum,'String'));
            set(CMD.DACgain,   'Value', get(CMD.ADCgain,'Value'));
            set(CMD.DACgainbox,'Value', get(CMD.ADCgainbox,'Value'));
        end
    case CMD.DACseparatornum
        nummer = min(1,max(0,str2double(get(hObject,'String'))));
        set(hObject,'String',sprintf('%3.2f',nummer));
        set(CMD.DACseparator,   'Value',2*nummer-2);
        set(CMD.DACseparatorbox,'Value',0);
    case CMD.DACseparatorbox
        if get(hObject,'Value')
            set(CMD.DACseparator,   'Value',0);
            set(CMD.DACseparatornum,'String','1.00');
        end
    case CMD.DACseparator
        shift  = (realpow(10,get(hObject,'Value'))-0.01)/0.99;
        if get(CMD.DACseparatorbox,'Value'), set(CMD.DACseparatorbox,'Value',0); end
        set(CMD.DACseparatornum,'String',sprintf('%3.2f',shift));
    case CMD.ADCseparatornum
        nummer = min(1,max(0,str2double(get(hObject,'String'))));
        set(hObject,'String',sprintf('%3.2f',nummer));
        set(CMD.ADCseparator,   'Value',2*nummer-2);
        set(CMD.ADCseparatorbox,'Value',0);
    case CMD.ADCseparatorbox
        if get(hObject,'Value')
            set(CMD.ADCseparator,   'Value',0);
            set(CMD.ADCseparatornum,'String','1.00');
        end
    case CMD.ADCseparator
        shift  = (realpow(10,get(hObject,'Value'))-0.01)/0.99;
        if get(CMD.ADCseparatorbox,'Value'), set(CMD.ADCseparatorbox,'Value',0); end
        set(CMD.ADCseparatornum,'String',sprintf('%3.2f',shift));
    case CMD.ADCgainnum
        gain = min(10,max(0.1,str2double(get(hObject,'String'))));
        set(hObject,'String',sprintf('%2.1f', gain));
        set(CMD.ADCgain,   'Value',log10(gain));
        set(CMD.ADCgainbox,'Value',0);
    case CMD.ADCgainbox
        if get(hObject,'Value')
            set(CMD.ADCgain,   'Value',0);
            set(CMD.ADCgainnum,'String','1.0');
        end
    case CMD.ADCgain
        gain = realpow(10,get(hObject,'Value'));
        set(hObject,'Value',log10(gain));
        if get(CMD.ADCgainbox,'Value'), set(CMD.ADCgainbox,'Value',0); end
        set(CMD.ADCgainnum,'String',sprintf('%2.1f', gain));                
    case CMD.DACgainnum
        gain = min(10,max(0.1,str2double(get(hObject,'String'))));
        set(hObject,'String',sprintf('%2.1f', gain));
        set(CMD.DACgainbox,'Value',0);
        set(CMD.DACgain,'Value',log10(gain));
    case CMD.DACgainbox
        if get(hObject,'Value')
            set(CMD.DACgain,   'Value',0);
            set(CMD.DACgainnum,'String','1.0');
        end
    case CMD.DACgain
        gain = realpow(10, get(hObject,'Value'));
        set(hObject,'Value',log10(gain));
        if get(CMD.DACgainbox,'Value'), set(CMD.DACgainbox,'Value',0); end
        set(CMD.DACgainnum,'String',sprintf('%2.1f', gain));
end
if str2double(get(CMD.ADCseparatornum,'String'))==1, kleur = [0.9 0.9 0.9]; else, kleur = [1 0 0]; end
set(CMD.ADCseparator,'BackgroundColor',kleur);
if str2double(get(CMD.ADCgainnum,'String'))==1,      kleur = [0.9 0.9 0.9]; else, kleur = [1 0 0]; end
set(CMD.ADCgain,'BackgroundColor',kleur);
if str2double(get(CMD.DACseparatornum,'String'))==1, kleur = [0.9 0.9 0.9]; else, kleur = [1 0 0]; end
set(CMD.DACseparator,'BackgroundColor',kleur);
if str2double(get(CMD.DACgainnum,'String'))==1,      kleur = [0.9 0.9 0.9]; else, kleur = [1 0 0]; end
set(CMD.DACgain,'BackgroundColor',kleur);
if strcmp(get(CMD.join,'String'),'===')
    if ~isempty(intersect([CMD.DACgainnum,CMD.DACgainbox,CMD.DACgain],hObject))
        set(CMD.ADCgainnum,'String',get(CMD.DACgainnum,'String'));
        set(CMD.ADCgain,   'Value', get(CMD.DACgain,'Value'));
        set(CMD.ADCgainbox,'Value', get(CMD.DACgainbox,'Value')); 
    elseif ~isempty(intersect([CMD.ADCgainnum,CMD.ADCgainbox,CMD.ADCgain],hObject))
        set(CMD.DACgainnum,'String',get(CMD.ADCgainnum,'String'));
        set(CMD.DACgain,   'Value', get(CMD.ADCgain,'Value'));
        set(CMD.DACgainbox,'Value', get(CMD.ADCgainbox,'Value'));
    end
end

function CMDzoom(CMD,hObject)
global timeline
xtmin = min(timeline.xy(:,1));
xtmax = max(timeline.xy(:,1));
xtwid = diff(timeline.boundery);
switch hObject
    case {CMD.hidemeans,CMD.hideswps}
    case CMD.Zoomstart, timeline.boundery(1) = xtmin;
    case CMD.Zoomeind,  timeline.boundery(2) = xtmax;
    case CMD.Zoomleft
        if timeline.boundery(1)<(xtmin+xtwid)
            timeline.boundery = [xtmin xtmin+xtwid];
        else
            timeline.boundery = timeline.boundery - xtwid;
        end
    case CMD.Zoomright
        if timeline.boundery(2)>(xtmax-xtwid)
            timeline.boundery = [xtmax-xtwid xtmax];
        else
            timeline.boundery = timeline.boundery + xtwid;
        end
    case CMD.Zoomexpand
        if isinf(timeline.boundery(1))
            timeline.boundery(1) = xtmin + 0.25 * (xtmax - xtmin);
        else
            timeline.boundery(1) = timeline.boundery(1) + 0.25 * xtwid;
        end
        if isinf(timeline.boundery(2))
            timeline.boundery(2) = xtmin + 0.75 * (xtmax - xtmin);
        else
            timeline.boundery(2) = timeline.boundery(2) - 0.25 * xtwid;
        end
    case CMD.Zoomshrink
        timeline.boundery(1) = max(xtmin,timeline.boundery(1) - 0.25 * xtwid);
        timeline.boundery(2) = min(xtmax,timeline.boundery(2) + 0.25 * xtwid);
end

function CMDbasic(CMD,hObject,~)
global panels Meting
switch hObject
    case CMD.reset, Resetall(true);
    case CMD.hrs, Timescale(CMD,'hrs'); Redraw;
    case CMD.min, Timescale(CMD,'min'); Redraw;
    case CMD.sec, Timescale(CMD,'sec'); Redraw;
    case CMD.ms,  Timescale(CMD,'ms');  Redraw;
    case CMD.charsize
        set([CMD.script, CMD.protocol],'Fontsize',str2double(get(CMD.charsize,'String')));
    case CMD.online
        if strcmp(computer,'PCWIN64')
            Message(sprintf('\n%s\n.','NIDAQ not yet available on 64bit systems'));
            Setonlinemode(false);
        else
            Setonlinemode(~panels.online);
        end
    case CMD.super
        panels.super.ans = 0;
        if KnobIsRed(hObject)
            KnobGrey(hObject);
            panels.super.abort = true;
            panels.abort       = true;
        else
            panels.super.abort = false;
            panels.abort       = false;
            KnobRed(hObject);
            bewaar = CMD.macro.Visible;
            CMD.macro.Visible = 'Off';
            SuperSet(hObject);
            CMD.macro.Visible = bewaar;
        end
    case {CMD.shift,CMD.hide}
        if panels.online
            if hObject==CMD.hide
                ToggleRed_Callback(hObject);
                if KnobIsRed(CMD.hide)
                    CMD.macro.Visible = 'Off';
                    return
                else
                    CMD.macro.Visible = 'On';
                end
            end
            pos = CMD.macro.Position;
            for jj = length(panels.slots):-1:1
                newpos = get(panels.slots(jj),'Position');
                if strcmpi(get(panels.slots(jj),'Visible'),'on')
                    if hObject==CMD.shift
                        set(panels.slots(jj),'Visible','off');
                        mypos = newpos(1);
                    else
                        mypos = newpos(1)+newpos(3);
                    end
                    break;
                end
                if jj==1
                    if hObject==CMD.shift
                        set(panels.slots,'Visible','on');
                        newpos = get(panels.slots(end),'Position');
                        mypos = newpos(1)+newpos(3);
                    else
                        mypos = newpos(1);
                    end
                end
            end
            CMD.macro.Position = [mypos, pos(2), 1-mypos, 0.42];
        elseif KnobIsRed(CMD.super)
            return
        else
            if hObject==CMD.hide
                ToggleRed_Callback(hObject);
                if KnobIsRed(CMD.hide)
                    CMD.macro.Visible = 'Off';
                    return
                else
                    CMD.macro.Visible = 'On';
                end
            end
            pos1 = get(CMD.valid(1), 'Position');
            pos2 = get(CMD.window(1),'Position');
            pos3 = get(CMD.txt(1),   'Position');
            pos  = get(CMD.macro,    'Position');
            if (pos(3)<0.5) || (hObject==CMD.hide)
                pos(3) = 0.8730; schaal = 0.8730/0.22;
                pos1([1,3]) = [0,   0.045]/schaal;
                pos2([1,3]) = [0.045,0.075]/schaal;
                pos3([1,3]) = [0.125/schaal,1-(0.125/schaal)];
            else
                pos(3) = 0.22;
                pos1([1,3]) = [0,    0.045];
                pos2([1,3]) = [0.045,0.075];
                pos3([1,3]) = [0.125,0.875];
            end
            set(CMD.macro,'Position',[pos(1:3), 0.420],'Visible','On');
            for jj = 1:4
                pos = get(CMD.valid(jj),'Position');
                set(CMD.valid(jj), 'Position', [pos1(1),pos(2),pos1(3),pos(4)],'Visible','On');
                set(CMD.window(jj),'Position', [pos2(1),pos(2),pos2(3),pos(4)],'Visible','On');
                set(CMD.txt(jj),   'Position', [pos3(1),pos(2),pos3(3),pos(4)],'Visible','On');
            end
        end
    case CMD.script
        KnobMake;
        if Error("box")
            color = [1 0 0];
        else
            color = [0 0 0];
            if get(CMD.ScriptAutosave,'Value')
                Script_Save(CMD);
            else
                KnobBlue(CMD.ScriptSave);
            end
        end
        set(hObject,'ForegroundColor',color);
    case CMD.protocol
        Protocol_Test;
        if Error
        elseif get(CMD.ProtocolAutosave,'Value')
            Protocol_Save(CMD);
        else
            KnobBlue(CMD.ProtocolSave);
        end
    otherwise
        makevalid = find(CMD.valid==hObject);
        if ~isempty(makevalid)
            if get(hObject,'Value')
                wintxt = get(CMD.window(makevalid),'String');
                for jj = 1:4
                    if (jj~=makevalid) && strcmp(wintxt,get(CMD.window(jj),'String'))
                        set(CMD.valid(jj),'Value',0);
                    end
                end
            end
        end
        panels.NRNabort = false;
        panels.NRNbusy  = false;
        setplotter('cmdline',Meting);
        NRNshow(Meting);
end

function CMDeeg(CMD,hObject)
global panels Meting spots
switch hObject
   case {CMD.startknob,CMD.eindknob}
        ToggleRed_Callback(hObject);
        if KnobIsRed(hObject), set(gcf,'Pointer','cross'); end
        drawnow;
    case {CMD.EEGrunL,CMD.EEGrunR}
        if ~KnobIsRed(hObject)
            KnobGrey([CMD.EEGrunL CMD.EEGrunR]);
            KnobRed(hObject);
            if length(Meting)==1
                maxsegments = length(Meting.SEGMENT.name);
            else
                maxsegments = 0;
            end
            [start,einde] = getdaqpars;
            duur = einde - start;
            while KnobIsRed(hObject)
                Redraw
                step = duur * str2double(get(CMD.Scrollfraction,'String'));
                if hObject==CMD.EEGrunR
                    if einde==panels.zoom.tend 
                        if panels.segnr>=maxsegments
                            KnobGrey(CMD.EEGrunR);
                        else
                            MemoryUpdate('segnxt');
                            start = panels.zoom.tnul;
                            einde = panels.zoom.tnul + duur;
                        end
                    elseif (einde+step)>=panels.zoom.tend
                        start = panels.zoom.tend - duur;
                        einde = panels.zoom.tend;
                    else
                        start = start + step;
                        einde = start + duur;
                    end
                else
                    if start==panels.zoom.tnul
                        if panels.segnr==1
                            KnobGrey(CMD.EEGrunL);
                        else
                            MemoryUpdate('segprv');
                            start = panels.zoom.tend - duur;
                            einde = panels.zoom.tend;
                        end
                    elseif (start-step)<panels.zoom.tnul
                        start = panels.zoom.tnul;
                        einde = panels.zoom.tend;
                    else
                        start = start - step;
                        einde = start + duur;
                    end
                end
                setdaqpars(start,einde);
            end
        end
        KnobGrey([CMD.EEGrunL CMD.EEGrunR]);
	case CMD.zoomrestore
        if isempty(spots), return; end
        spot = spots{end};
        setdaqpars(panels.zoom.tnul + spot.start,panels.zoom.tnul + spot.finish);
        if ~isempty(spots), spots(end) = []; end
        set(CMD.zoomrestore,'String',sprintf('stk %02u',length(spots))); drawnow;
        Redraw;
        KnobGrey(hObject);
    case CMD.timefind
        hlp = inputdlg('       give absolute time or cancel:       ','Ask Time point in seg file',1,panels.asktim,'on');
        if isempty(hlp), return; end
        try
            abstime = datenum(hlp);
        catch
            Error("tell",sprintf('Not a valid Windows time:\n  %s',hlp{1})); return
        end
        panels.asktim{1} = hlp{1};
        SetMenu(['you asked for:  ', datestr(abstime,'dd-mm-yyyy HH:MM:SS')]);
        DB = getPANEL('DBpanel');
        if isempty(DB)
            filenr = 1;
            segnr  = 1;
        else
            filenr  = find((events.files.time(:,1)<=abstime) & (events.files.time(:,2)>=abstime));
            if isempty(filenr), Error('This time is not in the Database (yet)'); return; end
            filetime = (abstime - events.files.time(filenr,1))*24*60*60*1000;
            segments = find(events.sgmt.filenr == filenr);
            segnr    = find((events.sgmt.start(segments)<=filetime) & (events.sgmt.eind(segments)>=filetime));
        end
        [start,einde] = getdaqpars; duur = einde-start;
        setdaqpars(filetime-0.5*duur,filetime+0.5*duur);
        MemoryUpdate(filenr,segnr);
        Error("box");
        Redraw(1);
    otherwise
        if (hObject~=CMD.zoomstart) && (hObject~=CMD.zoomeind) && (hObject~=CMD.zoomduur) && (hObject~=CMD.zoomslider)
            KnobRed(hObject);
        end
        Zoomstack(CMD)
        [start,einde] = getdaqpars;
        duur = einde-start;
        switch hObject
            case CMD.EEGzoomuitlinks,  start = einde - 0.5 * duur;
            case CMD.EEGzoomuitrechts, einde = start + 0.5 * duur;
            case CMD.EEGzoominlinks,   start = einde - 2.0 * duur;
            case CMD.EEGzoominrechts,  einde = start + 2.0 * duur;
            case CMD.EEGcompress,      start = start + 0.25 * duur; einde = einde - 0.25 * duur;
            case CMD.EEGexpand,        start = start - 0.25 * duur; einde = einde + 0.25 * duur;
            case CMD.EEGbackward1,     start = start - 0.5 * duur;
                                       einde = einde - 0.5 * duur;
            case CMD.EEGbackward2,     start = start - duur;     einde = einde - duur;
            case CMD.EEGbackward3,     start = panels.zoom.tnul; einde = start + duur;
            case CMD.EEGforward1,      if (start+duur) == panels.zoom.tend
                                            MemoryUpdate(panels.filenr,panels.segnr+1);
                                            start = panels.zoom.tnul;
                                            einde = start + duur;
                                       else
                                            start = start + 0.5 * duur;
                                            einde = einde + 0.5 * duur;
                                       end
            case CMD.EEGforward2,      start = start + duur;     einde = einde + duur;
            case CMD.EEGforward3,      einde = panels.zoom.tend; start = einde - duur;   
            case CMD.zoomstart,        start = str2double(get(CMD.zoomstart,  'String')) * panels.timegain;
            case CMD.zoomeind,         einde = str2double(get(CMD.zoomeind,   'String')) * panels.timegain;
            case CMD.zoomduur,         einde = start + str2double(get(hObject,'String')) * panels.timegain;
            case CMD.zoomslider,       start = panels.zoom.tnul + get(CMD.zoomslider,'Value') * ((panels.zoom.tend-panels.zoom.tnul) - duur);
                                       einde = start + duur;
        end
        setdaqpars(start,einde);
        if (hObject~=CMD.zoomstart) && (hObject~=CMD.zoomeind) && (hObject~=CMD.zoomduur) && (hObject~=CMD.zoomslider)
            KnobGrey(hObject);
        end
        Redraw;
end

function CMDonline(CMD,hObject,direct)
global panels axon Meting
switch hObject
    case CMD.Browse
        if isempty(panels.file.savepath), panels.file.savepath = cd; end
        hlp = uigetdir(panels.file.savepath,'Select directory to save datafiles');
        if hlp~=0, panels.file.savepath = hlp; end
    case CMD.Savedata
        KnobRed(hObject);
        if ~isempty(Meting(1).ADC.HWchn) && isempty(Meting(1).adc)
            Message('TraceData cannot be saved in retrospect');
            return;
        end
        SaveNeuron(Meting,ClaimFilename,CMD);
        KnobGrey(hObject);
    case CMD.Autosave
        if get(CMD.Autosave,'Value'), txt = 'off'; else, txt = 'on'; end
        set(CMD.Savedata,'Visible',txt);
    case CMD.Zeroindex
        set(CMD.Fileindex,'String','A');
    case CMD.Zeronumber
        set(CMD.Filenummer,'String','0000');        
    case CMD.Updateindex
        set(CMD.Fileindex,'String',char(1+double(get(CMD.Fileindex,'String'))));
        set(CMD.Filenummer,'String','0000');
    case CMD.Updatenummer
        set(CMD.Filenummer,'String',sprintf('%04u',1+str2double(get(CMD.Filenummer,'String'))));
    case CMD.Prefix
        Message('Name is best defined in protocol');
    case CMD.ProtocolSave
        Protocol_Test;
        if Error, Message('You cannot save a protocol with errors'); else
            [filename,filepath] = uiputfile('*.txt','Save protocol as',panels.file.proto);
            if filename~=0
                panels.file.proto = fullfile(filepath,filename);
                Protocol_Save(CMD);
            end
        end
    case CMD.ProtocolAutosave
        if get(CMD.ProtocolAutosave,'Value'), mode = 'off'; else, mode = 'on'; end
        set(CMD.ProtocolSave,'Visible',mode);
        Protocol_Save(CMD);
    case CMD.ProtocolLoad
        if direct
            newname = panels.file.proto;
        else
            [filename,filepath] = uigetfile('*.txt','Select a protocol text',panels.file.proto);
            if filename == 0, return; end
            newname = fullfile(filepath,filename);
        end
        [fid,message] = fopen(newname,'r');
        if ~isempty(message), Error(sprintf('%s\n%s',message,newname)); return; end
        protocol = textscan(fid,'%s','delimiter','\n','whitespace','');
        protocol = protocol{1};
        fclose(fid);
        dosave = false;
        [cmd,parms] = ParseCmd(protocol{1});
        if strcmp(cmd,'neuronfile')
            switch parms{1}
                case 'protocol',protocol(1:end-1) = protocol(2:end); protocol(end) = [];                
                case 'script',  Message('do not read a script-file as protocol'); return
                otherwise,      Message('not a protocol file'); return
            end
        else
            [~,denaam] = fileparts(newname);
            ButtonName = questdlg(sprintf('Are you sure \n%s\n is a protocol file?',denaam),'read protocol','Yes','Cancel','Yes');
            if strcmp(ButtonName,'Cancel'), return; end
            dosave =true;
        end
        WindowClear;
        panels.file.proto = newname;
        [~,filename] = fileparts(panels.file.proto);
        set(CMD.protocolfile,'String',filename);
        set(CMD.protocol,'String',protocol);
        panels.slots = [];
        PANEL = getPANEL('EPpanel');  if ~isempty(PANEL), delete(PANEL.handle); end
        PANEL = getPANEL('MCCpanel'); if ~isempty(PANEL), delete(PANEL.handle); end
        vsoft     = [-70,-70];
        amps{1}    = [];
        amps{2,1}  = [];
        state{1}   = [];
        state{2,1} = [];
        pnls = {'AXON1';'AXON2'};
        for j0 = 1:2
            AXON = getPANEL(pnls{j0});
            if ~isempty(AXON)
                vsoft(j0) = AXON.pars.Vsoft;
                amps{j0}  = AXON.clamp;
                state{j0} = AXON.state;
                delete(AXON.handle);
            end
        end
        axon.monitor = 0;
        reset = KnobMake;
        if ~Error && reset
            Resetall(false);
            KnobMake;
        end
        for j0 = 1:2
            AXON = getPANEL(pnls{j0});
            if ~isempty(AXON)
                AXON.pars.Vsoft = vsoft(j0);
                AXON.clamp      = amps{j0};
                AXON.state      = state{j0};
                handle = [AXON.IK, AXON.IA, AXON.IC, AXON.IH];
                if ~isempty(AXON.clamp)
                    for j1 = 1:4, set(handle(j1),'String',sprintf('%u',AXON.clamp(j1))); end
                end
                set(AXON.Vsoft,'String',sprintf('%0.1f',AXON.pars.Vsoft));
                set(AXON.handle,'UserData',AXON);
            end
        end
        if Error("box")
            set(CMD.protocol,'ForegroundColor',[1 0 0]);
        else
            set(CMD.protocol,'ForegroundColor',[0 0 0]);
            KnobGrey(CMD.ProtocolSave);
            if dosave, Protocol_Save(CMD); end
            SetMenu('version');
            if ~isempty(panels.slots)
                pos = get(panels.slots(end),'Position');
                newpos = pos(1)+pos(3);
                pos = get(CMD.macro,'Position');
                set(CMD.macro,'Position',[newpos,pos(2),1-newpos,pos(4)],'Visible','On');
                KnobGrey(CMD.hide);
            end
        end
end

function CMDoffline(CMD,hObject,direct)
global panels Meting IMG Log cache
switch hObject
    case CMD.ScriptSave
        KnobMake;
        if Error("box"), set(CMD.script,'ForegroundColor',[1 0 0]); else
            set(CMD.script,'ForegroundColor',[0 0 0]);
            [filename,filepath] = uiputfile('*.txt','Save script as',panels.file.script);
            if filename~=0
                panels.file.script = fullfile(filepath,filename);
                Script_Save(CMD);
            end
        end
    case CMD.ScriptAutosave
        if get(CMD.ScriptAutosave,'Value'), mode = 'off'; else, mode = 'on'; end
        set(CMD.ScriptSave,'Visible',mode);
        Script_Save(CMD);
    case CMD.ScriptLoad
        Error("clear",'Script');
        if direct
            newname = panels.file.script;
        else
            [filename,filepath] = uigetfile('*.txt','Select a script file',panels.file.script);
            if filename==0, return; end
            newname = fullfile(filepath,filename);
        end
        % prepared for saving bu version
        % [hlp1,hlp2,hlp3] = fileparts(newname);
        % buname = fullfile(hlp1,[hlp2 '-BU' hlp3]);
        % copyfile(newname,buname,'f');
        [fid,message] = fopen(newname,'r');
        if ~isempty(message), Error(sprintf('%s\n%s',message,newname)); return; end
        script = textscan(fid,'%s','delimiter','\n','whitespace','');
        script = script{1};
        fclose(fid);
        dosave = false;
        [cmd,parms] = ParseCmd(script{1});
        if strcmp(cmd,'neuronfile')
            switch parms{1}
                case 'Script',   script(1:end-1) = script(2:end); script(end) = [];                
                case 'Protocol', Message('this is a protocol'); return
                otherwise,       Message(sprintf('not a Script or Protocol file\n%s',parms{1})); return
            end
        else
            [~,fff] = fileparts(newname);
            if strcmp(questdlg(sprintf('Are you sure\n%s\ncan be used as a Script file?',fff),'Read Script','Yes','Cancel','Yes'),'Cancel'), return; end
            dosave =true;
        end
        panels.file.script = newname;
        [~,filename] = fileparts(panels.file.script);
        oldscript   = get(CMD.script,'String');
        oldfilename = get(CMD.Scriptfilename,'String');
        set(CMD.Scriptfilename,'String',filename);
        set(CMD.script,'String',script,'Visible','On');
        KnobMake;
        if Error("box")
            set(CMD.Scriptfilename,'String',oldfilename);
            set(CMD.script,'String',oldscript);
        else
            if dosave, Script_Save(CMD); end
        end
        set(CMD.script,'ForegroundColor',[0 0 0]);
    case CMD.cache
        cache = [];
        if KnobIsRed(hObject)
            KnobGrey(hObject);
            cache.status = false;
        else
            KnobRed(hObject);
            cache.status = true;
        end
        set(CMD.cachelevel,'String','0');
	case CMD.transform, datatransform(CMD)
    case CMD.linkfotos
        if isempty(panels.file.name), Error("tell",'first read the data to which to link'); return; end
        [path,name,~] = fileparts(panels.file.name);
        startname = fullfile(path,'*.*');
        [filenames,path] = uigetfile({'*.bmp;*.png;*.tif;*.tiff';...
                                      '*.bmp';'*.png';'*.tif';'*.tiff';'*.*'},...
                                      'Select foto(s) to add',startname, 'MultiSelect','on');
        if path==0, return; end
        if ~iscell(filenames)
            hlp = filenames;
            filenames = [];
            filenames{1} = hlp;
        end
        cnt = 0;
        for ii = 1:length(filenames)
            cnt = cnt + 1;
            org = imread(fullfile(path,filenames{ii}));
            if get(CMD.scalefotos,'Value')
                minz = min(min(hlp));
                maxz = max(max(hlp));
                gain = 65535/double(maxz-minz);
            else
                minz = 0;
                gain = 1;
            end
            IMG.bld{cnt,1} = uint16(round(double(hlp-minz)*gain));
            IMG.nam{cnt,1} = filenames{ii};
        end
        imgfile = fullfile(path,[name(1:end-4) 'foto.mat']);
        fotoset.bld = IMG.bld;
        fotoset.nam = IMG.nam;
        save(imgfile,'fotoset');
        Redraw(1);
    case CMD.DBase
        tmp = Log.master;
        button = {'load';'clear';'save'};
        switch questdlg('What to do with the Logger Dbase','Choose ',button{1},button{2},button{3},button{1})
            case button{1}, Log.master = true;
                            DoLogger(CMD,{'load'});
                            Log.master = tmp;
            case button{2}, LoggerClear;
                            KnobGrey(CMD.DBase);
            case button{3}, Log.master = true;
                            DoLogger(CMD,{'save'});
                            Log.master = tmp;
        end
    case CMD.noshow, ToggleRed_Callback(hObject);
    case CMD.myboolean
        if panels.myboolean, txt = 'Off'; KnobGrey(hObject); else,txt = 'On'; KnobRed(hObject); end
        panels.myboolean = ~panels.myboolean;
        set(CMD.myboolean,'String',[get(hObject,'UserData') txt]);
    case CMD.savehem                     % save offline data
        if isempty(Meting), return; end
        KnobRed(hObject);
        drawnow();
        for jj = 1:length(Meting), Meting(jj).version = getversion; end
        Meting = DACcompress(Meting);
        Meting = MeanIni(Meting);
        [filepath,filename,~] = fileparts(panels.file.name);
        save(fullfile(filepath,[filename '-saved.mat']),'Meting','-v6')
        KnobGrey(hObject);
    case CMD.Loadmodus
        switch get(hObject,'String')
            case 'cell', set(hObject,'String','dir', 'TooltipString','load all files from this cell');
            case 'dir',  set(hObject,'String','file','TooltipString','load all files in this dir');
            case 'file', set(hObject,'String','cell','TooltipString','load single or multiple file(s)');
        end
    case CMD.ClearMemory, MemoryUpdate; Redraw(1);
    otherwise
        if KnobIsBlue(CMD.Savedata)
            button1 = 'Cancel Load';
            button2 = 'Save Data';
            button = questdlg('You have unsaved measured data!','Load-Data',button1,button2,'Ignore',button1);
            switch button
                case button1, return;
                case button2, SaveNeuron(Meting,ClaimFilename,CMD);
            end
            KnobGrey(CMD.Savedata);
        end
        loaddata(hObject,[]);
        Error("box");
end

function CMD_Callback(hObject,~,mode)
global panels Meting timeline
CMD = getPANEL('CMDpanel'); if isempty(CMD), return; end
switch mode
    case 'statistics', DoStatistics;
    case 'offline',CMDoffline(CMD,hObject,false);
    case 'online', CMDonline (CMD,hObject,false);
    case 'basic',  CMDbasic  (CMD,hObject);
    case 'scale',  CMDscale  (CMD,hObject); Redraw;
    case 'eeg',    CMDeeg    (CMD,hObject);
    case 'zoom',   if ~isempty(Meting), CMDzoom(CMD,hObject); NRNtimeline; end
    otherwise
        switch hObject
            case CMD.clear
                Waitbar(CMD,'hide'); WindowClear;
            case CMD.smooth
                panels.cursor.smooth = get(CMD.smooth,'Value');
            case {CMD.zoom, CMD.setleft, CMD.setright}
                if ~panels.online, Timeklik(hObject,[],0); end
            case CMD.redraw
                WindowClear;
                panels.NRNabort = false;
                panels.NRNbusy = false;
                Redraw(1)
            case CMD.full
                timeline.boundery = [-inf inf];
                Zoomstack(CMD);
                setdaqpars(panels.zoom.tnul,panels.zoom.tend);
                Redraw(1);
                
            case CMD.skip
                CMD.skipnr.Value = true;
                switch CMD.skip.String
                    case 'all',   CMD.skip.String = 'skip';
                    case 'fix',   CMD.skip.String = 'skip';    
                    case 'skip',  CMD.skip.String = 'all';  CMD.skipnr.String = '1';
                end
                if ~panels.online, Redraw; end
            case CMD.skipnr
                CMD.skipnr.Value = true;
                CMD.skip.String = 'fix';
                if ~panels.online, Redraw; end
            case CMD.killset
                MemoryUpdate('remove');
                NRNtimeline;
            case CMD.kill
                if KnobIsRed(hObject)
                    KnobGrey(hObject);
                    txt = 'arrow';
                else
                    KnobRed(hObject);
                    txt = 'cross';
                end
                set(gcf,'Pointer',txt);
        end
end
Error("box");

function Setonlinemode(newmode)
global DAQ panels
CMD = getPANEL('CMDpanel');
panels.online = newmode && ~isempty(DAQ);
if panels.online
    txt = 'on line';
    set([CMD.offlineset; CMD.EEGset; CMD.macro; CMD.valid; CMD.window; CMD.txt],'Visible','Off');
    set([CMD.onlineset; CMD.timeset; CMD.protocol],'Visible','On');
else
    txt = 'off line';
    if get(CMD.zoom,'UserData')
        set([CMD.onlineset; CMD.protocol;CMD.timeset],'Visible','Off');
        set([CMD.offlineset;CMD.macro;  CMD.EEGset;  CMD.valid; CMD.window; CMD.txt],'Visible','On');
    else
        set([CMD.onlineset; CMD.protocol;CMD.EEGset],'Visible','Off');
        set([CMD.offlineset;CMD.macro;  CMD.timeset; CMD.valid;CMD.window;CMD.txt],'Visible','On');
    end
    CMD.transform.Visible = 'Off';
end
set(CMD.online,'String',txt);
KnobMake;
if ~Error("box"), NRNtimeline; end
%
% ====== Protocol and Script files =========================================
%
function Script_Save(CMD)
global panels
[fid,message] = fopen(panels.file.script,'w');
if ~isempty(message), Error(sprintf('%s\n%s',message,panels.file.script)); return; end
script = get(CMD.script,'String');
row = size(script,1);
for jj = 1:row
    if jj==1, fprintf(fid,'neuronfile (Script, %6.2f, %s) do not edit this line\n',getversion/1000,date); end
    if iscell(script)
        str1 = script{jj};
    else
        str1 = script(jj,:);
    end
    while (~isempty(str1)) && strcmp(str1(end),' '), str1(end) = []; end
    fprintf(fid,'%s\n',str1);
end
fclose(fid);
[~,fname] = fileparts(panels.file.script);
set(CMD.Scriptfilename,'String',fname);
KnobGrey(CMD.ScriptSave);

function Protocol_Test
reset = KnobMake;
if ~Error && reset
    Resetall(false);
    KnobMake;
end
CMD = getPANEL('CMDpanel');
if Error
    set(CMD.protocol,'ForegroundColor',[1 0 0]);
    SetMenu('error');
else
    set(CMD.protocol,'ForegroundColor',[0 0 0]);
    SetMenu('version');
end

function Protocol_Save(CMD)
global panels
[fid,message] = fopen(panels.file.proto,'w');
if ~isempty(message), Error(sprintf('%s\n%s',message,panels.file.proto)); return; end
protocol = get(CMD.protocol,'String');
row = size(protocol,1);
fprintf(fid,'neuronfile (protocol, %6.2f, %s) do not edit this line\n',getversion/1000,date);
for jj=1:row
    if iscell(protocol)
        fprintf(fid,'%s\n',protocol{jj});
    else
        fprintf(fid,'%s\n',protocol(jj,:));
    end
end
fclose(fid);
[~,fname] = fileparts(panels.file.proto);
set(CMD.protocolfile,'String',fname);
KnobGrey(CMD.ProtocolSave);
%

function DACset(devout)
global DAQ axon 
for device = devout
    if ~isrunning(DAQ(device).dac)
        daqchans = [DAQ(device).dac.Channel.HwChannel]';
        if iscell(daqchans), daqchans = cell2mat(daqchans); end
        daqchans = daqchans + 1;
        outdevs = [axon.output.device];
        outchns = [axon.output.local];
        holds = [];
        for jj = 1:length(daqchans)
            die = find((outdevs==device) & (outchns==daqchans(jj)));
            if ~isempty(die)
                holds = [holds (axon.output(die).hold + DAQ(device).DAC.scale(jj).junction) * DAQ(device).DAC.ints / DAQ(device).DAC.scale(jj).User];
            end
        end
        putsample(DAQ(device).dac,holds);
    end
end

function Axondisplay(AXON,voltage,current)
set(AXON.vvalue,'String',sprintf('%0.1f',voltage));
if abs(current)<=2000
    set(AXON.ivalue,'String',sprintf('%0.0f',current));
else
    set(AXON.ivalue,'String',sprintf('%0.2f',current/1000));
end

function monvals = GetMonitor
global DAQ axon
monvals  = getsample(DAQ(axon.monitor).adc);
junction = [DAQ(axon.monitor).ADC.scale.junction];
daar = find(junction~=0);
if ~isempty(daar)
    daar = daar(daar<=length(monvals));
    monvals(daar) = monvals(daar) - junction(daar);
end

function AXON = AxonMonitor(AXON,monvals)
global DAQ axon 
oldgain = DAQ(AXON.pars.dev).ADC.scale(AXON.pars.adc(1)).User;
[~,newidx] = min((AXON.selector-monvals(8)).^2);
newgain = AXON.gains(newidx);
if newgain~=oldgain
    monvals(1) = monvals(1) * newgain / oldgain;
    DAQ(AXON.pars.dev).ADC.scale  (AXON.pars.adc(1)).User     = newgain;
    DAQ(axon.monitor ).ADC.scale  (AXON.monchn(1)).User       = newgain;
    DAQ(axon.monitor ).adc.Channel(AXON.monchn(1)).UnitsRange = newgain * [-1 1];
end
AXON.pars.Cm  = monvals(5);
[~,index]   = min(((2:2:10)-monvals(6)).^2);
AXON.pars.flt = AXON.freqvals(index);
set(AXON.Cm,    'String',sprintf('%0.1f',AXON.pars.Cm));
set(AXON.filter,'String',sprintf('%2u',AXON.pars.flt));
if strcmp(AXON.pars.mode,'VC')
    Axondisplay(AXON,monvals(2),monvals(1));
else
    Axondisplay(AXON,monvals(1),monvals(2));
end
    
function ReporterStop
timers = timerfind('Tag','REPORTER');
for jj = 1:length(timers)
    if isvalid(timers(jj))
        name = get(timers(jj),'Name');
        stop   (timers(jj));
        delete (timers(jj));    
        clear name
    end
end
tags = findobj('Tag','reporter','Visible','On');
if ~isempty(tags), KnobGrey(tags); end

function Reporter(~,~)
global DAQ
tags = findobj('Tag','reporter');
tagon= findobj('Tag','reporter','Visible','On');
if ~isempty(tagon)
    AXON = get(get(tagon(1),'parent'),'UserData');
    if islogging(DAQ(AXON.pars.dev).adc)
        KnobBlue(tagon(1));
    else
        monvals = GetMonitor;
        AxonMonitor(AXON,monvals(AXON.monchn));
        ander = tags(tags~=tagon);
        if ~isempty(ander)
            AXON = get(get(ander,'parent'),'UserData');
            AxonMonitor(AXON,monvals(AXON.monchn));
        end
    end
end

function AxonSwitch(AXON,hObject)
global DAQ DAQrbp axon
parent = get(hObject,'Parent');
if KnobIsBlue(parent)
    KnobGrey(parent);
    set(hObject,'String','Switch');
    return
else
    KnobBlue(parent);
    set(hObject,'String','Cancel');
end
if strcmp(AXON.pars.mode,'CC')
    orgbits = getvalue(DAQrbp(AXON.rbp).DIO.outlines);
    orgbits(1:3) = [0,0,0];
    putvalue(DAQrbp(AXON.rbp).DIO.outlines, orgbits);
    pause(0.010);
end
outchn = find([axon.output.channel]==AXON.pars.hdac);
if isempty(outchn), Error('missing outputchannels'); return; end
monvals = GetMonitor; monvals = monvals(AXON.monchn);
AXON = AxonMonitor(AXON,monvals);
WindowClear;
device  = AXON.pars.dev;
newmain = DAQ(AXON.pars.dev).ADC.scale(AXON.pars.adc(2:-1:1));
newmoni = DAQ(axon.monitor ).ADC.scale(AXON.monchn(2:-1:1));
hwrmoni = DAQ(axon.monitor ).adc.Channel(1:2).UnitsRange;
cnt = 1;
raw = getsample(DAQ(axon.monitor).adc); raw = raw(AXON.monchn);
[~,index] = min((AXON.switcher - raw(7)).^2);
if AXON.switcher(index)>4
    junction = DAQ(axon.monitor).ADC.scale(2).junction;  
    voltage  = raw(2) - junction;
    current  = raw(1);    
	while (AXON.switcher(index)>4)
        if ~KnobIsBlue(parent), return; end
        raw = getsample(DAQ(axon.monitor).adc);
        raw = raw(AXON.monchn);
        voltage = (voltage*cnt + raw(2) - junction)/(cnt+1);
        current = (current*cnt + raw(1))/(cnt+1);
        Axondisplay(AXON,voltage,current);
        cnt = cnt + 1;        
        [~,index] = min((AXON.switcher-raw(7)).^2);
	end
    DAQ(axon.monitor).ADC.scale(AXON.monchn(1:2)) = newmoni;
    DAQ(device).ADC.scale(AXON.pars.adc(1:2))   = newmain;
    DAQ(device).DAC.scale(AXON.pars.dac)        = newmain(2);
    DAQ(device).DAC.scale(AXON.pars.dac).User   = AXON.CCmax;
    DAQ(axon.monitor).adc.Channel(1).UnitsRange = hwrmoni{2};
    DAQ(axon.monitor).adc.Channel(2).UnitsRange = hwrmoni{1};
    AXON.pars.Ihold          = current;
    AXON.pars.Vhold          = voltage;
    axon.output(outchn).hold = current;
    DACset(device);
    drawnow();
	while true
        pause(0.1);
        raw = getsample(DAQ(axon.monitor).adc);
        raw = raw(AXON.monchn);
        [~,index] = min((AXON.switcher-raw(7)).^2);
        if AXON.switcher(index)<3, break; end
	end
    AXON.pars.mode = 'CC';
else
    if ~isempty(DAQrbp)
        putvalue(DAQrbp(AXON.rbp).DIO.outlines,[0,0,0,0,0,0,0,0]);
        KnobGrey([AXON.soft, AXON.dyna]);
    end
    junction = DAQ(axon.monitor).ADC.scale(AXON.monchn(1)).junction;
    voltage  = raw(1) - junction;
    current  = raw(2);
	while AXON.switcher(index)<3
        if ~KnobIsBlue(parent), return; end
        raw = getsample(DAQ(axon.monitor).adc);
        raw = raw(AXON.monchn);
        voltage = (voltage*cnt + raw(1) - junction)/(cnt+1);
        current = (current*cnt + raw(2))/(cnt+1);        
        Axondisplay(AXON,voltage,current);
        cnt = cnt + 1;
        [~,index] = min((AXON.switcher-raw(7)).^2);
	end
    DAQ(axon.monitor).ADC.scale(AXON.monchn(1:2)) = newmoni;
    DAQ(device).ADC.scale(AXON.pars.adc(1:2))     = newmain;
    DAQ(device).DAC.scale(AXON.pars.dac)          = newmain(2);
    DAQ(device).DAC.scale(AXON.pars.dac).User     = AXON.VCmax;
    DAQ(axon.monitor).adc.Channel(1).UnitsRange   = hwrmoni{2};
    DAQ(axon.monitor).adc.Channel(2).UnitsRange   = hwrmoni{1};
    AXON.pars.Ihold = current;
    AXON.pars.Vhold = voltage;
    axon.output(outchn).hold = voltage;
    DACset(device);
    drawnow();
	while true
        pause(0.1);
        raw = getsample(DAQ(axon.monitor).adc);
        raw = raw(AXON.monchn);
        [~,index] = min((AXON.switcher-raw(7)).^2);
        if AXON.switcher(index)>4, break; end
	end
    AXON.pars.mode = 'VC';
end
set(AXON.mode,'String',AXON.pars.mode);
set(AXON.handle,'UserData',AXON);
KnobGrey(parent);
set(hObject,'String','Switch');
%
% ====== Make protocols ======================================
%
function setpanelaxonandp(Meting)
global panels p
flds = fieldnames(Meting.EXTRA.p);
for jj = 1:length(flds), p.(flds{jj}) = Meting.EXTRA.p.(flds{jj}); end
if isempty(Meting.EXTRA.AXON1.pars)
    panels.axon.Vh1  = NaN;
    panels.axon.Ih1  = NaN;
    panels.axon.Vs1  = NaN; 
    panels.axon.Vr1  = NaN;
    panels.axon.gm1  = NaN;
else
    panels.axon.Vh1  = Meting.EXTRA.AXON1.pars.Vhold;
    panels.axon.Ih1  = Meting.EXTRA.AXON1.pars.Ihold;
    panels.axon.Vs1  = Meting.EXTRA.AXON1.pars.Vsoft; 
    panels.axon.Vr1  = Meting.EXTRA.AXON1.imps.Vr;
    panels.axon.gm1  = Meting.EXTRA.AXON1.imps.gm;
end
if isempty(Meting.EXTRA.AXON2.pars)
    panels.axon.Vh2  = NaN;
    panels.axon.Ih2  = NaN;
    panels.axon.Vs2  = NaN; 
    panels.axon.Vr2  = NaN;
    panels.axon.gm2  = NaN;
else
    panels.axon.Vh2  = Meting.EXTRA.AXON2.pars.Vhold;
    panels.axon.Ih2  = Meting.EXTRA.AXON2.pars.Ihold;
    panels.axon.Vs2  = Meting.EXTRA.AXON2.pars.Vsoft;
    panels.axon.Vr2  = Meting.EXTRA.AXON2.imps.Vr;
    panels.axon.gm2  = Meting.EXTRA.AXON2.imps.gm;
end
if isempty(Meting.EXTRA.EP.stim)
    panels.axon.Int1 = NaN; 
    panels.axon.Int2 = NaN;
else
    panels.axon.Int1 = Meting.EXTRA.EP.stim.Istim(1); 
    panels.axon.Int2 = Meting.EXTRA.EP.stim.Istim(2);
end

function assigncmd(cmdstr)
global panels SEL axon p
if ~isempty(panels.mouse), mouse    = panels.mouse; end
if ~isempty(panels.duur),  duration = panels.duur; end
if ~isempty(SEL),          select3  = str2double(get(SEL.select3,'String')); end
MyBoolean = panels.myboolean;
if panels.online
    AXON = getPANEL('AXON1');
    if ~isempty(AXON)
        Vh1 = AXON.pars.Vhold;
        Ih1 = AXON.pars.Ihold;
        Vs1 = AXON.pars.Vsoft;
        Vr1 = AXON.imps.Vr;
        gm1 = AXON.imps.gm;
        if gm1>0, Rm1 = 1/gm1; else, Rm1 = NaN; end
    end
    AXON = getPANEL('AXON2');
    if ~isempty(AXON)
        Vh2 = AXON.pars.Vhold;
        Ih2 = AXON.pars.Ihold;
        Vs2 = AXON.pars.Vsoft;
        Vr2 = AXON.imps.Vr;
        gm2 = AXON.imps.gm;
        if gm2>0, Rm2 = 1/gm2; else, Rm2 = NaN; end
    end
    EP = getPANEL('EPpanel');
    if ~isempty(EP)
        Int1  = EP.stim.amp(1);
        Int2  = EP.stim.amp(2);
    end
else
    Vh1  = panels.axon.Vh1;
    Ih1  = panels.axon.Ih1;
    Vs1  = panels.axon.Vs1;
    Vr1  = panels.axon.Vr1;
    gm1  = panels.axon.gm1;
    if gm1>0, Rm1 = 1/gm1; else, Rm1 = NaN; end
    Vh2  = panels.axon.Vh2;
    Ih2  = panels.axon.Ih2;
    Vs2  = panels.axon.Vs2;
    Vr2  = panels.axon.Vr2;
    gm2  = panels.axon.gm2;
    if gm2>0, Rm2 = 1/gm2; else, Rm2 = NaN; end
    Int1 = panels.axon.Int1;
    Int2 = panels.axon.Int2;
    if strcmp(panels.amplifier,'AXON2')
        Vh = Vh2;
        Ih = Ih2;
        Vr = Vr2;
        Vs = Vs2;
        gm = gm2;
        Rm = Rm2;
    else
        Vh = Vh1;
        Ih = Ih1;
        Vr = Vr1;
        Vs = Vs1;
        gm = gm1;
        Rm = Rm1;
    end
end
SEamp = axon.SEA.tetamp;
try  
    eval([cmdstr ';']);
catch
    Error(sprintf("MATLAB cannot evaluate:\n%s",cmdstr));
end

function res = rsingle(str,varargin)
global panels SEL axon p
if isnumeric(str),  res = str; return; end
if strcmp(str,':'), res = 0;   return; end
res = str2double(str);
if find(isnan(res)==1)
    MyBoolean = panels.myboolean;
    if ~isempty(panels.mouse),   mouse = panels.mouse; end
    if ~isempty(panels.duur), duration = panels.duur; end
    if ~isempty(SEL),          select3 = str2double(get(SEL.select3,'String')); end
    if panels.online
        AXON = getPANEL('AXON1');
        if ~isempty(AXON)
            Vh1 = AXON.pars.Vhold;
            Ih1 = AXON.pars.Ihold;
            Vs1 = AXON.pars.Vsoft;
            Vr1 = AXON.imps.Vr;
            gm1 = AXON.imps.gm;
            if gm1>0, Rm1 = 1/gm1; else, Rm1 = NaN; end
        end
        AXON = getPANEL('AXON2');
        if ~isempty(AXON)
            Vh2 = AXON.pars.Vhold;
            Ih2 = AXON.pars.Ihold;
            Vs2 = AXON.pars.Vsoft;
            Vr2 = AXON.imps.Vr;
            gm2 = AXON.imps.gm;
            if gm2>0, Rm2 = 1/gm2; else, Rm2 = NaN; end
        end
        EP = getPANEL('EPpanel');
        if ~isempty(EP)
            Int1  = EP.stim.amp(1);
            Int2  = EP.stim.amp(2);
        end
    else
        Vh1 = panels.axon.Vh1;
        Vh2 = panels.axon.Vh2;
        Ih1 = panels.axon.Ih1;
        Ih2 = panels.axon.Ih2;
        Vr1 = panels.axon.Vr1;
        Vr2 = panels.axon.Vr2;
        Vs1 = panels.axon.Vs1;
        Vs2 = panels.axon.Vs2;
        gm1 = panels.axon.gm1;
        if gm1>0, Rm1 = 1/gm1; else, Rm1 = NaN; end
        gm2  = panels.axon.gm2;
        if gm2>0, Rm2 = 1/gm2; else, Rm2 = NaN; end
        if strcmp(panels.amplifier,'AXON2')
            Vh = Vh2;
            Ih = Ih2;
            Vr = Vr2;
            Vs = Vs2;
            gm = gm2;
            Rm = Rm2;
        else
            Vh = Vh1;
            Ih = Ih1;
            Vr = Vr1;
            Vs = Vs1;
            gm = gm1;
            Rm = Rm1;
        end
        Int1 = panels.axon.Int1;
        Int2 = panels.axon.Int2;
    end
    SEamp = axon.SEA.tetamp;
    try
        vraag = ['res=[' str '];'];
        evalc(vraag);
        if ~iscell(res) &&  ~isnumeric(res) && ~islogical(res)
            if nargin==1, Error(sprintf("\n%s is not numeric",str)); end
            res = NaN;
            return;
        end
    catch
        if nargin==1, Error(sprintf("%s does not result in numeric: %s",str)); end
        res = NaN;
    end
end

function num = nsingle(strin)
num = round(rsingle(strin));

function str = ssingle(str)
global SEL p
% str = Unquote(str);
str = strtrim(char(str));
if isempty(str)
    return
elseif strcmp(str,'select3') && ~isempty(SEL)
    str = SEL.select3.String;
elseif contains(str,'p.')
    try
        evalc(['str =' str ';']);
    catch
%         Message(sprintf('%s can not be evaluated', hlp));
    end
elseif ~ischar(str) && ~isstring(str)
    Message('Need a string as input');
end

function res = stringset(str)
hlp = textscan(Unquote(str),'%s','Delimiter',';');
res = hlp{1};
for jj = 1:length(res), res{jj} = ssingle(res{jj}); end

function valid = syntax(str)
global panels
str = char(str);
valid = false;
cmds = [];
d3 = strfind(str,'{')';
d4 = strfind(str,'}')';
if     length(d3)<length(d4)
    Error('{ missing'); return;
elseif length(d3)>length(d4)
    Error('} missing'); return;
elseif isempty(d3)
    cmds{1,1} = ' Single text ';
    cmds{1,2} = str;
else
    cmds{1,1} = str(1:d3(1)-1);
    cmds{1,2} = str(d3(1)+1:d4(1)-1);
    for jj = 2:length(d3)
        cmds{jj,1} = str(d4(jj-1)+1:d3(jj)-1);
        cmds{jj,2} = str(d3(jj)  +1:d4(jj)-1);
    end
end
for jj = 1:size(cmds,1)
    command = cmds{jj,1};
    hlp     = cmds{jj,2};
    if mod(length(strfind(hlp,char(39))),2)~=0
        Error(sprintf('Quote mismatch in\n%s', command)); return
    end
    d1 = length(strfind(hlp,'['));
    d2 = length(strfind(hlp,']'));
    if     d1<d2, Error(' [ missing in %s',command); return;
    elseif d1>d2, Error(' ] missing in %s',command); return;
    end
    d1 = strfind(hlp,'(');
    d2 = strfind(hlp,')');
    if     length(d1)<length(d2), fout = sprintf('    -(- missing in %s',command);
    elseif length(d1)>length(d2), fout = sprintf('    -)- missing in %s',command);
    else, continue; end
    cnt = 1;
    level     = 1;
    indent(1) = 0;
    pss = [];
    pss{cnt,1} = '';
    for jjj=1:length(hlp)
        pss{cnt,1}(end+1) = hlp(jjj);
        if hlp(jjj) == '('
            level = level+1;
            indent(level) = length(pss{cnt,1});
        elseif hlp(jjj) == ')'
            level = level-1;
        elseif (hlp(jjj) == ',')
            cnt = cnt + 1;
            pss{cnt,1} = blanks(indent(level));
            for ii=2:level-1, pss{cnt,1}(indent(ii)+1) = '|'; end
        end
    end
    wmax = 0; for ii = 1:length(pss), wmax = max(wmax,length(pss{ii})); end
    modus = get(0,'Units');
    set(0,'Units','characters');
    maxscherm = get(0,'Screensize');
    set(0,'Units',modus);
    breed = min(1.55*(wmax+2)/maxscherm(3),1);
    hoog  = min(1.25*(size(pss,1)-3)/maxscherm(4),0.915);
    pos   = [0.5-0.5*breed,0.965-hoog,breed,hoog];
    if isempty(panels.h)
        panels.h = figure('Toolbar','none','IntegerHandle','off','Menubar','none','NumberTitle','Off',...
                          'CloseRequestFcn',@CloseManager,'Units','normalized','Name',fout,...
                          'Position',pos);
    else
        figure(panels.h)
        set(panels.h,'Name',fout,'Position',pos);
    end
    uicontrol(panels.h,'Style','Listbox','Fontsize',10,'Fontname','Courier New','Units','normalized',...
                       'String',pss,'Position',[0,0,1,1]);
    Error(fout);
    return
end
valid = true;

function parms = ParseSimple(str,varargin)
parms = {};
str = char(str);
if isempty(str), return; end
if nargin>1, separator = ' '; else, separator = ','; end
if ~syntax(str), return; end
str=strtrim(str);
str(strfind(str,'  '))   = [];
str(strfind(str,'( ')+1) = [];
str(strfind(str,' )'))   = [];
str(strfind(str,'[ ')+1) = [];
str(strfind(str,' ]'))   = [];
str(strfind(str,': ')+1) = [];
str(strfind(str,' :'))   = [];
str(strfind(str,', ')+1) = [];
str(strfind(str,' ,'))   = [];
pnr = 0;
cnt = 0;
hstr = '';
while  cnt<length(str)
    cnt = cnt + 1;
    hstr(end+1) = str(cnt);
    if str(cnt)== ')'
        Error(sprintf('illegal sequence, forgot a comma as eol?\n%s',str(1:cnt)));
        return;
    elseif (str(cnt)=='(') || (str(cnt)=='[')
        lvl = 1;
        while lvl>0
            cnt = cnt + 1;
            hstr(end+1) = str(cnt);
            if (str(cnt)=='(') || (str(cnt)=='[')
                lvl = lvl + 1;
            elseif (str(cnt)==')') || (str(cnt)==']')
                lvl = lvl - 1;
            end
        end
        if cnt==length(str)
            pnr = pnr + 1;
            parms{pnr,1} = strtrim(hstr);
            hstr = '';
        end
    elseif str(cnt)==char(39)
        done = false;
        while ~done
            cnt = cnt + 1;
            if cnt>length(str)
                Error(sprintf('length error, forgotten comma around here?\n%s',str(1:cnt)));
            end
            hstr(end+1) = str(cnt);
            if (str(cnt)=='(') || (str(cnt)=='[')
                lvl = 1;
                while lvl>0
                    cnt = cnt + 1;
                    hstr(end+1) = str(cnt);
                    if (str(cnt)=='(') || (str(cnt)=='[')
                        lvl = lvl + 1;
                    elseif (str(cnt)==')') || (str(cnt)==']')
                        lvl = lvl - 1;                
                    end
                end
            end
            done = str(cnt)==char(39);
        end
        hstr = strtrim(hstr);
        if ~isempty(hstr) && (hstr(1)==char(39)) && (hstr(end)==char(39))
            hstr([1 end]) = [];
        end
        pnr = pnr + 1;
        parms{pnr,1} = strtrim(hstr);
        hstr = '';
    elseif str(cnt)=='"'
        done = false;
        while ~done
            cnt = cnt + 1;
            if cnt>length(str)
                Error(sprintf('length error, forgotten comma around here?\n%s',str(1:cnt)));
            end
            hstr(end+1) = str(cnt);
            if (str(cnt)=='(') || (str(cnt)=='[')
                lvl = 1;
                while lvl>0
                    cnt = cnt + 1;
                    hstr(end+1) = str(cnt);
                    if (str(cnt)=='(') || (str(cnt)=='[')
                        lvl = lvl + 1;
                    elseif (str(cnt)==')') || (str(cnt)==']')
                        lvl = lvl - 1;                
                    end
                end
            end
            done = str(cnt)=='"';
        end
        hstr = strtrim(hstr);
        if ~isempty(hstr) && (hstr(1)=='"') && (hstr(end)=='"')
            hstr([1,end]) = [];
        end
        pnr = pnr + 1;
        parms{pnr,1} = strtrim(hstr);
        hstr = '';
    elseif str(cnt)==separator
        if length(hstr)>1
            pnr = pnr + 1;
            parms{pnr,1} = strtrim(hstr(1:end-1));
        end
        hstr = '';
    elseif (cnt==length(str)) && ~isempty(hstr)
        pnr = pnr + 1;
        parms{pnr,1} = strtrim(hstr);
    end
end

function [cmd,parms,varargout] = ParseCmd(str,varargin)
cmd = char(str);
str = strtrim(Unquote(char(str)));
parms = [];
dosquare = nargin>1;
onequote = char(39);
twoquote = '"';
k1 = [];
lvl = 0;
jj = 1;
while jj<=length(str)
    if str(jj)=='('
        jj = jj + 1;
        if ~dosquare, k1 = jj; end
        lvl = lvl + 1;
        while jj<=length(str)
            if str(jj)=='('
                lvl = lvl + 1;
            elseif str(jj)==')'
                lvl = lvl - 1;
                if lvl==0
                    if ~dosquare, k2 = jj-1; end
                    jj = jj + 1;
                    break;
                end
            elseif str(jj)==onequote
                nxt = strfind(str(jj+1:end),onequote);
                if isempty(nxt), Error(sprintf('missing single quote in\n%s',str)); return; end
                jj = nxt(1)+jj;
            elseif str(jj)==twoquote
                nxt = strfind(str(jj+1:end),twoquote);
                if isempty(nxt), Error(sprintf('missing double quote in\n%s',str)); return; end
                jj = nxt(1)+jj;
            end
            jj = jj + 1;
        end
    elseif str(jj)=='['
        jj = jj + 1;
        if dosquare, k1 = jj; end
        lvl = lvl + 1;
        while jj<=length(str)
            if str(jj)=='['
                lvl = lvl + 1;
            elseif str(jj)==']'
                lvl = lvl - 1;
                if lvl==0
                    if dosquare, k2 = jj-1; end
                    jj = jj + 1;
                    break;
                end
            elseif str(jj)==onequote
                nxt = strfind(str(jj+1:end),onequote);
                if isempty(nxt), Error(sprintf('missing single quote in\n%s',str)); return; end
                jj = nxt(1)+jj;
            elseif str(jj)==twoquote
                nxt = strfind(str(jj+1:end),twoquote);
                if isempty(nxt), Error(sprintf('missing double quote in\n%s',str)); return; end
                jj = nxt(1)+jj;
            end
            jj = jj + 1;
        end
    elseif str(jj)==onequote
        jj = jj + 1;
        nxt = strfind(str(jj:end),onequote);
        if isempty(nxt), Error(sprintf('missing single quote in\n%s',str)); return; end
        jj = nxt(1)+jj-1;
    elseif str(jj)==twoquote
        jj = jj + 1;
        nxt = strfind(str(jj:end),twoquote);
        if isempty(nxt), Error(sprintf('missing double quote in\n%s',str)); return; end
        jj = nxt(1)+jj-1;
    elseif (str(jj)=='=') && (lvl==0) && ~dosquare
        return
    else
        jj = jj + 1; 
    end
end
if lvl~=0
    Error(sprintf('%s%s mismatch in\n%s',openchar,closechar,str));
    return
elseif ~isempty(k1)
    cmd = strtrim(str(1:k1-2)); 
    parms = ParseSimple(str(k1:k2));
    if nargout==3, varargout{1} = str(k1:k2); end 
end

function [parms,present,varargout] = ParseSpecial(parms,cmd)
present = false;
varargout{1} = [];
varargout{2} = [];
for ii = 1:length(parms)
    hlp = parms{ii};
    if isnumeric(hlp)
        Message(sprintf('par %u shoeld be text instead of %6.2f',ii,hlp));
        return
    end
    fnd = find(hlp=='(',1);
    if ~isempty(fnd), hlp = hlp(1:(fnd-1)); end
    hlp = strtrim(hlp);
    if strcmp(hlp,cmd)
        present = true;
        select = true(length(parms),1);
        select(ii) = false;
        if nargout>2
            [~,varargout{1}] = ParseCmd(parms{ii});
            if nargout>3, varargout{2} = [parms{~select}]; end
        end
        parms = parms(select);
        return
    end
end

function [ps,dacnrs] = ParseDACs(ps,Meting)
dacnrs = [];
if isempty(Meting), return; end
[ps,present,psh] = ParseSpecial(ps,'dacs');
if present
    res = rsingle(psh{1});
    if find(isnan(res)==1)
        fndnames = stringset(ssingle(psh{1}));
        dacnames = {Meting.DAC.scale.Name}';
        for jj = 1:length(fndnames)
            for ii = 1:length(dacnames)
                if strcmp(fndnames{jj},dacnames{ii})
                    dacnrs =[dacnrs ii];
                end
            end
        end
    else
        dacnrs = nsingle(psh{1});
        if dacnrs(1)==0
            dacnrs = 1:length(Meting.DAC.scale);
        end
    end
    dacnrs(dacnrs>length(Meting.DAC.scale)) = [];
end

function status = getboolean(parms,status)
global panels
if ~isempty(parms)
    str = ssingle(parms{1});
    if strcmpi(str,'On') || strcmpi(str,'Yes') || strcmpi(str,'Y') || strcmpi(str,'1')
        status = true;
    elseif strcmpi(str,'Off') || strcmpi(str,'No') || strcmpi(str,'N') || strcmpi(str,'0')
        status = false;
    elseif strcmpi(str,'MyBoolean')
        status = panels.myboolean;
    else
        Error('Not a boolean answer');
    end
end

function [parmout,status] = ParseBoolean(parmin,command,status)
first   = true;
parmout = {};
cnt     = 1;
for ii = 1:length(parmin)
    if strfind(parmin{ii},command)
        if first
            [~,ps] = ParseCmd(parmin{ii});
            status = getboolean(ps,status);
            if Error, return; end
            first = false;
            continue;
        end
    end
    parmout{cnt,1} = parmin{ii};
    cnt = cnt + 1;
end

function [parms,timegain] = gettimescale(parms,varargin)
[parms,present] = ParseSpecial(parms,'ms');
if present
    timegain = 1;
else
    [parms,present] = ParseSpecial(parms,'sec');
    if present
        timegain = 1000;
    else
        [parms,present] = ParseSpecial(parms,'min');
        if present
            timegain = 60000;
        else
            [parms,present] = ParseSpecial(parms,'hrs');
            if present
                timegain = 3600000;
            else
                if nargin>1
                    timegain = varargin{1};
                else
                    timegain = 1;
                end
            end
        end
    end
end

function [parms,tijd] = ParseTijd(parms,command,outputscale)
global panels
[parms,present,ps] = ParseSpecial(parms,command);
if present
    if nargin>3
        [ps,present] = ParseSpecial(ps,'full');
        if present
            tijd = ([panels.zoom.tnul,panels.zoom.tend])/outputscale;
            return
        else
            [ps,present] = ParseSpecial(ps,'frame');
            if present
                tijd = [panels.zoom.tbgn,panels.zoom.tlst]/outputscale;
                return
            end
        end
    end
    [ps,timegain] = gettimescale(ps);
    tijd = [];
    for jj = 1:length(ps)
        tijd = [tijd timegain * rsingle(ps{jj})];
    end
    tijd = tijd/outputscale;
elseif strcmp(command,'duur')
    tijd = panels.duur/outputscale;
else
    tijd = [];
end

function [t1,t2,extra] = ParseRange(times,varargin)
t1 = times(1);
extra = [];
if length(times)>1
    t2 = times(2);
    if (nargin>1) && ~isempty(varargin{1}), extra = varargin{1}; end
elseif (nargin>1) && isnumeric(varargin{1}{1})
    t2 = varargin{1}{1};
    if nargin>2, extra = varargin{2}{1}; end
else
    t2 = t1;
    if nargin>1, extra = varargin{2}{1}; end
end

function [parms,s] = ParseScale(parms)
global panels
s = struct('x', [-inf inf],'dx', [0,0],'logx', 'linear',...
           'y', [-inf inf],'dy', [0,0],'logy', 'linear',...
           'yl',[-inf inf],'dyl',[0,0],'logyl','linear',...
           'yr',[-inf inf],'dyr',[0,0],'logyr','linear',...
           'z', [-inf inf],'dz', [0,0],'logz', 'linear');
[parms,present,ps] = ParseSpecial(parms,'scale');
if present
    die = find(strncmp(ps,'log',3));
    if ~isempty(die)
        txt = ps{die};
        for jj=4:length(txt), s.(['log' txt(jj)]) = 'log'; end
    end
    options = {'x','y','yl','yr','z','t'};
    for jj = 1:6
        mode = options{jj};
        if jj==6, gain = panels.timegain; mode = 'x'; else, gain = 1; end
        [ps,present,psh] = ParseSpecial(ps,mode);
        if present
            if ~isempty(psh), tmp1 = rsingle(psh{1}) * gain; end
            if length(psh)>1, tmp2 = rsingle(psh{2}) * gain; end
            if length(psh)>2, tmp3 = rsingle(psh{3}) * gain; tmp4 = rsingle(psh{4}) * gain; end
            if Error, return; end
            switch length(psh)
                case 0
                case 1, s.(mode) = tmp1(1:2);
                case 2, if length(tmp1)==1
                            s.(mode) = [tmp1 tmp2];
                        else
                            s.(mode) = tmp1; s.(['d' mode]) = tmp2;
                        end
                case 4, s.(mode) = [tmp1 tmp2]; s.(['d' mode]) = [tmp3 tmp4];
                otherwise
                    Error('scale(%s(..) needs 4x1 2x2 or 1(2)x4 values',mode); return
            end
        end
    end
end

function parms = ParseCondition(parms)
for jj = 1:length(parms)
    [cmd,ps] = ParseCmd(parms{jj});
    if strcmp(cmd,'IF')
        if ssingle(ps{1})
            parms{jj} = ssingle(ps{2});
        else
            parms{jj} = ssingle(ps{3});
        end
    end
end

function [txt,mode1,mode2,metdash] = ParseDash(txtin)
mode1 = 'NN';
mode2 = 'NN';
[txt,rest] = strtok(txtin,'_');
metdash = ~isempty(rest);
if metdash
    rest = rest(2:end);
    [mode1,rest] = strtok(rest,'_');
    if ~isempty(rest)
        mode2 = rest(2:end);
    end
end

function [parms,local,device,chans] = ParseChans(mode,parms,device,txt)
global DAQ axon
local = [];
chans = [];
[parms,present,ps]    = ParseSpecial(parms,mode);
if present
    chans = nsingle(ps{1});
    if length(ps)>1
        if isnan(str2double(ps{2}))
            device = find(strcmp({DAQ.BoardName},ssingle(ps{2})));
            if isempty(device), Error(sprintf('device %s does not exist',ps{2})); return; end
        else
            device = nsingle(ps{2});
        end
    end
    if device>length(DAQ)
        Error(sprintf('You access a non-existing device %u',device));
    else
        if strcmp(mode,'dacs')
            if isempty(DAQ(device).dac)
                Error(sprintf('Device %u has no dac',device));
            else
                if device>1, chans = chans + DAQ(device).DAC.HWoff; end
                [device,local] = DACdev(chans);
                for jj=1:length(local)
                    range = DAQ(device(jj)).DAC.scale(local(jj)).Hardware;
                    if (range(1)~=-10) || (range(2)~=10)
                        Error(sprintf('Device %u (%s) for channel %u does not have [-10 10] range',device(jj),DAQ(device(jj)).BoardName,chans(jj)));
                        return
                    end
                end
            end
        else
            if isempty(DAQ(device).adc)
                Error(sprintf('Device %u has no adc',device));
            elseif device==axon.monitor
                Error(sprintf('Device %u is used as monitor',axon.monitor));
            else
                if device>1, chans = chans + DAQ(device).ADC.HWoff; end
                [device,local] = ADCdev(chans);
            end
        end
    end
elseif ~isempty(txt)    
    Error(sprintf('%s needs %s() specification',txt,mode));
end

function [parms,default] = ParseOne(parms,txt,default)
[parms,present,ps] = ParseSpecial(parms,txt);
if present && ~isempty(ps), default = rsingle(ps{1}); default = default(1); end

function [parms,out,present] = ParseTwo(parms,txt,varargin)
if nargin>2
    hlp = varargin{1};
    val1 = hlp(1);
    val2 = hlp(2);
else
    val1 = [];
    val2 = [];
end
[parms,present,ps] = ParseSpecial(parms,txt);
if present && ~isempty(ps)
    hlp = rsingle(ps{1});
    val1 = hlp(1);
    if length(hlp)>1
        val2 = hlp(2);
    elseif length(ps)>1
        val2 = rsingle(ps{2});
    else
        val2 = val1;
    end
end
out = [val1, val2];

function [parms,present,varargout] = ParseThree(parms,txt,default)
val1 = []; val2 = []; val3 = default;
[parms,present,ps] = ParseSpecial(parms,txt);
if present
    switch length(ps)
        case 3, val1 = rsingle(ps{1});
                val2 = rsingle(ps{2});
                val3 = rsingle(ps{3});
        case 2, hlp  = rsingle(ps{1});
                val1 = hlp(1);
                val2 = hlp(2);
                val3 = rsingle(ps{2});
        case 1, val1 = rsingle(ps{1});
                val2 = rsingle(ps{2});
        otherwise Error('ParseThree needs 2 or 3 inputs');
    end
end
switch nargout
    case 4, varargout{1} = [val1 val2]; 
            varargout{2} = val3;
    case 5, varargout{1} = val1; 
            varargout{2} = val2;
            varargout{3} = val3;
end

function [dozero,showzero,zerorange] = ParseZero(parms)
dozero = false;
zerorange = [];
[~,showzero,ps] = ParseSpecial(parms,'Zero');
if ~showzero
    [~,present,ps] = ParseSpecial(parms,'zero');
end
if showzero || present
    dozero = true;
    [ps,present]     = ParseSpecial(ps,'sec');  if present, factor = 1000; else,factor = 1; end
    if isempty(ps)
        zerorange = [-inf inf];
    else
        zerorange = rsingle(ps{1})*factor;
        if length(zerorange)==1
            if length(ps)>1
                zerorange(2) = rsingle(ps{2})*factor; 
            else
                zerorange = zerorange * [1 1];
            end
        end
    end
end

function [parms,binsize,nbins] = ParseBins(parms)
[parms,present,ps] = ParseSpecial(parms,'binsize'); if present, binsize = rsingle(ps{1}); else, binsize = []; end
[parms,present,ps] = ParseSpecial(parms,'nbins');   if present, nbins   = nsingle(ps{1}); else, nbins = []; end

function [parms,sets,mets,swps,nodes] = ParseList(parms)
global cmdlist
nodes = 1;
sets = 1;
mets = 1;
swps = 1;
listnr = 1;
[parms,present,ps] = ParseSpecial(parms,'list');
if present
    if ~isempty(cmdlist)
        if ~isempty(ps),listnr = nsingle(ps{1}); end
        sets = cmdlist{listnr}(:,1)';
        mets = cmdlist{listnr}(:,2)';
        swps = cmdlist{listnr}(:,3)';
        nodes = cmdlist{listnr}(:,4)';
    end
else
    [parms,present,ps] = ParseSpecial(parms,'sets');  if present, sets = nsingle(ps{1}); end
    [parms,present,ps] = ParseSpecial(parms,'mets');  if present, mets = nsingle(ps{1}); end
    [parms,present,ps] = ParseSpecial(parms,'swps');  if present, swps = nsingle(ps{1}); end
    [parms,present,ps] = ParseSpecial(parms,'nodes'); if present, nodes = nsingle(ps{1}); end
    lsets = length(sets);
    lmets = length(mets);
    lswps = length(swps);
    if lmets~=lswps
        if     (lswps==1) && (lsets==1), swps(1:lmets) = swps(1)*ones(lmets,1);
                                         sets(1:lmets) = sets(1)*ones(lmets,1);
        elseif (lmets==1) && (lsets==1), mets(1:lswps) = mets(1)*ones(lswps,1);
                                         sets(1:lmets) = sets(1)*ones(lswps,1);
        elseif (lmets==1) && (lswps==1), swps(1:lsets) = swps(1)*ones(lsets,1);
                                         mets(1:lsets) = mets(1)*ones(lsets,1);
        else
            Error('mismatch in #sets, #mets or #swps');
        end
    end
end

function [parms,winclear] = ParseClear(parms)
[parms,present,ps] = ParseSpecial(parms,'clear');
if present
    if isempty(ps), winclear = 0; else, winclear = nsingle(ps{1}); end
else
    winclear = [];
end

function DoFigparms(parms)
global panels
panels.fig.idx = 0;
panels.fig.nr  = nsingle(parms{1});
if length(parms)>1, panels.fig.sub = nsingle(parms{2}); end
if length(parms)>2, panels.fig.mar = rsingle(parms{3}); end

function parms = ParseFigure(parms)
[parms,present,ps] = ParseSpecial(parms,'figure');
if present && ~isempty(ps), DoFigparms(ps); end

function [cmd,nxtmacro] = Substitute(cmdstr)
global knobs
[cmd,parms] = ParseCmd(cmdstr);
nxtmacro  = "";
if isempty(knobs.macrocmd)
    macrocmd = [];
else
    macrocmd = find(strcmp(knobs.macrocmd,cmd));
end
if isempty(macrocmd)
    knobcmd = find(strcmp(knobs.knobcmd,cmd));
    if isempty(knobcmd)
        try
            eval([cmdstr ';']);
            cmd = [];
        catch
        	Message(sprintf('\n%s is not a valid knob, macro or command',cmd));
        end
    elseif length(knobcmd)>1
        Message(sprintf('\nKnob %s is double defined',cmd));
    else
        nxtmacro = knobs.knobtxt{knobcmd};
    end
elseif length(macrocmd)>1
    Message(sprintf('\nScript %s is double defined',cmd));
else
    nxtmacro = char(knobs.macrotxt{macrocmd});
    if length(parms)<length(knobs.macropar{macrocmd})
        Message('Not enough parameters to substitute')
    else
        hlp = knobs.macropar{macrocmd};
        if ~isempty(hlp)
            if length(hlp)~=length(parms)
                Error(sprintf('Parameter nr mismatch in %s',cmd)); return;
            end
            for k1=1:length(parms)
                nxtmacro = strrep(nxtmacro,char(hlp{k1}),parms{k1});
            end
        end
    end
end

function error = addoutputdevice(name,model,panelname,chan,maxval)
global axon
error = false;
if ~isempty(axon.output)
    cc = intersect([axon.output.channel],chan);
    if ~isempty(cc)
        Error(sprintf('Outputchannel %u in use',chan));
        error = true;
        return
    end
end
nr = length(axon.output)+1;
axon.output(nr,1).name    = name;
axon.output(nr,1).model   = model;
axon.output(nr,1).panel   = panelname;
axon.output(nr,1).channel = chan;
[axon.output(nr,1).device,axon.output(nr,1).local] = DACdev(chan);
axon.output(nr,1).type    = [];
axon.output(nr,1).duur    = [];
% axon.output(nr,1).patroon = [];
axon.output(nr,1).fixtop  = false;
axon.output(nr,1).text    = [];
axon.output(nr,1).stim    = [];
% axon.output(nr,1).ifixed  = 0;
axon.output(nr,1).hold    = 0;
axon.output(nr,1).maxval  = maxval;
axon.output(nr,1).slider  = 'none';
axon.output(nr,1).mcc.chn = [];
axon.output(nr,1).mcc.dev = [];
axon.output(nr,1).mcc.loc = [];
axon.output(nr,1).mcc.slider = 0;
axon.output(nr,1).metart = false;
axon.output(nr,1).parms  = [];

function error = addinputdevice(name,model,panelname,chan)
global axon
error = false;
if ~isempty(axon.input)
    cc = intersect([axon.input.channel],chan);
    if ~isempty(cc)
        Error(sprintf('inputchannel %u is in use',cc(1)));
        error = true;
        return
    end
end
nr = length(axon.input)+1;
axon.input(nr,1).name    = name;
axon.input(nr,1).model   = model;
axon.input(nr,1).panel   = panelname;
axon.input(nr,1).channel = chan;
[axon.input(nr,1).device,axon.input(nr,1).local] = ADCdev(chan);
axon.input(nr,1).clocksource  = 'Internal';
axon.input(nr,1).clocktrigger = 'PFI3';
axon.input(nr,1).duur = [];
axon.input(nr,1).disp = [];
axon.input(nr,1).show = [];

function DoRapp(parms,device)
global DAQ axon
[parms,present,ps] = ParseSpecial(parms,'Image');
if present
    [ps,~,~,imchan] = ParseChans('dacs',ps,1,'Image');
    if Error, return; end
    [ps,present,subs] = ParseSpecial(ps,'color'); if present, kleur = ssingle(subs{1}); else, kleur = 'g'; end
    if addoutputdevice('Image','Rapp','',imchan,10), return; end    
    DAQ_DAC_scaling(imchan,10,'image','TTL',0,kleur);
    axon.output(end,1).parms = ps;
end
nout = length(axon.output);
bkleur = 'b';
ykleur = 'r';
[~,present,subs] = ParseSpecial(ps,'color'); 
if present
    bkleur = ssingle(subs{1});
    if length(subs)>1, ykleur = ssingle(subs{2}); end
end
[parms,present,ps] = ParseSpecial(parms,'Blue');
if present
    if ~isempty(axon.output) && ~isempty(find(strcmp({axon.output.name},'Blue'),1))
        Error('Blue already exists');
        return
    end        
    [ps,~,~,chan] = ParseChans('dacs',ps,1,'Blue');
    if Error, return; end
    if length(chan)<2, Error('Laser needs TTL & Analog dac'); return; end
    if addoutputdevice('Blue','Rapp','',chan(1),10), return; end
    DAQ_DAC_scaling(chan(1),10,'Blue-TTL','TTL',0,bkleur);
    axon.output(end,1).parms = ps;
    if addoutputdevice('Blue','Rapp','',chan(2),100), return; end        
    DAQ_DAC_scaling(chan(2),200,'Blue-Int','%',0,bkleur);
end
[parms,present,ps] = ParseSpecial(parms,'Yellow');
if present
    if ~isempty(axon.output) && ~isempty(find(strcmp({axon.output.name},'Yellow'),1))
        Error('Yellow already exists');
        return
    end        
    [ps,loc,dev,chan] = ParseChans('dacs',ps,1,'Yellow');
    if Error, return; end
    if length(chan)<2, Error('Laser needs TTL & Analog dac'); return; end
    if addoutputdevice('Yellow','Rapp','',chan(1),10), return; end;
    DAQ_DAC_scaling(chan(1),10,'Yellow-TTL','TTL',0,ykleur);
    axon.output(end,1).parms = ps;
    if addoutputdevice('Yellow','Rapp','',chan(2),100), return; end        
    DAQ_DAC_scaling(chan(2),200,'Yellow-Int','%',0,ykleur);
end
if length(axon.output)==nout, Error('Rapp needs at least 1 laser'); end

function DoStimulator(parms,device)
global panels DAQ axon
[parms,ldac,device,dacs] = ParseChans('dacs',parms,device,'Stimulator');
if Error, return; end
eegprotocol = [];
swpprotocol = [];
[parms,present,ps] = ParseSpecial(parms,'maxint'); if present, maxi  = rsingle(ps{1}); else, maxi = []; end
[parms,present,ps] = ParseSpecial(parms,'unit');   if present, unit  = ssingle(ps{1}); else, unit = []; end
[parms,present,ps] = ParseSpecial(parms,'cycle');  if present, cycle = ssingle(ps{1}); else, cycle = []; end
[parms,present,ps] = ParseSpecial(parms,'color');  if present, kleur = ssingle(ps{1}); else, kleur = []; end
[parms,present,ps] = ParseSpecial(parms,'swpprotocol'); if present, swpprotocol = ssingle(ps{1}); end
[parms,present,ps] = ParseSpecial(parms,'eegprotocol'); if present, eegprotocol = ssingle(ps{1}); end
[parms,domcc,pmcc] = ParseSpecial(parms,'mcc');
[parms,metartchn]  = ParseSpecial(parms,'artefact');
[parms,doveldcalib,psv] = ParseSpecial(parms,'veldcalib');
[parms,dosld, pss] = ParseSpecial(parms,'percentage');
if length(parms)<2, Error('Stimulator needs at least name & model'); return; end
myname = ssingle(parms{1});
if ~isempty(axon.output)
    if ~isempty(find(strcmp(myname,{axon.output.name}),1))
        Error(sprintf('%s already in use',myname)); return
    end
end
mymodel = ssingle(parms{2});
if addoutputdevice(myname,mymodel,'EPpanel',dacs(1),10), return; end
nr = length(axon.output);
axon.output(nr,1).metart = metartchn;
if length(parms)>2, axon.output(nr,1).parms = parms(3:end); end
EP = getPANEL('EPpanel');
if isempty(EP)
    EP = Openpanel('EPpanel',@EP_Callback,length(panels.slots));
    panels.slots(end+1) = EP.handle;   
end
if isempty(swpprotocol), set(EP.run,'Visible','Off'); else, set(EP.run,'String',swpprotocol,'Visible','On'); end
if isempty(eegprotocol), set(EP.eeg,'Visible','Off'); else, set(EP.eeg,'String',eegprotocol,'Visible','On'); end
set(EP.name,'String',myname);
switch mymodel
    case 'DAC'
        if isempty(maxi), maxi = 10;  end
        if isempty(unit), unit = 'V'; end
        if isempty(kleur),kleur = 'k'; end
        DAQ_DAC_scaling(dacs,maxi,myname,unit,0,kleur);
    case {'NIbipolar';'TTL';'FNWI';'DS4';'NPI'}
        if isempty(kleur), kleur = 'k'; end
        modus = 'Off';
        unit = 'uA';
        maxi = 1000;
        switch mymodel
            case 'TTL'
                unit = 'V';
                maxi = 10;
            case 'FNWI'
                unit = 'uA';
                maxi = 2000;
            case 'DS4'
            case 'NIbipolar'
                unit  = 'V'; 
                maxi  = 10;
                modus = 'On';
                if doveldcalib
                    [psv,present,ps] = ParseSpecial (psv,'gain');
                    if present
                        EP.fld.gain = rsingle(ps{1});
                    end
                    [psv,present,ps] = ParseSpecial (psv,'veldamp');
                    if present
                        EP.fld.ref = rsingle(ps{1});
                        EP.fld.amp = EP.fld.ref;
                    end
                    EP.fld.dV = 0;
                    EP.fld.on = true;
                else
                    EP.fld.on = false;
                end
        end
        set([EP.veldsymmetry,EP.zero,EP.velderror],'Visible',modus);
        if length(dacs)>1            
            if addoutputdevice(myname,'Invert','EPpanel',dacs(2),10), return; end
            axon.output(nr,  1).maxval = 2*maxi;
            axon.output(nr+1,1).maxval = 2*maxi;
            if Error, return; end
        else
            axon.output(nr,1).maxval = maxi;            
        end
        DAQ_DAC_scaling(dacs,maxi,myname,unit,0,kleur);
        if dosld
            set(EP.mode,'String',mymodel);
            pcmd = ssingle(pss{1});
            if strcmp(pcmd,'left') || strcmp(pcmd,'both')
                axon.output(nr,1).slider = 'left';
                EP.stim.full(1) = axon.output(nr).maxval;
                set(EP.full1,'String',sprintf('%u',EP.stim.full(1)));
            end
            if strcmp(pcmd,'right') || strcmp(pcmd,'both')
                axon.output(nr,1).slider = 'right';
                EP.stim.full(2) = axon.output(nr).maxval;
                set(EP.full2,'String',sprintf('%u',EP.stim.full(2)));
            end
            if ~strcmp(pcmd,'left') && ~strcmp(pcmd,'right') && ~strcmp(pcmd,'both')
                Error('Couple percentage to left or right'); return
            else
               EP = setsliders(EP); 
            end
        else
            axon.output(nr,1).slider = 'none';
        end
        set(EP.handle,'UserData',EP);
	case 'Diego'
        if ~domcc, Error('Diego needs MCC device'); return; end
        MCC = Openpanel('MCCpanel',@MCC_Callback);
        if ~isempty(protoname)
            set(handles.EPtest2,'String',protoname);
        end
        if ~isempty(cycle) && get(handles.EPcyclecontrol2,'Value')
            axon.EP.int = cycle;
            set(handles.EPcycle2,'String',axon.EP.int);
        end
        if isempty(kleur), kleur = 'b'; end
        mccdevs = find(strcmp({DAQ.BoardName},'USB-3105'));
        [pmcc,axon.output(nr,1).mcc.slider] = ParseSpecial(pmcc,'slider');
        chns = nsingle(pmcc{1});
        if ~isempty(find(chns>(length(mccdevs)*16))), Error('mcc channels out of range'); return; end
        if axon.output(nr,1).mcc.slider
            set(handles.MCC_device,'String','MCC-3105: ');
            set(handles.MCC_channels,'String',['Slider linked to ' myname]);
        end
        if isempty(unit), unit = 'uA'; end
        if isempty(maxi), maxi = 1000; end
        DAQ_DAC_scaling(dacs(1),10,myname,'V',0,kleur);
        if Error, return; end
        if length(dacs)>1
            if addoutputdevice(myname,'Support','EPpanel',dacs(2),10), return; end
            DAQ_DAC_scaling(dacs(2),10,myname,'V',0,kleur);
            if Error, return; end
        end
        axon.output(nr,1).mcc.chn = chns;
        axon.output(nr,1).mcc.dev = mccdevs(1+floor(chns/17));
        axon.output(nr,1).mcc.loc = 1+mod(chns-1,16);
        [pmcc,present,subs] = ParseSpecial(pmcc,'minval');
        if present
            minvals = rsingle(subs{1});
            if length(minvals)==1, minvals(1:length(chns)) = minvals; end
        else,minvals = []; end
        [pmcc,present,subs] = ParseSpecial(pmcc,'maxval');
        if present
            maxvals = rsingle(subs{1});
            if length(maxvals)==1, maxvals(1:length(chns)) = maxvals; end
        else,maxvals = []; end
        if length(pmcc)>1
            curvals = rsingle(pmcc{2});
            if length(curvals)==1, curvals(1:length(chns)) = curvals; end
        else,curvals = []; end
        for jj=1:length(chns)
            device  = axon.output(nr,1).mcc.dev(jj);
            channel = axon.output(nr,1).mcc.loc(jj);
            DAQ(device).DAC.scale(channel).Name  = sprintf('%s-%u',myname,jj);
            DAQ(device).DAC.scale(channel).User  = maxi;
            DAQ(device).DAC.scale(channel).Units = unit;
            DAQ(device).dac.Channel(channel).UnitsRange = [0 maxi];
            if jj<=length(minvals), DAQ(device).MCC(channel,1) = minvals(jj); end
            if jj<=length(maxvals), DAQ(device).MCC(channel,2) = maxvals(jj); end
            if jj<=length(curvals), DAQ(device).MCC(channel,3) = curvals(jj); end
            DAQ(device).MCC(channel,1) = min(DAQ(device).MCC(channel,1),DAQ(device).MCC(channel,2));
        end
        MCC_Callback(handles.MCC_Ival,[])
    otherwise
        Error(sprintf('Unrecognized model: %s',mymodel));
end

function DCstate(AXON,bits)
dynablue = false;
dynared  = false;
if length(bits)>3
    if isequal(bits(1:3),[1,0,0]), KnobRed(AXON.soft); if KnobIsRed(AXON.dyna), dynablue = true;     end; end
    if isequal(bits(1:3),[0,1,0]), dynared = true;     if KnobIsRed(AXON.soft), KnobBlue(AXON.soft); end; end
    if isequal(bits(1:3),[1,1,0]), if KnobIsRed(AXON.soft), KnobBlue(AXON.soft); end
                                   if KnobIsRed(AXON.dyna), dynablue = true; end; end
    anydyna = false;
    if length(bits)>7
        if bits(5), KnobBlue(AXON.IKon); anydyna = true; else,KnobGrey(AXON.IKon); end
        if bits(6), KnobBlue(AXON.IAon); anydyna = true; else,KnobGrey(AXON.IAon); end
        if bits(7), KnobBlue(AXON.ICon); anydyna = true; else,KnobGrey(AXON.ICon); end
        if bits(8), KnobBlue(AXON.IHon); anydyna = true; else,KnobGrey(AXON.IHon); end
    end
    if anydyna
        if dynared, KnobRed(AXON.dyna); elseif dynablue, KnobBlue(AXON.dyna); end
    else
        KnobGrey(AXON.dyna);
    end
end

function AXON = DCUpdate(AXON,bits,vals)
global DAQrbp
nr = AXON.rbp;
orgbits = getvalue(DAQrbp(nr).DIO.outlines);
if ~isempty(bits), orgbits(1:length(bits)) = bits; end
adcs = getsample(DAQrbp(nr).adc);
set(AXON.adc0,'String',sprintf('%0.1f',adcs(1)*2000));
hlp = round(max(-2000,min(2000,10*(AXON.pars.Vsoft+AXON.pars.jun))))/10;
AXON.pars.Vsoft = hlp - AXON.pars.jun;
set(AXON.Vsoft,'String',sprintf('%0.1f',AXON.pars.Vsoft));
putvalue (DAQrbp(nr).DIO.outlines,[1,1,1,0,0,0,0,0]); pause(AXON.dc2del);
putsample(DAQrbp(nr).dac,[AXON.dc2off+AXON.dc2max*hlp/400, 0]); pause(AXON.dc2del);
bits = [1,1,1,0,1,0,0,0];
putvalue(DAQrbp(nr).DIO.outlines, bits); pause(AXON.dc2del);
if ~isempty(vals)
    handle = [AXON.IK, AXON.IA, AXON.IC, AXON.IH];
    index  = [0,1,0,0; 1,1,0,0; 0,0,1,0; 1,0,1,0];
    for jj = 1:4
        if isnan(vals(jj)), continue; end
        AXON.clamp(jj) = round(max(0,min(5000,vals(jj))));             set(handle(jj),'String',sprintf('%u',AXON.clamp(jj)));
        putvalue (DAQrbp(nr).DIO.outlines,[1,1,1,0,0,0,0,0]);          pause(AXON.dc2del);
        putsample(DAQrbp(nr).dac,[AXON.dc2max*AXON.clamp(jj)/5000,0]); pause(AXON.dc2del);
        bits = [1,1,1,0,index(jj,:)];
        putvalue (DAQrbp(nr).DIO.outlines, bits); pause(AXON.dc2del);                                                                                                                                                                                                                                                                           
    end
end
putvalue (DAQrbp(nr).DIO.outlines,[1,1,1,0,0,0,0,0]); pause(AXON.dc2del);
putvalue (DAQrbp(nr).DIO.outlines, orgbits);          pause(AXON.dc2del);
putsample(DAQrbp(nr).dac,[AXON.dc2off,0]);

function ArmDynamic
global swpcmd
for jj = swpcmd.dynamic
    if jj==1, name = 'AXON1'; else, name = 'AXON2'; end
    if ~isempty(swpcmd.(name).handle)
        AXON = get(swpcmd.(name).handle,'UserData');
        bits = swpcmd.(name).T2;
        AXON = DCUpdate(AXON,bits,swpcmd.(name).vals);
        DCstate(AXON,bits);
        if jj==1
            if isempty(bits)
                disp(sprintf('%s.T2: %+2u done, arm: %+2u  no RPI command',     name, swpcmd.nodenr, swpcmd.arm));
            else
                disp(sprintf('%s.T2: %+2u done, arm: %+2u  RPI mode: %u %u %u', name, swpcmd.nodenr, swpcmd.arm, bits(1:3)));
            end
        end
    end
end

function AXON_Callback(hObject,~)
global DAQrbp panels axon
AXON = get(get(hObject,'Parent'),'UserData');
outchn = find([axon.output.channel]==AXON.pars.hdac);
if isempty(outchn), Error('No outputchannels'); Error("box"); end
panelstate = [KnobIsBlue(AXON.IKon),KnobIsBlue(AXON.IAon),KnobIsBlue(AXON.ICon),KnobIsBlue(AXON.IHon)];
piegains   = {AXON.IKgain,AXON.IAgain,AXON.ICgain,AXON.IHgain};
clmpbhan   = {AXON.IKon, AXON.IAon, AXON.ICon, AXON.IHon};
clmpvhan   = {AXON.IK,   AXON.IA,   AXON.IC,   AXON.IH};
switch hObject
    case AXON.run,  pnls = findobj('Tag','axoncycle');
                    TSTrun(hObject,str2double(get(pnls(1),'String')));
    case AXON.at0,  set(AXON.ath, 'Value', 1-get(hObject, 'Value'));            
    case AXON.ath,  set(AXON.at0, 'Value', 1-get(hObject, 'Value'));
    case AXON.dyna, if KnobIsBlue(AXON.dyna) || KnobIsRed(AXON.dyna)
                    	orgbits = getvalue(DAQrbp(AXON.rbp).DIO.outlines);
                        KnobGrey([AXON.dyna,cell2mat(clmpbhan)]);
                        orgbits(5:8) = [0,0,0,0];
                        AXON = DCUpdate(AXON,orgbits,[]);
                        DCstate(AXON,orgbits);
                        set(AXON.handle,'UserData',AXON);
                    end
    case AXON.soft, state = [0,0,0,0,panelstate];
                    if ~KnobIsGrey(hObject)
                        KnobGrey(hObject);
                        set(AXON.Vstep,'Visible','off'); set(AXON.Istep,'Visible','on');
                        if KnobIsGrey(AXON.dyna)
                            state(1:3) = [1,1,0];
                            putvalue(DAQrbp(AXON.rbp).DIO.outlines,state);
                        else
                            state(1:3) = [0,1,0];
                            AXON = DCUpdate(AXON,state,[]);
                        end
                    else
                        KnobRed(hObject);
                        set(AXON.Istep,'Visible','off'); set(AXON.Vstep,'Visible','on');
                        state(1:3) = [1,0,0];
                        AXON = DCUpdate(AXON,state,[]);
                    end
                    set(AXON.handle,'UserData',AXON);
    case clmpbhan,  orgbits = getvalue(DAQrbp(AXON.rbp).DIO.outlines);
                    ToggleBlue_Callback(hObject);
                    index = find(cell2mat(clmpbhan)==hObject);
                    orgbits(index+4) = KnobIsBlue(hObject);
                    putvalue(DAQrbp(AXON.rbp).DIO.outlines, orgbits); pause(AXON.dc2del);
                    if KnobIsBlue(cell2mat(clmpbhan)), KnobBlue(AXON.dyna); else, KnobGrey(AXON.dyna); end
    case clmpvhan,  vals(cell2mat(clmpvhan)==hObject) = round(str2double(get(hObject,'String')));         
                    AXON = DCUpdate(AXON,[],vals); 
                    set(AXON.handle,'UserData',AXON);
    case {AXON.zero,AXON.down,AXON.up,AXON.Ihold,AXON.Vhold,AXON.Vsoft}
                    Vstep  = str2double(get(AXON.Vstep,'String'));
                    Istep  = str2double(get(AXON.Istep,'String'));
                    if (AXON.Vhold==hObject) || strcmp(AXON.pars.mode,'VC')
                        switch hObject
                            case AXON.Vhold, newval = str2double(get(AXON.Vhold,'String'));
                            case AXON.down,  newval = AXON.pars.Vhold - Vstep;
                            case AXON.up,    newval = AXON.pars.Vhold + Vstep;
                            case AXON.zero,  newval = 0;    
                        end
                        if abs(newval)<=AXON.VCmax
                            AXON.pars.Vhold = newval;
                            axon.output(outchn).hold = newval;
                            if KnobIsGrey(AXON.run), DACset(AXON.pars.dev); end
                        else
                            Error(sprintf('V: %d\n outside: \n +-%d',newval,AXON.VCmax));
                        end
                        set(AXON.Vhold,'String',sprintf('%.1f',AXON.pars.Vhold));
                    elseif ~KnobIsGrey(AXON.soft) || (AXON.Vsoft==hObject)
                        switch hObject
                            case AXON.Vsoft,newval = str2double(get(AXON.Vsoft,'String'));
                            case AXON.down, newval = AXON.pars.Vsoft - Vstep;
                            case AXON.up,   newval = AXON.pars.Vsoft + Vstep;
                            case AXON.zero, putvalue(DAQrbp(AXON.rbp).DIO.outlines, [0,0,0,0,0,0,0,0]);
                                            KnobBlue(AXON.soft);
                                            KnobGrey([AXON.IKon, AXON.IAon, AXON.ICon, AXON.IHon]);
                                            return
                        end
                        if abs(newval)<=AXON.VCmax
                            AXON.pars.Vsoft = newval;
                            AXON = DCUpdate(AXON,[],[]);
                        else
                            Error(sprintf('soft: %d\n outside: \n +-%d',newval,AXON.VCmax));
                        end
                        set(AXON.Vsoft,'String',sprintf('%.1f',AXON.pars.Vsoft));
                    elseif (AXON.Ihold==hObject) || strcmp(AXON.pars.mode,'CC')
                        switch hObject
                            case AXON.Ihold, newval = str2double(get(AXON.Ihold,'String'));
                            case AXON.down,  newval = AXON.pars.Ihold - Istep;
                            case AXON.up,    newval = AXON.pars.Ihold + Istep;
                            case AXON.zero,  newval = 0; 
                        end
                        if abs(newval)<=AXON.CCmax
                            AXON.pars.Ihold = newval;
                            axon.output(outchn).hold = newval;
                            if KnobIsGrey(AXON.run), DACset(AXON.pars.dev); end
                        else
                            Error(sprintf('I: %d\n outside: \n +-%d',newval,AXON.CCmax));
                        end
                        set(AXON.Ihold,'String',sprintf('%.1f',AXON.pars.Ihold));
                    end
                    set(AXON.handle,'UserData',AXON);
    case AXON.cycle,time = str2double(get(hObject,'String'));
                    pnls = findobj('Tag','axoncycle');
                    for jj = 1:length(pnls)
                        if get(pnls(jj),'parent')== AXON.handle
                            if strcmp(AXON.pars.mode,'VC')
                                AXON.VCcycle = time;
                            else
                                AXON.CCcycle = time;
                            end
                            set(AXON.handle,'UserData',AXON);
                        else
                            HLP = get(get(pnls(jj),'parent'),'UserData');
                            if strcmp(AXON.pars.mode,'VC')
                                HLP.VCcycle = time;
                            else
                                HLP.CCcycle = time;
                            end
                            set(get(pnls(1),'parent'),'UserData',HLP)
                        end
                    end
                    set(AXON.handle,'UserData',AXON);
    case AXON.switch, AxonSwitch(AXON,hObject);
                      Protocol_Test;
    case AXON.report, if KnobIsGrey(hObject)
                          KnobRed(hObject);
                          detimer = timer('TimerFcn',@Reporter,...
                                         'ExecutionMode','fixedRate',...
                                         'BusyMode','drop',...
                                         'Name','daq-reporter',...
                                         'Tag','REPORTER',...
                                         'Period',0.5,...
                                         'Startdelay',panels.timer.delay);
                         start(detimer);
                      else
                         ReporterStop;
                      end
    otherwise
end
Error("box");

function reset = DoAmplifier(cmd,parms,device)
global panels DAQ DAQrbp axon
CMD = getPANEL('CMDpanel');
reset = false;
myname    = ssingle(parms{1});
amplifier = ssingle(parms{2});
if ~isempty(axon.input) && ~isempty(find(strcmp(myname,{axon.input.name}),1))
	Error(sprintf('input %s already in use',myname)); return
end
if ~isempty(axon.output) && ~isempty(find(strcmp(myname,{axon.output.name}),1))
	Error(sprintf('output %s already in use',myname)); return
end
[parms,metselect,ps] = ParseSpecial(parms,'Hardwire');
if metselect
    [adcs,device] = Hardwire(ps);
    set(CMD.group,'Value',1);
else
    [parms,ladc,device,adcs] = ParseChans('adcs',parms,unique(device),[]);
end
if Error, return; end
device = unique(device);
[parms,ldac,devdac,dacs] = ParseChans('dacs',parms,unique(device),[]);
if Error, return; end
if strcmp(cmd,'Orca')
    DAQ_ADC_scaling(adcs(1),1,1,'Camera','V',0,'g'); if addinputdevice('Camera','Orca','', adcs(1)), return; end
    DAQ_DAC_scaling(dacs(1),10,'Camera','V',0,'g');  if addoutputdevice('Camera','Orca','',dacs(1),[]),return; end
    axon.output(end,1).text  = [];
    axon.output(end,1).parms = parms;
    DAQ_DAC_scaling(dacs(2),1,'LED','V',0,'g');      if addoutputdevice('Camera','LED','', dacs(2),[]), return; end
    axon.output(end,1).text  = [];
    axon.output(end,1).parms = [];
    return
end
swpprotocol = [];
eegprotocol = [];
[parms,present,ps] = ParseSpecial(parms,'maxint'); if present, maxi    = rsingle(ps{1}); else, maxi    = []; end
[parms,present,ps] = ParseSpecial(parms,'unit'  ); if present, unit    = ssingle(ps{1}); else, unit    = []; end
[parms,present,ps] = ParseSpecial(parms,'color' ); if present, kleur   = ssingle(ps{1}); else, kleur   = 'k';end
[parms,present,ps] = ParseSpecial(parms,'force' ); if present, force   = ssingle(ps{1}); else, force   = []; end
[parms,present,ps] = ParseSpecial(parms,'adcgain');if present, adcgain = rsingle(ps{1}); else, adcgain = 1;  end
[parms,present,ps] = ParseSpecial(parms,'cycle' ); if present, cycle   = rsingle(ps{1}); else, cycle   = []; end
[parms,present,ps] = ParseSpecial(parms,'steps' ); if present, steps   = rsingle(ps{1}); else, steps   = []; end
RPi = [];
rpdelay = 10;
rpgains = [1,1,1,1];
[parms,present,ps] = ParseSpecial(parms,'RPi' );
if present
    [ps,rpdelay] = ParseOne(ps,'delay',10);
    [ps,present,psh] = ParseSpecial(ps,'gains');
    if present
        rpgains = rsingle(psh{1}); if length(rpgains)~=4, Error('You need to provide a set of 4 gain factors'); return; end
    end
    RPi = rsingle(ps{1});
end
[parms,present,ps] = ParseSpecial(parms,'junction');
if present
    junval = rsingle(ps{1});
    juntxt = sprintf('JP %0.0f mV',junval);
else
    junval = 0;
    juntxt = '';
end
[parms,present,ps] = ParseSpecial(parms,'swpprotocol'); if present, swpprotocol = ssingle(ps{1}); end
[parms,present,ps] = ParseSpecial(parms,'eegprotocol'); if present, eegprotocol = ssingle(ps{1}); end
[parms,present,ps] = ParseSpecial(parms,'monitor');     if present, mondevice   = ssingle(ps{1}); else, mondevice = []; end
[parms,alsveld]    = ParseSpecial(parms,'FIELD');
[parms,present,ps] = ParseSpecial(parms,'external');
if present
    clocksource  = 'ExternalScanCtrl';
    clocktrigger = ssingle(ps{1});
else
    clocksource  = 'Internal';
    clocktrigger = 'PFI3';
end
if ~isempty(find(strcmp(amplifier,{'ADC';'EEG';'EP'}), 1))
    EP = getPANEL('EPpanel');
    if ~isempty(EP)
        EP = Openpanel('EPpanel',@EP_Callback,length(panels.slots));
        panels.slots(end+1) = EP.handle;
    end
    pos = get(EP.handle,'Position'); newpos = pos(1)+pos(3);
    pos = get(CMD.macro,'Position'); set(CMD.macro,'Position',[newpos,pos(2),1-newpos,pos(4)]);
    [parms,present,ps] = ParseSpecial(parms,'ampgain');
    if present
        [ps,metask] = ParseSpecial(ps,'ask');
        pregain = rsingle(ps{1});
        if metask
            set(EP.amp, 'Visible','on','String',sprintf('pre(%u x )',pregain));
            set(EP.gain,'Visible','on');
            if strcmp(get(EP.gain,'String'),'NaN'), EP = GainSelect(EP); end
            postgain = pregain * str2double(get(EP.gain,'String'));
        else
            set(EP.gain,'Visible','off');
            if length(ps)>1, postgain = abs(rsingle(ps{2}))* pregain; else, postgain = pregain; end
            set(EP.amp,'Visible','on','String',sprintf('gain (x %u )',postgain(1)));
        end
    end
    if isempty(swpprotocol), set(EP.run,'Visible','Off'); else, set(EP.run,'String',swpprotocol,'Visible','On'); end
    if isempty(eegprotocol), set(EP.eeg,'Visible','Off'); else, set(EP.eeg,'String',eegprotocol,'Visible','On'); end
    switch amplifier
        case 'ADC'
            for jj = 1:length(adcs)
                if isempty(maxi), ampgain = 1; else, ampgain = maxi; end
                if isempty(unit), units = 'V'; else, units = unit; end
                DAQ_ADC_scaling(adcs(jj),1,ampgain,sprintf('%s-%u',myname,jj),units,0,'k');
                if addinputdevice(myname,amplifier,'EPpanel',adcs(jj)), return; end
            end
        case 'EEG'
            if isempty(find(DAQ(device).ADC.Gains==adcgain,1))
                Error(sprintf('ADC gain %u does not exist on %s',adcgain,DAQ(device).BoardName)); return
            end
            Openpanel('SELpanel',@SEL_Callback,DAQ(device).ADC.scale(adcs),true,false);
            for jj = 1:length(adcs)
                if length(postgain)>=jj, ampgain = postgain(jj); else, ampgain = postgain(end); end
                DAQ_ADC_scaling(adcs(jj),adcgain,10000/ampgain,[],'mV',0,[]);
                if addinputdevice(myname,amplifier,'SELpanel',adcs(jj)), return; end
                axon.input(end).clocksource  = clocksource;
                axon.input(end).clocktrigger = clocktrigger;
            end
        case 'EP'
            if isempty(unit), strs{1} = 'mV'; else, strs = stringset(unit); end
            if isempty(find(DAQ(device).ADC.Gains==adcgain, 1))
                Error(sprintf('ADC gain %u does not exist on %s',adcgain,DAQ(device).BoardName)); return
            end
            for jj = 1:length(adcs)
                if length(postgain)>=jj, ampgain = postgain(jj); else, ampgain = postgain(end); end
                if length(strs)>=jj, units = strs{jj}; else, units = strs{end}; end
                kleur = 'k';
                if false
                    txt = [];
                    kleur = [];
                elseif max(adcs)>9
                    txt = sprintf('%s-%02u',myname,jj);
                else
                    txt = sprintf('%s-%u',myname,jj);
                end
                DAQ_ADC_scaling(adcs(jj),adcgain,10000/ampgain,txt,units,0,kleur);
                if addinputdevice(myname,amplifier,'EPpanel',adcs(jj)), return; end
                axon.input(end).clocksource  = clocksource;
                axon.input(end).clocktrigger = clocktrigger;
            end
    end
    set(EP.handle,'UserData',EP);
elseif ~isempty(find(strcmp(amplifier,{'Axon200';'Axon200A';'Axon200B'}), 1))
    doconfiger = false;
    panelname = 'AXON1';
    AXON = getPANEL(panelname);
    if ~isempty(AXON)
        if ~strcmp(AXON.pars.name,myname)
            panelname = 'AXON2';
            AXON = getPANEL(panelname);
            if isempty(AXON) || ~strcmp(AXON.pars.name,myname)
                AXON = Openpanel(panelname,@AXON_Callback,amplifier,length(panels.slots));
                if ~isempty(DAQrbp) && ~isempty(RPi), AXON.rbp = RPi; else, AXON.rbp = []; end
                AXON.monchn  = 9:16;
                panels.slots(end+1) = AXON.handle;
                set([AXON.report, AXON.ctxt, AXON.cycle],'Visible','Off');
                doconfiger = true;
            end
        end
    else
        AXON = Openpanel(panelname,@AXON_Callback,amplifier,length(panels.slots));
        if ~isempty(DAQrbp) && ~isempty(RPi), AXON.rbp = RPi; else, AXON.rbp = []; end
        AXON.monchn  = 1:8;
        panels.slots(end+1) = AXON.handle;
        doconfiger = true;
    end
    AXON.dc2del  = rpdelay/1000;
    AXON.RPgains = rpgains;
    hhh = [AXON.IKgain,AXON.IAgain,AXON.ICgain,AXON.IHgain];
    for jj = 1:4, set(hhh(jj),'String',sprintf('%.3f',AXON.RPgains(jj))); end
    if isempty(swpprotocol), set(AXON.run,'Visible','Off'); else, set(AXON.run,'String',swpprotocol,'Visible','On'); end
    AXON.pars.jun = junval;
    if strcmp(panelname,'AXON1')
        if isempty(ladc), [device,ladc,adcs] = ADCdev([1 2 3 7]); end
        device = unique(device);
        if isempty(ldac), [devdac,ldac,dacs] = DACdev(1); end
        if isempty(mondevice), mondevice = 'PCI-6259'; end
        brd = find(strcmp({DAQ.BoardName},mondevice));
        if isempty(brd)
            axon.monitor = 0;
            Error(sprintf('Device %s not available as Axon monitor',mondevice)); return
        elseif (axon.monitor~=brd) || ~isempty(force)
            axon.monitor = brd;
        end
    elseif strcmp(panelname,'AXON2')
        if isempty(ladc), [device,ladc,adcs] = ADCdev([4 5 6 8]); end
        device = unique(device);
        if isempty(ldac), [devdac,ldac,dacs] = DACdev(2); end
    else
        Error('Sorry, two patch amps max (for this moment)'); return;
    end
    if device~=unique(devdac), Error('Patch ADC & DAC of Axon must be on the same device'); return; end
    hwoff = AXON.monchn(1)-1 + DAQ(axon.monitor).ADC.HWoff;
    if doconfiger
        switch DAQ(axon.monitor).adc.InputType
            case 'Differential'
                DAQ(axon.monitor).adc.InputType = 'SingleEnded';
                Message('Axon monitor must be differential, reset needed');
                reset = true;
                return
            case 'NonReferencedSingleEnded'
                DAQ(axon.monitor).adc.InputType = 'SingleEnded';
            otherwise
        end
        if strcmp(panelname,'AXON1')
            delete(DAQ(axon.monitor).adc.Channel);
            addchannel(DAQ(axon.monitor).adc,AXON.monchn(1:8)-1);
            DAQ(axon.monitor).ADC.HWchn = hwoff+(1:8);
        elseif strcmp(panelname,'AXON2')
            addchannel(DAQ(axon.monitor).adc,AXON.monchn(1:8)-1);
            DAQ(axon.monitor).ADC.HWchn = [DAQ(axon.monitor).ADC.HWchn,hwoff+(1:8)];
        end
        DAQ_ADC_scaling(hwoff+3,1,1000,'Vmon','mV',0,'k');
        DAQ(axon.monitor).adc.Channel(AXON.monchn(3)).UnitsRange = [-1000 1000];
        DAQ_ADC_scaling(hwoff+4,1,100,'Temp','C',0,'k');
        DAQ(axon.monitor).adc.Channel(AXON.monchn(4)).UnitsRange = [-100 100];
        DAQ_ADC_scaling(hwoff+5,1,100,'Capacity','pF',0,'k');
        DAQ(axon.monitor).adc.Channel(AXON.monchn(5)).UnitsRange = [-100 100];
        DAQ_ADC_scaling(hwoff+6,1,10,'filter','V',0,'k');
        DAQ(axon.monitor).adc.Channel(AXON.monchn(6)).UnitsRange = [-10 10];
        DAQ_ADC_scaling(hwoff+7,1,10,'mode','V',0,'k');
        DAQ(axon.monitor).adc.Channel(AXON.monchn(7)).UnitsRange = [-10 10];
        DAQ_ADC_scaling(hwoff+8,1,10,'gain','V',0,'k');
        DAQ(axon.monitor).adc.Channel(AXON.monchn(8)).UnitsRange = [-10 10];
        showdaqs
    end
    DAQ(axon.monitor).ADC.scale(AXON.monchn(3)).junction = junval;
    monvals = GetMonitor;
    monvals = monvals(AXON.monchn);
    [~,switidx] = min((AXON.switcher - monvals(7)).^2);
    hlp = AXON.switcher(switidx);            
    if ~isempty(force) || (hlp==0)
        if strcmp(force,'VC') || strcmp(force,'CC')
            AXON.pars.mode = force;
        else
            Error('Switch on the Axon or define force(VC/CC)!')
            axon.monitor = 0;
            return
        end
    elseif hlp>4
        AXON.pars.mode = 'VC';
    elseif hlp<3
        AXON.pars.mode = 'CC';
    end
    AXON.pars.name = myname;
    set(AXON.name,'String',AXON.pars.name);
    set(AXON.mode,'String',AXON.pars.mode);
    chntxt = sprintf('%u',ladc(1));
    AXON.pars.hadc = adcs(1);
    AXON.pars.adc  = ladc(1);
    AXON.pars.dev  = device;
    [~,gainidx] = min((AXON.selector-monvals(8)).^2);
    channel1gain = AXON.gains(gainidx);
    keys = [AXON.soft,  AXON.Vsoft, AXON.IK, AXON.IA, AXON.IC, AXON.IH, AXON.IKon, AXON.IAon, AXON.ICon, AXON.IHon, AXON.dyna, AXON.adc0];
    if strcmp(AXON.pars.mode,'VC')
        if alsveld, Error('Field amplifier has to be in CC mode'); return; end
        name1 = 'Im';
        name2 = 'Vcmd';
        unit1 = 'pA';
        unit2 = 'mV';
        channel2gain = AXON.VCmax;
        junction1 = 0;
        junction2 = junval;
        holdval = AXON.pars.Vhold;
        set([keys, AXON.Imode, AXON.Ihold, AXON.Istep],'Visible','Off');
        set([AXON.Vmode, AXON.Vhold, AXON.Vstep],'Visible','On');
        set(AXON.cycle,'String',sprintf('%0.1f',AXON.VCcycle));
    elseif strcmp(AXON.pars.mode,'CC')
        name1 = 'Vm';
        name2 = 'Icmd';
        unit1 = 'mV';
        unit2 = 'pA';
        channel2gain = AXON.CCmax;
        junction1 = junval;
        junction2 = 0;
        if alsveld
            junction1 = 0;
            juntxt    = 'field';
            set(AXON.at0,'Value',1);
            set(AXON.ath,'Value',0);
            AXON.pars.Ihold = 0;
        end
        holdval = AXON.pars.Ihold;
        set([AXON.Vmode, AXON.Vhold, AXON.Vstep],'Visible','Off'); if isempty(AXON.rbp), set(keys,'Visible','Off'); end
        set([AXON.Imode, AXON.Ihold, AXON.Istep],'Visible','On');  if ~isempty(AXON.rbp), set(keys,'Visible','On'); end
        set(AXON.cycle,'String',sprintf('%0.1f',AXON.CCcycle));
    else
        return
    end
    if strcmp(AXON.pars.mode,'VC') || ~KnobIsGrey(AXON.soft)
        set(AXON.Istep,'Visible','off'); set(AXON.Vstep,'Visible','on');
    else
        set(AXON.Vstep,'Visible','off'); set(AXON.Istep,'Visible','on');
    end
    DAQ_ADC_scaling(hwoff+1,1,channel1gain,name1,unit1,junction1,'k');
    DAQ(axon.monitor).adc.Channel(1).UnitsRange = channel1gain *[-1 1];
    
    DAQ_ADC_scaling(hwoff+2,1,channel2gain,name2,unit2,junction2,'k');
    DAQ(axon.monitor).adc.Channel(2).UnitsRange = channel2gain *[-1 1];
    
    DAQ_ADC_scaling(adcs(1),1,channel1gain,name1,unit1,junction1,kleur);
    if addinputdevice(myname,amplifier,panelname,adcs(1)); return; end
    if length(ladc)>1
        chntxt = [chntxt sprintf(' %u',ladc(2))];
        AXON.pars.hadc(2) = adcs(2);
        AXON.pars.adc(2)  = ladc(2);
        DAQ_ADC_scaling(adcs(2),1,channel2gain,name2,unit2,junction2,kleur);
        if Error, return; end
        if addinputdevice(myname,amplifier,panelname,adcs(2)); return; end
    end
    if length(ladc)>2
        chntxt = [chntxt sprintf(' %u',ladc(3))];
        AXON.pars.hadc(3) = adcs(3);
        AXON.pars.adc(3)  = ladc(3);
        DAQ_ADC_scaling(adcs(3),1,1000,'10xVm','mV',junval,kleur);
        if Error, return; end
        if addinputdevice(myname,amplifier,panelname,adcs(3)); return; end
    end
    if length(ladc)>3
        chntxt = [chntxt sprintf(' %u',ladc(4))];
        AXON.pars.hadc(4) = adcs(4);
        AXON.pars.adc(4)  = ladc(4);
        DAQ_ADC_scaling(adcs(4),1,2000,'RPi','pA',0,kleur);
        if Error, return; end
        if addinputdevice(myname,amplifier,panelname,adcs(4)); return; end
    end
    chntxt = [chntxt sprintf('-%u',ldac)];
    AXON.pars.hdac = dacs(1);
    AXON.pars.dac  = ldac(1);
    DAQ_DAC_scaling(dacs(1), channel2gain,name2,unit2,junction2,kleur);
    if Error, return; end
    if addoutputdevice(myname,amplifier,panelname,dacs(1),[]), return; end
    
    axon.output(end).hold = holdval;
    [~,index] = min(((2:2:10)-monvals(5)).^2);
    AXON.pars.flt = AXON.freqvals(index);
    AXON.pars.Cm = monvals(4);
    set(AXON.channels,'String',chntxt);
    set(AXON.junction,'String',juntxt);
    set(AXON.Cm,      'String',sprintf('%0.1f',AXON.pars.Cm));
    set(AXON.filter,  'String',sprintf('%2u',  AXON.pars.flt));
    set(AXON.handle,  'UserData',AXON);
else
	Error(sprintf('Unknown amplifier %s',amplifier));
end

function GainClose(~,~,nr,EP)
global panels
set(EP.gain,'String',sprintf('%u',EP.gains(nr)));
set(get(EP.Control,'Parent'),'UserData',EP);
panels.h = [];
delete(gcf);

function EP = GainSelect(EP)
global panels
brd = 300;
hgt = 32 * length(EP.gains);
pos = [round(panels.primair(1)+(panels.primair(3)-brd-16)/2) round(panels.primair(2)+(panels.primair(4)-hgt-44)/2) brd hgt];
panels.h(1) = figure('Toolbar','none','IntegerHandle','off','Menubar','none','NumberTitle','Off','Position',pos,'Resize','off',...
                     'CloseRequestFcn',@CloseManager,'Units','pixels','Name',sprintf('Pre-Amp Gain: %s',get(EP.amp,'String')));
gain = str2double(get(EP.gain,'String'));
for iii = 1:length(EP.gains)
    panels.h(iii+1) = uicontrol('Style','radiobutton','Fontsize',14,'Fontname','Courier','Units','pixels',...
                                'String',sprintf('gain %u',EP.gains(iii)),...
                                'Position',[50 hgt-32*iii 200 28],'Callback',{@GainClose,iii,EP});
    if  gain == EP.gains(iii), set(panels.h(iii+1),'Value',1); end
end
uiwait(panels.h(1));

function [inputset, outputset, adcduur, disp, show, eeg] = EvaluateRecord(cmd, eeg, parms, outputset)
global axon
disp     = 1;
show     = 1;
inputset = [];
adcduur  = [];
if strcmp(cmd,'RecordTrace')
    [parms,eeg.spectrum.on,ps] = ParseSpecial(parms,'spectrum');
    if eeg.spectrum.on
        [ps,present,pss] = ParseSpecial(ps,'window');
        if present, eeg.spectrum.window = ssingle(pss{1}); end
        [ps,present,pss] = ParseSpecial(ps,'smooth');
        if present
            clen = nsingle(pss{1});
            eeg.spectrum.filt = ones(2*clen-1,1)/(2*clen-1);
        end
        [ps,present,pss] = ParseSpecial(ps,'kill');
        if present
            center = rsingle(pss{1});
            width  = rsingle(pss{2});
            eeg.spectrum.kill = [center-width, center+width];
        end
        eeg.spectrum.trace  = [];
        eeg.spectrum.bmh    = [];
        eeg.backward        = true;
        [~,eeg.spectrum.scale] = ParseScale(ps);
        if Error, return; end
    else
        [parms,present] = ParseSpecial(parms,'forward');
        eeg.backward = ~present;
    end
    [parms,eeg.video]     = ParseSpecial(parms,'video');
    [parms,eeg.multifile] = ParseSpecial(parms,'multifile');
    [parms,present,ps]    = ParseSpecial(parms,'segments');
    if present, eeg.cnt3max = nsingle(ps{1}); end
    if eeg.multifile && isinf(eeg.cnt3max), Error('multifile with inf segments is nonsense'); return; end
    [parms,present,ps] = ParseSpecial(parms,'duur');
    if ~present, Error('RecordTrace needs duur'); return; end
    adcduur      = rsingle(ps{1});
    eeg.refresh  = adcduur(1);
    eeg.view     = adcduur(2);
    eeg.cnt1max = round(adcduur(2)/adcduur(1));
    if (eeg.cnt1max*adcduur(1))~=adcduur(2)
        Error(sprintf('View(%0.1f)\nneeds to be exact multiple of\nrefresh(%0.1f)',adcduur(2),adcduur(1)));
        return
    end
    eeg.segmentlen = adcduur(3);
    eeg.cnt2max = round(adcduur(3)/adcduur(2));
    if (eeg.cnt2max*adcduur(2))~=adcduur(3)
        Error(sprintf('Segment duration(%0.1f)\nneeds to be exact multiple of \nView(%0.1f)',adcduur(3),adcduur(2)));
        return
    end
    adcduur = eeg.view*1000;
elseif strcmp(cmd,'RecordSweep')
    [parms,adcduur] = ParseTijd(parms,'duur',1);
    if isempty(adcduur), Error('Sweep needs duur or Duration'); return; end
    [parms,hlp] = ParseTijd(parms,'display',1);
    if ~isempty(hlp)
        disp = adcduur/hlp(1);
        if disp~=round(disp), Error('adclen must be integer multiple of disp'); return; end
        show = hlp(1)/hlp(2);
        if show~=round(show), Error('disp must be integer multiple of show'); return; end
        show = show * disp;
    end
end
if isempty(parms), Error("tell",'Specify input amplifiers'); return; end
names = stringset(ssingle(parms{1}));
inputset = [];
for jj = 1:length(names)
    [channame,ps] = ParseCmd(names{jj});
    if isempty(axon.input),  adcset=[]; else, adcset = find(strcmp(channame,{axon.input.name})); end
    if isempty(axon.output), dacset=[]; else, dacset = find(strcmp(channame,{axon.output.name})); end
    if isempty(adcset)
        Error(sprintf('Device: %s not defined',channame)); return
    elseif isempty(ps)
        inputset = [inputset adcset];
    else
        hlp = nsingle(ps{1});
        inputset = [inputset adcset(hlp)];
    end
    if ~isempty(dacset) && strcmp(cmd,'RecordSweep')
        if length(dacset)>1
            for ii = 1:length(dacset)
                die = dacset(ii);
                outputset = unique([outputset,die]);
                axon.output(die).type = 'TTL';
                axon.output(die).duur = adcduur;
                axon.output(die).text = ['duration ' hlp];
            end
        else
            pnls = {'AXON1';'AXON2'};
            hlp = 0;
            for jjj = 1:2
                AXON = getPANEL(pnls{jjj});
                if ~isempty(AXON) && (dacset==AXON.pars.dac)
                    switch AXON.pars.mode
                        case 'VC', hlp = 'Vh1';
                        case 'CC', hlp = 'Ih1';
                        otherwise, Error('Amp-1 needs VC or CC'); return
                    end
                end
            end
            outputset = unique([outputset,dacset]);
            axon.output(dacset).type = 'Puls';
            axon.output(dacset).duur = adcduur;
            axon.output(dacset).text = ['duration ' hlp];
        end
    end
end

function stimulus = StimulusRead(parms)
stimulus = [];
[parms,stimulus.sign] = ParseSpecial(parms,'sign');
switch ssingle(parms{1})
    case {'puls';'sine';'shape'}
    	stimulus.type = ssingle(parms{1});
        stimulus.dx   = rsingle(parms{2});
        stimulus.dy   = rsingle(parms{3});
        if length(stimulus.dx)~=length(stimulus.dy), Error('#times must be equal to #amps'); end
        if length(parms)>3, stimulus.minitv = rsingle(parms{4}); else, stimulus.minitv = 0; end
    otherwise
        Error(sprintf('Unknown stimulustype: %s',parms{1}));
end

function values = checkswpmax(values,swpmax)
if (length(values)==1) && (swpmax>1), values = values * ones(1,swpmax); end

function swpmax = updateswpmax(values,swpmax,errortext)
if Error || (length(values)==1) || (swpmax == length(values))
elseif swpmax==1
    swpmax = length(values);
else
    Error(sprintf('%s must be either 1 or swpmax(%u)',errortext,swpmax));    
end

function [trein,used] = makespiketrain(parms,swp,org)
maxafter = [];
after = 0;
[hlpspikes,present,pss] = ParseSpecial(parms,'maxafter');
if present
    maxafter = rsingle(pss{1});
    if length(pss)>1, hlp = rsingle(pss{2}); if swp<=length(hlp), after = hlp(swp); else, after = hlp(1); end; end
end
minbefore = [];
before = 0;
[hlpspikes,present,pss] = ParseSpecial(hlpspikes,'minbefore');
if present
    minbefore = rsingle(pss{1});
    if length(pss)>1, hlp = rsingle(pss{2}); if swp<=length(hlp), before = hlp(swp); else, before = hlp(1); end; end
end
[~,present,pss] = ParseSpecial(hlpspikes,'skip');
if present
    hlp = rsingle(pss{1}); if swp<=length(hlp), skip = hlp(swp); else, skip = hlp(1); end
else
    skip = 1;
end
trein = org;
used  = trein;
if ~isempty(trein)
    if ~isempty(minbefore)
        dorg = diff([0; org]);
        used = org(dorg>minbefore);
        trein = used + before;
    end
    if ~isempty(maxafter)
        dorg = diff([0; org; inf]);
        used = org((dorg(1:end-1)>maxafter) & (dorg(2:end)<maxafter));
        trein = used + after;
    end
    if skip>1
        trein = trein(1:skip:end);
        used  = used(1:skip:end);
    end
end

function signal = makechirp(siglen,dacrate,freq1,freq2,logchirp)
tas = (0:siglen-1)/dacrate;
if freq2>freq1
    if logchirp
        signal(1:siglen,1) = sin(2*pi * (tas(end)/log(freq2/freq1)*(freq1*(freq2/freq1).^(tas/tas(end))-freq1)));
    else
        signal(1:siglen,1) = sin(2*pi*(((freq2-freq1)/tas(end))./2.*(tas.^2) + freq1.*tas));
    end
else
    signal(1:siglen,1) = sin(2*pi*freq1*tas);
end

function [swpmax,stims,mccvals] = Stimcmd(swpmax,bron,type)
global DAQ axon
EP = getPANEL('EPpanel');
stims = cell(1,1);
mccvals = [];
metcc   = ~isempty(strfind(axon.output(bron).text,'mcc'));
commands = ParseSimple(strrep(axon.output(bron).text,'mcc','0'));
if Error, return; end
israpp = strcmp(type,'rapp');
newmax = swpmax;
for ncmd = 1:length(commands)
    modus = '';
    parms = ParseSimple(commands{ncmd},'spatie');
    [parms,present,trainpars] = ParseSpecial(parms,'train');
    if present
        if isempty(modus), modus = 'train'; else, Error(sprintf('You can not combine %s with train',modus)); end
        [trainpars, present, pps] = ParseSpecial(trainpars,'freq');
        if present
            newmax = updateswpmax(rsingle(pps{1}),newmax,'train-frequency');
        else
            Error('train needs freq(valueset)');
            return
        end
        [trainpars, present, pps] = ParseSpecial(trainpars,'duur');
        if present
            newmax = updateswpmax(rsingle(pps{1}),newmax,'train-duration');
        else
            Error('train needs duur(valueset)');
            return
        end
        [trainpars, present, pps] = ParseSpecial(trainpars,'poisson');
        if present && ~isempty(pps), newmax = updateswpmax(rsingle(pps{1}),newmax,'seed'); end
        [trainpars, present, pps] = ParseSpecial(trainpars,'dead');
        if present, newmax = updateswpmax(rsingle(pps{1}),newmax,'dead'); end
    end
    [parms,present,trainpars] = ParseSpecial(parms,'spikes');
    if present
        if isempty(modus), modus = 'spikes'; else, Error(sprintf('You can not combine %s with spikes',modus)); end
        [trainpars, present, pps] = ParseSpecial(trainpars,'skip');
        if present
            newmax = updateswpmax(rsingle(pps{1}),newmax,'spikes-skip');
        end
        [trainpars, present, pps] = ParseSpecial(trainpars,'maxafter');
        if present && (length(pps)>1)
            newmax = updateswpmax(rsingle(pps{2}),newmax,'max interval allowed for after');
        end
        [trainpars, present, pps] = ParseSpecial(trainpars,'minbefore');
        if present && (length(pps)>1)
            newmax = updateswpmax(rsingle(pps{2}),newmax,'min interval allowed for before');
        end
    end
    if israpp
        if length(parms)<4, Error('laser: image, moment, duration, intensity {train/spikes}'); return; end
        newmax = updateswpmax(rsingle(parms{1}),newmax,'rapp-image');
        newmax = updateswpmax(rsingle(parms{2}),newmax,'rapp-moments');
        newmax = updateswpmax(rsingle(parms{3}),newmax,'rapp-duration');
        newmax = updateswpmax(rsingle(parms{4}(parms{4}~='%')),newmax,'intensity/duration');
    else
        if length(parms)<2, Error('Stim: moment, intensity/duration, {rep} {rep}, {train'); return; end
        newmax = updateswpmax(rsingle(parms{1}),newmax,'moments');
        newmax = updateswpmax(rsingle(parms{2}(parms{2}~='%')),newmax,'intensity/duration');
    end
    if Error, return; end
end
swpmax = newmax;
if israpp, nr = 4; else, nr = 2; end
stims = cell(swpmax,nr);
for ncmd = 1:length(commands)
    parms = ParseSimple(commands{ncmd},'spatie');
    train = cell(swpmax,1);
    for jj = 1:swpmax, train{jj,1} = []; end
    modus = 0;
    [parms,present,trainpars] = ParseSpecial(parms,'train');
    if present
        modus = 1;
        [trainpars, duur] = ParseTijd(trainpars,'duur',1);
        if length(duur)==1, duur(1:swpmax) = duur; end
        [trainpars, present, pps] = ParseSpecial(trainpars,'freq');
        freq = rsingle(pps{1});
        if length(freq)==1, freq(1:swpmax) = freq; end
        [trainpars, present, pps] = ParseSpecial(trainpars,'dead');
        if present, dead = rsingle(pps{1}); else, dead = 0; end
        if length(dead)==1, dead(1:swpmax) = dead; end
        [trainpars, present, pss] = ParseSpecial(trainpars,'poisson');
        if present
            if present && ~isempty(pss)
                seed = rsingle(pps{1});
                if length(seed)==1, dead(1:swpmax) = seed; end
            else
                seed = [];
            end
            for jj = 1:swpmax, if freq(jj)>0
                if ~isempty(seed), rand('twister',seed(jj)); end
                intervals = random('exp',1000/freq(jj),[1,round(1.2*freq(jj)*duur(jj)/1000)]);
                intervals = [0 cumsum(intervals(intervals>dead(jj)))];
                train{jj,1} = intervals(intervals<duur(jj));
            end; end
        else
            for jj = 1:swpmax, if freq(jj)>0, train{jj,1} = 0:(1000/freq(jj)):duur(jj); end; end
        end
    else
    	[parms,present,trainpars] = ParseSpecial(parms,'chirp');
        if present
            modus = 1;
            [trainpars, duur] = ParseTijd(trainpars,'duur',1);
            if length(duur)==1, duur(1:swpmax) = duur; end
            [trainpars, present, pps] = ParseSpecial(trainpars,'freq');
            freq1 = rsingle(pps{1});
            freq2 = rsingle(pps{2});
            if length(freq1)==1
                freq1(1:swpmax) = freq1;
                freq2(1:swpmax) = freq2;
            end
            for jj = 1:swpmax
                signal = makechirp(siglen, dacrate, freq1(jj), freq2(jj), logchirp);
            end
        end
    end
    nxtpar = 0;
    if israpp
        nxtpar = nxtpar + 1;
        image  = rsingle(parms{nxtpar});
        if (length(image)==1)  && (swpmax>1), image = image * ones(1,swpmax); end
        nxtpar = nxtpar + 1;
        moment = rsingle(parms{nxtpar});
        if (length(moment)==1) && (swpmax>1), moment = moment * ones(1,swpmax); end
        nxtpar = nxtpar + 1;
        duur   = rsingle(parms{nxtpar});
        if (length(duur)==1)   && (swpmax>1), duur = duur * ones(1,swpmax); end
    else
        nxtpar = nxtpar + 1;
        moment = rsingle(parms{nxtpar});
        if (length(moment)==1) && (swpmax>1), moment = moment * ones(1,swpmax); end
    end
    nxtpar = nxtpar + 1;
    intstr = parms{nxtpar};
    switch type
        case 'TTL'
            intensity = rsingle(intstr);
            if (length(intensity)==1) && (swpmax>1), intensity = intensity * ones(1,swpmax); end
        case {'percent';'rapp'}
            nn = find(intstr=='%');
            if isempty(nn)
                intensity = rsingle(intstr);
            else
                switch axon.output(bron).slider
                    case 'none', Error('Link stimulator to slider for percentage'); return
                    case 'left', minstim = EP.stim.min(1);
                                 maxstim = EP.stim.max(1);
                    case 'right',minstim = EP.stim.min(2);
                                 maxstim = EP.stim.max(2); 
                end                    
                intstr(nn) = ' ';
                intensity = minstim + rsingle(intstr) * (maxstim-minstim)/100;
            end
            if (length(intensity)==1) && (swpmax>1), intensity = intensity * ones(1,swpmax); end
        case 'diego'
            if metcc
                intensity = zeros(1,swpmax);
                mccvals = 'mcc';
            else
                intensity = rsingle(intstr(intstr~='%'));
                if (length(intensity)==1) && (swpmax>1), intensity = intensity * ones(1,swpmax); end
                if isempty(find(intstr=='%', 1))
                    for jj = 1:length(intensity)
                        mccvals(jj,1:length(axon.output(bron).mcc.chn)) = intensity(jj);
                    end
                else
                    for jj = 1:length(intensity) 
                        for ii = 1:length(axon.output(bron).mcc.chn)
                            dev = axon.output(bron).mcc.dev(ii);
                            loc = axon.output(bron).mcc.loc(ii);
                            mccvals(jj,ii) = DAQ(dev).MCC(loc,1) + (DAQ(dev).MCC(loc,2)-DAQ(dev).MCC(loc,1)) * intensity(jj)/100;
                        end
                    end
                    intensity = mccvals(:,1);
                end
            end
    end
    nrep1 = 0;
    nrep2 = 0;
    if length(parms)>nxtpar
        nxtpar = nxtpar + 1;
        nrep1 = rsingle(parms{nxtpar});
        if length(parms)>nxtpar
            nxtpar = nxtpar + 1;
            nrep2 = rsingle(parms{nxtpar});
        end
    end
    if Error, return; end
    for swp = 1:swpmax
        nump = length(stims{swp,1});
        if modus>0
        	trein = train{swp};
        end
        for i2 = 1:length(nrep2)
            for i1 = 1:length(nrep1)
                if modus==0
                    nump = nump + 1;
                    stims{swp,1}(nump,1) = moment(swp) + nrep1(i1) + nrep2(i2);
                    stims{swp,2}(nump,1) = intensity(swp);
                    if israpp
                        stims{swp,3}(nump,1) = duur(swp);
                        stims{swp,4}(nump,1) = image(swp);
                    end
                else
                    for i0 = 1:length(trein)
                        nump = nump + 1;
                        stims{swp,1}(nump,1) = moment(swp) + nrep1(i1) + nrep2(i2) + trein(i0);
                        stims{swp,2}(nump,1) = intensity(swp);
                        if israpp
                            stims{swp,3}(nump,1) = duur(swp);
                            stims{swp,4}(nump,1) = image(swp);
                        end
                    end
                end
            end
        end
    end
end
for swp = 1:swpmax
    [~, index] = sort(stims{swp,1}(:));
    if length(index)>1
        for jj = 1:size(stims,2)
            stims{swp,jj} = stims{swp,jj}(index);
        end
    end
end

function [ExpMeting,dlen] = Expandmeting(ExpMeting,startnr,swpmax)
dlen = 1;
metlen = length(ExpMeting) - startnr + 1;
if swpmax==metlen
    
elseif swpmax==1
    dlen = swpmax;
elseif metlen==1
    serienaam = ExpMeting(startnr).serienaam;
    for jj = 2:swpmax
        ExpMeting(startnr+jj-1,1)          = ExpMeting(startnr);
        ExpMeting(startnr+jj-1,1).setnr    = false;
        ExpMeting(startnr+jj-1,1).nodenaam = sprintf('%s-%03u',serienaam,jj);
    end
else
    Error(sprintf('#traces either 1 or %u',metlen));
end

function ExpMeting = MakeDACs(ExpMeting,deprot,inputset,outputset,makereal)
global DAQ axon
Error("line",'Generate DAC traces');
EP = getPANEL('EPpanel');
startnr = length(ExpMeting);
ExpMeting(startnr).setnr         = true;
ExpMeting(startnr).plotter       = deprot.plotters;
ExpMeting(startnr).EXTRA.Beep    = deprot.beeps;
ExpMeting(startnr).EXTRA.disp    = deprot.disp;
ExpMeting(startnr).EXTRA.show    = deprot.show;
ExpMeting(startnr).EXTRA.MCC.chn = deprot.mccchn;
ExpMeting(startnr).EXTRA.MCC.val = deprot.mccval;
if isfield(ExpMeting(startnr).EXTRA,'AXON1')
    ExpMeting(startnr).EXTRA.AXON1.imps = deprot.AXON1.imps;
end
if isfield(ExpMeting(startnr).EXTRA,'AXON2')
    ExpMeting(startnr).EXTRA.AXON2.imps = deprot.AXON2.imps;
end
if ~isempty(inputset)
    adcduur = unique([axon.input(inputset).duur]);
    if length(adcduur)>1
        Error(sprintf('ADC traces must have the same length (%5.1f)',adcduur(1)));
        return
    end
    adcchannels = [axon.input(inputset).channel];
    adcdevices  = [axon.input(inputset).device];
    adclocals   = [axon.input(inputset).local];
	ExpMeting(startnr).ADC.HWchn = adcchannels;
    ExpMeting(startnr).ADC.HWloc = adclocals;
    ExpMeting(startnr).ADC.HWdev = adcdevices;
    ExpMeting(startnr).EXTRA.MEAN.aver = deprot.avgcnt;
    ExpMeting(startnr).ADC.scale = DAQ(adcdevices(1)).ADC.scale(adclocals(1));
    for chan = 2:length(adclocals)
    	ExpMeting(startnr).ADC.scale(chan,1) = DAQ(adcdevices(chan)).ADC.scale(adclocals(chan));
    end
    ExpMeting(startnr).ADC.ints = DAQ(adcdevices(1)).ADC.ints;
    if strcmp(axon.input(inputset(1)).clocksource,'Internal')
        adcrate = deprot.adcrate;
        adcpnts = round(adcrate * adcduur/1000);
        ExpMeting(startnr).adc = zeros(adcpnts,length(inputset),deprot.avgcnt,'int16');
    else
        adcrate = 50000;
        adcpnts = 30 * 10;
        ExpMeting(startnr).adc = zeros(adcpnts,length(inputset),1,'int16');
    end
    ExpMeting(startnr).ADC.rate         = adcrate;
    ExpMeting(startnr).ADC.clocksource  = axon.input(inputset(1)).clocksource;
    ExpMeting(startnr).ADC.clocktrigger = axon.input(inputset(1)).clocktrigger;
end
if ~isempty(outputset)
    dacduur = unique([axon.output(outputset).duur]);
    if length(dacduur)>1
        Error(sprintf('DAC traces in a sweep must have the same length (%5.1f ms)',dacduur(1)));
        return
    end
    dacrate = deprot.dacrate;
    dacpnts = round(dacrate * dacduur/1000);
    artpresent = ~isempty(find([axon.output(outputset).metart], 1));
    if artpresent
        artbron = find(strcmp({axon.output.model},'Artefact'));
        if isempty(artbron), Error('Define Artefact or do not use it!'); return; end
        outputset = [outputset artbron];
        [~, present,ps] = ParseSpecial(axon.output(artbron).parms,'width');
        if present, hlp = rsingle(ps{1}); else, hlp = 1; end
        artlen = round(hlp*dacrate/1000);
        artpls = round(axon.output(artbron).maxval);
        artaim = length(outputset);
    else
        artlen = 0;
    end
    dacchannels = [axon.output(outputset).channel];
    dacdevices  = [axon.output(outputset).device];
    daclocals   = [axon.output(outputset).local];
    ExpMeting(startnr).DAC.HWchn = dacchannels;
    ExpMeting(startnr).DAC.HWloc = daclocals;
    ExpMeting(startnr).DAC.HWdev = dacdevices;
    ExpMeting(startnr).DAC.rate = dacrate;
    ExpMeting(startnr).DAC.ints = DAQ(dacdevices(1)).DAC.ints;
    ExpMeting(startnr).cdac = [];
    ExpMeting(startnr).dac  = zeros(dacpnts,length(outputset),'int16'); 
    ExpMeting(startnr).DAC.scale = DAQ(dacdevices(1)).DAC.scale(daclocals(1));
    for chan = 2:length(daclocals), ExpMeting(startnr).DAC.scale(chan,1) = DAQ(dacdevices(chan)).DAC.scale(daclocals(chan)); end
end
swpmax = 1;
dacdone = false(1,length(outputset));
dacscale = ones(1,length(outputset));
for dacdoel = 1:length(outputset)
    bron = outputset(dacdoel);
    dacscale(dacdoel) = ExpMeting(startnr).DAC.ints/ExpMeting(startnr).DAC.scale(dacdoel).User;
    if dacdone(dacdoel) || isempty(axon.output(bron).type) || strcmp(axon.output(bron).type,'Artefact') , continue; end
    dacunits{dacdoel} = ExpMeting(startnr).DAC.scale(dacdoel).Units;
    dacdone(dacdoel)=true;
    Error("line",sprintf('Generate dac trace: %u for %s',dacdoel,ExpMeting(end).serienaam));
    channel = axon.output(bron).local;
    device  = axon.output(bron).device;
    tscale  = 0.001 * dacrate;
    [~,present,ps] = ParseSpecial(axon.output(bron).parms,'repeat');
    if present, dacrepeat = nsingle(ps{1})-1; else,dacrepeat = 0; end
    isTTL  = strcmpi(axon.output(bron).model,'TTL');
    isorca = strcmpi(axon.output(bron).model,'Orca'); 
    diego  = strcmpi(axon.output(bron).model,'Diego');
    if (length(axon.output)>bron) && strcmpi(axon.output(bron+1).model,'Support')
        dualdiego = true;
    else
        dualdiego = false;
    end
    bipolar = (length(axon.output)>bron) && strcmpi(axon.output(bron+1).model,'Invert');
    ttlamp = int16(round(ExpMeting(startnr).DAC.ints/2));
    switch axon.output(bron).type
        case 'Puls'
            parms = ParseSimple(axon.output(bron).text);
            if ~isempty(cell2mat(strfind(parms,'REPEAT')))
                rhlp = [];
                for jj = 1:length(parms)
                    [~, present, pss] = ParseSpecial(parms(jj),'REPEAT');
                    if present
                        for kkkk = 1:nsingle(pss{1})
                            for kk = 2:length(pss)
                                rhlp{end+1,1} = pss{kk};
                            end
                        end
                    else
                        rhlp{end+1,1} = parms{jj};
                    end
                end
                parms = rhlp;
            end
            cnt = 0;
            for jj=1:length(parms)
                hlp = ParseSimple(parms{jj},'spatie');
                cnt = cnt + 1;
                if length(hlp)<2, Error('Puls needs time & amplitude'); return; end
                hlpx{cnt} = rsingle(char(hlp{1}));
                hlpy{cnt} = rsingle(char(hlp{2}));
                if length(hlp)>2, hlpz{cnt} = rsingle(char(hlp{3})); else, hlpz{cnt} = hlpy{cnt};  end
                swpmax = max([swpmax,length(hlpx{cnt}),length(hlpy{cnt}),length(hlpz{cnt})]);
            end
            xstims = zeros(swpmax,cnt); 
            ystims = zeros(swpmax,cnt); 
            zstims = zeros(swpmax,cnt); 
            for jj = 1:cnt
                lx = length(hlpx{jj});
                ly = length(hlpy{jj});
                lz = length(hlpz{jj});
                if ((lx==1)||(lx==swpmax)) && ((ly==1)||(ly==swpmax)) && ((lz==1)||(lz==swpmax))
                    xstims(1:swpmax,jj) = hlpx{jj};
                    ystims(1:swpmax,jj) = hlpy{jj};
                    zstims(1:swpmax,jj) = hlpz{jj};
                else
                    Error(sprintf('Sweeps nr should be 1 or %u',swpmax)); return
                end
            end
            if ~isempty(find(isnan(ystims), 1))
                Error('You cannot have NaNs in the protocol'); return
            end
            if ~isempty(find(xstims<0, 1))
                Error('No negative durations allowed in Puls'); return
            end
            grens = double(intmax('int16'));
            swpduur = unique(sum(xstims,2));
            if length(swpduur)>1, Error('Time axis changes'); return; end
            if round(swpduur*tscale)~=dacpnts, Error(sprintf('Length does not add up to %0.1f ms',swpduur)); return; end
            [ExpMeting,dlen] = Expandmeting(ExpMeting,startnr,swpmax);
            if Error, return; end
            for kk = 0:(dlen-1)
                for jj=1:swpmax
                    xstart = 1;
                    for ii=1:cnt
                        xeind = xstart+round(xstims(jj,ii) * dacrate * 0.001)-1;
                        yampi = max(-grens,min(grens,dacscale(dacdoel) * ystims(jj,ii)));
                        zampi = max(-grens,min(grens,dacscale(dacdoel) * zstims(jj,ii)));
                        if ystims(jj,ii)==zstims(jj,ii)
                            ExpMeting(kk+startnr+jj-1).dac(xstart:xeind,dacdoel) = int16(round(yampi));
                        else
                            ExpMeting(kk+startnr+jj-1).dac(xstart:xeind,dacdoel) = int16(round((yampi + (zampi-yampi) * ((xstart:xeind)-xstart)/(xeind-xstart) ) ));
                        end
                        xstart = xeind+1;
                    end
                end
            end
        case 'Stim'
            DAQ(device).DAC.repeat = dacrepeat;
            if isTTL || isorca
                [swpmax,stims] = Stimcmd(swpmax,bron,'TTL');
                if Error, return; end
                ledchannel = find(strcmp({axon.output.model},'LED'));
                if isempty(ledchannel)
                    leddoel = [];
                else
                    leddoel = find([ExpMeting(startnr).DAC.HWchn]==axon.output(ledchannel).channel);
                    [~,present,ps] = ParseSpecial(axon.output(bron).parms,'margin');
                    if present, margin = round(tscale * rsingle(ps{1})); else, margin = 0; end
                end
            else
                [~,present,ps] = ParseSpecial(axon.output(bron).parms,'Stimulus');
                if present, stimulus = StimulusRead(ps); else, stimulus = axon.stim; end
                switch stimulus.type
                    case {'puls'}
                        tpnts = stimulus.dx * dacrate/1000;
                        ipnts = round(tpnts);
                        if max(abs(tpnts-ipnts))>0.1, Error('Rounding error >10 percent in Stimulus puls'); return; end
                        shape1 = zeros(sum(ipnts),1);
                        len = 1;
                        for ii=1:length(tpnts)
                            shape1(len:(len+ipnts(ii)-1)) = stimulus.dy(ii);
                            len = len + ipnts(ii);
                        end
                    case {'sine'}
                        for ii=1:length(stimulus.dx)
                            sinlen   = round(stimulus.dx(ii) * dacrate / 1000);
                            nperiods = stimulus.dy(ii) / stimulus.dx(ii);
                            if ii == 1
                                shape1 = sin(0:(2 * pi / sinlen):(2*pi*nperiods));
                            else
                                shape1 = shape1 + sin(0:(2 * pi / sinlen):(2 * pi * nperiods));
                            end
                        end
                    case {'shape'}
                        tpnts = stimulus.dx * dacrate / 1000;
                        ipnts = round(tpnts);
                        if max(abs(tpnts-ipnts))>0.1,  Error('Rounding error >10 percent in Stimulus puls'); return; end
                        shape1 = zeros(sum(ipnts),1);
                        len = 1;
                        for ii=1:length(tpnts)
                            dlen = ipnts(ii);
                            if ii == 1
                                shape1(len:(len+dlen)) = (0:(1/dlen):1) * stimulus.dy(ii);
                            else
                                shape1(len:(len+dlen)) = shape1(len)+(0:(1/dlen):1) * stimulus.dy(ii);
                            end
                            len = len + ipnts(ii);
                        end
                end
                stimlen = length(shape1);
                if diego
                    if dualdiego
                        shape2 = shape1;
                        shape1(shape1<0)  = 0;
                        shape1(shape1~=0) = ttlamp;        
                        shape2(shape2>0)  = 0;
                        shape2(shape2~=0) = ttlamp;
                        dacdone(dacdoel+1) = true;
                    else
                        shape1(shape1>0) =  intmax('int16');
                        shape1(shape1<0) = -intmax('int16');
                    end
                    [swpmax,stims,mccvals] = Stimcmd(swpmax,bron,'diego');
                    if Error, return; end
                    for jj = 1:swpmax
                        if length(unique(stims{jj,2}))>1
                            Error('Diego can have only 1 intensity/sweep'); return
                        end
                    end
                else
                    [swpmax,stims] = Stimcmd(swpmax,bron,'percent');
                    if bipolar, for jj = 1:size(stims,1), stims{jj,2} = 0.5*stims{jj,2}; end; end
                    if Error, return; end
                    for jj = 1:swpmax
                        if ~isempty(find(abs(stims{jj,2})>DAQ(device).DAC.scale(channel).User))
                            Error('Amplitude Overload'); return
                        end
                    end                
                end
            end
            [ExpMeting,dlen] = Expandmeting(ExpMeting,startnr,swpmax);
            if Error, return; end
            for kk = 0:(dlen-1)
                for swp = 1:swpmax
                    metnr = kk+startnr+swp-1;
                    ts = 1+round(tscale * stims{swp,1});
                    if isTTL || isorca
                        te = ts + round(tscale * stims{swp,2})-1;
                        ts = ts(te<dacpnts);
                        te = te(te<dacpnts);
                    else
                        ts = ts(ts<(dacpnts-stimlen));
                        te = ts + stimlen - 1;
                    end
                    ta = ts + artlen - 1;
                    if diego
                        ExpMeting(metnr).MCC.chn = [ExpMeting(metnr).MCC.chn axon.output(bron).mcc.chn];
                        if ischar(mccvals)
                            ExpMeting(metnr).MCC.val = 'mcc';
                        else
                            ExpMeting(metnr).MCC.val = [ExpMeting(metnr).MCC.val mccvals(swp,:)];
                        end
                    end
                    for ii = 1:length(ts)
                        if diego
                            ExpMeting(metnr).dac(ts(ii):te(ii),dacdoel)   = shape1;
                            if dualdiego
                                ExpMeting(metnr).dac(ts(ii):te(ii),dacdoel+1) = shape2;
                            end
                        elseif isorca
                            ExpMeting(metnr).dac(ts(ii):te(ii),dacdoel) = ttlamp;
                            if ~isempty(leddoel)
                                ExpMeting(metnr).dac(ts(ii)-margin:te(ii)+margin,leddoel) = ttlamp;
                            end
                        elseif isTTL
                            ExpMeting(metnr).dac(ts(ii):te(ii),dacdoel) = ttlamp;
                        else
                            ExpMeting(metnr).dac(ts(ii):te(ii),dacdoel) = int16(round(dacscale(dacdoel) * stims{swp,2}(ii) * shape1));
                        end
                        if artpresent && axon.output(bron).metart
                            ExpMeting(metnr).dac(ts(ii):ta(ii),artaim) = artpls;
                        end
                    end
                    if bipolar
                        if EP.fld.on
                            dV  = int16(round(dacscale(dacdoel) * EP.fld.dV * EP.fld.amp / EP.fld.ref));
                            daar = (ExpMeting(metnr).dac(:,dacdoel)~=0);
                            ExpMeting(metnr).dac(daar,dacdoel+1) = -ExpMeting(metnr).dac(daar,dacdoel) + dV;
                            ExpMeting(metnr).dac(daar,dacdoel)   =  ExpMeting(metnr).dac(daar,dacdoel) + dV;
                        else
                            ExpMeting(metnr).dac(:,dacdoel+1) = -ExpMeting(metnr).dac(:,dacdoel);
                        end
                    end
                end
            end
        case 'Wave'
            if isTTL, Error('TTL is incompatable with Wave'); return; end
            [~,present,ps] = ParseSpecial(axon.output(bron).parms,'background');
            if present, background = rsingle(ps{1}); else, background = 0; end
            swpmax = updateswpmax(background,swpmax,'background');
            if Error, return; end
            cmds = ParseSimple(axon.output(bron).text);
            for kk =1:length(cmds)
                parms = ParseSimple(cmds{kk},'spatie');
                swpmax = updateswpmax(rsingle(parms{1}),swpmax,'starttime');
                swpmax = updateswpmax(rsingle(parms{2}),swpmax,'duration');
                swpmax = updateswpmax(rsingle(parms{3}),swpmax,'amplitude');
                if Error, return; end
                [waveform,subs] = ParseCmd(parms{4});
                switch waveform
                    case {'sine';'noise';'chirp';'alfa'}
                        [subs,present,pss] = ParseSpecial(subs,'freq');
                        if present
                            swpmax = updateswpmax(rsingle(pss{1}),swpmax,'frequency');
                            if Error, return; end
                            if length(pss)>1
                                swpmax = updateswpmax(rsingle(pss{2}),swpmax,' second frequency');
                            elseif strcmp(waveform,'chirp')
                                Error('chirp needs freq(valset1,valset2)');
                            end
                        elseif strcmp(waveform,'sine') || strcmp(waveform,'chirp')
                            Error(' sine/chirp needs freq(s)');
                        end
                        [subs,present,pss] = ParseSpecial(subs,'phase');  if present, swpmax = updateswpmax(rsingle(pss{1}),swpmax,'phase');  end
                        [subs,present,pss] = ParseSpecial(subs,'tau');    if present, swpmax = updateswpmax(rsingle(pss{1}),swpmax,'tau');    end
                        [subs,present,pss] = ParseSpecial(subs,'seed');   if present, swpmax = updateswpmax(rsingle(pss{1}),swpmax,'seed');   end
                        [subs,present,pss] = ParseSpecial(subs,'offset'); if present, swpmax = updateswpmax(rsingle(pss{1}),swpmax,'offset'); end
                    otherwise, Error(sprintf('Unknown waveform :\n%s',waveform));
                end
                if Error, return; end
            end
            background = checkswpmax(background,swpmax);
            [ExpMeting,dlen] = Expandmeting(ExpMeting,startnr,swpmax);
            if Error, return; end
            for kk = 0:(dlen-1)
                for jj=1:swpmax, ExpMeting(kk+startnr+jj-1).dac(:,dacdoel) = int16(round(dacscale(dacdoel) * background(jj))); end
            end
            for kk =1:length(cmds)
                parms = ParseSimple(cmds{kk},'spatie');
                bgn = 1 + round(tscale *  checkswpmax(rsingle(parms{1}),swpmax));
                lst =     round(tscale * (checkswpmax(rsingle(parms{1}),swpmax) + checkswpmax(rsingle(parms{2}),swpmax)));
                bgn(bgn<1) = 1;
                lst(lst>dacpnts) = dacpnts;
                amps = checkswpmax(rsingle(parms{3}),swpmax);
                [waveform,subs] = ParseCmd(parms{4});
                [subs,logchirp] = ParseSpecial(subs,'log');
                [subs,present,pss] = ParseSpecial(subs,'freq');
                if present
                    freq1 = checkswpmax(rsingle(pss{1}),swpmax);
                    if length(pss)>1
                        freq2 = checkswpmax(rsingle(pss{2}),swpmax);
                    end
                else
                    freq1(1:swpmax) = 0;
                end
                [subs,present,pss] = ParseSpecial(subs,'phase');   if present, phase  = checkswpmax(rsingle(pss{1}),swpmax); else, phase(1:swpmax) = 0; end        
                [subs,present,pss] = ParseSpecial(subs,'tau');     if present, taus   = checkswpmax(rsingle(pss{1}),swpmax); else, taus(1:swpmax)  = 0; end
                [subs,present,pss] = ParseSpecial(subs,'seed');    if present, seed   = checkswpmax(rsingle(pss{1}),swpmax); else, seed = []; end
                [~,present,pss]    = ParseSpecial(subs,'offset');  if present, offset = checkswpmax(rsingle(pss{1}),swpmax); else, offset(1:swpmax) = 0; end
                for jj = 0:(dlen-1)
                    for swp = 1:swpmax
                        siglen = lst(swp)-bgn(swp)+1;
                        metnr = jj+startnr+swp-1;
                        switch waveform
                            case 'noise'
                                if ~isempty(seed), randn('state',seed(swp)); end
                                if taus(swp)==0
                                    signal = randn(siglen,1);
                                else
                                    tc  = taus(swp)*tscale;
                                    filt = exp(-(0:(3*tc))/tc)';
                                    filt = single(filt/norm(filt));
                                    signal = conv2(single(randn(siglen-1+length(filt),1)),filt,'valid');
                                end
                            case 'sine'
                                df = 2 * pi() * freq1(swp)/ dacrate;
                                faseshift = dacrate * phase(swp)/(freq1(swp)*360);
                                signal = sin(df * (faseshift + (0:siglen-1)'));
                            case 'chirp'
                                signal(1:siglen,1) = makechirp(siglen, dacrate, freq1(swp), freq2(swp), logchirp);
                            case 'alfa'
                                if freq1(swp)==0, interval = siglen; else,interval = round(tscale * dacrate / freq1(swp)); end
                                tijd = (0:siglen-1)/tscale;
                                signal = (tijd.*exp(-tijd/(taus(swp)*tscale)))';
                                hlp = signal;
                                signal = 0 * hlp;
                                for hh = bgn(swp):interval:lst(swp)
                                    start = hh-bgn(swp)+1;
                                    signal(start:end) = signal(start:end) + hlp(1:(end-start+1));
                                end
                            otherwise
                        end
                        ExpMeting(metnr).dac(bgn(swp):lst(swp),dacdoel) = ExpMeting(metnr).dac(bgn(swp):lst(swp),dacdoel) + int16(round( dacscale(dacdoel) * (amps(swp)* signal + offset(swp))));
                        if bipolar
                            if EP.fld.on
                                dV = int16(round(dacscale(dacdoel) * EP.fld.dV * EP.fld.amp / EP.fld.ref));
                                daar = (ExpMeting(metnr).dac(:,dacdoel)~=0);
                                ExpMeting(metnr).dac(daar,dacdoel+1) = -ExpMeting(metnr).dac(daar,dacdoel) + dV;
                                ExpMeting(metnr).dac(daar,dacdoel)   =  ExpMeting(metnr).dac(daar,dacdoel) + dV;
                            else
                                ExpMeting(metnr).dac(:,dacdoel+1) = -ExpMeting(metnr).dac(:,dacdoel);
                            end
                        end
                    end
                end
            end
        case {'Image';'Blue';'Yellow'}
            rapdoel = dacdoel;
            imagebron = find(strcmp({axon.output.type},'Image'));
            if ~isempty(imagebron)
                [~,present,ps] = ParseSpecial(axon.output(imagebron).parms,'width');
                if present, width  = round(tscale * rsingle(ps{1})); else, width = 1; end
                imageTTL = rapdoel;
                dacdone(rapdoel)=true;
                rapdoel = rapdoel + 1;
            end
            bluebron = find(strcmp({axon.output.type},'Blue'));
            if isempty(bluebron)
                metspikes = false;
            else
                metspikes = ~isempty(strfind(axon.output(bluebron(1)).text,'spikes'));
                [swpmax,bstims] = Stimcmd(swpmax,bluebron(1),'rapp');
            end
            if Error, return; end
            geelbron = find(strcmp({axon.output.type},'Yellow'));
            if ~isempty(geelbron)
                [newmax,ystims] = Stimcmd(swpmax,geelbron(1),'rapp');
                if (newmax>swpmax) && ~isempty(bluebron)
                    [swpmax,bstims] = Stimcmd(newmax,bluebron(1),'rapp');
                end
            end
            if Error, return; end
            ExpMeting = Expandmeting(ExpMeting,startnr,swpmax);
            if Error, return; end
            for kk = 1:2
                if kk==1, bron = bluebron; else,bron = geelbron; end
                if isempty(bron), continue; end
                TTL = rapdoel;
                dacdone(rapdoel)=true;
                rapdoel = rapdoel + 1;
                INT = rapdoel;
                dacdone(rapdoel)=true;
                rapdoel = rapdoel + 1;
                if kk==1, blueTTL = TTL; else,geelTTL = TTL; end
                [~,present,ps] = ParseSpecial(axon.output(bron(1)).parms,'margin');
                if present, margin = round(tscale * rsingle(ps{1})); else, margin = 0; end
                scale  = ExpMeting(startnr).DAC.ints/ExpMeting(startnr).DAC.scale(INT).User;
                for swp = 1:swpmax
                    metnr = startnr+swp-1;
                    amp = int16(round(scale * bstims{swp,2}));
                    bgn = 1 +  round(tscale * bstims{swp,1});
                    lst = round(tscale * (bstims{swp,1}+bstims{swp,3}));
                    if isempty(imagebron), bld = ttlamp+0*amp; else, bld = int16(round(bstims{swp,4})); end
                    keep = (bgn>0) & (lst<dacpnts);
                    bgn = bgn(keep);
                    lst = lst(keep);
                    amp = amp(keep);
                    if ~isempty(find((bgn(2:end)-lst(1:end-1))<0, 1)), Error('Blue laser pulses overlap'); return; end
                    for jj = 1:length(bgn)
                        ExpMeting(metnr).dac(bgn(jj):lst(jj),TTL) = bld(jj);
                    end
                    bgn = bgn - margin; bgn(bgn<1) = 1;
                    lst = lst + margin; lst(lst>dacpnts) = dacpnts;
                    for jj = 1:length(bgn)
                        ExpMeting(metnr).dac(bgn(jj):lst(jj),INT) = amp(jj);
                    end
                end
            end
            if ~isempty(imagebron)
                for swp = 1:swpmax
                    marker = [];
                    metnr = startnr+swp-1;
                    ExpMeting(metnr).dac(:,imageTTL) = 0;                                   
                    if ~isempty(bluebron) && ~isempty(geelbron)
                        transients = 1+[0; find((diff(ExpMeting(metnr).dac(:,blueTTL))~=0)|(diff(ExpMeting(metnr).dac(:,geelTTL))~=0))];
                        transients = [transients ExpMeting(metnr).dac(transients,blueTTL) ExpMeting(metnr).dac(transients,geelTTL)];
                        lastlaser = [0,0];
                        for ii = 1:size(transients,1)
                            hlp = double(transients(ii,2:3));
                            if hlp(1)==0, hlp(1) = lastlaser(1); end
                            if hlp(2)==0, hlp(2) = lastlaser(2); end
                            if ~isequal(hlp,lastlaser)
                                if (ii>1) && (transients(ii-1,2)==0) && (transients(ii-1,3)==0)
                                    marker = round((transients(ii,1)+transients(ii-1,1))/2);
                                else
                                    marker = transients(ii,1)-1;
                                end
                                lastlaser = hlp;
                                ExpMeting(metnr).dac(marker,imageTTL) = ttlamp;
                            end
                        end
                    	ExpMeting(metnr).dac(ExpMeting(metnr).dac(:,blueTTL)>0,blueTTL) = ttlamp;
                        ExpMeting(metnr).dac(ExpMeting(metnr).dac(:,geelTTL)>0,geelTTL) = ttlamp;
                    else
                        if ~isempty(bluebron), channel = blueTTL; else,channel = geelTTL; end
                        transients = 1+[0; find(diff(double(ExpMeting(metnr).dac(:,channel)))~=0)];
                        transients = [transients double(ExpMeting(metnr).dac(transients,channel))];
                        lastimage = 0;
                        for ii = 1:size(transients,1)
                            if (transients(ii,2)>0) && (transients(ii,2)~=lastimage)
                                if ii==1
                                    Error('No time to start image'); return;
                                elseif transients(ii-1,2)==0
                                    marker = round((transients(ii,1)+transients(ii-1,1))/2);
                                else
                                    marker = transients(ii,1)-1;
                                end
                                ExpMeting(metnr).dac(marker:marker+width-1,imageTTL) = ttlamp;
                                lastimage = transients(ii,2);
                            end
                        end
                    	ExpMeting(metnr).dac(ExpMeting(metnr).dac(:,channel)>0,channel) = ttlamp;
                    end
                    if ~isempty(marker), ExpMeting(metnr).dac((end-width):(end-1),imageTTL) = ttlamp; end
                end
            end
    end
end    
if makereal
    for jj = startnr:(startnr+swpmax-1)
        ExpMeting(jj).dacr = double(ExpMeting(jj).dac);
        for ii = 1:length(dacscale)
            ExpMeting(jj).dacr(:,ii) = ExpMeting(jj).dacr(:,ii) / dacscale(ii);
        end
    end
end

function set3 = mixed(set1,set2)
nmax = max(length(set1),length(set2));
if length(set1)<nmax
    set1 = set1(1)*ones(1,nmax);
else
    set2 = set2(1)*ones(1,nmax);
end
set3(1:2:2*nmax) = set1(1:end);
set3(2:2:2*nmax) = set2(1:end);

function txtout = Conditional(txtin)
txtout = txtin;
ifs = strfind(txtin,'IF_');
if ~isempty(ifs)
    ends = strfind(txtin,'END');
    if length(ifs)~=length(ends), Error('IF_ and END do not match'); return; end
    PANEL = getPANEL('AXON1'); if ~isempty(PANEL), modeA = PANEL.pars.mode; else, modeA = 'NN'; end
    PANEL = getPANEL('AXON2'); if ~isempty(PANEL), modeB = PANEL.pars.mode; else, modeB = 'NN'; end
    for jj = length(ifs):-1:1
        bgn = ifs(jj);
        lst = bgn -1 + strfind(txtin(bgn:end),'END');
        statement = txtin(bgn:lst(1)+2);
        commas = strfind(statement,','); 
        fcomma = commas(1);
        lcomma = commas(end);
        metelse = strfind(statement,'ELSE');
        if isempty(metelse)
            statement1 = statement(fcomma+1:lcomma-1);
            statement2 = '';
        else
            lecomma = commas(find(commas<metelse,1,'last'));
            fecomma = commas(find(commas>metelse,1,'first'));
            statement1 = statement(fcomma+1:lecomma-1);
            statement2 = statement(fecomma+1:lcomma-1);
        end
        [~,mode1,mode2] = ParseDash(statement(1:fcomma-1));
        if (~strcmp(mode1,'NN') && ~strcmp(mode1,modeA)) || (~strcmp(mode2,'NN') && ~strcmp(mode2,modeB))
            txtin = strrep(txtin,statement,statement2);
        else
            txtin = strrep(txtin,statement,statement1);
        end
    end
end
txtout = txtin;

function Meting = MetingIni(Meting,seriename,nodename)
global axon p
die = length(Meting)+1;
Meting(die,1).version   = getversion;
Meting(die).setnr       = true;
Meting(die,1).serienaam = seriename;
Meting(die,1).nodenaam  = nodename;
pold = '';
while ~strcmp(Meting(die).serienaam,pold)
    pold = Meting(die).serienaam;
    Meting(die).serienaam = strrep(strrep(pold,', ',','),'  ',' ');
end
Meting(die).abstime = 0;
Meting(die).reltime = 0;
Meting(die).ADC  = struct('HWchn',[],'HWloc',[],'HWdev',[],'ints',32767,'rate',0,'scale',[],'clocksource','','clocktrigger','');
Meting(die).adc  = [];
Meting(die).DAC  = struct('HWchn',[],'HWloc',[],'HWdev',[],'ints',32767,'rate',0,'scale',[],'repeat',0,'compress',true);
Meting(die).dac  = [];
Meting(die).cdac = [];
Meting(die).SEGMENT = struct('name','','cmt','','time',[],'start',[],'eind',[]);
Meting(die).EXTRA   = struct('p',p,'note','','input',axon.input,'output',axon.output,'stim',axon.stim,...
                             'MEAN',    struct('avg',[],'sem',[],'Sy',[],'Syy',[],'cnt',[],'aver',[],'chan',[],'zero',[]),...
                             'AXON1',   struct('pars',[],'imps',[],'clamp',[],'state',[],'RPgains',[1,1,1,1]),...
                             'AXON2',   struct('pars',[],'imps',[],'clamp',[],'state',[],'RPgains',[1,1,1,1]),...
                             'EP',      struct('stim',[],'fld',[]),...
                             'MCC',     axon.MCC,...
                             'SEA',     axon.SEA,...
                             'CAM',     axon.CAM,...
                             'ELS',     axon.ELS,...
                             'borders', struct('bgn',[],'end',[]),'Beep',[],'disp',1,'show',1,...
                             'comment1','empty',...
                             'comment2','empty');
Meting(die).plotter(1) = struct('window',9,'mode','adc');
Meting(die).result = [];
for jj = 1:2
    if jj==1, name = 'AXON1'; else, name= 'AXON2'; end
    AXON = getPANEL(name);
    if ~isempty(AXON)
        Meting(die).EXTRA.(name).pars    = AXON.pars;
        Meting(die).EXTRA.(name).imps    = AXON.imps;
        Meting(die).EXTRA.(name).RPgains = AXON.RPgains;
    end
end
EP = getPANEL('EPpanel');
if ~isempty(EP)
    Meting(die).EXTRA.EP.stim = EP.stim;
    Meting(die).EXTRA.EP.fld  = EP.fld;
end

function [ExpMeting, dosweep, eeg] = Protocol_Generate(firstscript,makereal)
global DAQrbp panels SEL axon protocol p
panels.neversave = false;
ExpMeting = [];
eeg = struct('trace',false,'video',false,'backward',true,'segmentlen',0,'refresh',0,'view',0,'multifile',false,...
             'cnt1max',1,'cnt2max',1,'cnt3max',1,'spectrum',[]);
eeg.spectrum = struct('on',false,'window',9,'filt',[],'kill',[],'trace',[],'bmh',[],'scale',0);
eeg.trace    = ~isempty(find([protocol.prot.mod]==5,1));
dosweep      = ~isempty(find([protocol.prot.mod]==4,1));
if ~dosweep && ~eeg.trace, Error('No recording in this protocol');  end
if  dosweep &&  eeg.trace, Error('You can not combine SWP & EEG in one set'); end
if Error, return; end
if ~isempty(firstscript), protocol.prot(1).txt = firstscript; end
for proto = 1:length(protocol.prot)
    for jj = 1:length(axon.input), axon.input(jj).duur = []; end
    for jj = 1:length(axon.output)
        axon.output(jj).duur = [];
        if ~strcmp(axon.output(jj).type,'Artefact'), axon.output(jj).type = []; end
        axon.output(jj).text = [];
    end
    panels.duur = [];
    protocol.prot(proto).newname  = [];
    protocol.prot(proto).beeps    = 0;
    protocol.prot(proto).avgcnt   = 1;
    protocol.prot(proto).avgmode  = 0;
    protocol.prot(proto).adcrate  = protocol.adcrate;
    protocol.prot(proto).dacrate  = protocol.dacrate;
    protocol.prot(proto).disp     = 1;
    protocol.prot(proto).show     = 1;
    protocol.prot(proto).mccchn   = [];
    protocol.prot(proto).mccval   = [];
    protocol.prot(proto).plotters = [];
    AXON1 = getPANEL('AXON1');
    if ~isempty(AXON1)
        AXON1.imps.on    = false;
        AXON1.imps.doavg = false;
        AXON1.imps.times = AXON1.imps.times;
        AXON1.imps.adc   = AXON1.pars.adc(1);
        AXON1.imps.dac   = AXON1.pars.dac(1);
        protocol.prot(proto).AXON1.imps = AXON1.imps;
        set(AXON1.handle,'UserData',AXON1);
    else
        protocol.prot(proto).AXON1.imps.on = false;
    end
    AXON2 = getPANEL('AXON2');
    if ~isempty(AXON2)
        AXON2.imps.on    = false;
        AXON2.imps.doavg = false;
        AXON2.imps.times = AXON2.imps.times;
        AXON2.imps.adc   = AXON2.pars.adc(1);
        AXON2.imps.dac   = AXON2.pars.dac(1);
        protocol.prot(proto).AXON2.imps = AXON2.imps;
        set(AXON2.handle,'UserData',AXON2);
    else
        protocol.prot(proto).AXON2.imps.on = false;
    end
    clamp1 = [];
    clamp2 = [];
    interval1 = protocol.inter1;
    interval2 = protocol.inter2;
    protocol.reset = [];
    inputset   = [];
    outputset  = [];
    eldacs     = [];
    electrodes = [];
    groupdisplay = false;
    protothis = Conditional(protocol.prot(proto).txt);
    commands = ParseSimple(protothis);
    for mm = 1:length(commands)
        cmdstr = commands{mm};
        Error("line",cmdstr,['Make: ' protocol.prot(proto).name]);
        if isempty(cmdstr)
        elseif contains(cmdstr,'=')
            assigncmd(cmdstr);
        else
            [cmd,parms] = ParseCmd(cmdstr);
            switch cmd
                case 'Askwrite',  if get(CMD.Autosave,'Value')==0
                                      if isempty(parms), txtcmd = 'Write your data to disk?'; else,txtcmd = parms{1}; end
                                      if strcmp(questdlg(txtcmd,'Saving data','Yes','No','Yes'),'Yes')
                                          set(CMD.Autosave,'Value',1);
                                          set(CMD.Savedata,'Visible','Off');
                                          Checksavedirectory;
                                      end
                                  end 
                case 'Confirm',   if isempty(parms), txtcmd = 'Confirm start'; else,txtcmd = parms{1}; end
                                  if strcmp(questdlg(txtcmd,'Confirm','Yes','Break','Break'),'Break'), Error('Break DAQ start'); end
                case 'NewName',   protocol.prot(proto).newname = ssingle(parms{1});
                case 'neversave', panels.neversave = true;
                case 'Blanker',   panels.blankeron = true; Blanker('activate'); figure(panels.root);
                case 'Duration',  [~,panels.duur] = ParseTijd({cmdstr},'Duration',1);
                case 'TimeStart', [~,protocol.reset] = ParseTijd({cmdstr},'TimeStart',1000);                    
                case {'ElectrodeSet';'ElectrodeSeq'}
                    if ~isempty(SEL)
                        [parms,groupdisplay] = ParseSpecial(parms,'link');
                        if strcmp(cmd,'ElectrodeSet')
                            for jjj = 1:length(parms)
                                electrodes{jjj} = nsingle(parms{jjj});
                            end
                        else
                            electrodes = nsingle(parms{1});
                            set(SEL.linked,'Value',0);
                            set(SEL.modus2,'String','single','Visible','on');
                        end
                    else
                        Error(sprintf('%s needs SEL panel',cmd));
                    end
                case 'Average'
                    [parms,presa] = ParseSpecial(parms,'perset');   if presa, protocol.prot(proto).avgmode = 1; end
                    [parms,presb] = ParseSpecial(parms,'pertrace'); if presb, protocol.prot(proto).avgmode = 2; end
                    if ~presa && ~presb
                        Error('Averagemode: pertrace or perset');
                    else
                        protocol.prot(proto).avgcnt = rsingle(parms{1});
                        if protocol.prot(proto).avgcnt==1, protocol.prot(proto).avgmode = 0; end
                    end
                case 'Impedance'
                    [parms,doclear]   = ParseSpecial(parms,'clear');
                    [parms,doavg]     = ParseSpecial(parms,'avg');
                    [parms,metadc,ps] = ParseSpecial(parms,'adc'); if metadc, adcs = nsingle(ps{1}); end
                    [parms,metdac,ps] = ParseSpecial(parms,'dac'); if metdac, dacs = nsingle(ps{1}); end
                    times = rsingle(parms{2});
                    if mod(length(times),2) || (length(times)<4), Error('Impedance bounderies error'); break; end
                    if ~isempty(AXON1) && strcmp(AXON1.pars.name,ssingle(parms{1}))
                        AXON1.imps.on = true;
                        if doclear, AXON1.imps.avgs = []; end
                        AXON1.imps.doavg = doavg;
                        AXON1.imps.times = times;
                        if metadc, AXON1.imps.adc =adcs; end
                        if metdac, AXON1.imps.dac =dacs; end
                        set(AXON1.handle,'UserData',AXON1);
                        protocol.prot(proto).AXON1.imps = AXON1.imps;
                    elseif ~isempty(AXON2) && strcmp(AXON2.pars.name,ssingle(parms{1}))
                        AXON2.imps.on = true;
                        if doclear, AXON2.imps.avgs = []; end
                        AXON2.imps.doavg = doavg;
                        AXON2.imps.times = times;
                        if metadc, AXON2.imps.adc=adcs; end
                        if metdac, AXON2.imps.dac=dacs; end
                        set(AXON2.handle,'UserData',AXON2);
                        protocol.prot(proto).AXON2.imps = AXON2.imps;
                    else
                        Error('Impedance needs valid amplifier');
                        break
                    end
    %
    % Define traces ======================================
    %
                case {'RecordSweep';'RecordTrace'}
                    [inputset, outputset, evaduur, evadisp, evashow, eeg] = EvaluateRecord(cmd, eeg, parms, outputset);
                    protocol.prot(proto).disp = evadisp;
                    protocol.prot(proto).show = evashow;
                    if ~Error, [axon.input(inputset).duur] = deal(evaduur); end
                case 'Laser'
                    oldlen = length(outputset);
                    [parms,dacduur] = ParseTijd(parms,'duur',1);
                    if isempty(dacduur), Error('Laser needs duur'); break; end
                    [parms,present] = ParseSpecial(parms,'Image');
                    if present
                        addset = find(strcmp({axon.output.name},'Image'));
                        if isempty(addset)
                            Error('Image channel is not defined');
                            return
                        else
                            outputset = [outputset addset];
                            axon.output(addset).type = 'Image';
                            axon.output(addset).duur = dacduur;
                        end
                    end
                    [parms,present,ps] = ParseSpecial(parms,'Blue');
                    if present
                        addset = find(strcmp({axon.output.name},'Blue'));
                        if length(addset)<2, Error('Blue laser not (correctly) defined'); break; else
                            outputset = [outputset addset];
                            axon.output(addset(1)).type = 'Blue';
                            axon.output(addset(1)).text = ssingle(ps{1});
                            axon.output(addset(1)).duur = dacduur;
                            axon.output(addset(2)).type = 'Blue';
                            axon.output(addset(2)).duur = dacduur;
                        end
                    end
                    [parms,present,ps] = ParseSpecial(parms,'Yellow');
                    if present
                        addset = find(strcmp({axon.output.name},'Yellow'));
                        if length(addset)<2, Error('Yellow laser not (correctly) defined'); break; else
                            outputset = [outputset addset];
                            axon.output(addset(1)).type = 'Yellow';
                            axon.output(addset(1)).text = ssingle(ps{1});
                            axon.output(addset(1)).duur = dacduur;
                            axon.output(addset(2)).type = 'Yellow';
                            axon.output(addset(2)).duur = dacduur;
                        end
                    end
                    if oldlen==length(outputset), Error('Laser has no content'); end
                case 'MCC'
                    devnames = stringset(parms{1});
                    for jj = 1:length(devnames)
                        devnr = find(strcmp({axon.output.name},devnames{jj}));
                        protocol.prot(proto).mccchn = [protocol.prot(proto).mccchn axon.output(devnr(1)).mcc.chn];
                    end
                    values = rsingle(parms{2});
                    if length(values)==1, values = values + 0*protocol.prot(proto).mccchn; end
                    protocol.prot(proto).mccval = values;
                case 'Camera'
                    dacset = find(strcmp({axon.output.name},'Camera'));
                    if isempty(dacset)
                        Error('Camera not defined:');
                    else
                        [parms,modus] = ParseSpecial(parms,'Tellme');
                        panels.astrocam.ask = modus;
                        panels.astrocam.use = true;
                        outputset = unique([outputset dacset]);
                        [parms,axon.output(dacset(1)).duur] = ParseTijd(parms,'duur',1);
                        if isempty(axon.output(dacset(1)).duur), Error('Specify duur or Duration'); return; end
                        axon.output(dacset(1)).type = 'Stim';
                        axon.output(dacset(1)).text = parms{1};
                    end
                case 'Dynamic'
                    if isempty(DAQrbp), Error('You need USB-6009 to drive the Raspberry Pie'); return; end
                    name = ssingle(parms{1}); 
                    if     ~isempty(AXON1) && strcmp(AXON1.pars.name,name), AXON = AXON1; whichamp = 'AXON1';
                    elseif ~isempty(AXON2) && strcmp(AXON2.pars.name,name), AXON = AXON2; whichamp = 'AXON2';
                    else
                        Error(sprintf('%s is not a valid amplifier',name)); break;
                    end
                    [parms,present,ps] = ParseSpecial(parms,'soft');
                    if present
                        AXON.pars.Vsoft = rsingle(ps{1});
                        KnobRed(AXON.soft);
                        set(AXON.Vsoft,'String',sprintf('%0.1f',AXON.pars.Vsoft));
                        set(AXON.handle,'UserData',AXON);
                    end
                    [parms,present,ps] = ParseSpecial(parms,'use');
                    if present
                        state = [~isempty(find(strcmp(ps,'IK'),1)),...
                                 ~isempty(find(strcmp(ps,'IA'),1)),...
                                 ~isempty(find(strcmp(ps,'IC'),1)),...
                                 ~isempty(find(strcmp(ps,'IH'),1))];
                    else
                        state = [];
                    end
                    [parms,present,ps] = ParseSpecial(parms,'IK'); if present, IK = rsingle(ps{1}); else, IK = NaN; end
                    [parms,present,ps] = ParseSpecial(parms,'IA'); if present, IA = rsingle(ps{1}); else, IA = NaN; end
                    [parms,present,ps] = ParseSpecial(parms,'IC'); if present, IC = rsingle(ps{1}); else, IC = NaN; end
                    [parms,present,ps] = ParseSpecial(parms,'IH'); if present, IH = rsingle(ps{1}); else, IH = NaN; end
                    maxlen = max([length(IK),length(IA),length(IC),length(IH)]);
                    clampamp = NaN(4,maxlen);
                    if length(IK)==maxlen, clampamp(1,:) = IK; else
                        if length(IK)==1, clampamp(1,:) = repmat(IK,1,maxlen); else, Error(sprintf('IK must be 1 or %u long', maxlen)); break; end
                    end
                    if length(IA)==maxlen, clampamp(2,:) = IA; else
                        if length(IA)==1, clampamp(2,:) = repmat(IA,1,maxlen); else, Error(sprintf('IA must be 1 or %u long', maxlen)); break; end
                    end
                    if length(IC)==maxlen, clampamp(3,:) = IC; else
                        if length(IC)==1, clampamp(3,:) = repmat(IC,1,maxlen); else, Error(sprintf('IC must be 1 or %u long', maxlen)); break; end
                    end
                    if length(IH)==maxlen, clampamp(4,:) = IH; else
                        if length(IH)==1, clampamp(4,:) = repmat(IH,1,maxlen); else, Error(sprintf('IH must be 1 or %u long', maxlen)); break; end
                    end
                    if strcmp(whichamp,'AXON1')
                        clamp1 = clampamp;
                        state1 = state;
                    else
                        clamp2 = clampamp; 
                        state2 = state;
                    end
                case {'Puls';'Stim';'Wave';'TTL'}
                    [parms,present,ps] = ParseSpecial(parms,'veldamp');
                    if present
                        EP = getPANEL('EPpanel');
                        EP.fld.amp = rsingle(ps{1});
                        EP.fld.on  = true;
                        set(EP.handle,'UserData',EP);
                    end
                    [parms,eldacs] = ParseSpecial(parms,'Electrodes');
                    devname = ssingle(parms{1});
                    dacset = find(strcmp({axon.output.name},devname));
                    if eldacs
                        eldacs = dacset;
                    end
                    if isempty(dacset)
                        Error(sprintf('Device %s not defined:',devname));
                    else
                        outputset = unique([outputset dacset]);
                        axon.output(dacset(1)).type = cmd;
                        dacset = dacset(1);
                        [parms,axon.output(dacset).duur] = ParseTijd(parms,'duur',1);
                        if isempty(axon.output(dacset).duur), Error('Specify duur or Duration'); break; end
                        if length(parms)>1, axon.output(dacset).text = ssingle(parms{2}); end
                        [~,present1] = ParseSpecial(axon.output(dacset).parms,'Stimulus');
                        [~,present2] = ParseSpecial(parms,'Stimulus');
                        if present1 && present2
                            axon.output(dacset).parms = ParseSpecial(axon.output(dacset).parms,'Stimulus');
                        end
                        hlp = [];
                        cnt = 0;
                        for jj=1:length(axon.output(dacset).parms)
                            cnt = cnt + 1;
                            hlp{cnt} = axon.output(dacset).parms{jj};
                        end
                        for jj=3:length(parms)
                            cnt = cnt + 1;
                            hlp{cnt} = parms{jj};
                        end
                        axon.output(dacset).parms = hlp;
                    end
    %-- Overwrite defaultts
                case 'Beep',    if isempty(parms), protocol.prot(proto).beeps = 2; else,protocol.prot(proto).beeps = nsingle(parms{1}); end    
                case 'Clear',	WindowClear(parms);
                case 'Timescale',Timescale(CMD,ssingle(parms{1}));
                case {'Samplerate';'ADCrate';'DACrate'}
                    hlp = rsingle(parms{1});
                    if ~strcmp(cmd,'DACrate')
                        protocol.prot(proto).adcrate = hlp(1);
                    end
                    if ~strcmp(cmd,'ADCrate')
                        if length(hlp)==1, hlp(2) = hlp; end
                        protocol.prot(proto).dacrate = hlp(2);
                    end
                case 'GenPlotter'
                    protocol.prot(proto).plotters = protocol.plot;
                case 'Plotter'
                    protocol.prot(proto).plotters(end+1).window = nsingle(parms{1});
                    protocol.prot(proto).plotters(end).mode     = ssingle(parms{2});
                case 'SwpInterval'
                    [~,hlp] = ParseTijd({cmdstr},'SwpInterval',1000);
                    if (hlp(1)>0) &&(hlp(1)<0.010), Error('Most likely you mean Swp seconds, not ms?'); return; end
                    interval1 = hlp(1);
                    if length(hlp)>1
                        interval2 = hlp(2);
                    else
                        interval2 = 0;
                    end
                otherwise
                    Error(sprintf('Unknown command in Protocol :\n%s',cmd));
            end
            if Error, return; end
        end
        if Error, return; end
    end
    if Error, return; end
    if isempty(protocol.prot(proto).newname)
        naam1 = char(protocol.prot(proto).name);
    else
        naam1 = protocol.prot(proto).newname;
    end
    naam2 = sprintf('%s-%03u',naam1,1);
    ExpMeting = MetingIni(ExpMeting,naam1,naam2);
    protocol.prot(proto).bgn = length(ExpMeting);
    ExpMeting = MakeDACs(ExpMeting,protocol.prot(proto),inputset,outputset,makereal);
    if (size(clamp1,2)>0) || (size(clamp1,2)>0)
        len1 = size(clamp1,2);
        len2 = size(clamp2,2);
        if     (len1>0) && (len1<len2), clamp1 = repmat(clamp1,1,len2);
        elseif (len2>0) && (len2<len1), clamp2 = repmat(clamp2,1,len1); end
        metlen = length(ExpMeting);
        for jj = 1:max(len1,len2)
            for jjj = 1:metlen
                if jj>1,   ExpMeting((jj-1)*metlen+jjj) = ExpMeting((jj-2)*metlen+jjj); end
                if len1>0
                    ExpMeting((jj-1)*metlen+jjj).EXTRA.AXON1.clamp = clamp1(:,jj)'; 
                    ExpMeting((jj-1)*metlen+jjj).EXTRA.AXON1.state = state1;
                end
                if len2>0
                    ExpMeting((jj-1)*metlen+jjj).EXTRA.AXON2.clamp = clamp2(:,jj)';
                    ExpMeting((jj-1)*metlen+jjj).EXTRA.AXON2.state = state2;
                end
            end
        end
    end
    if Error, return; end
    protocol.prot(proto).lst = length(ExpMeting);
    interval = interval1 * length(find([protocol.prot.order]==protocol.prot(proto).order));
    if ~isempty(protocol.reset)
        starttijd = protocol.reset;
    elseif protocol.prot(proto).serie<2
        starttijd = protocol.eind; 
    else
        starttijd = protocol.start+interval1;
    end
    avgc = protocol.prot(proto).avgcnt;
    tijdmax   = 0;
    numtraces = protocol.prot(proto).lst-protocol.prot(proto).bgn+1;
    for jj = 1:numtraces
        nr = protocol.prot(proto).bgn + jj - 1;
        switch protocol.prot(proto).avgmode
            case 0, tijd = starttijd + (jj-1) * interval;
            case 1, tijd = starttijd + interval * (jj-1) * avgc + interval * (0:avgc-1);
            case 2, tijd = starttijd + interval * (jj-1) + numtraces *interval * (0:avgc-1); 
        end
        if isempty(ExpMeting(nr).adc) && isempty(ExpMeting(nr).dac)
            Error(sprintf('Meting %u has no adc and no dac',nr));
        end
        ExpMeting(nr).reltime = tijd;
        tijdmax = max([tijdmax tijd]);
    end
    if ~isempty(electrodes)
        bgn = protocol.prot(proto).bgn;
        lst = bgn + numtraces - 1;
        numel  = length(electrodes);
        denaam = ExpMeting(bgn).serienaam;
        if numtraces>1
            if length(ExpMeting(bgn).reltime)==1
                interval = (ExpMeting(bgn+1).reltime - ExpMeting(bgn).reltime);
            else
                interval = min([ExpMeting(bgn+1).reltime(1) - ExpMeting(bgn).reltime(1),...
                                ExpMeting(bgn).reltime(2)- ExpMeting(bgn).reltime(1)]);
            end
        end
        for jj2 = 2:numel
            ExpMeting(end+(1:numtraces)) = ExpMeting(bgn:lst);
        end
        for jj2 = 1:numel
            if iscell(electrodes)
                elset = electrodes{jj2};
                elnam = jj2;
            else
                elset = electrodes(jj2);
                elnam = elset;
            end
            for met = bgn:lst
                ExpMeting(met).serienaam = sprintf('%s-el-%02u',denaam, elnam);
                ExpMeting(met).reltime   = starttijd + numel * (ExpMeting(met).reltime-starttijd) + (jj2-1)*interval;
                ExpMeting(met).EXTRA.ELS.elec = elset;
                if groupdisplay
                    ExpMeting(met).EXTRA.ELS.grp = elset;
                else
                    ExpMeting(met).EXTRA.ELS.grp = [];
                end
                if ~isempty(eldacs) && ~iscell(electrodes)
                    gen = axon.SEA.sgn(elset)*(axon.SEA.max(elset) - axon.SEA.min(elset))/(EP.par.max(1) - EP.par.min(1));
                    off = axon.SEA.sgn(elset)*(axon.SEA.min(elset) - gen * EP.stim.min(1));
                    tmp = find(ExpMeting(met).dac(:,eldacs(1))~=0);
                    ExpMeting(met).dac(tmp,eldacs) = int16(round(off + gen * double(ExpMeting(met).dac(tmp,eldacs))));
                end
            end
            bgn = bgn + numtraces;
            lst = lst + numtraces;
            protocol.prot(proto).lst = protocol.prot(proto).lst + numtraces;
        end
        for met = 1:length(ExpMeting)
            if ~isempty(ExpMeting(met).EXTRA.ELS.elec)
                set(SEL.sth,'Value',0);
                for jjj = 1:length(ExpMeting(met).EXTRA.ELS.elec)
                    set(SEL.sth(ExpMeting(met).EXTRA.ELS.elec(jjj)),'Value',1);
                end
                Setrelais;
                break;
            end
        end
    end
    protocol.start = starttijd;
    protocol.eind  = max([ExpMeting.reltime]) + interval1 + interval2;
    if Error, return; end
end

function [parms,device] = getDAQnr(parms)
global DAQ
device = 1;
[parms,present,ps] = ParseSpecial(parms,'device');
if present && ~isempty(ps)
    if isnan(str2double(ps{1}))
        device = find(strcmp({DAQ.BoardName},ssingle(ps{1})));
        if isempty(device), Error(sprintf('device %s does not exist',ps{1})); end
    else
        device = nsingle(ps{1});
        if (device>length(DAQ))||(device<1)
            Error(sprintf('device %u does not exit',device));
        end
    end
end

function reset = Configuration
global DAQ protocol panels axon knobs p
CMD = getPANEL('CMDpanel'); 
reset = false;                                             % reset is to reset the ADCmode, otherwise use Error
adcmodes = cell(length(DAQ),1);
for jj = 1:length(DAQ)
    if strcmp(DAQ(jj).BoardName,'USB-6009')
        adcmodes{jj} = 'Differential';
    elseif ~isempty(DAQ(jj).adc)
        adcmodes{jj} = 'NonReferencedSingleEnded';
    end
end
if isempty(knobs.config)
    Error('You need a Configuration block'); return
else
    txtin = Conditional(knobs.config);
end
% set(handles.MCC_device,'String','MCC');
panels.inconfig = false;
p = [];
artpars  = [];
protocol = struct('adcrate',10000,'dacrate',10000,'reset',[],'start',0,'eind',0,'inter1',1,'inter2',0,'plot',[],'prot',[]);
panels.blankeron   = false;
axon.input   = [];
axon.output  = [];
axon.stim    = [];
commands = ParseSimple(txtin);
for mm = 1:length(commands)
    cmdstr = strtrim(commands{mm});
    if isempty(cmdstr), continue; end
    if contains(cmdstr,'=')
        assigncmd(cmdstr);
    else
        [cmd,parms]    = ParseCmd(cmdstr);
        [parms,device] = getDAQnr(parms);
        if Error, return; end
        switch cmd
            case 'Temperature'
            case 'Autohide',    set(CMD.autohide,'Value',getboolean(parms,true));
            case 'ADCmode',     modus =  ssingle(parms{1});
                                if isempty(strcmp({'SingleEnded';'Differential';'NonReferencedSingleEnded'},modus))
                                    Error(sprintf('%s is not a valid ADCmode',modus));
                                else
                                    adcmodes{device} = modus;
                                end
            case 'Artefact',	artpars = parms;
            case 'ADCoffset',   set(CMD.ADCseparatornum,'String',parms{1}); CMDscale(CMD,CMD.ADCseparatornum);
            case 'ADCgain',     set(CMD.ADCgainnum,'String',parms{1});      CMDscale(CMD,CMD.ADCgainnum)
            case 'DACoffset',   set(CMD.DACseparatornum,'String',parms{1}); CMDscale(CMD,CMD.DACseparatornum)
            case 'DACgain',     set(CMD.DACgainnum,'String',parms{1});      CMDscale(CMD,CMD.DACgainnum)
            case 'ADCscale',    for chn = nsingle(parms{1})
                                    DAQ(device).ADC.scale(chn).User  = rsingle(parms{2});
                                    DAQ(device).ADC.scale(chn).Units = ssingle(parms{3});
                                end
            case 'DACscale',    for chn = nsingle(parms{1})
                                    DAQ(device).DAC.scale(chn).User  = rsingle(parms{2});
                                    DAQ(device).DAC.scale(chn).Units = ssingle(parms{3});
                                end
            case 'Full',        status = getboolean(parms,true);
                                if status, setdaqpars(panels.zoom.tnul, panels.zoom.tend); end
                                CMD.autofull.Value = status;
            case 'Hide',        if getboolean(parms,true), CMD.macro.Visible = 'on'; else, CMD.macro.Visible = 'off'; end
            case 'Group',       CMD.group.Value = getboolean(parms,true);
            case 'AutoWrite',   status = getboolean(parms,true);
                                if status, txt = 'on'; else, txt = 'off'; end
                                CMD.Savedata.Visible = txt;
                                CMD.Autosave.Value = status;
            case {'Amplifier';...
                  'Orca'},      if DoAmplifier(cmd,parms,device), reset = true; return; end
            case 'Colormap',    eval(['colormap(' ssingle(parms{1}) ')']);
            case 'DevNames',    DoNames(parms,device);
                                set(CMD.group,'Value',1);
            case 'Filesystem',  prefix  = ssingle(parms{1});
                                set(CMD.Prefix,'String',prefix);
                                DD=round(clock); set(CMD.Filedate,'String',sprintf('%02u%02u%02u',DD(1)-2000,DD(2),DD(3)));
            case 'Rapp',        DoRapp(parms,device);
            case 'Stimulator',  DoStimulator(parms,device);
            case 'Stimulus',    axon.stim = StimulusRead(parms);
            case 'TriggerDefine',trg = ssingle(parms{1});
                                txt = {'PFI0';'PFI1';'PFI2';'PFI3';'PFI4';'PFI5';'PFI6';'PFI7'};
                                if strcmp(trg,DAQ(device).trg.Intbit)
                                    Error(sprintf('%s is already used internally',trg));
                                else
                                    if isempty(strmatch(trg,txt))
                                        Error(sprintf('%s not valid: use PFI0-PTI7',trg));
                                    elseif strcmp(trg,DAQ(device).trg.Intbit)
                                        Error(sprintf('%s is taken as internal triggerbit',trg));
                                    else
                                        DAQ(device).trg.Extbit = trg;
                                    end
                                end
            case 'TriggerStart',if isempty(DAQ(device).trg.Extbit)
                                    Error('External Trigger not defined');
                                else
                                    DAQ(device).trg.Trgbit = DAQ(device).trg.Extbit;
                end
%             case 'Veldcalib',   EP.stim.fldon  = false;
%                                 [parms,present,ps] = ParseSpecial (parms,'veldamp');
%                                 if present, field.ref = rsingle(ps{1}); field.amp = field.ref; end
%                                 [~,present,ps] = ParseSpecial (parms,'gain');
%                                 if present
%                                     field.gain  = rsingle(ps{1});
%                                 end
% --- parameters will be reset to these values in each protocol:
            case 'ADCrate',     protocol.adcrate = rsingle(parms{1});
            case 'DACrate',     protocol.dacrate = rsingle(parms{1});
            case 'Timescale',   Timescale(CMD,ssingle(parms{1}));
            case 'Samplerate',  protocol.adcrate = rsingle(parms{1});
                                if length(parms)>1
                                    protocol.dacrate = rsingle(parms{2});
                                else
                                    protocol.dacrate = protocol.adcrate;
                                end
            case 'SwpInterval', [~,hlp] = ParseTijd({cmdstr},'SwpInterval',1000);
                                if (hlp(1)>0) &&(hlp(1)<0.010)
                                    Error('Most likely you mean Swp seconds, not ms?');
                                else
                                    protocol.inter1 = hlp(1);
                                    if length(hlp)>1
                                        protocol.inter2 = hlp(2);
                                    else
                                        protocol.inter2 = 0;
                                    end
                                end
            case 'Plotter',     protocol.plot(end+1).window = nsingle(parms{1});
                                protocol.plot(end).mode     = ssingle(parms{2});
            otherwise
                Error(sprintf('Unknown in configuration:\n%s',cmd));
        end
    end
    if Error, return; end
end
if Error, return; end
for jj = 1:length(DAQ) 
    if ~isempty(DAQ(jj).adc)
        curmode = DAQ(jj).adc.InputType;
        DAQ(jj).adc.InputType = adcmodes{jj};
        if ~strcmp(curmode,adcmodes{jj}) && strcmp(adcmodes{jj},'Differential'), reset =true; return; end
    end
end
if ~isempty(artpars)
    [artpars,ldac,device,dacs] = ParseChans('dacs',artpars,device,'Stimulator');
    if addoutputdevice('Artefact','Artefact','',dacs(1),10), return; end
    artchan = length(axon.output);
	axon.output(artchan,1).type = 'Artefact';
    [artpars,present,ps] = ParseSpecial(artpars,'adcgain');
    if present, adcgain = rsingle(ps{1}); else, adcgain = 1; end   
    axon.output(artchan,1).maxval = round(0.5 * DAQ(axon.output(artchan,1).device).DAC.ints/adcgain);
    axon.output(artchan,1).parms = artpars;
	DAQ_DAC_scaling(dacs,10,'Artefact','V',0,'g');
end
panels.inconfig = true;
%
% For all measurement types
%
function reset = KnobMake
global panels DAQ knobs
Error("clear",'make knobs');
reset = false;
CMD = getPANEL('CMDpanel');
if panels.online
    txtin = get(CMD.protocol,'String');
    if isempty(txtin), return; end
    if strcmp(txtin,'Protocol'), Error('Measurement needs at least one Protocol'); return; end
else
    txtin = get(CMD.script,'String');
    if isempty(txtin), return; end
    if strcmp(txtin,'Script'), Error('Analysis needs at least one Script'); return; end
end
if ~iscell(txtin)
    for jj =1:size(txtin,1), script{jj} = strtrim(txtin(jj,:)); end
    txtin = script;
end
script = [];
for ii = 1:length(txtin)
    if ~isempty(txtin{ii}) && ~strcmp(txtin{ii}(1),'!')
        script = [script strtrim(strtok(txtin{ii},'!'))];
    end
end
kk = strfind(script,'$$');
if mod(length(kk),2), Error('$$ mismatch'); return; else
    for ii=length(kk):-2:1, script = [strtrim(script(1:kk(ii-1)-1)) strtrim(script(kk(ii)+2:end))]; end
end
if ~syntax(script), return; end
knobs = struct('config',[],'init',[],'macrocmd',[],'macropar',[],'macrotxt',[],'macromod',[],...
                                     'knobhan',[], 'knobcmd',[], 'knobtxt',[], 'knobmod',[]);
kk1 = strfind(script,'{');
kk2 = [0 strfind(script,'}')];
for ii = 1:length(kk1)
    cmdtxt = strtrim(script((kk1(ii)+1):(kk2(ii+1)-1)));
    cmd    = strtrim(script((kk2(ii)+1):(kk1(ii)-1)));
    if strcmp(cmd,'Configuration')
        knobs.config = cmdtxt;
        if Configuration, return; end
    elseif strcmp(cmd,'Initialize')
        knobs.init = cmdtxt;
    end
end
macronr = 0;
knobnr  = 0;
PANEL = getPANEL('AXON1'); if ~isempty(PANEL), modeA = PANEL.pars.mode; else, modeA = 'NN'; end
PANEL = getPANEL('AXON2'); if ~isempty(PANEL), modeB = PANEL.pars.mode; else, modeB = 'NN'; end

for ii = 1:length(kk1)
    cmdtxt = strtrim(script((kk1(ii)+1):(kk2(ii+1)-1)));
    [cmd,parms] = ParseCmd(strtrim(script((kk2(ii)+1):(kk1(ii)-1) )));
    if strcmp(cmd,'Configuration') || strcmp(cmd,'Initialize')
    elseif contains(cmd,'Experiment')
        [~,mode1,mode2,metdash] = ParseDash(cmd);
        if metdash
            if                         ~strcmp(mode1,modeA), continue; end
            if ~strcmp(mode2,'NN') &&  ~strcmp(mode2,modeB), continue; end
        end
        exparms = ParseSimple(cmdtxt);
        if length(exparms)<2
            Error('Experiment needs commands');
            return;
        end
        data.parms = exparms(2:end);
        knobnr = knobnr + 1;
        mm = strfind(cmdtxt,',');
        knobs.knobcmd{knobnr,1} = Unquote(cmdtxt(1:mm(1)-1));
        knobs.knobtxt{knobnr,1} = cmdtxt(mm(1)+1:end);
        knobs.knobmod(knobnr,1) = 6;
        set(CMD.keys(knobnr),'Callback',{@run_exp},...
                             'BackgroundColor',panels.color.dark,...
                             'ForegroundColor',panels.color.red,...
                             'String',knobs.knobcmd{knobnr},...
                             'UserData',data,...
                             'Visible','on',...
                             'Tag','EXPERIMENT');
    elseif contains(cmd,'Protocol') || contains(cmd,'Script')
        [cmd,mode1,mode2,metdash] = ParseDash(cmd);
        if metdash
            if ~strcmp(mode1,modeA), continue; end
            if ~strcmp(mode2,'NN') &&  ~strcmp(mode2,modeB), continue; end
        end
        knobnr = knobnr + 1;
        mm = strfind(cmdtxt,',');
        if isempty(mm)
            knobs.knobcmd{knobnr,1} = '------------';
            knobs.knobtxt{knobnr,1} = '';
            knobs.knobmod(knobnr,1) = 0;
            set(CMD.keys(knobnr),'Callback','',...
                                 'BackgroundColor',panels.color.grey,...
                                 'ForegroundColor',panels.color.zwart,...
                                 'String',knobs.knobcmd{knobnr},...
                                 'UserData',[],...
                                 'Visible','on',...
                                 'Tag','');
        else
            knobs.knobcmd{knobnr,1} = Unquote(cmdtxt(1:mm(1)-1));
            knobs.knobtxt{knobnr,1} = cmdtxt(mm(1)+1:end);
            if contains(cmd,'Protocol')
                if isempty(DAQ), Error('No ADC devices'); return; end
                if contains(cmdtxt,'RecordTrace')
                    knobs.knobmod(knobnr,1) = 5;
                    tag = 'EEG';
                else
                    knobs.knobmod(knobnr,1) = 4;
                    tag = 'SWP';
                end
                set(CMD.keys(knobnr),'Callback',{@run_single},...
                                     'BackgroundColor',panels.color.grey,...
                                     'ForegroundColor',panels.color.zwart,...
                                     'String',knobs.knobcmd{knobnr},...
                                     'UserData','',...
                                     'Visible','on',...
                                     'Tag','SWP');
            else
                knobs.knobmod(knobnr,1) = 3;
                set(CMD.keys(knobnr),'Callback',{@run_script},...
                                     'BackgroundColor',panels.color.grey,...
                                     'ForegroundColor',panels.color.zwart,...
                                     'String',knobs.knobcmd{knobnr},...
                                     'UserData','',...
                                     'Visible','on',...
                                     'Tag','SCRIPT');
            end
        end
    else
        macronr = macronr + 1; 
        knobs.macrocmd{macronr,1} = cmd;
        knobs.macropar{macronr,1} = parms;
        knobs.macrotxt{macronr,1} = cmdtxt;
        if     contains(cmdtxt,'experiment'),  modus = 6;
        elseif contains(cmdtxt,'RecordTrace'), modus = 5;    
        elseif contains(cmdtxt,'RecordSweep') || contains(cmdtxt,'Stim'), modus = 4;  
        else, modus = 3; end
        knobs.macromod(macronr,1) = modus;
    end
end
set(CMD.keys(knobnr+1:end),"Visible","Off");
if panels.online
    for jj = 1:length(knobs.knobtxt)
        if knobs.knobmod(jj)==6
            data = CMD.keys(jj).UserData;
            ekey = [];
            for jjj = 1:length(data.parms)
                hhh = data.parms{jjj};
                tmp = ParseCmd(hhh);
                if strcmp(tmp,'experiment')
                	ekey{end+1,1} = data.parms{jjj};
                else
                    zoek = find(strcmp(knobs.macrocmd,tmp));
                    if isempty(zoek), Error(sprintf('%s is not usable in experiment',tmp)); return; end
                    [~,ppp] = ParseCmd(data.parms{jjj});
                    epars = knobs.macropar{zoek};
                    decmds = ParseSimple(knobs.macrotxt{zoek});
                    for iii = 1:length(decmds)
                        ekey{end+1,1} = decmds{iii};
                        for jjjj = 1:length(epars)
                            ekey{end} = strrep(ekey{end},epars{jjjj},ppp{jjjj});
                        end
                    end
                end
            end
            data.parms = ekey;
            CMD.keys(jj).UserData = data;
            accu = ekey{1};
            for jjj = 2:length(ekey), accu = [accu ',' ekey{jjj}]; end
            knobs.knobtxt{jj} = accu;
        end
    end
    hlp = find(knobs.macromod==3);
    if ~isempty(hlp)
        for jj = 1:length(hlp)
            hhparms = ParseSimple(knobs.macrotxt{hlp(jj)});
            hcmd    = ParseCmd(hhparms{1});
            demacro = find(strcmp(knobs.macrocmd,hcmd));
            if ~isempty(demacro)
                knobs.macromod(hlp(jj)) = knobs.macromod(demacro);
            end
        end
    end
    for jj = 1:length(knobs.knobcmd)    
        modus = unique(getprotocolmodus(['XYZXYZ(' knobs.knobtxt{jj} ')'],[],jj));
        if Error
            return
        elseif length(modus)>1
            modus = 6;
        elseif isempty(modus)
            modus = 0;
        end
        knobs.knobmod(jj) = modus;
        if modus==3, CMD.keys(jj).BackgroundColor = panels.color.wit; end
    end
end
drawnow;

function DAQini(CMD,soort)
global SWP EEG
Hlp = [];
Hlp.run    = 0;
Hlp.abort  = false;
Hlp.starttoc = [];
Hlp.maxtoc   = 0;
Hlp.teller   = 0;
Hlp.filename = '';
Hlp.segname  = '';
Hlp.dosave   = true;
Hlp.cycle    = inf;
Hlp.pltwin   = [];
Hlp.Meting   = [];
Hlp.backward = true;
Hlp.spectrum = [];
Hlp.video    = false;
Hlp.blok     = 0;
%
Hlp.adcbuf = [];
Hlp.adcall = [];
Hlp.adcloc = [];
Hlp.adcdev = [];
%
Hlp.dacbuf = [];
Hlp.dacall = [];
Hlp.dacloc = [];
Hlp.dacdev = [];
Hlp.dacusr = [];
Hlp.dacjun = [];
Hlp.dachld = [];
%
Hlp.trgext  = false;
Hlp.trgbits = [];
Hlp.trgdev  = [];
%
if strcmp(soort,'eeg')
Hlp.save     = get(CMD.Autosave,'Value');
    Hlp.maxwrite = 2520 * 1024 * 128;
    Hlp.total   = 0;
    Hlp.offset  = [];
    Hlp.cnt1    = 0;
    Hlp.cnt2    = 0;
    Hlp.cnt3    = 0;
    EEG = Hlp;
else
    SWP = Hlp;
end

function Meting = JunctionADC(Meting,range,swp)
junction = int16(round(Meting.ADC.ints*[Meting.ADC.scale.junction]./[Meting.ADC.scale.User]));
warning off 'MATLAB:intMathOverflow'
for jj=1:size(Meting.adc,2)
    if junction(jj)==0
        
    elseif isempty(swp) && isempty(range)
        Meting.adc(:,jj) = Meting.adc(:,jj)-junction(jj);
    elseif isempty(swp)
        Meting.adc(range,jj) = Meting.adc(range,jj)-junction(jj);
    elseif isempty(range)
        Meting.adc(:,jj,swp) = Meting.adc(:,jj,swp)-junction(jj);
    else
        Meting.adc(range,jj,swp) = Meting.adc(range,jj,swp)-junction(jj);
    end
end
warning on 'MATLAB:intMathOverflow'

function EXTtrigger(~,~)
global panels
Waitbar(CMD,'hide');
if panels.blankeron, Blanker('on'); end

function [HLP, fout] = TRGfind(soort,HLP,device)
global DAQ
fout = false;
if isempty(HLP.trgdev), HLP.trgdev = device; end
die = find([DAQ(HLP.trgdev).TRG.out.targetdev] == device);
if isempty(die)
    Error('Trigger connection missing');
    fout = true;
else
    HLP.trgbits = unique([HLP.trgbits,DAQ(HLP.trgdev).TRG.out(die).out]);
    if strcmp(soort,'adc')
        DAQ(device).adc.HwDigitalTriggerSource = DAQ(HLP.trgdev).TRG.out(die).targetbit;
    elseif strcmp(soort,'dac')
        DAQ(device).dac.HwDigitalTriggerSource = DAQ(HLP.trgdev).TRG.out(die).targetbit;
    end
end

function CameraStart(Meting)
global DAQ panels
panels.astrocam.use = false;
swdac  = find(strcmp({Meting(1).DAC.scale.Name},'Camera'));
numpls = 0;
for metnr = 1:length(Meting)
    [numpnt,numchan,numswp] = size(Meting(metnr).adc);
    numpls = numpls + numswp * length(find((Meting(metnr).dac(1:end-1,swdac)==0) & (Meting(metnr).dac(2:end,swdac)>0)));
end
if panels.astrocam.ask
    if strcmp(questdlg(sprintf('%u Orca triggers, hit start',numpls),'Imaging','Start','Cancel','Start'),'Cancel')
        Error('Measurement Canceled');
        return
    end
end
hwdac  = Meting(1).DAC.HWloc(swdac);
device = Meting(1).DAC.HWdev(swdac);
back   = double(Meting(1).dac(1,Meting(1).DAC.HWdev==device));
hwchns = cell2mat(DAQ(device).dac.Channel.HWchannel)+1;
holds = back;
holds(hwchns==hwdac) = Meting(1).DAC.ints/2;
putsample(DAQ(device).dac,back);
pause(0.005);
putsample(DAQ(device).dac,holds);
pause(0.005);
putsample(DAQ(device).dac,back);
pause(0.005);
%
%  --- TST metingen
%
function txt = ShowImpedance(Mets,ampnr) 
global panels
pnls = {'AXON1';'AXON2'};
if panels.online
    AXON = getPANEL(pnls{ampnr});
    imps = AXON.imps;
else
    imps = Mets.EXTRA.(pnls{ampnr}).imps;
end
txt  = sprintf('\n Vr: %7.1f mV\n Rm: %7.1f MOhm\n', imps.Vr,1/imps.gm);
if panels.online && imps.doavg
    for jj = 1:length(imps.avgs)
    	txt = sprintf('%s\n %8.1f',txt,1/imps.avgs(jj));
    end
end

function MakeImpedance(Mets,swpnr)
for amps = 1:2
    if amps==1, AXON = getPANEL('AXON1'); else, AXON = getPANEL('AXON2'); end
    if isempty(AXON) || ~AXON.imps.on, continue; end
    Mets = DACexpand(Mets);
    chan1 = find(Mets.ADC.HWloc==AXON.imps.adc,1,'first');
    chan2 = find(Mets.DAC.HWloc==AXON.imps.dac,1,'first');
    term1 = [];
    term2 = [];
    cnt = 0;
    for jj = 1:2:length(AXON.imps.times)
        cnt = cnt + 1;
        aa = 1+round(AXON.imps.times([jj,jj+1]) * Mets.ADC.rate / 1000);
        bb = 1+round(AXON.imps.times([jj,jj+1]) * Mets.DAC.rate / 1000);
        term1(cnt,1) = mean(double(Mets.adc(aa(1):aa(2),chan1,swpnr))) * (Mets.ADC.scale(chan1).User/Mets.ADC.ints);
        term2(cnt,1) = mean(double(Mets.dac(bb(1):bb(2),chan2)))       * (Mets.DAC.scale(chan2).User/Mets.DAC.ints);
    end
    if strcmp(Mets.ADC.scale(chan1).Units,'mV')
        xxx = term1;
        yyy = term2;
    else
        xxx = term2;
        yyy = term1;
    end
    if ~isempty(find(diff(xxx)~=0, 1))
        bbb = regress(yyy,[ones(size(xxx,1),1) xxx]);
        if bbb(2)~=0
            AXON.imps.gm = bbb(2)/1000;
            if AXON.imps.doavg
                AXON.imps.avgs(end+1,1) = AXON.imps.gm;
                AXON.imps.gm = mean(AXON.imps.avgs,1);
            end
            AXON.imps.Vr = -bbb(1)/bbb(2);
            set(AXON.gm,'String',sprintf('%0.0f',1/AXON.imps.gm ));
            set(AXON.Vr,'String',sprintf('%0.1f',AXON.imps.Vr));
        else
            set(AXON.gm,'String','inf');
            set(AXON.Vr,'String','NaN');
        end
    end
    set(AXON.handle,'UserData',AXON);
    Mets.EXTRA.AXON(amps).imps = AXON.imps;
end

function TSTdisplay(~,~)
global DAQ SWP Meting SEL graf
metnr = 1;
device = unique(SWP.adcdev);
warning off 'MATLAB:intConvertOverflow'
SWP.Meting(metnr).adc = int16(round(getdata(DAQ(device).adc)));
warning on 'MATLAB:intConvertOverflow'
SWP.Meting(metnr).abstime = DAQ(device).adc.InitialTriggerTime;
EP = getPANEL('EPpanel');
SWP.Meting(metnr) = JunctionADC(SWP.Meting(metnr),[],[]);
if ~isempty(EP) && get(EP.avg,'Value')
    SWP.Meting(metnr).EXTRA.MEAN.cnt = SWP.Meting(metnr).EXTRA.MEAN.cnt + 1;
    naver = SWP.Meting(metnr).EXTRA.MEAN.cnt;
    if naver == 1
        SWP.Meting(metnr).EXTRA.MEAN.Sy  = double(SWP.Meting(metnr).adc);
        SWP.Meting(metnr).EXTRA.MEAN.Syy = SWP.Meting(metnr).EXTRA.MEAN.Sy.^2;
        SWP.Meting(metnr).EXTRA.MEAN.avg = SWP.Meting(metnr).EXTRA.MEAN.Sy;
        SWP.Meting(metnr).EXTRA.MEAN.sem = 0*SWP.Meting(metnr).EXTRA.MEAN.avg;
        SWP.Meting(metnr).EXTRA.MEAN.missers = false(size(SWP.Meting(metnr).adc,3),1);
        SWP.Meting(metnr).EXTRA.MEAN.spikers = false(size(SWP.Meting(metnr).adc,3),1);
    else
        SWP.Meting(metnr).EXTRA.MEAN.Sy  = SWP.Meting(metnr).EXTRA.MEAN.Sy  + double(SWP.Meting(metnr).adc);
        SWP.Meting(metnr).EXTRA.MEAN.Syy = SWP.Meting(metnr).EXTRA.MEAN.Syy + double(SWP.Meting(metnr).adc).^2;
        SWP.Meting(metnr).EXTRA.MEAN.avg = SWP.Meting(metnr).EXTRA.MEAN.Sy / naver;
        SWP.Meting(metnr).EXTRA.MEAN.sem = realsqrt(abs((SWP.Meting(metnr).EXTRA.MEAN.Syy - ((SWP.Meting(metnr).EXTRA.MEAN.Sy.^2)/naver))/(naver*(naver-1))));
    end
    SWP.Meting(metnr).EXTRA.MEAN.aver = naver;
end
adcbasisgain  = power(10,get(CMD.ADCgain,'Value'));
adcseparation = (realpow(10,get(CMD.ADCseparator,'Value'))-0.01)/0.99;
dacbasisgain  = power(10,get(CMD.DACgain,'Value'));
dacseparation = (realpow(10,get(CMD.DACseparator,'Value'))-0.01)/0.99;
winhandles    = find([graf.eeg]);
MakeImpedance(SWP.Meting(metnr),1);
for kk = 1:length(winhandles) 
    set (gcbf,'CurrentAxes',winhandles(kk));
    gbuf = get(winhandles(kk),'UserData');
    if gbuf.impamp>0
        TextLeft(winhandles(kk), ShowImpedance(SWP.Meting(metnr),gbuf.impamp), 12);
    end
    numtrace = length(gbuf.handles.trace);
    if strcmp(gbuf.type,'adc')
        alltraces = 1:length(gbuf.handles.trace);
        vld = (alltraces>0);
        if ~isempty(SEL) && gbuf.useselect
            grps = find(strcmp(get(SEL.rch,'Visible'),'on')' & cell2mat(get(SEL.rch,'Value')')==1);
            set1 = cell2mat(get(SEL.chh,'Value')');
            chns = find(set1);
            vld = false(1,length(alltraces));
            for jj = 1:length(alltraces)
                grp    = gbuf.grp(jj);
                subgrp = gbuf.subgrp(jj);
                if ~isempty(find(grps==grp, 1)) && ~isempty(find(chns==subgrp, 1))
                    vld(jj) = true;
                end
            end
            notraces = alltraces(~vld);
            alltraces = alltraces(vld);
            if ~isempty(alltraces)
                adcseparation = (realpow(10,get(CMD.ADCseparator,'Value'))-0.01)/0.99;
                adcbasisgain  = power(10,get(CMD.ADCgain,'Value'));
                set([gbuf.handles.trace(alltraces) gbuf.handles.names(alltraces) gbuf.handles.nul(alltraces)],'Visible','on');
                set([gbuf.handles.trace(notraces) gbuf.handles.names(notraces) gbuf.handles.nul(notraces)],'Visible','off');
                if isempty(gbuf.yfixed)
                    lbuf = get(gbuf.handles.trace(alltraces(1)),'UserData');
                    symax = SWP.Meting(metnr).ADC.scale(alltraces(1)).User / abs(lbuf.yas.pltgain * adcbasisgain);
                else
                    symax = gbuf.yfixed;
                end
                symin = -symax - 2 * symax * adcseparation * (length(alltraces)-1);
                ylims = [symin symax];
                set(winhandles(kk),'YLim',ylims);
            end
        end
        if ~isempty(EP)
            keepon = get(EP.keep,'Value') && (~gbuf.keepon || ~isequal(gbuf.keepset,vld));
            keepof = ~get(EP.keep,'Value') && gbuf.keepon;
        end
        gbuf.keepset=vld;
        for jj=1:length(alltraces)
            tracenr = alltraces(jj);
            lbuf = get(gbuf.handles.trace(tracenr),'UserData');
            dev = SWP.Meting(metnr).ADC.HWdev(lbuf.wie.chn);
            chn = SWP.Meting(metnr).ADC.HWloc(lbuf.wie.chn);
            maxy = DAQ(dev).ADC.scale(chn).User / abs(lbuf.yas.pltgain * adcbasisgain);
            if maxy ~= lbuf.yas.scale(3)
                lbuf.yas.scale = [2 * maxy * (1-length(alltraces)) * adcseparation - maxy,...
                                  2 * maxy * adcseparation * (1-jj),...
                                  maxy];
                lbuf.yas.adcgain = SWP.Meting(metnr).ADC.scale(tracenr).User/SWP.Meting(metnr).ADC.ints;
                set(gbuf.handles.trace(tracenr),'UserData',lbuf);
                if (jj==1) && isempty(gbuf.yfixed)
                    gbuf.yscale = lbuf.yas.scale([1 3]);
                    set(winhandles(kk),'UserData',gbuf,'YLim',gbuf.yscale);
                end
            end
            if gbuf.useselect
                gain   = lbuf.yas.adcgain * symax / maxy;
                offset = 2 * maxy * adcseparation * (1-jj) * symax / maxy;
            else
                gain   = lbuf.yas.adcgain  * gbuf.yscale(2) / lbuf.yas.scale(3);
                offset = lbuf.yas.scale(2) * gbuf.yscale(2) / lbuf.yas.scale(3);
            end
            if offset~=unique(get(gbuf.handles.nul(tracenr),'YData'))
                set(gbuf.handles.nul(tracenr),'YData',offset*[1 1]);
                pos = get(gbuf.handles.names(tracenr),'Position');
                pos(2) = offset;
                set(gbuf.handles.names(tracenr),'Position',pos);
                if jj==1, TextYAS(handle,''); end
            end
            if ~isempty(gbuf.zero)
                offset = offset - gain * mean(double(SWP.Meting(metnr).adc(gbuf.zero(1):gbuf.zero(2),lbuf.wie.chn,1)));
            end
            set(gbuf.handles.trace(tracenr),'YData',offset + gain * double(squeeze(SWP.Meting(metnr).adc(lbuf.xas.idx(1):lbuf.xas.idx(3),lbuf.wie.chn,1))),'LineStyle','-');
        end
        if ~isempty(EP) && ( keepon || keepof)
            if isempty(gbuf.handles.keeps), gbuf.handles.keeps=zeros(length(gbuf.handles.trace),1); end
            for jj = 1:length(gbuf.handles.trace)
                if keepon && vld(jj)
                    if gbuf.handles.keeps(jj)>0
                        set(gbuf.handles.keeps(jj),'Visible','on',...
                            'XData', get(gbuf.handles.trace(jj),'XData'),...
                            'YData', get(gbuf.handles.trace(jj),'YData'));
                    else
                        gbuf.handles.keeps(jj) = line('Visible','on',...
                            'XData', get(gbuf.handles.trace(jj),'XData'),...
                            'YData', get(gbuf.handles.trace(jj),'YData'),...
                            'Color', get(gbuf.handles.trace(jj),'Color'),...
                            'LineStyle',':','Parent',winhandles(kk));
                    end
                elseif gbuf.handles.keeps(jj)>0
                    delete(gbuf.handles.keeps(jj));
                    gbuf.handles.keeps(jj) = 0;
                end
            end
            if keepon, gbuf.keepon = true; else, gbuf.keepon = false; end
        end
	elseif strcmp(gbuf.type,'dac')
        for jj=1:numtrace
            lbuf = get(gbuf.handles.trace(jj),'UserData');
            if (jj==1) && isempty(gbuf.yfixed)
                maxy = SWP.Meting(metnr).DAC.scale(lbuf.wie.chn).User / abs(lbuf.yas.pltgain * dacbasisgain);
                newscale = [2 * maxy * (1-numtrace) * dacseparation - maxy, 2 * maxy * dacseparation * (1-jj), maxy];
                if newscale(3) ~= lbuf.yas.scale(3)
                    lbuf.yas.scale = newscale;
                    gbuf.yscale = lbuf.yas.scale([1 3]);
                    set(gbuf.handles.trace(jj),'UserData',lbuf);
                    set(winhandles(kk),'YLim',gbuf.yscale,'UserData',gbuf);
                    TextYAS(handle,'');
                    for ii = 1:numtrace, set(gbuf.handles.nul(ii),'YData',2 * newscale(3) * adcseparation * (1-ii)*[1 1]); end
                end
            end
            offset = lbuf.yas.scale(2) * gbuf.yscale(2) / lbuf.yas.scale(3);
            gain   = lbuf.yas.adcgain  * gbuf.yscale(2) / lbuf.yas.scale(3);
            set(gbuf.handles.trace(jj),'YData',offset + gain * double(SWP.Meting(metnr).dac(:,lbuf.wie.chn)),'LineStyle','-');
        end
    end
    set(winhandles(kk),'UserData',gbuf);
end
if (SWP.Meting(1).EXTRA.Beep>1) && (SWP.cycle>0)
    DoMusic(SWP.Meting(1).EXTRA.Beep);
end
hhh = toc;
CMD_wait(sprintf('cycle %6.3f s',hhh-SWP.starttoc));
SWP.starttoc = hhh;
if SWP.abort
    Meting = SWP.Meting;
    keys = timerfind('Tag','TST');
    if ~isempty(keys)
        name = keys.name;
        stop(keys);
        delete(keys);
        clear name
    end
    if isrunning(DAQ(device).adc), stop(DAQ(device).adc); end
    if isrunning(DAQ(device).dac), stop(DAQ(device).dac); end
    set(CMD.Savedata,'Visible','on');
    KnobBlue(CMD.Savedata);
    CMD = getPANEL('CMDpanel');
    if get(CMD.autohide,'Value')
        CMDbasic(CMD,CMD.hide)
        KnobGrey(CMD.hide);
    end
    pnls = {'AXON1';'AXON2'};
    for jj=1:2
        AXON = getPANEL(pnls{jj});
        if ~isempty(AXON) && strcmp(AXON.pars.mode,'CC') && KnobIsBlue(AXON.soft)
            KnobRed(AXON.soft);
            AXON = DCUpdate(AXON,[1,0,0,0,0,0,0,0],[]);
        end
    end
    for device = unique(SWP.adcdev), if islogging(DAQ(device).adc), stop(DAQ(device).adc); end; end
	for device = unique(SWP.dacdev), if issending(DAQ(device).dac), stop(DAQ(device).dac); end; end
    DAQini(CMD,'swp');
end
keys = timerfind('Tag','TST');
if ~isempty(keys)
    cmd  = get(keys,'UserData');
    if cmd.single, start(keys); end
end

function TSTtimer(~,~)
global DAQ SWP panels axon
% MCC_put(SWP.Meting(1)); 
if isempty(SWP.starttoc), tic; end
SWP.starttoc = toc;
device = unique(SWP.adcdev);
metnr = 1;
next  = 1;
yy = SWP.Meting(metnr).dacr(:,:,next);
if SWP.factor(1) || SWP.factor(2), monvals = GetMonitor;  end
for jj = 1:2
    if SWP.factor(jj)
        if jj==1, name = 'AXON1'; else, name = 'AXON2'; end
        next = next + 1;
        AXON = getPANEL(name);
        channel = [SWP.Meting(metnr).ADC.HWchn]==AXON.pars.hadc(1);
        SWP.Meting(metnr).ADC.scale(channel).User = DAQ(axon.monitor).ADC.scale(AXON.monchn(1)).User;
        AXON = AxonMonitor(AXON,monvals(AXON.monchn));
        if get(AXON.ath,'Value')
            if strcmp(AXON.pars.mode,'VC')
                multi = AXON.pars.Vhold/100;
            elseif strcmp(AXON.pars.mode,'CC')
                multi = AXON.pars.Ihold/1000;
            end
            yy = yy + multi * SWP.Meting(metnr).dacr(:,:,next);
        end
    end
end
if SWP.factor(3) || SWP.factor(4)
    EP = getPANEL('EPpanel');
    if strcmp(get(EP.sign,'Visible'),'on') && KnobIsRed(EP.sign), teken = -1; else, teken = 1; end
    if SWP.factor(3)
        next = next + 1;
        yy = yy + SWP.Meting(metnr).dacr(:,:,next) * teken * EP.stim.amp(1)/EP.stim.full(1);
    end
    if SWP.factor(4)
        next = next + 1;
        yy = yy + SWP.Meting(metnr).dacr(:,:,next) * teken * EP.stim.amp(2)/EP.stim.full(2);
    end
end
junction = [SWP.Meting(metnr).DAC.scale.junction];
zz = yy;
for jj=1:size(yy,2)
    schaal = SWP.Meting(metnr).DAC.ints/SWP.Meting(metnr).DAC.scale(jj).User;
    yy(:,jj) = yy(:,jj) * schaal;
    if junction(jj)==0
        zz(:,jj) = yy(:,jj);
    else
        zz(:,jj) = yy(:,jj) + (junction(jj)*schaal);
    end
end
while isrunning(DAQ(device).dac), stop(DAQ(device).dac); end
putdata(DAQ(device).dac,zz);
DAQ(device).DAC.values = zz(end,:);
warning off 'MATLAB:intConvertOverflow'
SWP.Meting(metnr).dac = int16(round(yy));
warning on 'MATLAB:intConvertOverflow'
while ~isrunning(DAQ(SWP.adcdev(1)).adc), start(DAQ(SWP.adcdev(1)).adc); end
while ~isrunning(DAQ(SWP.adcdev(1)).dac), start(DAQ(SWP.adcdev(1)).dac); end
pause(panels.timer.delay);
writedigitalbits(SWP.trgdev,SWP.trgbits,1);
pause(panels.timer.delay);
writedigitalbits(SWP.trgdev,SWP.trgbits,0);

function TSTrun(hObject,cycle)
global panels knobs DAQ SWP swpcmd
if CheckRunning(hObject), SWP.abort = true; return; end
swpcmd = getcmd;
swpcmd.nodenr = 1;
ReporterStop;
protocolname = get(hObject,'String');
index = find(strcmp(knobs.macrocmd,protocolname));
if isempty(index), Error(sprintf('Protocol %s does not exits',protocolname)); return; end
DAQini(CMD,'swp');
Configuration;
if Error, return; end
addprotocol(['XYZXYZ(' knobs.macrocmd{index} ')'],0);
if Error, return; end
ScriptTxt = Conditional(char(knobs.macrotxt{index}));
if Error, return; end
KnobBlue(hObject);
CMD = getPANEL('CMDpanel');
set(CMD.autofull,'Value',1);
if get(CMD.autohide,'Value')
    KnobRed(CMD.hide);
    set(CMD.macro,'Visible','Off');
end
SWP.cycle = cycle;
SWP.factor = false(1,4);
SWP.nterm = 0;
s1 = [];
s2 = 0;
if contains(ScriptTxt,'Vh1') || contains(ScriptTxt,'Ih1')
    SWP.nterm = SWP.nterm + 1;
	if contains(ScriptTxt,'Vh1')
        s1{SWP.nterm,1} = 'Vh1';
        s2(SWP.nterm,SWP.nterm+1) = 100;
	else
        s1{SWP.nterm,1} = 'Ih1';
        s2(SWP.nterm,SWP.nterm+1) = 1000;
	end
    SWP.factor(1) = true;
end
if contains(ScriptTxt,'Vh2') || contains(ScriptTxt,'Ih2')
    SWP.nterm = SWP.nterm + 1;
    if contains(ScriptTxt,'Vh2')
        s1{SWP.nterm,1} = 'Vh2';
        s2(SWP.nterm,SWP.nterm+1) = 100;
    else
        s1{SWP.nterm,1} = 'Ih2';
        s2(SWP.nterm,SWP.nterm+1) = 1000;
    end
    SWP.factor(2) = true;
end
if contains(ScriptTxt,'Int1') || contains(ScriptTxt,'Int2')
    EP = getPANEL('EPpanel');
    if ~isempty(EP)
        if contains(ScriptTxt,'Int1')
            if isnan(EP.stim.full(1)), Error('Int1 is not linked to a slider'); return; end
            SWP.nterm = SWP.nterm + 1;
            s1{SWP.nterm,1} = 'Int1';
            s2(SWP.nterm,SWP.nterm+1) = EP.stim.full(1);
            SWP.factor(3) = true;
        end
        if contains(ScriptTxt,'Int2')
            if isnan(EP.stim.full(2)), Error('Int2 is not linked to a slider'); return; end
            SWP.nterm = SWP.nterm + 1;
            s1{SWP.nterm,1} = 'Int2';
            s2(SWP.nterm,SWP.nterm+1) = EP.stim.full(2);
            SWP.factor(4) = true;
        end
    end
end
for iii = 1:SWP.nterm
    ScriptTxt = strrep(ScriptTxt,s1{iii},['[' sprintf('%6.3f %6.3f %6.3f %6.3f %6.3f %6.3f %6.3f',s2(iii,:)) ']']);
end
SWP.Meting = Protocol_Generate(ScriptTxt,true);
if Error, return; end
adcdev = ADCinput (SWP.Meting(1).ADC.HWchn);
dacdev = DACoutput(SWP.Meting(1).DAC.HWchn);
for device = unique(adcdev), if islogging(DAQ(device).adc), stop(DAQ(device).adc); end; end
for device = unique(dacdev), if issending(DAQ(device).dac), stop(DAQ(device).dac); end; end
if isrunning(DAQ(device).adc), stop(DAQ(device).adc); end
if isrunning(DAQ(device).dac), stop(DAQ(device).dac); end
hlp = zeros([size(SWP.Meting(1).dac) length(SWP.Meting)]);
hlp(:,:,1) = SWP.Meting(1).dacr(:,:,1);
for iii = 2:length(SWP.Meting), hlp(:,:,iii) = SWP.Meting(iii).dacr(:,:,1)-hlp(:,:,1); end
SWP.Meting(1).dacr = hlp;
SWP.Meting(2:end)  = [];
adclen = size(SWP.Meting(1).adc,1);
SWP.trgdev  = [];
SWP.trgbits = [];
if adclen>0
    [SWP.adcdev,SWP.adcloc,SWP.adcall] = ADCinput(SWP.Meting(1).ADC.HWchn);
    SWP.adcbuf = zeros(adclen,length(SWP.adcall),'int16');
    device = unique(SWP.adcdev);
    if length(device)>1, Error('TST can only from single ADC'); return; end
    while islogging(DAQ(device).adc), disp('stop adc in TST'); stop(DAQ(device).adc); end
    if ADCchannels(device,SWP.adcloc(SWP.adcdev==device)), return; end
    DAQ(device).adc.SampleRate  = SetRate(device,'adc',SWP.Meting(1));
    if Error, return; end
    DAQ(device).adc.StartFcn    = [];
    DAQ(device).adc.StopFcn     = [];
    DAQ(device).adc.LoggingMode = 'Memory';
    DAQ(device).adc.ClockSource             = SWP.Meting(1).ADC.clocksource;
    DAQ(device).adc.ExternalScanClockSource = SWP.Meting(1).ADC.clocktrigger;
    DAQ(device).adc.SamplesAcquiredFcn  = {@TSTdisplay};
    DAQ(device).adc.SamplesAcquiredFcnCount = adclen;
    DAQ(device).adc.TriggerFcn        = [];
    DAQ(device).adc.TriggerType       = 'HwDigital';
    DAQ(device).adc.TriggerCondition  = 'NegativeEdge';
    DAQ(device).adc.SamplesPerTrigger = adclen;
    [SWP,fout] = TRGfind('adc',SWP,device);
    if fout, return; end
end
daclen = size(SWP.Meting(1).dacr,1);
if daclen>0
    [SWP.dacdev,SWP.dacloc,SWP.dacall] = DACoutput(SWP.Meting(1).DAC.HWchn);
    SWP.dacbuf = zeros(daclen,length(SWP.dacall));
    device = unique(SWP.dacdev);
    if length(device)>1, Error('TST can only run from single DAC'); return; end
    if length(unique([SWP.adcdev SWP.dacdev]))>1, Error('TST needs ADC & DAC on same device'); return; end
    while issending(DAQ(device).dac), disp('stop dac in TST'); stop(DAQ(device).dac); end
    DACchannels(device,SWP.dacloc(SWP.dacdev==device));
    DAQ(device).dac.SampleRate = SetRate(device,'dac',SWP.Meting(1));
    if Error, return; end
    DAQ(device).dac.RepeatOutput = 0;
    DAQ(device).dac.StartFcn     = [];
    DAQ(device).dac.StopFcn      = [];
    DAQ(device).dac.SamplesOutputFcn      = [];
    DAQ(device).dac.SamplesOutputFcnCount = daclen;
    DAQ(device).dac.TriggerFcn            = [];
    DAQ(device).dac.TriggerType           = 'HwDigital';
    [SWP,fout] = TRGfind('dac',SWP,device);
    if fout, return; end
end
writedigitalbits(SWP.trgdev,SWP.trgbits,1);
NRNtimeline;
panels.NRNbusy  = false;
panels.NRNabort = false;
panels.plotter = SWP.Meting(1).plotter;
for jj = 1:length(panels.plotter)
    panels.plotter(jj).metnr = 1;
    panels.plotter(jj).subnr = 1;
end
NRNshow(SWP.Meting,-2);
if SWP.cycle==0
    cmd.single = true;
    tsttimers = timer('TimerFcn',     {@TSTtimer},...
                     'ExecutionMode','singleShot',...
                     'BusyMode',     'queue',...
                     'Name',         'TST-Timer',...
                     'Tag',          'TST',...
                     'Period',       0.001,...
                     'UserData',     cmd,...
                     'Startdelay',   panels.timer.delay);
else
    cmd.single = false;
    tsttimers = timer('TimerFcn',     {@TSTtimer},...
                     'ExecutionMode','fixedRate',...
                     'BusyMode',     'drop',...
                     'Name',         'TST-Timer',...
                     'Tag',          'TST',...
                     'Period',       SWP.cycle,...
                     'UserData',     cmd,...
                     'Startdelay',   panels.timer.delay);
end
for jj=1:2
    if jj==1, AXON = getPANEL('AXON1'); else, AXON = getPANEL('AXON2'); end
    if ~isempty(AXON) && strcmp(AXON.pars.mode,'CC')
        KnobGrey([AXON.dyna,AXON.IKon,AXON.IAon,AXON.ICon,AXON.IHon,]);
        if KnobIsRed(AXON.soft), KnobBlue(AXON.soft); end
        AXON = DCUpdate(AXON,[1,1,0,0,0,0,0,0],[]);
        set(AXON.handle,'UserData',AXON);
    end
end
tic
start(tsttimers); 
%
% ====== Sweeps metingen  ============================================
%
function DACbufferFill(metnr)
global SWP
SWP.dacbuf = zeros(size(SWP.Meting(metnr).dac,1),length(SWP.dacall));
for jj = 1:length(SWP.dacdev)
    die    = find(SWP.Meting(metnr).DAC.HWchn==SWP.dacall(jj));
    schaal = SWP.Meting(metnr).DAC.ints/SWP.dacusr(jj);
    if isempty(die)
        SWP.dacbuf(:,jj) =  schaal * (SWP.dachld(jj)   +  SWP.dacjun(jj));
    else
        SWP.dacbuf(:,jj) = (schaal * (SWP.dacjun(jj))) +  double(SWP.Meting(metnr).dac(:,die));
    end
end

function SWParm
global DAQ panels SEL SWP swpcmd
ArmDynamic;
devs = [];
adclen = size(SWP.Meting(swpcmd.arm).adc,1);
fraction = SWP.Meting(swpcmd.arm).EXTRA.show;
if ~isempty(SWP.Meting(swpcmd.arm).EXTRA.ELS.elec)
    set(SEL.sth,'Value',0);
    hlp = SWP.Meting(swpcmd.arm).EXTRA.ELS.elec;
    for jj = 1:length(hlp), set(SEL.sth(hlp(jj)),'Value',1); end
    Setrelais;
end
first2draw = true;
SWP.teller = 0;
if adclen>0
    for device = unique(SWP.adcdev)
        if isrunning(DAQ(device).adc), disp('stop SWP adc'); stop(DAQ(device).adc); end
        DAQ(device).adc.SampleRate = SetRate(device,'adc',SWP.Meting(swpcmd.arm));
        if Error("box"), return; end
        DAQ(device).adc.SamplesPerTrigger       = adclen;
        DAQ(device).adc.SamplesAcquiredFcnCount = adclen/fraction;
        if first2draw
            DAQ(device).adc.SamplesAcquiredFcn = {@SWPdisplay};
            first2draw = false;
        end
        devs = [devs DAQ(device).adc];
    end
end
daclen = size(SWP.Meting(swpcmd.arm).dac,1);
if daclen>0
    DACbufferFill(swpcmd.arm); 
    for device = unique(SWP.dacdev)
        if isrunning(DAQ(device).dac)
            fprintf('stop SWP dac %u\n',device);
            stop(DAQ(device).dac);
        end
        DAQ(device).dac.SampleRate = SetRate(device,'dac',SWP.Meting(swpcmd.arm));
        if Error("box"), return; end
        DAQ(device).dac.SamplesOutputFcnCount  = daclen;
        if first2draw
            DAQ(device).dac.SamplesOutputFcn = {@SWPdisplay};
            first2draw = false;
        end
        chansel = find(SWP.dacdev==device);
        putdata(DAQ(device).dac,SWP.dacbuf(:,chansel));
        DAQ(device).DAC.values = SWP.dacbuf(end,chansel);
        devs = [devs DAQ(device).dac];
    end
end
start(devs);
pause(panels.timer.delay);

function SWPdisplay(~,~)
global DAQ SWP panels SEL graf swpcmd
tt1   = toc-SWP.starttoc;
metnr = swpcmd.nodenr;
swpnr = swpcmd.swpnr;
Error("line",sprintf('SWPdisplay  %s  meting: %u', swpcmd.protocol, metnr));
SWP.teller = SWP.teller + 1;
swplocal   = SWP.teller;
adclen     = size(SWP.Meting(metnr).adc,1);
fraction   = SWP.Meting(metnr).EXTRA.show;
if adclen>0
    adcbuf = zeros(adclen/fraction,length(SWP.adcall),'int16');
    chanoff = 0;
    for device = unique(SWP.adcdev)
        numchan = length(find(SWP.adcdev==device));
        warning off 'MATLAB:intConvertOverflow'
        adcbuf(:,chanoff+(1:numchan)) = int16(round(getdata(DAQ(device).adc,adclen/fraction)));
        warning on 'MATLAB:intConvertOverflow'
        chanoff = chanoff + numchan;
    end
    SWP.Meting(metnr).abstime = datenum(DAQ(SWP.trgdev).adc.InitialTriggerTime);
end
if ~SWP.abort && (swplocal>=fraction) && (swpcmd.arm>0), SWParm; end
writedigitalbits(SWP.trgdev,SWP.trgbits,1);
tt2 = toc-SWP.starttoc;
if ~isempty(SWP.Meting(metnr).EXTRA.ELS.grp)
    set(SEL.rch(1:end),'Value',0);
    hlp = SWP.Meting(metnr).EXTRA.ELS.grp;
    for jj = 1:length(hlp), set(SEL.rch(hlp(jj)),'Value',1); end   
end
if (adclen>0) || ~isempty(SWP.Meting(metnr).dac)
    if adclen>0
        [~,adcchan] = ismember(SWP.Meting(metnr).ADC.HWchn,SWP.adcall);
        bgn = 1 + (swplocal-1) * adclen/fraction;
        lst = swplocal * adclen/fraction;
        if size(SWP.Meting(metnr).adc,3)>1
            deswp = swpnr;
            SWP.Meting(metnr).adc(bgn:lst,:,swpnr) = adcbuf(:,adcchan);
        else
            deswp = [];
            SWP.Meting(metnr).adc(bgn:lst,:) = adcbuf(:,adcchan);
        end
        SWP.Meting(metnr) = JunctionADC(SWP.Meting(metnr),bgn:lst,deswp);
    end
%     if ~isempty(SWP.Meting(metnr).EXTRA.MCC.chn), MCC_show(handles,3); end
    if panels.blankeron, Blanker('off'); end
    slen = SWP.Meting(metnr).EXTRA.show;
    stuk = slen/SWP.Meting(metnr).EXTRA.disp;
    if swplocal==1
        panels.NRNabort = false; 
        panels.NRNbusy  = false;
        SWP.Meting(metnr).EXTRA.MEAN.cnt = swpnr;
        MakeImpedance(SWP.Meting(metnr),swpnr);
        if ~isempty(SWP.Meting(metnr).plotter)
            panels.plotter = SWP.Meting(metnr).plotter;
            for jj = 1:length(panels.plotter)
                if (stuk<slen) &&  (~isempty(strfind(panels.plotter(jj).mode,'swp')) || ~isempty(strfind(panels.plotter(jj).mode,'adc')))
                    panels.plotter(jj).mode = [panels.plotter(jj).mode sprintf('/scale(x(%0.0f,%0.0f))',0,stuk*adclen*1000/(slen*SWP.Meting(metnr).ADC.rate))];
                end
                panels.plotter(jj).metnr = metnr;
                panels.plotter(jj).subnr = swpnr;
            end
            NRNshow(SWP.Meting,2);
        end
    else
        for jj = 1:length([graf.window])
            graf(jj).swp = ismember(graf(jj).window,[SWP.Meting(metnr).plotter.window]);
        end
        winhandles = graf(graf.swp>0).handle;
        for kk = 1:length(winhandles)
            gbuf = get(winhandles(kk),'UserData');
            if strcmp(gbuf.type,'adc') || strcmp(gbuf.type,'swp')
                newgain = power(10,get(CMD.ADCgain,'Value'))/gbuf.adcbasisgain;
                for jj = 1:length(gbuf.handles.trace)
                    lbuf = get(gbuf.handles.trace(jj),'UserData');
                    if isempty(gbuf.zero)
                        tracezero = 0;
                    else
                        tracezero = mean(double(squeeze(SWP.Meting(metnr).adc(gbuf.zero(1):gbuf.zero(2),lbuf.wie.chn,swpnr))));
                    end
                    gain   = newgain*lbuf.yas.adcgain  * gbuf.yscale(2) / lbuf.yas.scale(3);
                    offset = lbuf.yas.scale(2) * gbuf.yscale(2) / lbuf.yas.scale(3);
                    tt = lbuf.xas.idx;
                    if SWP.teller>stuk
                        tduur = tt(3)-tt(1);
                        tt(3) = SWP.teller*tt(3)/stuk;
                        tt(1) = tt(3)-tduur;
                    end
                    set(gbuf.handles.trace(jj),...
                        'YData',offset + gain * (double(squeeze(SWP.Meting(metnr).adc(tt(1):tt(2):tt(3),lbuf.wie.chn,swpnr))) - tracezero));
                end
            elseif strcmp(gbuf.type,'dac')
                xlims = get(winhandles(kk),'XLim');
                set(gbuf.handles.vline,'Xdata',[1 1] * (xlims(1) + (xlims(2)-xlims(1))*swplocal/slen ),'Ydata',get(winhandles(kk),'YLim'));
            end
        end
    end
end
tt3 = toc-SWP.starttoc;
SWP.maxtoc = max(SWP.maxtoc,tt3);
CMD_wait(sprintf('%0.2f  %0.2f  %0.3f  (%0.3f)',tt1,tt2,tt3,SWP.maxtoc));
if (swplocal<fraction), return; end
if SWP.abort || (swpcmd.arm==0), SWPend; end
SWP.run = 0;

function SWPend
global panels DAQ SWP swpcmd
if panels.blankeron, Blanker('off'); end
KnobBlue(CMD.Savedata);
if ~SWP.abort
    if swpcmd.autosavemode
        SaveNeuron(SWP.Meting,SWP.filename,CMD);
    elseif ~panels.neversave
        set(CMD.Savedata,'Visible','on');
    end
end
CopyMeting(SWP.Meting);
metnr = swpcmd.nodenr;
for jj = swpcmd.dynamic
    if jj==1; name = 'AXON1'; else, name = 'AXON2';  end;
    if ~isempty(swpcmd.(name).handle)
        AXON = get(swpcmd.(name).handle,'UserData');
        AXON = DCUpdate(AXON,swpcmd.(name).T3,[]);
        DCstate(AXON,swpcmd.(name).T3)
    end
end
geel = KnobIsYellow(swpcmd.startkey); 
if ~geel || swpcmd.explst
    if geel, KnobDark(swpcmd.startkey);else, KnobGrey(swpcmd.startkey);  end
    if SWP.Meting(metnr).EXTRA.Beep>1, DoMusic(SWP.Meting(metnr).EXTRA.Beep); end
    CMD = getPANEL('CMDpanel');
    if get(CMD.autohide,'Value')
        KnobGrey(CMD.hide);
        set(CMD.macro,'Visible','On');
    end
end
for device = unique(SWP.adcdev), if islogging(DAQ(device).adc), stop(DAQ(device).adc); end; end
for device = unique(SWP.dacdev), if issending(DAQ(device).dac), stop(DAQ(device).dac); end; end
DAQini(CMD,'swp');
SWP.run = 0;

function SWPtimer(hObject,~)
global DAQrbp SWP swpcmd
cmd = get(hObject,'UserData');
Error("line",sprintf('Timer  %s  starting: %u', cmd.protocol, cmd.nodenr));
for jj = cmd.dynamic
    if jj==1; name = 'AXON1'; else, name = 'AXON2';  end
    AXON = get(cmd.(name).handle,'UserData'); 
    if isempty(cmd.(name).T1)
        if jj==1, disp(sprintf('%s.T1:    trigger: %+2u  no RPI command', name, cmd.nodenr)); end
    else
        putvalue(DAQrbp(AXON.rbp).DIO.outlines, cmd.(name).T1);
        DCstate(AXON,cmd.(name).T1)
        if jj==1, disp(sprintf('%s.T1:    trigger: %+2u    RPi mode: %u %u %u', name, cmd.nodenr,cmd.(name).T1(1:3))); end
    end
end
if readbackdigital(SWP.trgdev,SWP.trgbits)
    swpcmd = cmd;
    SWP.starttoc = toc;
    writedigitalbits(SWP.trgdev,SWP.trgbits,0);
    SWP.run = 1;
    name = get(hObject,'Name');
    stop(hObject);
    delete(hObject);
    clear name
else
    Error("tell",sprintf('Overrun, interval too short  %0.3f',toc-SWP.starttoc));
end


%     MCC_put(SWP.Meting(swp.metnr));
%     if ~isempty(SWP.Meting(swp.metnr).dac)
%         if (axon.AMP(1).soft.on>0) || (axon.AMP(2).soft.on>0)
%             DACbufferFill(swp.metnr);
%             dacdev = [];
%             for device = unique(SWP.dacdev)
%                 DAQ(device).dac.SamplesOutputFcnCount = size(SWP.dacbuf,1);
%                 chansel = find(SWP.dacdev==device);
%                 putdata(DAQ(device).dac,SWP.dacbuf(:,chansel));
%                 DAQ(device).DAC.values = SWP.dacbuf(end,chansel);
%                 dacdev = [dacdev DAQ(device).dac];
%             end
%             start(dacdev);
%             pause(panels.timer.delay);
%         end
%     end

function SWPrun(ExpMeting,cmd)
global panels axon DAQ DAQrbp SWP swpcmd
while true
    adcall = [];
    dacall = [];
    times  = [];
    if ~isempty(ExpMeting(1).EXTRA.AXON1.clamp), cmd.dynamic = 1; end
    if ~isempty(ExpMeting(1).EXTRA.AXON2.clamp), cmd.dynamic = [cmd.dynamic,2]; end
    for jj=1:length(ExpMeting)
        adcall = unique([adcall,ExpMeting(jj).ADC.HWchn]);
        dacall = unique([dacall,ExpMeting(jj).DAC.HWchn]);
        for ii=1:ExpMeting(jj).EXTRA.MEAN.aver
            times(end+1,1:3) = [ExpMeting(jj).reltime(ii), jj, ii];
        end
    end
    DAQini(CMD,'swp');
    SWP.Meting = ExpMeting; 
    clear ExpMeting
    [SWP.adcdev,SWP.adcloc,SWP.adcall] = ADCinput (adcall);
    [SWP.dacdev,SWP.dacloc,SWP.dacall] = DACoutput(dacall);
    for jj = 1:length(SWP.dacall)
        die = find([axon.output.channel]==SWP.dacall(jj));
        SWP.dacusr(jj) = DAQ(SWP.dacdev(jj)).DAC.scale(SWP.dacloc(jj)).User;
        SWP.dacjun(jj) = DAQ(SWP.dacdev(jj)).DAC.scale(SWP.dacloc(jj)).junction;
        SWP.dachld(jj) = axon.output(die).hold;
    end
    if ~panels.neversave, NRNtimeline; end
    for jj = cmd.dynamic
        if jj==1; name = 'AXON1'; else, name = 'AXON2';  end
        if ~isempty(cmd.(name).handle)
            AXON = get(cmd.(name).handle,'UserData');
            if ~isempty(AXON.rbp) && strcmp(AXON.pars.mode,'CC')
                orgbits{jj}    = getvalue(DAQrbp(AXON.rbp).DIO.outlines);
                panelstate{jj} = [KnobIsBlue(AXON.IKon), KnobIsBlue(AXON.IAon), KnobIsBlue(AXON.ICon), KnobIsBlue(AXON.IHon)];
                panelclamp{jj} = str2double ({get(AXON.IK,'String'),get(AXON.IA,'String'),get(AXON.IC,'String'),get(AXON.IH,'String')});
                metsoft(jj)    = KnobIsRed(AXON.soft);
            else
                cmd.(name).handle = [];
            end
        end
    end
    hlp = [];
    for jj = cmd.dynamic
        if jj==1; name = 'AXON1'; else, name = 'AXON2';  end
        if ~isempty(cmd.(name).handle)
            for ii = 1:size(times,1)
                metdyna = false;
                vals = SWP.Meting(times(ii,2)).EXTRA.(name).clamp;
                bits = SWP.Meting(times(ii,2)).EXTRA.(name).state;
                if find(bits)
                    metdyna = true;
                elseif find(panelstate{jj})
                    metdyna = true;
                    bits = panelstate{jj};
                    vals = panelclamp{jj};
                    SWP.Meting(times(ii,2)).EXTRA.(name).clamp = vals;
                    SWP.Meting(times(ii,2)).EXTRA.(name).state = bits;
                elseif ~metsoft(jj)
                    continue
                end
                if isempty(vals)
                    hlp.(name).vals = []; 
                else
                    hlp.(name).vals(ii,1:4) = vals;
                end
                T1 = [0,0,0,0,0,0,0,0];
                T2 = [0,0,0,0,0,0,0,0];
                if ~isempty(bits)
                    T1(5:8) = [bits];
                    T2(5:8) = [bits];
                end
                if metsoft(jj) && metdyna
                    T1(1:3) = [0,1,0];
                    T2(1:3) = [1,0,0];
                elseif metdyna
                    T1(1:3) = [0,1,0];
                    T2(1:3) = [1,1,0];
                elseif metsoft(jj)
                    T1(1:3) = [1,1,0];
                    T2(1:3) = [1,0,0];
                end
                hlp.(name).T1(ii,:) = T1;
                hlp.(name).T2(ii,:) = T2;
            end
        end
    end
    warning off
    [~,volgorde] = sort(times(:,1));
    times = times(volgorde,:);
    for ii = 1:size(times,1)
        index = volgorde(ii);
        cmd.time   = times(index,1);
        cmd.nodenr = times(index,2);
        cmd.swpnr  = times(index,3);
        if ii==size(times,1), arm = 0; else, arm = times(volgorde(ii+1),2); end
        cmd.arm    = arm;
        if index==1, swpcmd = cmd; end
        for jj = cmd.dynamic
            if jj==1; name = 'AXON1'; else, name = 'AXON2';  end;
            if ~isempty(cmd.(name).handle) && ~isempty(hlp) && ~isempty(hlp.(name).T1)
                cmd.(name).T1 = hlp.(name).T1(index,:);
                cmd.(name).T3 = orgbits{jj};
                if arm>0
                    cmd.(name).T2 = hlp.(name).T2(arm,:);
                    if ~isempty(hlp.(name).vals), cmd.(name).vals = hlp.(name).vals(arm,:); end 
                else
                    cmd.(name).T2   = [];
                    cmd.(name).vals = [];
                end
            end
        end
        if index==1
            swpcmd  = cmd;
            if ~isempty(hlp)
                cmd.(name).T2 = hlp.(name).T2(1,:);
                if ~isempty(hlp.(name).vals), cmd.(name).vals = hlp.(name).vals(1,:); end
            end
        end
        detimers(index,1) = timer('TimerFcn',     @SWPtimer,...
                                  'ExecutionMode','singleShot',...
                                  'BusyMode',     'queue',...
                                  'Name',         sprintf('SWP-%04u',index),...
                                  'Tag',          'SWP',...
                                  'UserData',     cmd,...
                                  'Period',       0.1,...
                                  'StartDelay',   0.1+times(index,1));
    end
    warning on
    adclen = size(SWP.Meting(1).adc,1);
    daclen = size(SWP.Meting(1).dac,1);
    if daclen==0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             
        adcstart = true;
    else
        adcstart = (adclen >= round(daclen * SWP.Meting(1).ADC.rate / SWP.Meting(1).DAC.rate));
    end
    SWP.trgdev  = [];
    SWP.trgbits = [];
    if adclen>0
        for device = unique(SWP.adcdev)
            while isrunning(DAQ(device).adc), stop(DAQ(device).adc); end
            if ADCchannels(device,SWP.adcloc(SWP.adcdev==device)), break; end
            DAQ(device).adc.StartFcn    = [];
            DAQ(device).adc.StopFcn     = [];
            DAQ(device).adc.LoggingMode = 'Memory'; 
            if adcstart && (device==SWP.adcdev(1))
                DAQ(device).adc.SamplesAcquiredFcn = {@SWPdisplay};
            else
                DAQ(device).adc.SamplesAcquiredFcn = [];
            end
            if SWP.trgext
                DAQ(device).adc.TriggerFcn = @EXTtrigger; 
            else
                DAQ(device).adc.TriggerFcn = [];
            end
            DAQ(device).adc.TriggerType      = 'HwDigital';
            DAQ(device).adc.TriggerCondition = 'NegativeEdge';
            [SWP, fout] = TRGfind('adc',SWP,device);
            if fout, break; end
        end
    end
    if daclen>0
        [SWP.dacdev,SWP.dacloc,SWP.dacall] = DACoutput(SWP.dacall);  
        for device = unique(SWP.dacdev)
            while isrunning(DAQ(device).dac), stop(DAQ(device).dac); end
            DACchannels(device,SWP.dacloc(SWP.dacdev==device));
            DAQ(device).dac.RepeatOutput = 0;
            DAQ(device).dac.StartFcn = [];
            DAQ(device).dac.StopFcn  = [];
            if ~adcstart && (device==SWP.dacdev(1))
                DAQ(device).dac.SamplesOutputFcn = {@SWPdisplay};
            else
                DAQ(device).dac.SamplesOutputFcn = [];
            end
            if SWP.trgext && (adclen==0)
                DAQ(device).dac.TriggerFcn = @EXTtrigger;
            else
                DAQ(device).dac.TriggerFcn = [];
            end
            DAQ(device).dac.TriggerType = 'HwDigital';
            [SWP,fout] = TRGfind('dac',SWP,device);
            if fout, break; end
        end
    end
    if panels.astrocam.use, CameraStart(SWP.Meting); end
    if swpcmd.autosavemode, SWP.filename = ClaimFilename; end
    swpcmd.arm = 1;
    SWParm;
    swpcmd.arm = 2;
    writedigitalbits(SWP.trgdev,SWP.trgbits,1);
    SWP.maxtoc = 0;
    break
end
if ~Error
    if strcmp(cmd(1).experiment,'manual'), KnobBlue(cmd(1).startkey); end
    if SWP.trgext
        if panels.blankeron, Blanker('on'); end
        CMD_wait('String','wait for trigger');
        Waitbar(CMD,'show',1,'Wait for trigger');
    else
        start(detimers);
    end
end
%
% ====== Trace metingen ========================================
%
function CopyMeting(hlp)
global Meting
Meting = hlp;

function syncvideo(videonaam)
global axon
tt = [];
for jj = 1:length(axon.CAM)
    if ~isempty(axon.CAM{jj})
        tt = [tt sprintf('%s ',axon.CAM{jj,1})];
    end
end
system(sprintf('"%s" %s %s', [pwd '\distr\syncrst.pye'], videonaam, tt));

function [select1,select2,spectra] = SelectChannels(channels,scales)
global SEL
channelsel = find(cell2mat(get(SEL.chh,'Value')));
spectrasel = find(cell2mat(get(SEL.sph,'Value')));
grpselect1 = find(cell2mat(get(SEL.rch,'Value')));
grpselect2 = find(cell2mat(get(SEL.sth,'Value')));
select1 = [];
select2 = [];
spectra = [];
grpnrs  = [scales.Group]';
grpnr   = 0;
for jj = 1:length(channels)
    if grpnr~=grpnrs(jj), channelnr = 1; grpnr=grpnrs(jj); else, channelnr = channelnr + 1; end
    if ismember(grpnrs(jj),grpselect1) && ismember(channelnr,channelsel); select1 = [select1,jj]; end
    if ismember(grpnrs(jj),grpselect2); select2 = [select2,jj]; end
    if ismember(grpnrs(jj),grpselect2) && ismember(channelnr,spectrasel); spectra = [spectra,jj]; end
end
if ~isempty(get(SEL.art1,'UserData'))
    if isempty(get(SEL.art2,'UserData'))
        if get(SEL.art1,'Value'), select1 = [select1,length(channels)]; end
    else
        if get(SEL.art1,'Value'), select1 = [select1,length(channels)-1]; end
        if get(SEL.art2,'Value'), select1 = [select1,length(channels)]; end
    end
end

function EEGacquired(~,~,cmd)
global DAQ panels SEL EEG graf
if EEG.video && ((EEG.cnt1+1)==EEG.cnt1max) && ((EEG.cnt2+1)==EEG.cnt2max)
    [~,hlp,~] = fileparts(EEG.segname);
    if ((EEG.cnt3+1)==EEG.cnt3max)
        if EEG.multifile
            videonaam = sprintf('%s%04u000',hlp(1:(end-7)),str2double(hlp((end-6):(end-3)))+1);
        else
            videonaam = 'test';
        end
    else
        videonaam = sprintf('%s%03u',hlp(1:(end-3)),str2double(hlp((end-2):(end)))+1);
    end
    syncvideo(videonaam);
end
adcshow = round(size(EEG.Meting(cmd.nodenr).adc,1) * EEG.refresh/EEG.view);
adcrate = EEG.Meting(cmd.nodenr).ADC.rate;
if ~isempty(EEG.Meting(cmd.nodenr).adc)
    chanoff = 0;
    adcbuf = zeros(adcshow,length(EEG.adcall),'int16');
    for device = unique(EEG.adcdev)
        numchan = length(find(EEG.adcdev==device));
        warning off 'MATLAB:intConvertOverflow'
        adcbuf(:,chanoff+(1:numchan)) = int16(round(getdata(DAQ(device).adc,adcshow)));
        warning off 'MATLAB:intConvertOverflow'
        chanoff = chanoff + numchan;
    end
end
adcselect = [];
for jj = 1:length(EEG.Meting(cmd.nodenr).ADC.HWchn)
    adcselect = [adcselect find(EEG.adcall==EEG.Meting(cmd.nodenr).ADC.HWchn(jj))];
end
if EEG.backward
    last = size(EEG.Meting(cmd.nodenr).adc,1)-adcshow;
    EEG.Meting(cmd.nodenr).adc((1:last),:) = EEG.Meting(cmd.nodenr).adc(adcshow+(1:last),:);
    EEG.Meting(cmd.nodenr).adc(last+(1:adcshow),:) = adcbuf(1:adcshow,adcselect);
    EEG.Meting(cmd.nodenr) = JunctionADC(EEG.Meting(cmd.nodenr),adcshow+(1:last),[]);
else
    if EEG.cnt1max ==1
        range = 1:adcshow;
    else
        range = EEG.cnt1*adcshow +(1:adcshow);
    end
    EEG.Meting(cmd.nodenr).adc(range,:) = adcbuf(1:adcshow,adcselect);
    EEG.Meting(cmd.nodenr) = JunctionADC(EEG.Meting(cmd.nodenr),range,[]);
end
writesegment = false;
closesegment = false;
shutup       = false;
newfile      = false;
EEG.cnt1     = EEG.cnt1 + 1;
dataend      = EEG.cnt1 * adcshow;
EEG.total    = EEG.total + adcshow;
if isempty(EEG.offset), EEG.offset = 0; else, EEG.offset = EEG.offset + adcshow; end
if EEG.cnt1==1, EEG.nulpnt = EEG.offset; end
if EEG.cnt1==EEG.cnt1max, EEG.cnt1 = 0; EEG.cnt2 = EEG.cnt2 + 1; writesegment = true; end
if EEG.cnt2==EEG.cnt2max, EEG.cnt2 = 0; EEG.cnt3 = EEG.cnt3 + 1; closesegment = true; end
if EEG.cnt3==EEG.cnt3max
    if EEG.multifile
        newfile = true;
    else
        shutup = true;
    end
end
if shutup
    EEG.abort = true;
elseif EEG.abort
    writesegment = true;
    closesegment = true;
    EEG.cnt3     = EEG.cnt3 + 1;
    EEG.cnt3max  = EEG.cnt3;
end
if EEG.Meting(cmd.nodenr).abstime==0
    EEG.Meting(cmd.nodenr).abstime = datenum(get(DAQ(EEG.trgdev).adc,'InitialTriggerTime'));
    T0 = datevec(EEG.Meting(cmd.nodenr).abstime);
    CMD_wait(sprintf('EEG: %02u:%02u:%5.3f %02u-%02u-%04u ',T0([4 5 6]),T0([3 2 1])));
end
if EEG.save  &&  writesegment && ~isempty(EEG.segname)
    hlpbuffer = squeeze(EEG.Meting(cmd.nodenr).adc(1:dataend,:,1));
    fwrite(EEG.fid, hlpbuffer','integer*2');
    if closesegment
        if EEG.cnt3>1
            EEG.Meting(cmd.nodenr).SEGMENT.start(EEG.cnt3,1) = EEG.Meting(cmd.nodenr).SEGMENT.eind(EEG.cnt3-1,1) + (1 / adcrate);
        else
            EEG.Meting(cmd.nodenr).SEGMENT.start(1,1) = 0;
        end
        kk = strfind(EEG.segname ,filesep);
        EEG.Meting(cmd.nodenr).SEGMENT.name{EEG.cnt3,1} = EEG.segname((kk(end)+1):end);
        EEG.Meting(cmd.nodenr).SEGMENT.time(EEG.cnt3,1) = EEG.Meting(cmd.nodenr).abstime + (EEG.Meting(cmd.nodenr).SEGMENT.start(EEG.cnt3,1)/(24*60*60));
        EEG.Meting(cmd.nodenr).SEGMENT.eind(EEG.cnt3,1) = EEG.Meting(cmd.nodenr).SEGMENT.start(EEG.cnt3,1) + ((EEG.total - 1)/EEG.Meting(cmd.nodenr).ADC.rate);
        fclose(EEG.fid);
        if ~EEG.abort
            if EEG.save
                SaveHulp(EEG.filename,EEG.Meting,'noadc');
            end
            if newfile
                panels.file.name = EEG.filename;
                dezenaam = ClaimFilename;
                EEG.filename = [dezenaam '.mat'];
                EEG.segname  = [dezenaam '000.SEG'];
                kk = strfind(EEG.segname ,filesep);
                set(CMD.NRNfile,'String',EEG.segname ((1+kk(end)):(end-4)));
                EEG.Meting(cmd.nodenr).abstime = EEG.Meting(cmd.nodenr).abstime + (EEG.Meting(cmd.nodenr).SEGMENT.start(EEG.cnt3,1) + (EEG.total/EEG.Meting(cmd.nodenr).ADC.rate))/(24*60*60);
                EEG.cnt3 = 0;
                EEG.Meting(cmd.nodenr).SEGMENT.name  = {};
                EEG.Meting(cmd.nodenr).SEGMENT.time  = 0;
                EEG.Meting(cmd.nodenr).SEGMENT.start = 0;
                EEG.Meting(cmd.nodenr).SEGMENT.eind  = 0;
                panels.segnr = 1;
            else
                EEG.segname = sprintf('%s%03u.SEG',EEG.segname(1:(end-7)),str2double(EEG.segname((end-6):(end-4))) + 1);
            end
            [EEG.fid,message] = fopen(EEG.segname,'w');
            if ~isempty(message), Error(sprintf('%s\n%s',message,EEG.segname)); return; end
            set(CMD.NRNfile,'String',EEG.segname ((1+kk(end)):(end-4)));
        end
        EEG.total = 0;
    end
end
if ~isempty(find(graf.eeg,1))
    winhandles = graf.handle(graf.eeg>0);
    for kk = 1:length(winhandles)
        gbuf  = get(winhandles(kk),'UserData');
        ylims = get(winhandles(kk),'YLim');        
        if strcmp(gbuf.type,'adc')
            usetraces  = true(1,length(EEG.Meting(cmd.nodenr).ADC.HWchn));
            maxtraces = length(usetraces);
            usespectra = ~usetraces;
            adcseparation = (realpow(10,get(CMD.ADCseparator,'Value'))-0.01)/0.99;
            adcbasisgain  = power(10,get(CMD.ADCgain,'Value'));
            if ~isempty(SEL) && (gbuf.useselect>0)
                [usetraces1,usetraces2,usespectra] = SelectChannels(usetraces,EEG.Meting(cmd.nodenr).ADC.scale);
                switch gbuf.useselect
                    case 1, usetraces = usetraces1;
                    case 2, usetraces = usetraces2; 
                            usespectra = false(length(usetraces),1);
                end
                set([gbuf.handles.trace(usetraces)  gbuf.handles.names(usetraces)  gbuf.handles.nul(usetraces)], 'Visible','on')
                notinuse = setdiff(1:maxtraces,usetraces);
                set([gbuf.handles.trace(notinuse) gbuf.handles.names(notinuse) gbuf.handles.nul(notinuse)],'Visible','off');
            end
            ylims = get(winhandles(kk),'YLim');
            symax = ylims(2);
            if isempty(gbuf.yfixed) && (maxtraces>0)
                lbuf = get(gbuf.handles.trace(1),'UserData');
                symax = EEG.Meting(1).ADC.scale(1).User / abs(lbuf.yas.pltgain * adcbasisgain);
                symin = -symax - 2 * symax * adcseparation * (length(usetraces)-1);
                set(winhandles(kk),'YLim',[symin symax]);
             else
                maxy = gbuf.yfixed;
            end
            tracecnt = 0;
            for jj=1:length(usetraces)
                traceindex = usetraces(jj);
                lbuf = get(gbuf.handles.trace(traceindex),'UserData');
                tracecnt = tracecnt + 1;
                if isempty(gbuf.yfixed)
                    maxy = EEG.Meting(cmd.nodenr).ADC.scale(traceindex).User / abs(lbuf.yas.pltgain * adcbasisgain);
                end
                gain   = lbuf.yas.adcgain * symax / maxy;
                offset = 2 * adcseparation * (1-tracecnt) * symax;
                if (gbuf.useselect>0) && (offset~=unique(get(gbuf.handles.nul(traceindex),'YData')))
                    set(gbuf.handles.nul(traceindex),'YData',offset*[1 1]);
                    pos = get(gbuf.handles.names(traceindex),'Position');
                    pos(2) = offset;
                    set(gbuf.handles.names(traceindex),'Position',pos);
                end
                set(gbuf.handles.trace(traceindex),'YData', offset + gain * double(squeeze(EEG.Meting(cmd.nodenr).adc(lbuf.xas.idx(1):lbuf.xas.idx(2):lbuf.xas.idx(3),lbuf.wie.chn,1))));
            end
            if EEG.spectrum.on
                tracenr = 0;
                for jj=1:length(usespectra)
                    if ~usespectra(jj) || (tracenr>4), continue; end
                    tracenr = tracenr + 1;
%                     if jj>length(teken), set(EEG.spectrum.trace(jj),'Visible','off'); continue; end
%                     tracenr = teken(jj);
                    lbuf = get(gbuf.handles.trace(tracenr),'UserData');
                    signaal = gain * double(squeeze(EEG.Meting(cmd.nodenr).adc(lbuf.xas.idx(1):1:lbuf.xas.idx(3),lbuf.wie.chn,1)));
                    helft  = floor(length(signaal)/2); siglen = 2*helft;
                    if length(signaal) ~= siglen, signaal = signaal(1:siglen); end
                    if isempty(EEG.spectrum.bmh)
                        df = 1 / EEG.view;
                        fas = df * (1:siglen);
                        EEG.spectrum.bmh = blackmanharris(siglen);
                        set(EEG.spectrum.trace,'XData',fas(1:helft),'YData',0.0000000001*fas(1:helft));
%                        set(get(EEG.spectrum.trace(1),'Parent'),'XLim',[fas(1) fas(helft)]);
                    else
                        fas = [];
                    end
                    amp = abs(fft((signaal-mean(signaal)).*EEG.spectrum.bmh));
                    amp = amp(1:helft);
                    if ~isempty(EEG.spectrum.kill) && get(SEL.k50Hz,'Value')
                        if isempty(fas), fas = get(EEG.spectrum.trace(1),'Xdata'); end
                        kill = find((fas>=EEG.spectrum.kill(1)) & (fas<=EEG.spectrum.kill(2)));
                        b = amp(kill(1));
                        a = (amp(kill(end))-b)/(length(kill)-1);
                        amp(kill) = a*(kill-kill(1))+b;
                    end
                    if isempty(EEG.spectrum.filt)
                        set(EEG.spectrum.trace(jj),'YData',amp/helft,'Visible','on');
                    else
                        set(EEG.spectrum.trace(jj),'YData',filter(EEG.spectrum.filt/helft,1,amp),'Visible','on');
                    end
                end
            end
            if ~EEG.backward, set(gbuf.handles.vline,'Xdata',[1 1] * 1000 * dataend /(adcrate * panels.timegain),'YData',ylims); end
        elseif strcmp(gbuf.type,'dac')
            xlims = get(winhandles(kk),'XLim');
            set(gbuf.handles.vline,'Xdata',[1 1] * (xlims(1) + 1000*EEG.total/(adcrate * panels.timegain)),'Ydata',ylims);
        end
    end
    EEG.refreshcount = EEG.refreshcount + EEG.refresh;
    if panels.blankeron
        Blanker(sprintf(' %0.1f ',EEG.segmentlen * EEG.cnt3max-EEG.refreshcount + 1));
    elseif EEG.multifile || isinf(EEG.cnt3max)
        Clock_Show(CMD,EEG.refreshcount/(24*60*60),0);
    else
        Clock_Show(CMD,EEG.refreshcount/(24*60*60),EEG.segmentlen * EEG.cnt3max/(24*60*60));
    end
    drawnow() 
end
if EEG.abort
    if EEG.cnt3max==1
        if (EEG.cnt2max>1) && ~isempty(EEG.segname)
            propone   = dir(EEG.segname);
            channels  = size(EEG.Meting(cmd.nodenr).adc,2);
            maxpnts   = propone.bytes/(2*channels);
            [fids,message] = fopen(EEG.segname,'r');
            if ~isempty(message), Error(sprintf('%s\n%s',message,EEG.segname)); return; end
            EEG.Meting(cmd.nodenr).adc = [];
            EEG.Meting(cmd.nodenr).adc = fread(fids,[channels maxpnts],'int16=>int16')';
            fclose(fids);
        end
        EEG.Meting(cmd.nodenr).SEGMENT.name  = [];
        EEG.Meting(cmd.nodenr).SEGMENT.cmt   = [];
        EEG.Meting(cmd.nodenr).SEGMENT.time  = [];
        EEG.Meting(cmd.nodenr).SEGMENT.start = [];
        EEG.Meting(cmd.nodenr).SEGMENT.eind  = [];
        panels.segnr = [];
        if EEG.save
            EEG.Meting(cmd.nodenr).dac = [];
            SaveHulp(EEG.filename,EEG.Meting);
            panels.file.name = EEG.filename;
            if ~isempty(EEG.segname), delete(EEG.segname); end
        else
            KnobBlue(CMD.Savedata);
        end
    elseif EEG.save
        SaveHulp(EEG.filename,EEG.Meting,'noadc');
        panels.file.name = EEG.filename;
    end
    for device = unique(EEG.adcdev)
        while isrunning(DAQ(device).adc), stop(DAQ(device).adc); end
        set(DAQ(device).adc,'StartFcn',{});
        DAQ(device).adc.SamplesAcquiredFcn = {};
        DAQ(device).adc.SamplesAcquiredFcnCount = 8192;
    end
    for device = unique(EEG.dacdev)
        while isrunning(DAQ(device).dac)
            stop(DAQ(device).dac);
        end
    end
    EEG.run = 0;
    EEG.abort  = false;
    EEG.pltwin = [];
    EEG.adcall = [];
    EEG.adcloc = [];
    EEG.adcdev = [];
    EEG.dacall = [];
    EEG.dacloc = [];
    EEG.dacdev = [];
    CopyMeting(EEG.Meting);
    EEG.Meting = [];
    KnobGrey(CMD.Savedata);
    if panels.blankeron, Blanker('off'); end
    Clock_Stop(CMD);
end

function EEGtimer(~,~)
global EEG
writedigitalbits(EEG.trgdev,EEG.trgbits,0);
if EEG.video, [~,videonaam,~] = fileparts(EEG.segname); syncvideo(videonaam); end

function EEGrun(ExpMeting,cmd,eeg)
global DAQ EEG panels graf
DAQini(CMD,'eeg');
flds = fieldnames(eeg);
for jj = 1:length(flds)
    name = flds{jj};
    EEG.(name) = eeg.(name);
end
while true
    adcall = [];
    dacall = [];
    for jj=1:length(ExpMeting)
        adcall = unique([adcall, ExpMeting(jj).ADC.HWchn]);
        dacall = unique([dacall, ExpMeting(jj).DAC.HWchn]);
    end
    if ~isempty(adcall), adcdev = ADCinput(adcall);  end
    if ~isempty(dacall), dacdev = DACoutput(dacall); end

    if ~isempty(adcall), for device = unique(adcdev), if islogging(DAQ(device).adc), Error('EEG-adc is logging'); break; end; end; end
    if ~isempty(dacall), for device = unique(dacdev), if issending(DAQ(device).dac), Error('EEG-dac is sending'); break; end; end; end
    EEG.Meting = ExpMeting;
    clear ExpMeting
    EEG.run = 1;
    if ~isempty(adcall), [EEG.adcdev, EEG.adcloc, EEG.adcall] = ADCinput(adcall);  end
    if ~isempty(dacall), [EEG.dacdev, EEG.dacloc, EEG.dacall] = DACoutput(dacall); end
    % MCC_put(EEG.Meting(1));
    % MCC_show(handles,3)
    EEG.trgdev  = [];
    EEG.trgbits = [];
    devs = [];
    if size(EEG.Meting(1).adc,1)>0   
        for device = unique(EEG.adcdev)
            while isrunning(DAQ(device).adc), disp('stop EEG adc'); stop(DAQ(device).adc); end
            if ADCchannels(device,EEG.adcloc(EEG.adcdev==device)), break; end
            DAQ(device).adc.SampleRate = SetRate(device,'adc',EEG.Meting(1));
            if Error, break; end
            DAQ(device).adc.StartFcn = [];
            DAQ(device).adc.StopFcn  = [];
            DAQ(device).adc.LoggingMode = 'Memory';
            if (device==EEG.adcdev(1))
                DAQ(device).adc.SamplesAcquiredFcn = {@EEGacquired,cmd};
                DAQ(device).adc.SamplesAcquiredFcnCount = round(size(EEG.Meting(1).adc,1) * EEG.refresh / EEG.view);
            else
                DAQ(device).adc.SamplesAcquiredFcn = [];
            end
            DAQ(device).adc.TriggerType       = 'HwDigital';          
            DAQ(device).adc.TriggerCondition  = 'NegativeEdge';
            DAQ(device).adc.SamplesPerTrigger = inf;  
            if EEG.trgext
                DAQ(device).adc.TriggerFcn = @EXTtrigger; 
            else
                DAQ(device).adc.TriggerFcn = [];
            end
            [EEG,fout] = TRGfind('adc',EEG,device);
            if fout, break; end
            devs = [devs DAQ(device).adc];
        end
    end
    if size(EEG.Meting(1).dac,1)>0
        dacmet = EEG.Meting(1).DAC.HWchn;
        dacselect = [];
        for jj = 1:length(dacmet), dacselect = [dacselect find(EEG.dacall==dacmet(jj))]; end
        buffer(:,dacselect) = double(EEG.Meting(1).dac);
        junction(dacselect) = EEG.Meting(1).DAC.ints*[EEG.Meting(1).DAC.scale.junction]./[EEG.Meting(1).DAC.scale.User];
        for jj=1:length(junction)
            if junction(jj)~=0
                buffer(:,dacselect(jj)) = buffer(:,dacselect(jj)) + junction(jj);
            end
        end
        for device = unique(EEG.dacdev)
            while isrunning(DAQ(device).dac), disp('stop EEG dac'); stop(DAQ(device).dac); end
            DACchannels(device,EEG.dacloc(EEG.dacdev==device));
            DAQ(device).dac.SampleRate  = SetRate(device,'dac',EEG.Meting(1));
            if Error, break; end
            DAQ(device).dac.RepeatOutput = DAQ(device).DAC.repeat;
            DAQ(device).dac.StartFcn     = [];
            DAQ(device).dac.StopFcn      = [];
            DAQ(device).dac.TriggerType  = 'HwDigital';
            if EEG.trgext
                DAQ(device).dac.TriggerFcn = @EXTtrigger;
            else
                DAQ(device).dac.TriggerFcn = [];
            end
            [EEG,fout] = TRGfind('dac',EEG,device);
            if fout, break; end
            DAQ(device).dac.SamplesOutputFcn      = {};
            DAQ(device).dac.SamplesOutputFcnCount = size(EEG.Meting(1).dac,1);
            chansel = find(EEG.dacdev==device);
            putdata(DAQ(device).dac,buffer(:,chansel));
            DAQ(device).DAC.values = buffer(end,chansel);
            devs = [devs DAQ(device).dac];
        end
        pause(panels.timer.delay);
    end
    if panels.astrocam.use, CameraStart(EEG.Meting); end
    writedigitalbits(EEG.trgdev,EEG.trgbits,1);
    start(devs)
    T0 = clock();
    Clock_Start(CMD);
    EEG.refreshcount = 0;
    if EEG.cnt3max<inf
        Clock_Show(CMD,EEG.refreshcount/(24*60*60),EEG.segmentlen * EEG.cnt3max/(24*60*60));
    else
        Clock_Show(CMD,EEG.refreshcount/(24*60*60),0);
    end
    setmaxpars(EEG.Meting(1),'full');
    NRNtimeline;
    panels.segnr = 0;
    panels.NRNabort = false;
    panels.NRNbusy = false;
    panels.plotter = EEG.Meting(1).plotter;
    for jj = 1:length(panels.plotter)
        panels.plotter(jj).metnr = 1;
        panels.plotter(jj).subnr = 1;
    end
    NRNshow(EEG.Meting,3);
    for jj = 1:length([graf.window])
        graf(jj).eeg = ismember(graf(jj).window,[EEG.Meting(1).plotter.window]);
    end
    if EEG.spectrum.on
        handle = getplothandle(EEG.spectrum.window,true);
        set(handle,'Xscale',EEG.spectrum.scale.logx,'Yscale',EEG.spectrum.scale.logy,'XGrid','on','YGrid','on');
        if sum(isinf(EEG.spectrum.scale.x))<2, set(handle,'XLim',EEG.spectrum.scale.x); end
        if sum(isinf(EEG.spectrum.scale.y))<2, set(handle,'Ylim',EEG.spectrum.scale.y); end
        EEG.spectrum.bmh = [];
        kleur='kbrgy';
        for jj = 1:5
            EEG.spectrum.trace(jj) = line('XData',EEG.spectrum.scale.x(1:2),...
                                          'YData',EEG.spectrum.scale.x(1:2),'Color',kleur(jj));
        end
    end
    if EEG.save
        dezenaam = ClaimFilename;
        EEG.filename  = [dezenaam '.mat'];
        if Donotoverwrite(EEG.filename), KnobGrey(hObject); break; end
        kk = strfind(EEG.filename,filesep);
        set(CMD.NRNfile,'String',EEG.filename ((1+kk(end)):(end-4)));
        if (EEG.cnt2max*EEG.cnt3max)>1
            EEG.segname  = [dezenaam '000.SEG'];
            kk = strfind(EEG.segname ,filesep);
            set(CMD.NRNfile,'String',EEG.segname ((1+kk(end)):(end-4)));
            [EEG.fid,message] = fopen(EEG.segname,'w');
            if ~isempty(message), Error(sprintf('%s\n%s',message,EEG.segname)); break; end
        end
    end
    EEG.Meting(1).SEGMENT.cmt = 'NRN Segment';
    EEG.Meting(1).SEGMENT.name {1,1} = '';
    EEG.Meting(1).SEGMENT.time (1,1) = datenum(T0);
    EEG.Meting(1).SEGMENT.start(1,1) = 0;
    EEG.Meting(1).SEGMENT.eind (1,1) = 0;
    panels.segnr = 1;
    if EEG.save
        EEG.Meting = DACcompress(EEG.Meting);
        SaveHulp(EEG.filename,EEG.Meting,'noadc');
    end
    break
end
if Error
    KnobGrey(cmd.startkey);
    DAQini(CMD,'eeg');
else
    if EEG.trgext
        if panels.blankeron, Blanker('on'); end
        CMD_wait('wait for trigger');
        Waitbar(CMD,'show',1,'Wait for external trigger');
    else
        mytimer = timer('TimerFcn',     @EEGtimer,...
                        'ExecutionMode','singleShot',...
                        'BusyMode',     'queue',...
                        'Name',         'EEG-1',...
                        'Tag',          'EEG',...
                        'Period',       0.1,...
                        'StartDelay',   panels.timer.delay);
        start(mytimer);
    end
end

function modus = getprotocolmodus(command, modus, nr)
global knobs
if Error, return; end
[cmd,parms] = ParseCmd(command);
Error("header",'protocol');
Error("line",cmd,'protocol');
switch cmd
    case 'Clear',     WindowClear; return
    case 'experiment',modus = 6;
                      return
    case 'XYZXYZ',    nbgn = 1;   
    case 'ALTERNATE', nbgn = 1;
    case 'REPEAT',    nbgn = 2;
    otherwise,        proto = strtok(cmd,'(');
                      mnr = find(strcmp(knobs.macrocmd,proto));
                      if isempty(mnr)
                          knr = 11 + find(strcmp(knobs.knobcmd(12:end),proto));
                          if isempty(knr)
                              Error(sprintf('%s is not defined as script or knob',proto));
                          elseif knr==nr
                              Error(sprintf('%s is calling itself',proto));
                          else
                              modus = [modus knobs.knobmod(knr)];
                          end                          
                      elseif length(mnr)>1
                          Error(sprintf('%s is double defined',proto));
                      elseif ~isempty(mnr)
                          modus = [modus knobs.macromod(mnr)];
                      end
                      return
end
for nn = nbgn:length(parms)
    modus = [modus getprotocolmodus(parms{nn},modus,nr)];
end

function addprotocol(cmdtxt,parallel)
global protocol knobs
if Error, return; end
if isempty(cmdtxt), Error('No protocol on this knob'); return; end
Error("header",'protocol');
Error("line",cmdtxt);
[cmd,parms] = ParseCmd(cmdtxt);
switch cmd
    case 'XYZXYZ'
        for jj = 1:length(parms)
            addprotocol(parms{jj},parallel);
            if Error, return; end
        end
    case 'ALTERNATE'
        for jj = 1:length(parms)
            addprotocol(parms{jj},jj);
            if Error, return; end
        end
    case 'REPEAT'
        parlist = rsingle(parms{1});
        if length(parlist)==1, parlist = 1:parlist; end
        for jj = 1:length(parlist)
            for jjj = 2:length(parms)
                addprotocol(strrep(parms{jjj},'REP',sprintf('%-0.4g',parlist(jj))),parallel);
                if Error, return; end
            end
        end
    otherwise
        knr = find(strcmp(knobs.knobcmd,cmd));
        mnr = find(strcmp(knobs.macrocmd,cmd));
        if ~isempty(mnr)
            [macro,ps] = ParseCmd(cmdtxt);
            if length(knobs.macropar{mnr})~=length(ps)
                Error(sprintf('%s needs %u parameters',macro,length(knobs.macropar{mnr}))); return
            end
            demacro = knobs.macrotxt{mnr};
            hlp     = knobs.macropar{mnr};
            for jj=1:length(ps)
                demacro = strrep(demacro,hlp{jj},ps{jj});
            end
            nxt = length(protocol.prot)+1;
            protocol.prot(nxt,1).name  = cmdtxt;
            if nxt==1
                protocol.prot(nxt,1).order = 1;
            elseif protocol.prot(nxt-1).serie==0
                protocol.prot(nxt,1).order = protocol.prot(nxt-1,1).order+1;
            elseif parallel>protocol.prot(nxt-1).serie
                protocol.prot(nxt,1).order = protocol.prot(nxt-1,1).order;
            else
                protocol.prot(nxt,1).order = protocol.prot(nxt-1,1).order+1;
            end
            protocol.prot(nxt,1).serie  = parallel;            
            protocol.prot(nxt,1).txt    = demacro;
            protocol.prot(nxt,1).mod    = knobs.macromod(mnr);
            protocol.prot(nxt,1).bgn    = 0;
            protocol.prot(nxt,1).lst    = 0;
            protocol.prot(nxt,1).time   = 0;
            protocol.prot(nxt,1).inter1 = 0;
            protocol.prot(nxt,1).inter2 = 0;
        elseif ~isempty(knr)
            addprotocol(['XYZXYZ(' knobs.knobtxt{knr} ')'],parallel);
        else
            Error(sprintf('Cannot find %s',cmd));
        end
end

function MarkIntensity(cmd)
global DAQ SEL
if isempty(SEL), Error('markintensity needs SE panel'); return; end
device = cmd.markdev;
txt    = cmd.marktxt;
amp = 0.5*rsingle(txt);
tmp = get(SEL.sth,'Value');
set(SEL.sth,'Value',0);
Setrelais;
pause(0.1);
if isrunning(DAQ(device).dac), stop(DAQ(device).dac); end
set(DAQ(device).dac,'SampleRate',10,'TriggerType','immediate');
putdata(DAQ(device).dac,[0 0; -5 -5; -5 -5; amp -amp; amp -amp; 0 0]*32767/10 );
start(DAQ(device).dac);
wait(DAQ(device).dac,1);
if isrunning(DAQ(device).dac), disp('stoppped'); stop(DAQ(device).dac); end
for jj = 1:length(SEL.sth), set(SEL.sth(jj),'Value',tmp{jj}); end
Setrelais;
pause(0.1);

function ExpTimer(hObject,~)
cmd = get(hObject,'UserData');
if cmd.clrimp
    AXON = getPANEL('AXON1'); if ~isempty(AXON), AXON.imps.avgs = []; set(AXON.handle,'UserData',AXON); end
    AXON = getPANEL('AXON2'); if ~isempty(AXON), AXON.imps.avgs = []; set(AXON.handle,'UserData',AXON); end
end
if ~isempty(cmd.markdev), MarkIntensity(cmd); end
if ~Error
    if ~isempty(cmd.pars)
        for mm = 1:length(cmd.pars)
            assigncmd(strtrim(cmd.pars{mm}));
            if Error, break; end
        end
    end
    if ~Error
        Configuration;
        if ~Error
            addprotocol(['XYZXYZ(' cmd.protocol ')'],0);
            if ~Error
                [ExpMeting, dosweep, eeg] = Protocol_Generate('',false);
                if ~Error
                    if eeg.trace, Error('Do not run EEG via experiment'); end
                    if dosweep && ~Error
                        if strcmp(get(hObject,'ExecutionMode'),'singleShot')
                            stop(hObject);
                            delete(hObject);
                        end
                        SWPrun(ExpMeting,cmd);
                    end
                end
            end
        end
    end
end
if Error("box")
    hlp = timerfind('Tag','EXPERIMENT');
    if ~isempty(hlp)
        stop(hlp);
        delete(hlp);
    end
end

function zetuit = CheckRunning(hObject)
global EEG SWP
zetuit = true;
if KnobIsGreen(hObject)
    EEG.abort = true;
    return
end
tims = [timerfind('Tag','EXPERIMENT'); timerfind('Tag','SWP'); timerfind('Tag','TST')];
if ~isempty(tims)
    stop(tims);
    delete(tims);
end
if ~KnobIsGrey(hObject) && ~KnobIsDark(hObject)
    SWP.abort = true;
    if KnobIsYellow(hObject)
        KnobDark(hObject);
    elseif KnobIsBlue(hObject)
        KnobGrey(hObject);
    end
    if SWP.run==0, SWPend; end
else
    zetuit = false;
end

function cmd = getcmd
global panels
cmd  = struct('experiment','manual','protocol','empty','startkey',[],'knob',0,'clrimp',false,...
              'time',0,'arm',[],'expnr',0,'expbgn',true,'explst',true,'nodenr',1,'swpnr',1,'markdev',[],'marktxt','','pars',[],...
              'dynamic',[],...
              'AXON1',struct('handle',findobj('Tag','AXON1','-depth',2),'T1',[],'T2',[],'T3',[],'vals',[]),...
              'AXON2',struct('handle',findobj('Tag','AXON2','-depth',2),'T1',[],'T2',[],'T3',[],'vals',[]),...
              'autosavemode',get(CMD.Autosave,'Value') && ~panels.neversave);

function run_exp(hObject,~)
global knobs
if CheckRunning(hObject), return; end
CMD = getPANEL('CMDpanel');
cmdbasis            = getcmd;
cmdbasis.knob       = find(CMD.keys==hObject,1);
cmdbasis.startkey   = hObject;
cmdbasis.experiment = knobs.knobtxt{cmdbasis.knob};
Error("clear",['run-exp', cmdbasis.experiment]);
expname = hObject.String;
runs    = hObject.UserData;
numexp  = length(strfind(cmdbasis.experiment,'experiment'));
if numexp<1, Error("tell",sprintf('%s needs at least one experiment(xx)',expname)); return; end
timval = 0;
nexp   = 0;
for expcnt = 1:numexp
    cmd = cmdbasis;
    [runs.parms,present,ps,cmd.experiment] = ParseSpecial(runs.parms,'experiment');
    if present
        [ps,clrimp]     = ParseSpecial(ps,'ClearImp');
        [ps,pres0,subs] = ParseSpecial(ps,'markintensity'); if pres0, [~,cmd.markdev] = getDAQnr(subs); cmd.marktxt = ssingle(subs{1}); end
        [ps,pres0]      = ParseSpecial(ps,'Nosave');        if pres0, cmd.autosavemode = false;  end
        [ps,pres0,subs] = ParseSpecial(ps,'defpars');       if pres0, cmd.pars = subs; end
        times = [];
        [ps,pres1,tims] = ParseSpecial(ps,'Loop');  if pres1, times = rsingle(tims{1}); end
        [ps,pres2,tims] = ParseSpecial(ps,'Start'); if pres2, times = rsingle(tims{1}); end
        [ps,pres3,tims] = ParseSpecial(ps,'Inc');   if pres3, times = rsingle(tims{1}); end
        if isempty(times), Error("tell",'Each experiment needs timing: Loop, Start or Inc!'); return; end
        cmd.protocol = ssingle(ps{1});
        for jj = 2:length(ps), cmd.protocol = [cmd.protocol ',' ssingle(ps{jj})]; end
        warning off
        if pres1
            if numexp>1, Error("tell",' You can not have an infinite loop in a multiple experiment'); retutn; end
            timers(1) = timer('TimerFcn',      {@ExpTimer},...
                              'ExecutionMode', 'fixedRate',...
                              'BusyMode',      'drop',...
                              'Name',          'looping',...
                              'Tag',           'EXPERIMENT',...
                              'UserData',      cmd,...
                              'Period',        times,...
                              'StartDelay',    0.1);
        else
            for timcnt = 1:length(times)
                if pres2, timval = times(timcnt); end
                if pres3, timval = timval + times; end
                nexp = nexp + 1;
                cmd.expnr  = nexp;
                cmd.expbgn = (expcnt==1)      && (timcnt==1);
                cmd.explst = (expcnt==numexp) && (timcnt==length(times));
                cmd.time   = timval;
                cmd.clrimp = clrimp;
                timers(nexp) = timer('TimerFcn',      {@ExpTimer},...
                                     'ExecutionMode', 'SingleShot',...
                                     'BusyMode',      'queue',...
                                     'Name',          sprintf('experiment-%02u',nexp),...
                                     'Tag',           'EXPERIMENT',...
                                     'UserData',      cmd,...
                                     'Period',        0.1,...
                                     'StartDelay',    timval);
            end
        end
        warning on
    end
end
KnobYellow(hObject);
tic;
if CMD.autohide.Value
    KnobRed(CMD.hide);
    CMD.macro.Visible = 'Off';
end
start(timers);

function run_single(hObject,~)
global knobs
if CheckRunning(hObject), return; end
CMD = getPANEL('CMDpanel');
tic;
cmd          = getcmd;
cmd.knob     = find(CMD.keys==hObject,1);
cmd.startkey = hObject;
cmd.protocol = knobs.knobcmd{cmd.knob};
Error("clear",['run-single ', cmd.protocol]);
Configuration;
if ~Error
    addprotocol(['XYZXYZ(' cmd.protocol ')'],0);
    if ~Error
        [ExpMeting, dosweep, eeg] = Protocol_Generate('',false);
        if ~Error
            if CMD.autohide.Value
                KnobRed(CMD.hide);
                CMD.macro.Visible = 'Off';
            end
            if eeg.trace
                KnobGreen(hObject);
                EEGrun(ExpMeting,cmd,eeg);
            end
            if dosweep
                KnobBlue(hObject);
                SWPrun(ExpMeting,cmd);
            end
        end
    end
end
Error("box");

function Mets = MeanIni(Mets)
if isempty(Mets), return; end
for metnr = 1:length(Mets)
    if ~isempty(Mets(metnr).cdac), Mets(metnr).dac = []; end
    Mets(metnr).EXTRA.MEAN = [];
    Mets(metnr).EXTRA.MEAN.avg     = [];
    Mets(metnr).EXTRA.MEAN.sem     = [];
    Mets(metnr).EXTRA.MEAN.Sy      = [];
    Mets(metnr).EXTRA.MEAN.Syy     = [];
    Mets(metnr).EXTRA.MEAN.cnt     = 0;
    Mets(metnr).EXTRA.MEAN.aver    = 0;
    Mets(metnr).EXTRA.MEAN.chan    = [];
    Mets(metnr).EXTRA.MEAN.zero    = [];
    Mets(metnr).EXTRA.MEAN.missers = false(size(Mets(metnr).adc,3),1);
    Mets(metnr).EXTRA.MEAN.spikers = false(size(Mets(metnr).adc,3),1);
    Mets(metnr).EXTRA.MEAN.nospike = false(size(Mets(metnr).adc,3),1);
end

function data = MakeAverage(data,SWPS)
global Meting
[~,datlen] = size(data.SWPs);
data.missers = false(datlen,1);
data.spikers = false(datlen,1);
data.nospike = false(datlen,1);
data.outlier = false(datlen,1);
data.error  = NaN(datlen,1);
data.kkwamp = NaN(datlen,1);
data.kkwer1 = NaN(datlen,1);
data.kkwref = NaN(datlen,1);
data.kkwer2 = NaN(datlen,1);
mets = unique(SWPS.metnr)';
for metnr = mets
    if SWPS.missers, data.missers(SWPS.metnr==metnr) = Meting(metnr).EXTRA.MEAN.missers; end
    if SWPS.spikers, data.spikers(SWPS.metnr==metnr) = Meting(metnr).EXTRA.MEAN.spikers; end
    if SWPS.nospike, data.nospike(SWPS.metnr==metnr) = Meting(metnr).EXTRA.MEAN.nospike; end
end
exclude = data.missers | data.spikers | data.nospike;
mets = [SWPS.ref, mets(mets~=SWPS.ref)];
if ~isempty(SWPS.o)
    range = SWPS.o(1):SWPS.o(2);
    for metnr=mets
        select = (SWPS.metnr==metnr) & ~exclude;
        data.error(select,1) = sum((data.SWPs(range,select)-mean(data.SWPs(range,select),2)).^2);
        data.outlier(select) = isoutlier(data.error(select));
    end
end
if ~isempty(SWPS.k)
    p4p3   = SWPS.k(2)-SWPS.k(1)+1;
    avg = data.SWPs(SWPS.k(1):SWPS.k(2),:)-mean(data.SWPs(SWPS.nul(1):SWPS.nul(2),:));
    for metnr = mets
        select = (SWPS.metnr==metnr) & ~data.outlier & ~exclude;
        if metnr==1
            avgref = mean(avg(:,select),2);
            nrmref = sum(avgref.*avgref);
            avgexp = avgref;
            nrmexp = nrmref;
        else
            avgexp = mean(avg(:,select),2);
            nrmexp = sum(avgexp.*avgexp);
        end
        for swpnr = find(select)'
            data.kkwref(swpnr,1) = sum(avgref.*avg(:,swpnr))/nrmref;
            data.kkwamp(swpnr,1) = sum(avgexp.*avg(:,swpnr))/nrmexp;
            data.kkwer2(swpnr,1) = realsqrt(sum(realpow(data.kkwref(swpnr)*avgref-avg(:,swpnr),2))/p4p3);
            data.kkwer1(swpnr,1) = realsqrt(sum(realpow(data.kkwamp(swpnr)*avgexp-avg(:,swpnr),2))/p4p3);
        end
    end
end
avg = data.SWPs(:,~data.outlier & ~exclude);
data.yscale = [-1 1]*max(abs([min(avg(:)),max(avg(:))]));

function showfilename(CMD,str)
[~,name,ext] = fileparts(str);
if strcmp(ext,'h5'), name = [name ext];end
CMD.datafile.String = name(max(1,(end-36)):end);

function DoNewname(parms)
global Meting
[parms,donumber] = ParseSpecial(parms,'numbers');
setnrs = cumsum([Meting.setnr]);
name = ssingle(parms{1});
for jj = 1:length(Meting)
    if donumber
        Meting(jj).serienaam = sprintf(name,setnrs(jj));
    else
        Meting(jj).serienaam = name;
    end
end

function DoSetname(parms)
global Memoryset
[parms,present,ps] = ParseSpecial(parms,'files');
if present, files = nsingle(ps{1}); end
name = ssingle(parms{1});
for jj = 1:length(files)
    filenr = files(jj);
    for ii =1:length(Memoryset{filenr}.Meting)
        Memoryset{filenr}.Meting(ii).serienaam = name;
    end
end

function MemoryUpdate(varargin)
global Memoryset Meting cache timeline panels SEL events
%  zet data vanuit Memoryset en/of segment vanaf disk in Memory
%  text parameters in varargin:
%
%  nobar         do not display the waitbar during loading (mostly used when caller displays this bar)
%  clear:        maar memoryset schoon
%  refresh:      set the current Meting/img and spikes terug in memoryset
%  basic:        load file 1 and segment 1
%
%  remove(nr):   remove the current file from memoryset or nr
%  addtomemory:  add the current meting to the dataset(only during loading)
%
%  reload:       reload th eseg from disk, or the file from memoryset, or the file from disk
%  fileprv       load previous file from memoryset
%  filenxt       load next     file from memoryset
%  segprv        load previous segment from disk
%  segnxt        load next     segment from disk
%
CMD = getPANEL('CMDpanel');
opdracht = 'none';
switch nargin
    case 0, cache = [];
            cache.status = false;
            set(CMD.cachelevel,'String','0');
            KnobGrey(CMD.cache);
            Memoryset = [];
            panels.filenr = 0;
            panels.segnr  = 0;
            IMGini(true);
            WindowClear;
            return
    case 1, opdracht = varargin{1};
    case 2, filenr   = varargin{1};
            segnr    = varargin{2};
    case 3, opdracht = varargin{1};
            filenr   = varargin{2};
            segnr    = varargin{3};
end
doshow = true;
switch opdracht
    case 'refresh'
        if panels.filenr>0
            Memoryset{panels.filenr,1}.Meting = Meting;
        end
        return
    case 'addtomemory'
        panels.filenr = length(Memoryset) + 1;
        Memoryset{panels.filenr,1}.Meting = Meting;
        return
    case 'correct'
        panels.filenr = 1;
        panels.segnr = 0;
        filenr = 1;
        segnr  = 1;
    case 'basic'
        if (panels.filenr==1) && (panels.segnr<2) && ~isempty(Meting), return; end
        filenr = 1;
        segnr  = 1;
    case 'remove'
        if isempty(ps),filenr = panels.filenr; else,filenr = nsingle(ps{1}); end
        Memoryset(filenr) = [];
        filenr = panels.filenr;
        panels.filenr = 0;
        panels.segnr  = 0;
        filenr = max(1,min(filenr,length(Memoryset)));
        segnr  = 1;
    case 'reload'
        filenr = panels.filenr;
        panels.filenr = 0;
        segnr = panels.segnr;
        panels.segnr = 0;
    case 'nobar', doshow = false;
    case 'fileprv', filenr = panels.filenr - 1;
    case 'filenxt', filenr = panels.filenr + 1;
    case 'segprv',  filenr = panels.filenr; segnr = panels.segnr - 1;
    case 'segnxt',  filenr = panels.filenr; segnr = panels.segnr + 1; 
end
metnr = 1;
if isempty(Memoryset)
    panels.filenr = 0;
elseif (filenr<1)||(filenr>length(Memoryset))
    Error(sprintf('Memoryset %u does not exist',filenr));
    return
elseif filenr ~= panels.filenr
    Meting = Memoryset{filenr}.Meting;
%     img    = Memoryset{filenr}.Photo;
    panels.file.name = Meting(1).filename;
    panels.filenr = filenr;
    panels.segnr = 0;
    if isfield(Meting(1).EXTRA,'imp') && isfield(Meting(1).EXTRA.imp,'gm')
        set(CMD.label1,'String',sprintf('A1  Rm:%4.1f, Vm:%4.1f',Meting(1).EXTRA.imp{1}.gm,Meting(1).EXTRA.imp{1}.Vm));
        set(CMD.label2,'String',sprintf('A2  Rm:%4.1f, Vm:%4.1f',Meting(1).EXTRA.imp{2}.gm,Meting(1).EXTRA.imp{2}.Vm));
    end
    showfilename(CMD,Meting(1).filename);
    if ~isempty(SEL)
        Openpanel('SELpanel',@SEL_Callback,Meting(1).ADC.scale,false,~isempty(SEL.metvideo));
    end
end
if ~isempty(Meting(metnr).SEGMENT.name) && (panels.segnr~=segnr)
	if (segnr<1)||(segnr>length(Meting(metnr).SEGMENT.name))
        Error(sprintf('segment %u does not exist',segnr));
        return
	end
    hitnr = 0;
    if cache.status
        if isfield(cache,'order')
            hitnr = find((cache.filnr==filenr) & (cache.segnr==segnr));
        else
            cachesize = 100;
            cache.filnr = zeros(cachesize,1,'uint16');
            cache.segnr = zeros(cachesize,1,'uint16');
            cache.order = zeros(cachesize,1,'uint16');
            cache.size  = zeros(cachesize,1);
            cache.data  = [];
        end
    end
    if hitnr>0
        Meting(metnr).adc = cache.data{hitnr};
    else
        segname = char(Meting(metnr).SEGMENT.name{segnr});
        DB = getPANEL('DBpanel');
        if ~isempty(DB)
            if isempty(events.segdir1)
                
                hlp = uigetdir(events.segdir1,sprintf('Give primary segment directory for: %s',segname));
                if hlp==0, return; else,events.segdir1=hlp; end
            end
            fid = fopen(fullfile(events.segdir1,segname),'r');
            if fid<0
                if isempty(events.segdir2)
                    hlp = uigetdir(events.segdir2,sprintf('Give secondary segment directory for: %s',segname));
                    if hlp==0, return; else,events.segdir2=hlp; end
                end
                [fid,message] = fopen(fullfile(events.segdir2,segname),'r');
                if fid<0
                    if fid==-1
                        hlp = uigetdir(events.segdir2,sprintf('Give secondary segment directory for: %s',segname));
                        if hlp==0, return; events.segdir2=''; else,events.segdir2=hlp; end
                        [fid,message] = fopen(fullfile(events.segdir2,segname),'r');
                    end
                    if fid<0
                        Error("tell",sprintf('Segment Load error:\n%s\n%s',fullfile(events.segdir2,segname),message));
                        events.segdir1 = [];
                        events.segdir2 = [];
                        return
                    end
                end
            end
            numchan = length(Meting(metnr).ADC.HWchn);
            exclude = [];
        else
            segdir = panels.file.segdir;
            if isempty(segdir), [segdir,~,~] = fileparts(panels.file.name); end
            fid = fopen(fullfile(segdir,segname),'r');
            if fid<0
                hlp = uigetdir(segdir,sprintf('Give segment directory for: %s',segname));
                if hlp==0, Error('Dir canceled'); return; else,segdir = hlp; end
                [fid,message] = fopen(fullfile(segdir,segname),'r');
                if fid<0, Error(sprintf('%s\n%s',message,segname)); return; end
            end
            panels.file.segdir = segdir;
            numchan = length(Meting(metnr).ADC.HWchn);
        end
        fseek(fid,0,'eof');
        numpnts = ftell(fid)/(2 * numchan);
        if doshow && (numchan*numpnts)>10000000
            Waitbar(CMD,'show',0,sprintf('Load:   %s   (%uMb)',segname,round(numchan*numpnts/(1024 * 512))));
        end
        frewind(fid);
        Meting.adc = fread(fid,[numchan numpnts],'int16=>int16')';
        fclose(fid);
        if ~isempty(SEL)
            if ~isempty(SEL.stmart) && SEL.stmart.Value
               script = string(SEL.artrun.UserData);
               if ~isempty(script)
                   Script_Run("run segment script", script);
               end
            end
        end
        if KnobIsRed(CMD.transform)
            KnobGrey(CMD.transform);
            CMD.transform.String = '>>>';
            datatransform(CMD);
        end
        if doshow, Waitbar(CMD,'hide'); end
        if cache.status
            newsize = 2*length(Meting(1).adc(:));
            maxsize = str2double(get(CMD.cachemax,'String'))*1024*1024*1024;
            oldsize = sum(cache.size);
            while (oldsize+newsize)>=maxsize   % release until enough
                hlp = cache.order;
                hlp(hlp==0) = max(hlp);
                [~,idx] = min(hlp);
                cache.data {idx,1} = [];
                cache.filnr(idx,1) = 0;
                cache.segnr(idx,1) = 0;
                cache.order(idx,1) = 0;
                cache.size (idx,1) = 0;
                oldsize = sum(cache.size);
            end
            idx = find(cache.order==0,1,'first');
            cache.data {idx,1} = Meting(1).adc;
            cache.filnr(idx,1) = panels.filenr;
            cache.segnr(idx,1) = segnr;
            cache.order(idx,1) = max(cache.order)+1;
            cache.size (idx,1) = newsize;
            set(CMD.cachelevel,'String',sprintf('%0.2f',sum(cache.size)/(1024*1024*1024)));
        end
    end
    panels.segnr = segnr;
    if ~isempty(timeline.xy)
        timeline.par(:,4) = 0;
        timeline.par((timeline.par(:,1)==11) & (timeline.idx(:,3)==segnr),4) = 1;
        rodestippen;
    end
end
if ~get(CMD.zoom,'UserData')
    set(CMD.zoom,'String','Zoom');
elseif panels.segnr>0
    set(CMD.zoom,'String',sprintf('Seg(%u)',panels.segnr));
elseif ~isempty(Memoryset)
    set(CMD.zoom,'String',sprintf('Met(%u-%u)',metnr,panels.filenr));
else
    set(CMD.zoom,'String',sprintf('Met(%u)',metnr));
end
if get(CMD.autofull,'Value')
    setmaxpars(Meting(metnr),'full');
else
    setmaxpars(Meting(metnr));
end
TopTime(Meting(metnr).abstime + (panels.zoom.tnul/(24*60*60*1000)), panels.zoom.tnul/(60*60*1000),'uur');
drawnow();

function evaluate(terms)
global p
for jj = 1:length(terms)
    try  
        eval(terms(jj)+";");
    catch
        Error(sprintf("Error in evaluation of\n%s\ndirect MATLAB error",terms{jj})); break;
    end
end

function doPars(strin,command)
global panels
if (command=="clear") || isempty(panels.pars)
     panels.pars = struct('basis',[],'overrule',[],'channel',[],'channellist',[]);
end
parms = string(strin);
switch command
    case "clear"
    case "basis",   panels.pars.basis    = parms;
    case "overrule",panels.pars.overrule = parms;
    case "channel", if length(parms)>1
                        channel = nsingle(parms{1});
                        index = find(panels.pars.channellist==channel);
                        if isempty(index), index = length(panels.pars.channellist)+1; end
                        panels.pars.channel{index,1} = parms(2:end);
                        panels.pars.channellist(index,1) = channel;
                    end
    case "get",     evaluate(panels.pars.basis);
                    evaluate(panels.pars.overrule);
                    if ~isempty(parms)
                        index = panels.pars.channellist==nsingle(parms(1));
                        if any(index), evaluate(panels.pars.channel{index}); end
                    end
    otherwise,      Error("dit kan niet");
end

function [str,answer] = ParseSelect(str,default,question)
if length(str)==1, answer  = 1; else
    [answer,OK] = listdlg('PromptString',question,...
                          'Selectionmode','Multiple',...
                          'InitialValue',default,...
                          'OKString','OK',...
                          'uh',32,...
                          'fus',12,...
                          'ffs',12,...
                          'ListString',str);
    if OK, str = str(answer); else, str = ""; end
end

function doMem(parms,cmd)
global Memoryset Meting panels
if strcmp(cmd,'label')
    for jj = 1:min(length(parms),length(Memoryset))
        for ii = 1:length(Memoryset{jj}.Meting)
            if ~isempty(Memoryset{jj}.Meting(ii).result)
                names = fieldnames(Memoryset{jj}.Meting(ii).result);
                for kk = 1:length(names)
                    Memoryset{jj}.Meting(ii).result.(names{kk}).basis.label{1} = ssingle(parms{jj});
                end
            end
        end
    end
elseif strcmp(cmd,'save')
    [filename,filepath] = uiputfile('*.mat','Save Memoryset',panels.file.name);
    if filename~=0
        newname = fullfile(filepath,filename);
        save(newname,'Memoryset');
    end
elseif strcmp(cmd,'load')
    [filename,filepath] = uigetfile('*.mat','Select a Memoryset file (carefull!)',panels.file.name);
    if filename == 0, return; end
    newname = fullfile(filepath,filename);
    load(newname, 'Memoryset');
    Meting = Memoryset{1}.Meting;
    NRNtimeline;
elseif strcmp(cmd,'print')
    p3 = 4000;
    p4 = 116000;
    txt = cell(length(Memoryset),1);
    for jj = 1:length(Memoryset)
        Meting             = Memoryset{jj}.Meting(1);
        [~,file,~] = fileparts(Meting(1).filename);
        protocol           = Meting.serienaam;
        p                  = Meting.p;
        for ii = 1:length(parms)
            fld = parms{ii};
            if isfield(Meting(1).p,fld)
                waarde = sprintf('%0.2f',p.(fld));
                protocol = strrep(protocol,['p.' fld],waarde);
            end
        end
        Vstart = mean(double(Meting.adc(1:200,1,1)) * Meting.ADC.scale(1).User / double(Meting.ADC.ints));
        if ~isempty(strfind(protocol,'Noise'))
            Meting = DACexpand(Meting);
            iscale = Meting.DAC.scale(1).User/double(Meting.DAC.ints);
            noiseamp = iscale * mean(double(Meting.dac(p3:p4,1)));
            noisestd = iscale * std(double(Meting.dac(p3:p4,1)));
        else
            noiseamp = 0;
            noisestd = 0;
        end
        tijd = datestr(Meting(1).abstime,13);
        txt{jj,1} = sprintf('%s, %s,  %7.1f,%7.1f,%7.1f,%7.1f,%7.1f,  "%s"\n', tijd, file,Meting.EXTRA.imp{1}.gm,Meting.EXTRA.imp{1}.Vm,Vstart,noiseamp,noisestd,protocol);
    end
    fid = fopen('memshow.txt','w');
    fprintf(fid,'%s\n','time,      file,                  Rm,      Vm,  Vstart,   mean,   std,   protocol');
    for jj = 1:length(Memoryset)
        fprintf(fid,'%s',txt{jj,1});
    end
    fclose(fid);
elseif strcmp(cmd,'keep') || strcmp(cmd,'delete')
    res = stringset(ssingle(parms{1}));
    nmets = length(Memoryset);
    if nmets==0, Error('No data'); return; end
    memselect = true(nmets,1);
    for jj = 1:nmets
        fname = Memoryset{jj}.Meting(1).filename;
        serienames = {Memoryset{jj}.Meting.serienaam}';
        select = false(length(serienames),1);
        for j1 = 1:length(serienames)
            for j2 = 1:length(res)
                select(j1)= select(j1) | ~isempty(strfind(serienames{j1},res{j2}));
            end
        end
        if strcmp(cmd,'delete'), select = ~select; end
        Memoryset{jj}.Meting = Memoryset{jj}.Meting(select);
        memselect(jj) = ~isempty(Memoryset{jj}.Meting);
        if ~isempty(Memoryset{jj}.Meting)
            Memoryset{jj}.Meting(1).filename = fname;
        end
    end
    Memoryset = Memoryset(memselect);
    panels.filenr = 0;
    MemoryUpdate(1,1);
    NRNtimeline;
else
    Error('Illegal Mem command');
end

function [fileset,selected] = CmdFile(CMD,name)
global panels
fileset  = [];
selected = [];
[filepath,filename,fileext] = fileparts(ssingle(name));
if isempty(fileext),  fileext = '.txt'; end
if isempty(filepath), filepath = fileparts(panels.file.script); end
newname = fullfile(filepath,[filename fileext]);

[fid,message] = fopen(newname,'r');
if ~isempty(message), Error(sprintf('%s\n%s',message,newname)); return; end
hlp = textscan(fid,'%s','delimiter','\n','whitespace','');
fclose(fid);
tmp = strtrim(string(hlp{1}));
tmp(~endsWith(tmp,',')) = tmp(~endsWith(tmp,','))+",";
tmp = strrep(strrep(join(tmp),",(","("),"(,","(");
tmp = ParseSimple(tmp);
tmp = string(tmp);
[tmp,present,psh] = ParseSpecial(tmp,"DataRoot"); if present, panels.file.root = unifile(ssingle(psh{1})); end
[fileset,present,pars] = ParseSpecial(tmp,"Parameters");
if present
    pars = string(pars);
    for jj = 1:length(pars)
        [cmd,parm] = ParseCmd(pars(jj));
        switch string(cmd)
            case "label", if ~isempty(parm), CMD.label1.UserData = ssingle(parm{1}); else, CMD.label1.UserData = []; end
                          if length(parm)>1, CMD.label2.UserData = ssingle(parm{2}); else, CMD.label2.UserData = []; end
            case "Parclear",   doPars(parm,"clear");
            case "Parbasis",   doPars(parm,"basis");
            case "Parchannel", doPars(parm,"channel");
            otherwise, Error(sprintf(" command %s is unknown",cmd)); return
        end
    end
end
if KnobIsRed(CMD.super)
    if isempty(panels.run.select2), selected = 1; else, selected = panels.run.select2; end
else
    [selected,OK] = listdlg('PromptString', 'Select the files to analyse',...
                            'Selectionmode','Multiple',...
                            'InitialValue', panels.run.select2(panels.run.select2<=length(fileset)),...
                            'OKString', 'Select',...
                            'uh', 32,...
                            'fus',12,...
                            'ffs',12,...
                            'ListString',string(fileset));
    if OK, panels.run.select2 = selected'; end
end

function doMemoryset(parms)
global panels Memoryset Meting
CMD = getPANEL('CMDpanel');
[parms,dosort]     = ParseSpecial(parms,'sort');
[parms,doclear]    = ParseSpecial(parms,'clear'); if doclear, MemoryUpdate; end
[parms,dolimit,ps] = ParseSpecial(parms,'limit'); if dolimit, maxmetnr = nsingle(ps{1}); end
[parms,dofile,psf] = ParseSpecial(parms,'cmdfile');
psf = string(psf);
if dofile
    if KnobIsRed(CMD.super)
        if isempty(panels.run.select1), panels.run.select1 = 1; end
        psf = psf(panels.run.select1);
    else
        [psf,panels.run.select1] = ParseSelect(psf,panels.run.select1,"Select the file that contain the instructions");
    end
else
    if isempty(Memoryset), Error('MemorySet needs data'); return; end
    psf = "none";
end
[~,~,runps] = ParseSpecial(parms,'run');
if isempty(runps), Error("MemorySet needs at least one run(....)"); return; end
org.root = panels.file.root;
for jj = 1:length(psf)
    if dofile
        [fileset,selected] = CmdFile(CMD,psf(jj));
        if Error, return; end
    else
        selected = 1;
    end
    for j2 = selected
        if dofile
            Memoryset = [];                               
            Meting    = [];
            [~,dofile,psh] = ParseSpecial(fileset(j2),'FileLoad');
            if ~dofile
                [~,docell,psh] = ParseSpecial(fileset(j2),'CellLoad');
                if docell
                    psh{end+1,1} = 'cell';
                else
                    [~,dodir,psh] = ParseSpecial(fileset(j2),'DirLoad');
                    if ~dodir, Error(sprintf('No data to analyse!\n%s',fileset{j2})); return; end
                    psh{end+1,1} = 'dir';
                end
            end
            [psh,present,pss] = ParseSpecial(psh,"overrule");
            if present, doPars(pss,"Overrule"); doPars([],"get"); end
            loaddata([],psh);
            if Error, return; end 
            if dolimit, Memoryset = Memoryset(1:min(maxmetnr,length(Memoryset))); end
            set(CMD.filecount,'String',sprintf('%u',j2),'Visible','On');
            if dosort
                names = [];
                for j3 = 1:length(Memoryset)
                    [~,names{j3,1},~] = fileparts(Memoryset{j3}.Meting(1).filename);
                end
                [~,idx] = sort(names);
                Memoryset = Memoryset(idx); 
            end
        end
        for j3 = 1:max(1,length(Memoryset))
            if ~isempty(Memoryset)
                MemoryUpdate(j3,1);
                panels.file.name = Memoryset{j3}.Meting(1).filename;
            end
            if ~isempty(Meting)
                NRNtimeline;
                Script_Run("Memoryset_Run",join(string(runps),","));
                if ~isempty(Memoryset), MemoryUpdate('refresh'); end
            end
        end
    end
end
panels.file.root = org.root;
CMD.filecount.Visible='Off';

function Mets = ConvertOldMat(Mets)
global panels
CMD = getPANEL('CMDpanel');
if ~isfield(Mets,'version') || (Mets(1).version<=100000)
    for die = 1:length(Mets)
        if ~isfield(Mets,'cdac'), Mets(die).cdac = []; end
        Mets(die).EXTRA.note        = '';
        Mets(die).EXTRA.Temp        = NaN;
        Mets(die).EXTRA.Beep        = 0;
        Mets(die).EXTRA.disp        = 1;
        Mets(die).EXTRA.show        = 1;
        Mets(die).EXTRA.imps        = [];
        Mets(die).EXTRA.comment1    = '';
        Mets(die).EXTRA.comment2    = '';
        Mets(die).EXTRA.borders.bgn = [];
        Mets(die).EXTRA.borders.end = [];
        Mets(die).EXTRA.ELS.elec    = [];
        Mets(die).EXTRA.ELS.grp     = [];
        Mets(die).ADC.HWchn  = [];
        Mets(die).ADC.HWloc  = [];
        Mets(die).ADC.HWdev  = [];
        Mets(die).ADC.ints   = 32767;
        Mets(die).ADC.rate   = 0;
        Mets(die).ADC.scale  = [];
        Mets(die).DAC.HWchn  = [];
        Mets(die).DAC.HWloc  = [];
        Mets(die).DAC.HWdev  = [];
        Mets(die).DAC.ints   = 32767;
        Mets(die).DAC.rate   = 0;
        Mets(die).DAC.repeat = 0;
        Mets(die).DAC.scale  = [];
        Mets(die).SEGMENT.name  = {};
        Mets(die).SEGMENT.cmt   = {};
        Mets(die).SEGMENT.time  = [];
        Mets(die).SEGMENT.start = [];
        Mets(die).SEGMENT.eind  = [];
        Mets(die).result  = [];
    end
    if isfield(Mets,'version')
        versie = Mets(1).version;
    else
        versie = 0;
    end
    panels.zoom.tnul = 0;
    if isfield(Mets,'sets')
        for ii = 1:length(Mets)
            Mets(ii).setnr = Mets(ii).sets;
        end
        Mets = rmfield(Mets,'sets');
    end
    if (length(unique([Mets.setnr]))>2) || isempty(find([Mets.setnr]==0, 1))
        sets = [Mets.setnr];
        for ii = 1:length(sets)
            if ii==1
                Mets(ii).setnr = true;
            elseif sets(ii)>sets(ii-1)
                Mets(ii).setnr = true;
            else
                Mets(ii).setnr = false;
            end
        end
    end
    for ii = 1:length(Mets)
        Mets(ii).version = getversion;
        if isfield(Mets,'ADC_HWchan')
            hlp = Mets(ii).ADC_HWchan;
        elseif isfield(Mets,'ADCchannel')
            hlp = Mets(ii).ADCchannel;
        else
            continue;
        end
        Mets(ii).ADC.HWchn = hlp;
        Mets(ii).ADC.HWloc = hlp;
        Mets(ii).ADC.HWdev = 1+0*hlp;
        if isfield(Mets,'DAC_HWchan')
            hlp = Mets(ii).DAC_HWchan;
        elseif isfield(Mets,'DACchannel')
            hlp = Mets(ii).DACchannel;
        else
            continue;
        end
        Mets(ii).DAC.HWchn = hlp;
        Mets(ii).DAC.HWloc = hlp;
        Mets(ii).DAC.HWdev = hlp;
        if isfield(Mets,'ADCscale')
            for jj = 1:length(Mets(ii).ADC.HWchn)
                Mets(ii).ADC.scale(jj,1).InputRange = Mets(ii).ADCscale(jj).InputRange;
                if isfield(Mets(ii).ADCscale(jj),'ChannelName')
                    Mets(ii).ADC.scale(jj,1).Name  = Mets(ii).ADCscale(jj).ChannelName;
                elseif isfield(Mets(ii).ADCscale(jj),'Name')
                    Mets(ii).ADC.scale(jj,1).Name  = Mets(ii).ADCscale(jj).Name;
                end
                Mets(ii).ADC.scale(jj,1).User  = Mets(ii).ADCscale(jj).UnitsRange(2);
                Mets(ii).ADC.scale(jj,1).Units = Mets(ii).ADCscale(jj).Units;
                if isfield(Mets(ii).ADCscale(jj),'Group')
                    Mets(ii).ADC.scale(jj,1).Group = Mets(ii).ADCscale(jj).Group;
                    Mets(ii).ADC.scale(jj,1).Color = Mets(ii).ADCscale(jj).Color;
                else
                    Mets(ii).ADC.scale(jj,1).Group = 0;
                    Mets(ii).ADC.scale(jj,1).Color = 'k';
                end
            end
        end
        if isfield(Mets,'ADCrate')
            Mets(ii).ADC.rate = Mets(ii).ADCrate;
        end
        if isfield(Mets,'DACscale')
            for jj = 1:length(Mets(ii).DAC.HWchn)
                Mets(ii).DAC.scale(jj,1).OutputRange = Mets(ii).DACscale(jj).OutputRange;
                if isfield(Mets(ii).DACscale(jj),'ChannelName')
                    Mets(ii).DAC.scale(jj,1).Name  = Mets(ii).DACscale(jj).ChannelName;
                elseif isfield(Mets(ii).DACscale(jj),'Name')
                    Mets(ii).DAC.scale(jj,1).Name  = Mets(ii).DACscale(jj).Name;
                end
                Mets(ii).DAC.scale(jj,1).User  = Mets(ii).DACscale(jj).UnitsRange(2);            
                Mets(ii).DAC.scale(jj,1).Units = Mets(ii).DACscale(jj).Units;
    %             Mets(ii).DAC.scale(jj,1).soft  = [];
                if isfield(Mets(ii).DACscale(jj),'Group')
                    Mets(ii).DAC.scale(jj,1).Group = Mets(ii).DACscale(jj).Group;
                    Mets(ii).DAC.scale(jj,1).Color = Mets(ii).DACscale(jj).Color;
                else
                    Mets(ii).DAC.scale(jj,1).Group = 0;
                    Mets(ii).DAC.scale(jj,1).Color = 'k';
                end
            end
        end
        if isfield(Mets,'DACrate'), Mets(ii).DAC.rate = Mets(ii).DACrate; end
        if versie<=3000
            if isfield(Mets,'ADCUnits')
                for jj = 1:length(Mets(ii).ADC.HWchn)
                    Mets(ii).ADC.scale(jj,1).User  = Mets(ii).ADCUnitsRange(jj);
                    Mets(ii).ADC.scale(jj,1).Units = Mets(ii).ADCUnits{jj};
                    if isfield(Mets(ii),'ADCnames'), txt = Mets(ii).ADCnames{jj};  else,txt = sprintf('ADC-%u',jj); end
                    Mets(ii).ADC.scale(jj,1).Name = txt;
                    Mets(ii).ADC.scale(jj,1).Group = 0;
                    Mets(ii).ADC.scale(jj,1).Color = 'k';
                end
            end
            if isfield(Mets,'DACUnits')
                for jj = 1:length(Mets(ii).DAC.HWchn)
                    if isfield(Mets(ii),'DACnames'), txt = Mets(ii).DACnames{jj}; else,txt = sprintf('DAC-%u',jj); end
                    Mets(ii).DAC.scale(jj,1).Name = txt;   
                    Mets(ii).DAC.scale(jj,1).User  = Mets(ii).DACUnitsRange(jj);
                    Mets(ii).DAC.scale(jj,1).Units = Mets(ii).DACUnits{jj};
                    Mets(ii).DAC.scale(jj,1).Group = 0;
                    Mets(ii).DAC.scale(jj,1).Color = 'k';
                end
            end
        end
        if isfield(Mets,'beeps'), Mets(ii).EXTRA.Beep  = Mets(ii).beeps; end
        if ~isfield(Mets(ii),'borders') || isempty(Mets(ii).borders)
        elseif isfield(Mets(ii).borders,'start')
            Mets(die).EXTRA.borders.bgn = Mets(ii).borders.start;
            Mets(die).EXTRA.borders.end = Mets(ii).borders.eind;
        end
        drug = '';
        kk = regexp(panels.file.name,'[()]');
        if ~isempty(kk)
            drug = panels.file.name(1:kk(end));
            kk = strfind(drug,filesep);
            if ~isempty(kk), drug = drug(kk(end)+1:end); end
        end
        Mets(ii).EXTRA.comment1 = drug;
        set(CMD.comment1,'String',drug);
        if isfield(Mets,'plt')
            jj = 0;
            if Mets(ii).plt.ADC1plot>0
                jj = jj + 1;
                Mets(ii).plotter(jj).window = Mets(ii).plt.ADC1plot;
                Mets(ii).plotter(jj).type   = 'adc';
                Mets(ii).plotter(jj).clear  = Mets(ii).plt.ADC1clear;
                Mets(ii).plotter(jj).xzoom  = [Mets(ii).plt.ADC1zooml Mets(ii).plt.ADC1zoomr];
            end
            if Mets(ii).plt.ADC2plot>0
                jj = jj + 1;
                Mets(ii).plotter(jj).window = Mets(ii).plt.ADC2plot;
                Mets(ii).plotter(jj).type   = 'adc';
                Mets(ii).plotter(jj).clear  = Mets(ii).plt.ADC2clear;
                Mets(ii).plotter(jj).xzoom  = [Mets(ii).plt.ADC2zooml Mets(ii).plt.ADC2zoomr];
            end
            if Mets(ii).plt.ADC3plot>0
                jj = jj + 1;
                Mets(ii).plotter(jj).window = Mets(ii).plt.ADC3plot;
                Mets(ii).plotter(jj).type   = 'adc';
                Mets(ii).plotter(jj).clear  = Mets(ii).plt.ADC3clear;
                Mets(ii).plotter(jj).xzoom  = [Mets(ii).plt.ADC3zooml Mets(ii).plt.ADC3zoomr];
            end
            if Mets(ii).plt.DACplot>0
                jj = jj + 1;
                Mets(ii).plotter(jj).window = Mets(ii).plt.DACplot;
                Mets(ii).plotter(jj).type   = 'dac';
                Mets(ii).plotter(jj).clear  = Mets(ii).plt.DACclear;
                Mets(ii).plotter(jj).xzoom  = [Mets(ii).plt.DACzooml Mets(ii).plt.DACzoomr];
            end
        end
        if isfield(Mets(ii).plotter,'clear')
            for jj=1:length(Mets(ii).plotter)
                tt = Mets(ii).plotter(jj).type;
                switch Mets(ii).plotter(jj).clear
                    case 0
                    case 1, tt = [tt '/first'];
                    case 2, tt = [tt '/never'];
                end
                if (Mets(ii).plotter(jj).xzoom(1)~=0)||(Mets(ii).plotter(jj).xzoom(2)~=inf)
                    tt = [tt sprintf('/scale(x(%.1f,%.1f))',Mets(ii).plotter(jj).xzoom(1),Mets(ii).plotter(jj).xzoom(2))];
                end
                Mets(ii).plotter(jj).mode = tt;
            end
            removes = {'type','clear','xzoom','handle'};
            for jj = 1:length(removes)
                if isfield(Mets(ii).plotter,removes{jj}), Mets(ii).plotter = rmfield(Mets(ii).plotter,removes{jj}); end
            end
        end
        if Mets(ii).abstime==0
            DD = dir(panels.file.name);
            Mets(ii).abstime = DD.datenum; 
        elseif length(Mets(ii).abstime)>1
            Mets(ii).abstime = datenum(Mets(ii).abstime);
        end
        if isfield(Mets,'Segment')
            if length(Mets(ii).Segment)<2
                Mets(ii).SEGMENT.name  = [];
                if ~isempty(Mets(ii).Segment), Mets(ii).SEGMENT.name = Mets(ii).Segment;  end
                Mets(ii).SEGMENT.cmt   = [];
                Mets(ii).SEGMENT.time  = [];
                Mets(ii).SEGMENT.start = [];
                Mets(ii).SEGMENT.eind  = [];
            else
                Mets(ii).SEGMENT.name  = Mets(ii).Segment;
                Mets(ii).SEGMENT.cmt   = Mets(ii).Segcomm;
                Mets(ii).SEGMENT.time  = Mets(ii).Segtime;
                Mets(ii).SEGMENT.start = Mets(ii).Segstart;
                Mets(ii).SEGMENT.eind  = Mets(ii).Segeind;
            end
        end
        if isfield(Mets,'Exec1'), Mets(ii).Macro = {'empty';'empty';'empty'}; end

        if isfield(Mets,'ADCstim')
            Mets(ii).axon.stim = Mets(ii).ADCstim;
        elseif isfield(Mets,'stimtype')
            if isfield(Mets,'sx')
                Mets(ii).axon.stim.type = Mets(ii).stimtype;
                Mets(ii).axon.stim.dx   = Mets(ii).sx;
                Mets(ii).axon.stim.dy   = Mets(ii).sy;
                Mets(ii).axon.stim.minitv = 0;
            elseif isfield(Mets,'dx')
                Mets(ii).axon.stim.type = Mets(ii).stimtype;
                Mets(ii).axon.stim.dx   = Mets(ii).dx;
                Mets(ii).axon.stim.dy   = Mets(ii).dy;
                Mets(ii).axon.stim.minitv = 0;
            end
        elseif isfield(Mets,'slen')
            Mets(ii).axon.stim.type = 1;
            Mets(ii).axon.stim.dx = [Mets(ii).slen(1) Mets(ii).slen(2) Mets(ii).slen(3)];
            Mets(ii).axon.stim.dy = [1 0 -1];
            Mets(ii).axon.stim.minitv = 0;
        end
        if ~isempty(Mets(ii).adc) && isfloat(Mets(ii).adc)
            Mets(ii).adc = int16(round(Mets(ii).adc * Mets(ii).ADC.ints / Mets(ii).ADC.scale(1).User));
        end
        if ~isempty(Mets(ii).dac) && isfloat(Mets(ii).dac)
            Mets(ii).dac = int16(round(Mets(ii).dac * Mets(ii).ADC.ints / Mets(ii).DAC.scale(1).User));
        end
        if isfield(Mets,'name')
            Mets(ii).name{1} = strrep(Mets(ii).name{1},'swp','-');
            if length(Mets)==1
                Mets(ii).nodenaam = Mets(ii).name{2};
            else
                Mets(ii).nodenaam = [Mets(ii).name{2} Mets(ii).name{1}];
            end
            Mets(ii).serienaam  = Mets(ii).name{2};
            Mets(ii).EXTRA.note = 'converted';
        end
        for jj = 1:length(Mets(ii).plotter)
            cmdtxt = Mets(ii).plotter(jj).mode;
            cmdtxt = strrep(cmdtxt,'never','always');
            cmdtxt = strrep(cmdtxt,'first','always');
            cmdtxt = strrep(cmdtxt,'color15','map(15)');
            Mets(ii).plotter(jj).mode = cmdtxt;
        end
        if versie<3000
            conversion = [0 1 2 3 4 5 21 9 11 13 7 8 21 32 33 34 35 10 12 6 17 18 19 20];
            for jj = 1:length(Mets(ii).plotter)
                Mets(ii).plotter(jj).window = conversion(round(Mets(ii).plotter(jj).window)+1);
            end
        end
    end
    removes = {'cap';'mode';'freq';'tnul';'cursorrange';'specialrange';'getimp';'comment';'ADCzero';'zero';'first';'setdelay';...
               'interval';'cnt';'nummer';'sweep';'ADCrate';'DACrate';'Sy';'Syy';'tstinter';'clear';'borders';'ADCcnt';...
               'ADCstd';'std';'ADCaver';'average';'ADCmean';'mean';'sets';'start';'barcode';'Temperature';'ADCints';'DACints';...
               'ADC_HWchan';'ADCchannel';'DAC_HWchan';'DACchannel';'averagemode';'ADCavgmode';'plt';'timer';'name';'naam';...
               'ADCscale';'ADCnames';'ADCUnitsRange';'ADCUnits';'DACscale';'DACnames';'DACUnitsRange';'DACUnits';...
               'Drug';'Drugname';'Drugconcentration';'stimtype';'sx';'sy';'dx';'dy';'slen';'ADCstim';'beeps';'fitter';...
               'Segment';'Segtime';'Segstart';'Segeind';'Segcomm';'ADCtracelen';'holdfirst';'Worm';...
               'Segsecs';'Exec1';'Exec2';'Exec3';'Axon';'Axoncap';'Axonmode';'Axonfreq';'Axonscale';'Axonunit';'ADCpregain'};
    for jj = 1:length(removes)
        if isfield(Mets,removes{jj}), Mets = rmfield(Mets,{removes{jj}}); end
    end
end
if Mets(1).ADC.ints>double(intmax('int16'))
    [~,numchans] = size(Mets.adc);
    for jj = 1:numchans
        yas = cumsum(double(Mets.adc(:,jj)));
        yas(1) = 0;
        if max(yas)>double(intmax('int16')), Error("tell",sprintf('%lu',round(max(yas)))); end
        Mets.adc(:,jj) = int16(yas);
        Waitbar(CMD,'show',jj/numchans,'convert');
    end
    Mets(1).ADC.ints = double(intmax('int16'));
    Waitbar(CMD,'hide');
end
if Mets(1).version<105000
    for die = 1:length(Mets)
        Mets(die).EXTRA.comment1 = '';
        Mets(die).EXTRA.comment2 = '';
    end
end
if Mets(1).version<110000
    for die = 1:length(Mets)
        Mets(die).EXTRA.MCC.chn = [];
        Mets(die).EXTRA.MCC.val = [];
    end
end
if Mets(1).version<210000
    for die = 1:length(Mets)
        for jj = 1:length(Mets(die).plotter)
            Mets(die).plotter(jj).mode = strrep(Mets(die).plotter(jj).mode,'/uni','');
        end
    end
end
if Mets(1).abstime==0
    button = {'Yes';'No'};
    if strcmp(questdlg('Abs Time error, Try to repair?','Start-Time = 0',button{1},button{2},button{1}),button{1})
        if ~isempty(Mets(1).SEGMENT.name)
            if isempty(Mets(1).SEGMENT.name{1})
                info = dir(panels.file.name);
                Mets(1).abstime = info.datenum-(size(Mets(1).adc,1)/(Mets(1).ADC.rate*24*60*60));
            else
                path = fileparts(panels.file.name);
                name = fullfile(path,Mets(1).SEGMENT.name{1});
                info = dir(name);
                Mets(1).abstime = info.datenum-(Mets(1).SEGMENT.eind(1)/(24*60*60));
            end
        end
    end
end
if (length(Mets)==1) && isempty(Mets(1).adc) && ~isempty(Mets.SEGMENT.name) && isempty(Mets.SEGMENT.name{1})
    [~,name] = fileparts(panels.file.name);
    Mets(1).SEGMENT.name{1} = [name '000.SEG'];
    MemoryUpdate('correct');
    Mets(1).SEGMENT.name = [];
end
if (length(Mets)==1) && get(CMD.dacmatch,'Value')
    if ~(isempty(Mets.cdac) && isempty(Mets.dac))
        docompress = false;
        Mets = DACexpand(Mets);
        adclen = round(size(Mets.adc,1) * Mets.DAC.rate/Mets.ADC.rate);
        [daclen,dchan] = size(Mets.dac);
        if daclen>adclen
            Mets.dac = Mets.dac(1:adclen,:);
            docompress = true;
        elseif  daclen<adclen
            hlp = Mets.dac;
            Mets.dac = zeros(adclen,dchan,'int16');
            Mets.dac(1:daclen,1:dchan) = hlp;
            copylen = daclen;
            start = 1;
            while copylen>0
                Mets.dac(start:start+copylen-1,1:dchan) = hlp(1:copylen,1:dchan);
                start = start+copylen;
                copylen = min(daclen,adclen-start);
            end
            docompress = true;
        end
        if docompress
            Mets.cdac = [];
            Mets.DAC.compress = true;
            Mets = DACcompress(Mets);
        end
    end
end

function value = Copyifpresent(Hlp,name)
if isfield(Hlp,name), value = Hlp.(name); else, value = []; end

function Mets = ConvertMat(Mets)
if isfield(Mets(1),'EXTRA') && isfield(Mets(1).EXTRA,'AXON1') && ~isfield(Mets(1).EXTRA.AXON1,'RPgains')
    for jj = 1:length(Mets)
        Mets(jj).EXTRA.AXON1.RPgains = [1,1,1,1];
        Mets(jj).EXTRA.AXON2.RPgains = [1,1,1,1];
    end
else
    if ~isfield(Mets(1),'version') || (Mets(1).version<200000), Mets = ConvertOldMat(Mets); end
    for jj = 1:length(Mets)
        if ~isfield(Mets(jj),'SEGMENT'), Mets(jj).SEGMENT = struct('name',[],'cmt',[],'time',[],'start',[],'eind',[]); end
        if isfield(Mets(jj),'compress'), Mets(jj).DAC.compress = Mets(jj).compress; end
        if ~isfield(Mets(jj).ADC.scale,'Subgroup')
            grps = [Mets(jj).ADC.scale.Group];
            total = length(grps);
            grpnr = 0;
            while (total>0) && (grpnr<21)
                deset = find(grps==grpnr);
                if ~isempty(deset)
                    for jjj = 1:length(deset)
                        if grpnr==0, group = 0; else, group = jjj; end
                        Mets(jj).ADC.scale(deset(jjj),1).Subgroup = group;
                    end
                end
                total = total - length(deset);
                grpnr = grpnr + 1;
            end
            for jjj = 1:size(Mets(jj).DAC.scale,1), Mets(jj).DAC.scale(jjj,1).Subgroup = 0; end
        end
        if isfield(Mets,'axon')
            Hlp = Mets(jj).EXTRA;
            axn = Mets(jj).axon;
            Mets(jj).EXTRA   = [];
            Mets(jj).EXTRA.p      = Copyifpresent(Mets(jj),'p');
            Mets(jj).EXTRA.note   = Hlp.note;
            Mets(jj).EXTRA.input  = Copyifpresent(axn,'input');
            Mets(jj).EXTRA.output = Copyifpresent(axn,'output');
            Mets(jj).EXTRA.stim   = Copyifpresent(axn,'stim');
            for j2 = 1:2
                if j2==1, name = 'AXON1'; else, name = 'AXON2'; end
                Mets(jj).EXTRA.(name) = struct('pars',[],'imps',[],'clamp',[],'state',[],'RPgains',[1,1,1,1]);
                if isfield(axn,'AMP1')
                elseif isfield(axn,'AMP') && ~isempty(axn.AMP(j2).adc)
                    Mets(jj).EXTRA.(name).pars.name = axn.AMP(j2).name;
                    Mets(jj).EXTRA.(name).pars.type = axn.AMP(j2).type;
                    Mets(jj).EXTRA.(name).pars.mode = axn.AMP(j2).mode;
                    Mets(jj).EXTRA.(name).pars.hadc = axn.AMP(j2).hadc;
                    Mets(jj).EXTRA.(name).pars.adc  = axn.AMP(j2).adc;
                    Mets(jj).EXTRA.(name).pars.hdac = axn.AMP(j2).hdac;
                    Mets(jj).EXTRA.(name).pars.dac  = axn.AMP(j2).dac;
                    Mets(jj).EXTRA.(name).pars.dev  = axn.AMP(j2).dev;
                    Mets(jj).EXTRA.(name).pars.flt  = axn.AMP(j2).filter;
                    Mets(jj).EXTRA.(name).pars.Cm   = axn.AMP(j2).cap;
                    Mets(jj).EXTRA.(name).pars.Vhold= axn.AMP(j2).VChold;
                    Mets(jj).EXTRA.(name).pars.Ihold= axn.AMP(j2).CChold;
                    Mets(jj).EXTRA.(name).pars.Vsoft= axn.AMP(j2).soft.goal;
                    Mets(jj).EXTRA.(name).pars.jun  = [];
                    Mets(jj).EXTRA.(name).imps.on   = false;
                    gm    = NaN;
                    Vr    = NaN;
                    adcs  = [];
                    dacs  = [];
                    times = [];
                    doavg = false;
                    avgs  = [];
                    if isfield(axn.AMP,'gm')
                        gm    = axn.AMP(j2).gm;
                        Vr    = axn.AMP(j2).Vm;
                    elseif isfield(Hlp,'imp')
                        gm    = Hlp.imp{j2}.gm;
                        Vr    = Hlp.imp{j2}.Vm;
                        adcs  = Hlp.imp{j2}.adc;
                        dacs  = Hlp.imp{j2}.dac;
                        times = Hlp.imp{j2}.times;
                        doavg = Copyifpresent(Hlp.imp{j2},'doavg');
                        avgs  = Copyifpresent(Hlp.imp{j2},'avg');
                    elseif isfield(axn.AMP,'imp')
                        gm = axn.AMP(j2).imp.gm;
                        Vr = axn.AMP(j2).imp.Vm;
                    end  
                    if gm>5, gm = 1/gm; end
                    Mets(jj).EXTRA.(name).imps.Vr    = Vr;
                    Mets(jj).EXTRA.(name).imps.gm    = gm;
                    Mets(jj).EXTRA.(name).imps.times = times;
                    Mets(jj).EXTRA.(name).imps.adc   = adcs;
                    Mets(jj).EXTRA.(name).imps.dac   = dacs;
                    Mets(jj).EXTRA.(name).imps.doavg = doavg;
                    Mets(jj).EXTRA.(name).imps.avgs  = avgs;
                    Mets(jj).EXTRA.(name).clamp      = [];
                    Mets(jj).EXTRA.(name).state      = [];
                    Mets(jj).EXTRA.(name).RPgains    = [1,1,1,1];
                end
            end
            Mets(jj).EXTRA.EP.stim  = Copyifpresent(axn,'EP');
            if ~isfield(Mets(jj).EXTRA.EP.stim,'Istim'), Mets(jj).EXTRA.EP.stim.Istim = [0,0]; end
            Mets(jj).EXTRA.SEA      = Copyifpresent(axn,'SEA');
            Mets(jj).EXTRA.CAM      = Copyifpresent(axn,'CAMERA');
            Mets(jj).EXTRA.MCC      = Copyifpresent(Mets(jj),'MCC');
            Mets(jj).EXTRA.ELS.elec = Copyifpresent(Hlp,'elec');
            Mets(jj).EXTRA.ELS.grp  = Copyifpresent(Hlp,'grp');
            Mets(jj).EXTRA.borders  = Copyifpresent(Hlp,'borders');
            Mets(jj).EXTRA.comment1 = Copyifpresent(Hlp,'comment1');
            Mets(jj).EXTRA.comment2 = Copyifpresent(Hlp,'comment2');
            Mets(jj).EXTRA.Beep     = Copyifpresent(Hlp,'Beep');
            Mets(jj).EXTRA.disp     = Copyifpresent(Hlp,'disp');
            Mets(jj).EXTRA.show     = Copyifpresent(Hlp,'show');
        end
    end
    removes = {'p';'axon';'MCC';'fitter';'SPIKES';'compress';'pp';'MEAN'};
    for jj = 1:length(removes)
        if isfield(Mets,removes{jj}), Mets = rmfield(Mets,{removes{jj}}); end
    end
end
Mets = MeanIni(Mets);
for jj = 1:length(Mets), Mets(jj).version = getversion; end



function skipem = Getmatfile
global panels timeline Meting
skipem = ~isempty(strfind(panels.file.name,'foto.mat'));
if skipem, return; end
CMD = getPANEL('CMDpanel');
Waitbar(CMD,'show',0,'Loading data');
Meting = [];
tmp    = [];
mea    = [];
warning off
try
    load(panels.file.name);
catch
    warning on
    Waitbar(CMD,'hide',0,'');
    Error(sprintf('can not open \n%s',panels.file.name));
    return
end
warning on
timeline.boundery   = [-inf inf];
panels.ExportCnt    = 0;
panels.last.plotter = [];
panels.last.cmd     = [];
panels.plotter      = [];
if isempty(Meting)
    [~,name] = fileparts(panels.file.name);
    if ~isempty(tmp)
        Error(sprintf('%s\n\nread this compound file via IMG panel',name));
    else
        Error(sprintf('%s\n\nIs not a NEURON data file',name));
    end
    return
end
if ~isempty(mea), MEAinclude(CMD,mea); end
Waitbar(CMD,'hide',0,'');
showfilename(CMD,panels.file.name);
panels.snap.nr = 0;
Meting = ConvertMat(Meting);
DB = getPANEL('DBpanel');
if ~isempty(DB), DB.showall.Value = 0; end
if CMD.includefotos.Value, loadfotos(); end

function loadfotos()
global panels IMG
try
    [filepath,filename,~] = fileparts(panels.file.name);
    denaam = unifile(fullfile(filepath,makecellname(filename)+"foto.mat"));
    fotoset = [];
    load(denaam); 
    if ~isempty(fotoset)
        IMG.bld = fotoset.bld;
        IMG.nam = fotoset.nam;
    end
catch
% there are no fotos to link
end
%
%  MEA routines
%
function stim = MEAgetstimfile(maxtime)
global panels
stim = struct('time',[],'amps',[],'stnr',[],'ttot',[],'stmlen',NaN);
[path,~,~] = fileparts(panels.file.name);
[filename,filepath] = uigetfile({'*.dat;*.txt';'*.dat;*.txt';'*.txt'},'select a protocol file *.txt, *.dat',path,'MultiSelect','off');
if filename==0, return; end
[~,~,fileext] = fileparts(filename);
fid = fopen(fullfile(filepath,filename));
if fid<=0, Error(sprintf("could not open %s",filename)); return; end
if strcmp(fileext,".dat"), textscan(fid,'%s',12,'delimiter',newline); end
hlp = textscan(fid,"%f %f");
fclose(fid);
amps = abs(hlp{1});      % maak de amplitudes altijd positief
duur = hlp{2};           % tijd in us
maxtime = maxtime *1000; % max duration of single sweep, came in ms
tend = 0;
time = 0;
stimnr = 0;
stimlen = [];
index = 1;
for jj = 1:length(amps)
    if amps(jj)~=0
        stimnr = stimnr + 1;
        stim.time(index,stimnr) = time;
        stim.amps(index,stimnr) = amps(jj);
        if isempty(stimlen), stim.stmlen = duur(jj); end
    end
    time = time + duur(jj);
    if time>=maxtime
        stim.stnr(index,1) = stimnr;
        stim.ttot(index,1) = tend;
        tend = tend + time;
        index = index + 1;
        time   = 0;
        stimnr = 0;
    end
end
stim.time = panels.firststim + (stim.time/1000);  % stim times in ms
stim.ttot = stim.ttot/(1000*1000);                % sweep times in seconds

function SWPdelete(parms)
global Meting
if ~isempty(parms)
    metnr = 1;
    swpnrs = nsingle(parms{1});
    Meting(metnr).adc(:,:,swpnrs) = [];
    Meting(metnr).reltime(swpnrs) = [];
    NRNtimeline;
    Redraw
end

function MEAloadh5(filename)
global panels Meting
import McsHDF5.*
WindowClear;
CMD = getPANEL("CMDpanel");
Waitbar(CMD,"show",0.25,"loading h5 file ...");
panels.file.name = filename;
showfilename(CMD,filename);                  
hlp = [];
hlp.dataType = 'raw';
data  = McsHDF5.McsData(filename,hlp);
kanaal = data.Recording{1,1}.AnalogStream{1,1}.Info.Label;
for jj = 1:length(kanaal)
    if length(kanaal{jj})==2, kanaal{jj} = [kanaal{jj}(1),'0',kanaal{jj}(2)]; end
end
[~,order] = sort(kanaal);
numkan = length(order);
MEA = getPANEL("MEApanel");
if isempty(MEA)||(numkan~=length(MEA.xx))
    MEA = Openpanel("MEApanel",@MEA_Callback,numkan,'O');
end
hlp =split(string(data.Data.MeaName),"MEA");
MEA.spatial.String = hlp(2);
MEA.link.UserData.size= str2double(split(hlp(2),"/"));
maxuser = double(round(data.Recording{1}.AnalogStream{1}.Info.ConversionFactor(1)*32.767/1000000));
newname = 'MEA';
Meting = MetingIni([],newname,newname);
Meting.serienaam = newname;
Meting.nodenaam  = newname;
Meting.ADC.HWchn = 1:numkan; 
Meting.ADC.HWloc = 1:numkan;
Meting.ADC.HWdev = ones(numkan,1);
Meting.ADC.rate  = 1000000/double(data.Recording{1}.AnalogStream{1}.ChannelDataTimeStamps(2)-data.Recording{1}.AnalogStream{1}.ChannelDataTimeStamps(1));
dt   = 1000/Meting.ADC.rate;
amax = max(data.Recording{1,1}.AnalogStream{1,1}.ChannelData(:));
amin = min(data.Recording{1,1}.AnalogStream{1,1}.ChannelData(:));
gain = 30000.0/double(max(abs([amax,amin])));
if MEA.autofilt.Value, gain = gain*str2double(MEA.readgain.String); end
for ii = 1:numkan
    Meting.ADC.scale(ii,1).Name      = sprintf("%s-%02u",newname,ii);
    Meting.ADC.scale(ii,1).Hardware  = [-10,10];
    Meting.ADC.scale(ii,1).User      = maxuser/gain;
    Meting.ADC.scale(ii,1).Units     = "mV";
    Meting.ADC.scale(ii,1).HWchn     = ii;
    Meting.ADC.scale(ii,1).junction  = 0;
    Meting.ADC.scale(ii,1).Group     = 0;
    Meting.ADC.scale(ii,1).Subgroup  = 0;
    Meting.ADC.scale(ii,1).Color     = "k";
end
if MEA.autofilt.Value
    adcrate = Meting.ADC.rate;
    orde = str2double(MEA.orde.String);
    freq = str2double(MEA.freq.String);
    FF1  = 2*freq/adcrate;
    [facB,facA] = butter(orde,FF1,'high');
    [n1,n2] = size(data.Recording{1,1}.AnalogStream{1,1}.ChannelData);
    Meting.adc = zeros(n2,n1,'int16');
    for jj = 1:numkan
        Meting.adc(:,jj) = int16(round(filtfilt(facB,facA,gain*double(data.Recording{1,1}.AnalogStream{1, 1}.ChannelData(jj,:)))));
        Waitbar(CMD,"show",jj/numkan,"high pass filter");
    end
else
    Meting.adc = int16(round(gain*double(data.Recording{1,1}.AnalogStream{1,1}.ChannelData)))';
end
Meting.adc = Meting.adc(:,order);
Meting.adc(1,:) = 0;
Meting.adc(:,4) = int16(round(0.5*(double(Meting.adc(:,3))+double(Meting.adc(:,5)))));
MEApower(MEA,Meting);
MEA.select.UserData(:) = 1;
MEAelektrodes(MEA);
%
% expnt   = double(data.Recording{1}.AnalogStream{1}.Info.Exponent(1));
% adczero = double(data.Recording{1}.AnalogStream{1}.Info.ADZero(1));
% units   = data.Recording{1}.AnalogStream{1}.Info.Unit{1}; 16.7771 --> uV
%
Meting.plotter.window = 23;
Meting.plotter.mode  = "adc(1)";
CMD.window(1).String = "9";
CMD.valid(1).Value   = 1;
CMD.valid(2).Value   = 0;
CMD.valid(3).Value   = 0;
CMD.valid(4).Value   = 0;
if ~strcmp(MEA.modus.String,'O'), MEAini(MEA.nr,"units"); end
CMD.autofull.Value = 0;
Zoom(CMD,{"on";"sec"});
panels.zoom.pnts = size(Meting.adc,1);
panels.zoom.tend = dt * (panels.zoom.pnts-1);
CMD.adcpnts.String = sprintf('%u pnts',panels.zoom.pnts);
CMD.adctime.String = sprintf([panels.timefrmt,' %s'], panels.zoom.tend/panels.timegain,panels.timetxt);
[start,einde] = getdaqpars;
if ((einde-start)>(dt*500000)) || (einde>panels.zoom.tend), setdaqpars(0,dt*500000); end
if ~isempty(data.Recording{1,1}.EventStream)
    numstim = size(data.Recording{1,1}.EventStream{1,1}.Events{1,1},2);
    datlen = size(Meting.adc,1);
    MEA.link.UserData.stim = MEAgetstimfile(2*dt*datlen/numstim);
    if Error, return; end
    if isempty(MEA.link.UserData.stim)
        swplen = datlen/numstim;
    else
        swplen = datlen/length(MEA.link.UserData.stim.ttot);
    end
    MEA.link.UserData.trg = (1:swplen:datlen)'+swplen-1;
    MEA.triggers.Value    = 1;
    MEA.triggers.Visible  = true;
end
Waitbar(CMD,"hide");
NRNtimeline;
setplotter("cmdline",Meting);
for jj = 1:length(panels.plotter)
    panels.plotter(jj).metnr = 1;
    panels.plotter(jj).subnr = 1;
end
NRNshow(Meting);

function MEAimage(CMD,MEA)
global panels Meting IMG
if isempty(panels.file.name) || isempty(Meting), Error("tell",'you need the data trace to establish the link'); return; end
WindowClear;
[path,~,~] = fileparts(panels.file.name);
[filenames,filepath] = uigetfile({'*.bmp;*.png;*.tif;*.tiff';'*.bmp';'*.png';'*.tif';'*.tiff';'*.*'},...
                                  'Select image(s) to add',fullfile(path,'*.*'), 'MultiSelect','on');
if ~isnumeric(filepath)
    if ~iscell(filenames)
        hlp = filenames;
        filenames = [];
        filenames{1} = hlp;
    end
    cnt = 0;
    for ii = 1:length(filenames)
        cnt = cnt + 1;
        org = imread(fullfile(filepath,filenames{ii}));
        handle = getplothandle('9',true);
        imshow(org,'Parent',handle);
        text(1,1,sprintf('rotate image %u',ii),'Fontsize',24,'Fontname','Courier','FontWeight','bold',...
             'Color','y','HorizontalAlignment','Left','VerticalAlignment','Top');
        pos  = wait(impoly);
        hoek = find((((pos(:,1)-mean(pos(:,1)))>0)+((pos(:,2)-mean(pos(:,2)))>0))==0);
        order = [hoek:4, 1:hoek-1];
        pos = pos(order,:); 
        hoek1 = atan((pos(4,2)-pos(3,2))/(pos(3,1)-pos(4,1)));
        hoek2 = atan((pos(2,2)-pos(1,2))/(pos(1,1)-pos(2,1)));
        hoek = 360*(hoek1+hoek2)/(4*pi);
        bld = imrotate(org,-hoek);
        cla
        imshow(bld,'Parent',handle);
        text(1,1,sprintf('scale image %u',ii),'Fontsize',24,'Fontname','Courier','FontWeight','bold',...
             'Color','y','HorizontalAlignment','Left','VerticalAlignment','Top');
        pos  = wait(impoly);
        hlp = sort(pos(:,1));
        xmin = mean(hlp(1:2));
        xmax = mean(hlp(3:4));
        hlp = sort(pos(:,2));
        ymin = mean(hlp(1:2));
        ymax = mean(hlp(3:4));
        dd = ((xmax-xmin)+(ymax-ymin))/10;
        x1 = round(xmin-1.5*dd);
        y1 = round(ymin-1.5*dd);
        x2 = x1 + round(8*dd);
        y2 = y1 + round(8*dd);
        MEA.link.UserData.bld{cnt,1} = bld(y1:y2,x1:x2,:);
        MEA.link.UserData.nam{cnt,1} = filenames{ii};
        IMG.nam{cnt,1} = filenames{ii};
        bld = rgb2gray(uint16(org));
        if CMD.scalefotos.Value
            minz = min(bld(:));
            maxz = max(bld(:));
            gain = 65535/double(maxz-minz);
            IMG.bld{cnt,1} = uint16(round(double(bld-minz)*gain));
        else
            IMG.bld{cnt,1} = uint16(round(bld));
        end
    end
end
WindowClear

% function MEAstimulus(parms)
% global Meting
% MEA = getPANEL('MEApanel');
% [parms,MEA.link.UserData.chnl,MEA.link.UserData.crct] =  getMEAchannel(parms);
% if isempty(MEA.link.UserData.chnl), Error( 'MEAstimulus needs at least one channel'); return; end
% dt = 1000/Meting(1).ADC.rate;
% [parms,present,ps] = ParseSpecial(parms,'interval');
% if present, mininterval = round(rsingle(ps{1}) * Meting(1).ADC.rate); else, mininterval = 0; end
% [parms,present,ps] = ParseSpecial(parms,'level');
% if present
%     [ps,doinvert] = ParseSpecial(ps,'invert');
%     [ps,doabs]    = ParseSpecial(ps,'abs');
%     height = rsingle(ps{1});
%     if length(ps)>1, depth = rsingle(ps{2}); else, depth = height/2; end
% else
%     doinvert = false;
%     doabs    = true;
%     height   = 25000;
%     depth    = height/2;
% end
% if isempty(MEA.link.UserData.crct)
%     schaal = Meting.ADC.scale(MEA.link.UserData.chnl).User/Meting.ADC.ints;
%     if doinvert,  trace = -1 *double(Meting.adc(:,MEA.link.UserData.chnl))*schaal;
%     elseif doabs, trace = abs(double(Meting.adc(:,MEA.link.UserData.chnl))*schaal);
%     else,         trace = double(Meting.adc(:,MEA.link.UserData.chnl))*schaal;
%     end
%     pnts = peakfinder(trace,height,depth,mininterval);
%     MEA.link.UserData.lvls = height;
%     MEA.link.UserData.duur = [];
%     MEA.link.UserData.amps = [];
%     MEA.link.UserData.stnr = [];
% else
%     stim = MEAgetstimfile(mininterval*1000/Meting(1).ADC.rate);
%     if Error, return; end
%     for jj = 1:length(MEA.link.UserData.chnl)
%         if doabs
%             hlp = abs(double(Meting.adc(:,MEA.link.UserData.chnl(jj))));
%         elseif doinvert
%             hlp = -1 * double(Meting.adc(:,MEA.link.UserData.chnl(jj)));
%         else
%             hlp = double(Meting.adc(:,MEA.link.UserData.chnl(jj)));
%         end
%         if jj==1, trace = hlp; else, trace = trace + hlp; end
%     end
%     trace = trace/length(MEA.link.UserData.chnl);
%     pnts = find((trace(1:end-1)<height) & (trace(2:end)>=height));
%     while true
%         die = 1+find(diff(pnts)<mininterval);
%         if isempty(die), break; else, pnts(die) = []; end
%     end
%     MEA.link.UserData.lvls = height * Meting.ADC.scale(MEA.link.UserData.chnl(1)).User/Meting.ADC.ints;
%     MEA.link.UserData.duur = stim.duur(1:length(pnts));
%     MEA.link.UserData.amps = stim.amps(1:length(pnts));
%     MEA.link.UserData.stnr = stim.stnr(1:length(pnts));
% end
% MEA.link.UserData.trg = pnts;
% MEA.link.UserData.ttot = dt*pnts/1000;
% MEA.triggers.Visible = ~isempty(pnts);
% MEA.triggers.Value   = ~isempty(pnts);
% Redraw;

function MEApower(MEA,Meting)
if length(Meting)>1, return; end
[~,numkan,~] = size(Meting.adc);
MEA.link.UserData.valid = true(numkan,1);
MEA.link.UserData.std   = zeros(numkan,1);
MEA.link.UserData.plus  = zeros(numkan,1);
MEA.link.UserData.minus = zeros(numkan,1);
MEA.link.UserData.thres = [];
scale = 1000*Meting.ADC.scale(1).User(1)/Meting.ADC.ints;
for jj = 1:numkan
    yas = double(Meting.adc(:,jj));
    yas = yas-mean(yas);
    ystd = 3*std(yas);
    MEA.link.UserData.std(jj)   = scale * std(yas(abs(yas)<ystd));
    MEA.link.UserData.plus(jj)  = scale * mean(yas(yas>ystd));
    MEA.link.UserData.minus(jj) = scale * mean(yas(yas<(-ystd)));
end

function MEAdrempel(MEA)
drempel = str2double(MEA.drempel.String);
MEA.link.UserData.thres = drempel;
MEA.link.UserData.valid = (MEA.link.UserData.std>drempel)';
MEA.select.UserData(:) = 1;
MEA.select.UserData(MEA.link.UserData.valid) = 2;
MEAelektrodes(MEA);

function MEAinclude(CMD,mea)
global panels Meting IMG
MEA = getPANEL("MEApanel");
Waitbar(CMD,"show",0.75,"loading image/stim ...");
[~,numkan,~] = size(Meting(1).adc);
dt = 1000/Meting(1).ADC.rate;
if isempty(MEA) || (numkan~=length(MEA.xx))
    MEA = Openpanel("MEApanel",@MEA_Callback,numkan,'O');
end
%
% tempory code to read old MEA files, may be removed after a while
%
if isfield(mea,'chnl')
    hlp = mea;
    mea = struct('org',[],'bld',[],'nam',[],'size',hlp.size,'std',[],'plus',[],'minus',[],'valid',[],...
                 'thres',0,'trg',[],'stim',[],'stimkan',hlp.chnl,'correct',hlp.crct,'select',[]);
    mea.org = hlp.org;
    mea.bld = hlp.bld;
    mea.nam = hlp.nam;
	clear hlp
end
if length(mea.size)==1, mea.size(2)=30; end
MEA.link.UserData = mea;
IMG.bld = mea.org; 
IMG.nam = mea.nam;
if isempty(mea.select)
    KnobBlue(MEA.set);
    MEA.link.UserData.select = [];
else
    MEA.select.UserData = mea.select;
end
MEA.mode1.String = "tog";
MEA.mode2.String = "tog";
MEA.spatial.String = sprintf("%u/%u",mea.size(1),mea.size(2));
MEA.triggers.Value   = false;
MEA.triggers.Visible = false;
MEApower(MEA,Meting);
if isempty(mea.bld)
    dovis = 'Off';
    MEA.image.Value   = 0;
    MEA.contour.Value = 1;
else
    dovis = 'On';
    MEA.imgnr.String = [];
    for jj = 1:length(MEA.link.UserData.bld), MEA.imgnr.String{jj} = sprintf("img-%u",jj); end
    MEA.imgnr.Value  = 1;
    set([MEA.image, MEA.surf, MEA.gradient, MEA.csd, MEA.surf3D],'Value',0);
    set([MEA.contour, MEA.super, MEA.conlvl],'Value',1);
end
set([MEA.image, MEA.imgnr, MEA.conlvl,MEA.super],'Visible',dovis);
if length(Meting)>1
    Zoom(CMD,{"off";"ms"});
    CMD.autofull.Value = 1;
else
    Meting(1).ADC.ints = 32767;
    setplotter("cmdline",Meting);
%     meagain = str2double(MEA.readgain.String);
%     if meagain~=1, Meting(1).adc = meagain * Meting(1).adc; end
    Zoom(CMD,{"off";"sec"});
    CMD.autofull.Value = 0;
end
panels.zoom.pnts   = size(Meting(1).adc,1);
panels.zoom.tend   = (panels.zoom.pnts-1)*1000/Meting(1).ADC.rate;
CMD.adcpnts.String = sprintf("%u pnts",panels.zoom.pnts);
CMD.adctime.String = sprintf([panels.timefrmt,' ',panels.timetxt],panels.zoom.tend/panels.timegain);
[start,einde] = getdaqpars;
if ((einde-start)>(dt*500000)) || (einde>panels.zoom.tend)
    setdaqpars(0,min(dt*500000,panels.zoom.tend));
    SkipOn(CMD)
end
MEA_Callback(MEA.imgnr,[]);

%
% end

function MEAset(parms)
MEA = getPANEL('MEApanel');
[parms,dored,psr]  = ParseSpecial(parms,'red');
[parms,doblue,psb] = ParseSpecial(parms,'blue');
[parms,dopwr,psp]  = ParseSpecial(parms,'power');
if ~dored && ~doblue && ~dopwr, return; end
MEA.select.UserData(:) = 1;
if dored
    kanalen = nsingle(psr{1});
    MEA.select.UserData(kanalen) = 2;
end
if doblue
    kanalen = nsingle(psb{1});
    MEA.select.UserData(kanalen) = 3;
end
if dopwr
    MEA.link.UserData.thres = rsingle(psp{1});
    MEAdrempel(MEA)
else
    MEAelektrodes(MEA);
end


function [kanalen,correct] = MEAremovearts(MEA,ps)
global Meting
kanalen = nsingle(ps{1});
correct = nsingle(ps{2});
for kanaal=kanalen
    weights = zeros(length(correct),1);
    for jj = 1:length(correct)
        weights(jj) = 1/realsqrt( (MEA.xx(kanaal)-MEA.xx(correct(jj)))^2  + (MEA.yy(kanaal)-MEA.yy(correct(jj)))^2);
    end
    weights = weights/sum(weights);
    trace  = weights(1) * double(Meting.adc(:,correct(1)));
    for j2 = 2:length(correct), trace = trace + weights(j2) * double(Meting.adc(:,correct(j2))); end
    Meting.adc(:,kanaal) = int16(round(trace));
end

function MEAextract(parms)
global Meting
if length(Meting)>1, Error("tell","Data is already extracted or contains more than one Meting"); return; end
MEA = getPANEL("MEApanel");
[parms,present,ps] = ParseSpecial(parms,'artefact');
if present
    if length(ps)<2
        Error("artefact needs two parameters for channel and correct");
        return;
    end
    [kanaal,correct] = MEAremovearts(MEA,ps);
    MEA.link.UserData.stimkan = kanaal;
    MEA.link.UserData.correct = correct;
end
CMD = getPANEL("CMDpanel");
nchan = size(Meting.adc,2);
dt    = 1000/Meting.ADC.rate;
[~,present,ps] = ParseSpecial(parms,'gain');
if present
    gain = rsingle(ps{1});
    Meting.adc = int16(round(gain*double(Meting.adc)));
    for j4 = 1:nchan
        Meting.ADC.scale(j4).User = Meting.ADC.scale(j4).User/gain;
    end
end
Meting.result = [];
if isempty(MEA.link.UserData.stim)
    idxs = MEA.link.UserData.trg;
    [~,present,ps] = ParseSpecial(parms,'around');
    if present
        before = round(rsingle(ps{1})/dt);
        after  = round(rsingle(ps{2})/dt);
    else
        before = idxs(1)-1;
        after  = 1;
    end
    adc = zeros(before+after,nchan,length(idxs),'int16');
    for swpnr = 1:length(idxs)
        bgn = idxs(swpnr)-before;
        lst = idxs(swpnr)+after-1;
        if (bgn<=0) || (lst>size(Meting.adc,1)), continue; end
        adc(1:(before+after),1:nchan,swpnr) = Meting.adc(bgn:lst,1:nchan);
        Meting.reltime(swpnr) = bgn*dt/1000;
    end
    Meting.adc = adc;
    Zoom(CMD,{'off','ms'})
    setmaxpars(Meting,'adc');  
    setdaqpars(0,dt*(size(Meting.adc,1)-1) );
else
    stim = MEA.link.UserData.stim;
    stimlen = round(stim.stmlen/(1000*dt));
    bgn = MEA.link.UserData.trg-MEA.link.UserData.trg(1)+1;
    lst = MEA.link.UserData.trg;
    npnts = lst(1);
    Meting.DAC.HWchn = 1;
    Meting.DAC.HWloc = 1;
    Meting.DAC.HWdev = 1;
    Meting.DAC.ints  = 32767;
    Meting.DAC.rate  = Meting.ADC.rate;
    Meting.DAC.scale = struct('OutputRange',[-10.0,10.0],'Name','stim','User',5000.0,'Units','mV','Group',0,'Color','k','Subgroup',0);
    dacgain = Meting.DAC.ints / Meting.DAC.scale.User;
    adc = Meting.adc;
    modes = unique(stim.stnr)';
    metnr = 0;
    for j1 = 1:length(modes)
        mymode = modes(j1);
        amps = unique(stim.amps(stim.stnr==mymode,1))';
        for j2 = 1:length(amps)
            metnr = metnr + 1;
            myamp = amps(j2);
            idxs = find((stim.amps(:,1)==myamp) & (stim.stnr==mymode));
            stimamp = round(myamp*dacgain);
            Meting(metnr,1) = Meting(1);
            Meting(metnr,1).dac  = [];
            Meting(metnr,1).cadc = [];
            p0 = stim.time(idxs(1),1)/dt;
            switch mymode
                case 1, newname = "sin";
                        Meting(metnr).cdac{1,1} = [p0,0; stimlen, stimamp; npnts-p0-stimlen, 0];
                case 2, newname = "duo";
                        p1 = stim.time(idxs(1),2)/dt;
                        Meting(metnr).cdac{1,1} = [p0,0; stimlen, stimamp; p1-p0-stimlen,0; stimlen, stimamp; npnts-p1-stimlen,0];
            end
            Meting(metnr).serienaam = sprintf("%s",newname);
            Meting(metnr).nodenaam  = Meting(metnr).serienaam;
            Meting(metnr).setnr     = (myamp==amps(1));
            Meting(metnr).reltime   = [];
            Meting(metnr,1).adc     = [];
            for j3 = 1:length(idxs)
                Meting(metnr).adc(1:npnts,1:nchan,j3) = adc(bgn(idxs(j3)):lst(idxs(j3)),1:nchan);
                Meting(metnr).reltime(j3) = stim.ttot(idxs(j3));
            end
        end
    end
    Zoom(CMD,{"off","ms"})
    setmaxpars(Meting(1),"adc");  
    setdaqpars(0,dt*(npnts-1));
end
NRNtimeline;
setplotter('cmdline',Meting,1,1);
NRNshow(Meting);
MEA.link.UserData.trg = [];
MEA.triggers.Value    = false;
MEA.triggers.Visible  = false;
%
%  MEA protocol generator
%
function val = absamp(mea,relamp)
if isnan(relamp), val = -1; else, val = -round(mea.min+(mea.max-mea.min)*relamp/100.0); end

function mea = makemeastim(mea,psh,nstim)
switch nstim
    case 1, t2  = mea.interval-mea.stimlen;
            tt2 = mea.interval-mea.triglen;
    case 2, t2  = mea.tdouble(2)-mea.stimlen;
            t3  = mea.interval-t2-2*mea.stimlen;
            tt2 = mea.tdouble(2)-mea.triglen;
            tt3 = mea.interval-tt2-2*mea.triglen;
    case 3, t2  = mea.ttriple(2)-mea.stimlen;
            t3  = mea.ttriple(3)-mea.stimlen;
            tt2 = mea.ttriple(2)-mea.triglen;
            tt3 = mea.ttriple(3)-mea.triglen;
end
if isempty(psh), amp1 = mea.amp; else
    switch psh{1}
        case 'select', amp1 = mea.amp;
        case 'nul',    amp1 = NaN;
        otherwise,     amp1 = rsingle(psh{1});
    end
end
if length(psh)<2, amp2 = mea.amp; else
    switch psh{2}
        case 'select', amp2 = mea.amp;
        case 'nul',    amp2 = NaN;
        otherwise,     amp2 = rsingle(psh{2});
    end
end
if length(psh)<3, amp3 = mea.amp; else
    switch psh{3}
        case 'select', amp3 = mea.amp;
        case 'nul',    amp3 = NaN;
        otherwise,     amp3 = rsingle(psh{3});
    end
end
mea.txt{end+1,1} = sprintf('%d\t%d', absamp(mea,amp1),mea.stimlen);
mea.txt{end+1,1} = sprintf('%d\t%d', 0,t2);
mea.trg{end+1,1} = sprintf('1\t%d',  mea.triglen);
mea.trg{end+1,1} = sprintf('0\t%d',  tt2);
if nstim>1
    mea.txt{end+1,1} = sprintf('%d\t%d', absamp(mea,amp2),mea.stimlen);
    mea.txt{end+1,1} = sprintf('%d\t%d', 0,t3);
    mea.trg{end+1,1} = sprintf('1\t%d',  mea.triglen);
    mea.trg{end+1,1} = sprintf('0\t%d',  tt3);
    if nstim>2
        mea.txt{end+1,1} = sprintf('%d\t%d', absamp(mea,amp3),mea.stimlen);
        mea.txt{end+1,1} = sprintf('%d\t%d', 0,mea.interval-t2-t3-3*mea.stimlen);
        mea.trg{end+1,1} = sprintf('1\t%d',  mea.triglen);
        mea.trg{end+1,1} = sprintf('0\t%d',  mea.interval-tt2-tt3-3*mea.triglen);
    end
end
mea.total = mea.total + mea.interval;

function mea = dorepeat(mea,ps)
herhaal = nsingle(ps{1});
for jj = 1:herhaal
    mea = meagenerate(mea,ps(2:end));
end

function mea = doserie(mea,ps)
[ps,doinvert] = ParseSpecial(ps,'reverse');
amps = rsingle(ps{1});
if doinvert, amps = amps(end:-1:1); end
for jj = 1:length(amps)
    mea.amp = amps(jj);
    mea = meagenerate(mea,ps(2:end));
end

function mea = meagenerate(mea,parms)
hlp = [mea.min, mea.max, mea.tsingle, mea.tdouble, mea.ttriple, mea.amp, mea.interval];
for jj = 1:length(parms)
    [~,present,ps] = ParseSpecial(parms(jj),'minmax');  if present, mea.min = rsingle(ps{1}); mea.max = rsingle(ps{2}); end
    [~,present,ps] = ParseSpecial(parms(jj),'tsingle'); if present,                      mea.tsingle = round(1000*rsingle(ps{1})); end                                                            
    [~,present,ps] = ParseSpecial(parms(jj),'tdouble'); if present, tt = rsingle(ps{1}); mea.tdouble = round(1000*[tt(1), tt(2)-tt(1)]); end
    [~,present,ps] = ParseSpecial(parms(jj),'ttriple'); if present, tt = rsingle(ps{1}); mea.ttriple = round(1000*[tt(1), tt(2)-tt(1), tt(3)-tt(2)]); end
    
    [~,present,ps] = ParseSpecial(parms(jj),'interval');if present, mea.interval = round(1000*1000*rsingle(ps{1})); end
    [~,present,ps] = ParseSpecial(parms(jj),'single');  if present, mea = makemeastim(mea,ps,1); end
    [~,present,ps] = ParseSpecial(parms(jj),'double');  if present, mea = makemeastim(mea,ps,2); end
    [~,present,ps] = ParseSpecial(parms(jj),'triple');  if present, mea = makemeastim(mea,ps,3); end
    [~,present,ps] = ParseSpecial(parms(jj),'repeat');  if present, mea = dorepeat(mea,ps); end
    [~,present,ps] = ParseSpecial(parms(jj),'serie');   if present, mea = doserie (mea,ps); end
end
mea.min     = hlp(1);
mea.max     = hlp(2);
mea.tsingle = hlp(3);
mea.tdouble = hlp(4:5);
mea.ttriple = hlp(6:8);
mea.amp     = hlp(9);
mea.interval= hlp(10);

function MEAprotocol(parms)
mea = struct('txt',[],'trg',[],'total',0,'stimlen',100,'triglen',300,...
             'min',0,'max',4000,'tsingle',50,'tdouble',[50,70],'ttriple',[50,250,270],'amp',NaN,'interval',10);
[parms,present,ps] = ParseSpecial(parms,'file');
if present, filename = ssingle(ps{1}); else, Error('need filename'); return; end
[parms,present,ps] = ParseSpecial(parms,'stimlen');  if present, mea.stimlen  = rsingle(ps{1}); end
[parms,present,ps] = ParseSpecial(parms,'triglen');  if present, mea.triglen  = rsingle(ps{1}); end
mea = meagenerate(mea,parms);
[path,name,~] = fileparts(filename);
name = fullfile(path,[name,'.dat']);
fid = fopen(name,'w');
fprintf(fid,'%s\n%s\n\n','Multi Channel Systems MC_Stimulus II','ASCII import Version 1.10');
fprintf(fid,'%s\n\n%s\n\n%s\n\n%s\n\n%s\n','channels: 2','output mode: voltage','format: 4','channel: 1','value	time');
for jj = 1:length(mea.txt), fprintf(fid,'%s\n',mea.txt{jj}); end
fprintf(fid,'\n%s\n\n%s\n','channel: 3','value	time');
for jj = 1:length(mea.trg), fprintf(fid,'%s\n',mea.trg{jj}); end
fclose(fid);
Message(sprintf('MCrack protocol is saved as\n\n   %s\n\nwill take %5.2f minutes', filename, mea.total/(1000*1000*60)));
%
%
%
function RemoveEmpty
global Meting
die = find([Meting.abstime]==0);
if ~isempty(die), Meting(die) = []; end

function [idx,sub] = setfind(nameset,content)
idx = [];
sub = [];
fnd = strfind(nameset,content);
for jj = 1:length(fnd)
    if ~isempty(fnd{jj})
        idx = [idx jj];
        sub = [sub fnd{jj}];
    end
end

function cellname = makecellname(filename)
[~,cellname,~] = fileparts(filename);
cellname = char(cellname);
while (cellname(end)>='0') && (cellname(end)<='9') && ~isempty(cellname)
    cellname = cellname(1:end-1);
end
cellname = string(cellname);

function filenames = selectfiles(filenames,txt)
if ~isempty(filenames)
    select = true(length(filenames),1);
    for iii = 1:length(select)
        if  isempty(strfind(filenames{iii},'.mat')),        select(iii) = false; continue; end
        if  isempty(strfind(filenames{iii},  txt )),        select(iii) = false; continue; end
        if ~isempty(strfind(filenames{iii},'spikes.mat')),  select(iii) = false; continue; end
        if ~isempty(strfind(filenames{iii},'foto.mat')),    select(iii) = false; continue; end
        if ~isempty(strfind(filenames{iii},'-result.mat')), select(iii) = false; continue; end
        if ~isempty(strfind(filenames{iii},'.SEG')),        select(iii) = false; continue; end
    end
    filenames = filenames(select);
end

function loaddata(hObject,parms)
global Memoryset Meting panels
CMD = getPANEL('CMDpanel');
if get(CMD.autoclear,'Value'), WindowClear; end
doask = isempty(parms);
panels.abort    = false;
panels.NRNbusy  = false;
panels.NRNabort = false;
tomemory  = false;
domerge   = false;
dokeep    = false;
dodelete  = false;
filenames = [];
newname   = [];
pex       = [];
while true
    if doask
        loadmodus = get(CMD.Loadmodus,'String');
    else
        loadmodus = 'file';
        [parms,present] = ParseSpecial(parms,'reload');
        if present
            hObject = CMD.Reload;
        else
            hObject = CMD.Loaddata;
            [parms,present,ps] = ParseSpecial(parms,'label');
            if present
               if isempty(ps),  CMD.label1.UserData = []; else, CMD.label1.UserData = ssingle(ps{1}); end
               if length(ps)<2, CMD.label2.UserData = []; else, CMD.label2.UserData = ssingle(ps{2}); end
            end
            [parms,dokeep, keepnames] = ParseSpecial(parms,'keep');
            [parms,dodelete,delnames] = ParseSpecial(parms,'delete');
            [parms,present,ps]        = ParseSpecial(parms,'newname'); if present, newname   = ssingle(ps{1}); end
            [parms,present]           = ParseSpecial(parms,'add');   if present, tomemory  = true; end
            [parms,present]           = ParseSpecial(parms,'file');  if present, loadmodus = 'file'; end
            [parms,present]           = ParseSpecial(parms,'cell');  if present, loadmodus = 'cell'; end
            [parms,present]           = ParseSpecial(parms,'dir');   if present, loadmodus = 'dir';  end
            [parms,domerge,ps]        = ParseSpecial(parms,'merge'); if domerge && ~isempty(ps), mergegap = rsingle(ps{1}); else, mergegap = 0; end
%
            if isempty(parms)
            	panels.file.name = fullfile(panels.file.root,'*.mat');
            else
                panels.file.name = fullfile(panels.file.root,unifile(ssingle(parms{1})));
            end
        end
    end
    if hObject==CMD.Reload
        if ~isempty(Meting(1).SEGMENT.name)
            MemoryUpdate('reload');
            Redraw;
            break
        elseif isempty(Memoryset)
            if isempty(panels.file.name), Error('No last datafile'); break; end
            [filepath,filename,fileext] = fileparts(panels.file.name);
            filenames{1} = [filename,fileext];
            hObject = CMD.Loaddata;
        else
            Error('You can not reload part of a memoryset from disk'); 
            break;
        end
    elseif (hObject==CMD.Nextfile) || (hObject==CMD.Prevfile)
        if isempty(panels.file.name), Error('No last datafile'); break; end
        [filepath,filename,fileext] = fileparts(panels.file.name);
        alldir = fullfile(filepath,'*.mat');
        ddd = dir(alldir);
        ddd([ddd.isdir]) = [];
        allfiles = selectfiles({ddd.name}','.mat');
        index = find(strcmp([filename fileext],allfiles));
        if (hObject==CMD.Nextfile) && (index<length(allfiles))
            filenames{1} = allfiles{index+1};
        elseif (hObject==CMD.Prevfile) && (index>1)
            filenames{1} = allfiles{index-1};
        else
            break
        end
    else
        if isempty(panels.file.name)
            filepath = [];
        else
            filepath = fileparts(panels.file.name);
        end
        switch loadmodus
            case 'cell'
                fileext = '.mat';
                if doask
                    [filename,filepath] = uigetfile({'*.mat';'*.mat';'*.*'},'Select one file from a cell',panels.file.name);
                    if filename==0, break; end
                else
                    [filepath,filename] = fileparts(panels.file.name);
                end
                cellname = makecellname(filename);
                ddd = dir(filepath);
                ddd([ddd.isdir]) = [];
                filenames = selectfiles({ddd.name}',cellname);
            case 'dir'
                fileext = '.mat';
                if doask
                    filepath = uigetdir(filepath,'Select a directory');
                    if filepath==0, break; end
                else
                    filepath = fileparts(panels.file.name);
                end
                ddd = dir(filepath);
                ddd([ddd.isdir]) = [];
                filenames = selectfiles({ddd.name}',fileext);
            otherwise
                if doask
                    [hlpname,filepath] = uigetfile({'*.mat;*.daq;*.dat;*.abf;*.bin;*.edf;*.txt;*.LOG;*.tif;*.png;*.raw;*.bmp;*.his;*.h5;';...
                                                    '*.mat';'*.daq';'*.dat';'*.abf';'*.h5';'*.bin';'*.txt';'*.LOG';'*.tif';'*.edf';'*.png';'*.raw';'*.bmp';'*.his';'*.*'},...
                                                    'Select datafile(s)',filepath,'MultiSelect','on');
                    if iscell(hlpname)
                        filenames = hlpname';
                    elseif hlpname==0
                        break
                    else
                        filenames{1} = hlpname;
                    end
                    [~,~,fileext] = fileparts(filenames{1});
                else
                    [filepath,filename,fileext] = fileparts(panels.file.name);
                    filenames{1}  = [filename fileext];
                end
        end
    end
    KnobRed(hObject);
	switch lower(fileext)
%         case '.log', VSDload (filepath,filenames);
%         case '.edf', EDFload (filepath,filenames);
%         case '.daq', DAQread (filepath,filenames);
%         case '.abf', Axonread(filepath,filenames);
%         case '.bin', convertbinfile;
%         case '.dat', convertdatfile;
        case '.h5', MEAloadh5(fullfile(filepath,filenames{1}));
        case '.txt',for iii = 1:length(filenames)
                        panels.file.name = fullfile(filepath,filenames{iii});
                        convertceline;
                        NRNtimeline;
                        if ~KnobIsRed(hObject), break; end
                    end
                    if Error, break; end
                    Redraw(1)
        case '.mat'
            if isempty(filenames), break; end
            numfiles  = length(filenames);
            if numfiles>1, filenames = sort(filenames); end
            if ~tomemory && (hObject~=CMD.Loadmemory)
                Memoryset = [];
                panels.filenr = 0;
                panels.segnr  = 0;
                tomemory = numfiles>1;
            end
            Zoomstackclear(CMD);
            IMGini(true);
            TemplateIni;
            SpikeIni;
            TriggerIni;
            DB = getPANEL('DBpanel');
            for iii = 1:numfiles
                if numfiles>5, Waitbar(CMD,'show',(iii-1)/numfiles,filenames{iii}); end
%                 if ~isempty(pex), doExecute(pex); end
                panels.file.name = fullfile(filepath,filenames{iii});
                showfilename(CMD,panels.file.name);
                if domerge, TmpMet = Meting; end
                if Getmatfile, continue; end
                if Error, break; end
                if dokeep
                    select = true(length(Meting),1);
                    for jjj = 1:length(keepnames)
                        naam = keepnames{jjj};
                        for jj = 1:length(Meting)
                            if ~isempty(strfind(Meting(jj).serienaam, naam))
                               select(jj) = false;
                            end
                        end
                    end
                    Meting = Meting(~select);
                    if isempty(Meting), continue; end
                end
                if dodelete
                    select = true(length(Meting),1);
                    for jjj = 1:length(delnames)
                        naam = delnames{jjj};
                        for jj = 1:length(Meting)
                            if ~isempty(strfind(Meting(jj).serienaam, naam))
                                select(jj) = false;
                            end
                        end
                    end
                    Meting = Meting(select);
                    if isempty(Meting), continue; end
                end
                if get(CMD.removeempty,'Value')
                    RemoveEmpty;
                end
                if domerge
                   tmax = 0;
                   for jj = 1:length(TmpMet)
                       tmax = max([tmax,TmpMet(jj).reltime]);
                   end
                   tmax = tmax + mergegap;
                   for jj = 1:length(Meting)
                       Meting(jj).reltime = tmax + Meting(jj).reltime;
                       TmpMet(end+1) = Meting(jj);
                   end
                   Meting = TmpMet;
                   clear TmpMet
                end
                if ~isempty(newname)
                    metnumber = contains(newname,'%');
                    cnt = 0;
                    for jj = 1:length(Meting)
                        cnt = cnt + Meting(jj).setnr;
                        if metnumber
                            Meting(jj).serienaam = sprintf(newname,cnt);
                        else
                            Meting(jj).serienaam = newname;
                        end
                    end
                end
                if (length(Meting(1).SEGMENT.name)==1) && isempty(DB)
                    Meting(1).SEGMENT.name  = [];
                    Meting(1).SEGMENT.time  = [];
                    Meting(1).SEGMENT.start = [];
                    Meting(1).SEGMENT.eind  = [];
                    Meting(1).SEGMENT.cmt  = [];
                    Meting(1).reltime  = 0;
                end
                Meting(1).filename = panels.file.name;
                if tomemory, MemoryUpdate('addtomemory'); end
            end
            Waitbar(CMD,'hide');
            if Error, break; end
            if tomemory
                panels.filenr = 0;
                MemoryUpdate('basic');
                NRNtimeline;
            else
                setmaxpars(Meting(1));
%                 doExecute(pex);
            end
            if Error, break; end
            panels.cursor.absnul = Meting(1).abstime;
            if CMD.autofull.Value
                setdaqpars(panels.zoom.tnul, panels.zoom.tend);
            else
                setdaqpars(panels.zoom.tbgn, panels.zoom.tlst);
            end
            if doask
                if ~isempty(Meting(1).SEGMENT.name) && isempty(Meting(1).adc) && isempty(DB)
                    set(CMD.zoom,'UserData',false);
                    panels.filenr = 1;
                    MemoryUpdate(1,1);
                end
                NRNtimeline;
                NRNshow(Meting);
            end
        otherwise
            Error(sprintf('File extension -%s- is not recognized',fileext)); break
	end
    break
end
NRNtimeline;
KnobGrey([CMD.Reload,CMD.Loaddata,CMD.Nextfile,CMD.Prevfile,CMD.Loadmemory]);
%
% ====== Offline cmdstack management ===============================
%
function CloseManager(~,~)
global panels
delete(gcf);
panels.h = [];

function cmdstackpush
global panels
CMD = getPANEL('CMDpanel');
die = length(panels.stacker)+1;
if die>1, panels.stacker(die) = panels.stacker(die-1); end
panels.stacker(die).win   = get(CMD.window,'String');
panels.stacker(die).txt   = get(CMD.txt,   'String');
panels.stacker(die).valid = get(CMD.valid, 'Value');   

function cmdstackpull
global panels
CMD = getPANEL('CMDpanel');
for ii=1:4
    set(CMD.window(ii),'String',panels.stacker(end).win{ii});
    set(CMD.txt(ii),   'String',panels.stacker(end).txt{ii});
    set(CMD.valid(ii), 'Value', panels.stacker(end).valid{ii});
end  
if length(panels.stacker)>1, panels.stacker(end) = []; end


%
% ====== Mouse interactions ===============================================
%
function [xmin,xmax,ymin,ymax,dx,dy] = getscales
hlp = get(gca,'XLim');
xmin = hlp(1);
xmax = hlp(2);
dx = xmax-xmin;
hlp = get(gca,'YLim');
ymin = hlp(1);
ymax = hlp(2);
dy = ymax - ymin;

function TopTime(timeabs,timerel,txt)
T0 = datevec(timeabs);
set(gcf,'Name',sprintf('Date:  %02u-%02u-%04u    Time:  %02u:%02u:%5.3f  (%6.3f %s after start)',T0([3 2 1]),T0([4 5 6]),timerel,txt));

function CursorShow(handle,xnew,ynew,init,metnul)
global panels
parent = get(handle,'Parent');
gbuf   = get(parent,'UserData');
lbuf   = get(handle,'UserData');
if strcmp(gbuf.type,'spectrum')
    gbuf.refhandle = [];
    xas = get(handle,'XData');
    yas = get(handle,'YData');
    index = find(xas>xnew,1);
    if init
        gbuf.curhandle = line('XData',xas(index),'YData',yas(index),...
                              'LineStyle','none','Marker','o','MarkerSize',12,'Color','g','LineWidth',4);
    else
    	set(gbuf.curhandle,'XData',xas(index),'YData',yas(index));
    end
    txt = sprintf('freq %0.2f Hz,  amp = %0.0f',xas(index),yas(index));
    TextLeft(parent,txt,10);
    set(parent,'UserData',gbuf);
    return
end
gain = lbuf.yas.scale(3)/gbuf.yscale(2);
xas = get(handle,'XData');
yas = get(handle,'YData');
index = find(xas>xnew,1);
if isempty(index), index = round(0.5 *(xas(1)+xas(end))); end
hlp = get(parent,'XLim'); dx = hlp(2)-hlp(1);
hlp = get(parent,'YLim'); dy = hlp(2)-hlp(1);
if panels.cursor.smooth && ~strcmp(get(parent,'Xscale'),'log')
    pmin = max(1,index-150);
    pmax = min(length(yas),index + 150);
    xpnt = xas(pmin:pmax);
    ypnt = yas(pmin:pmax);
    [~,pnt] = min(((ynew-ypnt)/dy).^2 +((xnew-xpnt)/dx).^2);
    index = pmin + pnt - 1;
end
hlptxt = '';
if metnul
    if init
        gbuf.xnul = xas(index);
        gbuf.ynul = yas(index);
        gbuf.inul = index + lbuf.xas.idx(1);
        gbuf.refhandle = line('XData',xas(index),'YData',yas(index),'LineStyle','none','Marker','o','MarkerSize',12,'Color','r','LineWidth',4);
    else
        frq = abs(xas(index)-gbuf.xnul);
        if frq>0, hlptxt = sprintf(' (%0.2f Hz)',1000/(panels.timegain*frq)); end
    end
else
    gbuf.xnul = 0;
    gbuf.ynul = 0;
    gbuf.inul = 0;
    gbuf.refhandle = [];
end
txt = sprintf('\n  channel %u\n%10.4f %s  %s\n%10.4f %s(%d)\n%10d pnt',...
              lbuf.wie.chn,...
              xas(index)-gbuf.xnul,...
              lbuf.xas.unit,... 
              hlptxt,...
              gain * yas(index) - lbuf.yas.scale(2) - gbuf.ynul,...
              lbuf.yas.unit,...
              round(yas(index)/lbuf.yas.adcgain),...
              index+lbuf.xas.idx(1)-gbuf.inul);
if init
    if panels.informule
        gbuf.curhandle = line('XData',[1 1]*xas(index),'YData',[symin symax],...
                              'LineStyle',':','Color','g','LineWidth',2);
    else
        gbuf.curhandle = line('XData',xas(index),'YData',yas(index),...
                                 'LineStyle','none','Marker','o','MarkerSize',12,'Color','g','LineWidth',4);
    end
else
    if panels.informule
        set(gbuf.curhandle,'XData',[1 1]*xas(index));
    else
        set(gbuf.curhandle,'XData',xas(index),'YData',yas(index));
    end
end
set(parent,'UserData',gbuf)
for jj = 1:length(panels.cursor.shadow)
    set(panels.cursor.shadow(jj),'XData',xas(index)*[1 1]);
end
TextLeft(parent,txt,10);
                       
function CursorFinish(src,evnt)
global panels
gbuf = get(get(src,'CurrentAxes'),'UserData');
if ishandle(gbuf.curhandle), delete(gbuf.curhandle); end; gbuf.curhandle = [];
if ishandle(gbuf.refhandle), delete(gbuf.refhandle); end; gbuf.refhandle = [];
panels.informule = false;
set(gcf,'WindowButtonMotionFcn','','WindowButtonUpFcn','','BusyAction','queue');

function CursorMove(src, evnt, shift, handle)
if isvalid(handle)
    [xpnt,ypnt] = getmouse;
    CursorShow(handle,xpnt,ypnt,false,shift);    
else
    CursorFinish(src,evnt); 
end 
%
%
%  special for femke's respons
%
function FemkeShow(wie)
global panels
gbuf = get(gca,'UserData');
lbuf = get(gbuf.handles.trace(1),'UserData');
xas  = panels.timegain * get(gbuf.handles.trace(1),'XData')';
yas  = get(gbuf.handles.trace(1),'YData')';
sxmin = xas(1);
sxmax = xas(end);
ylims = gbuf.yscale;
if (length(panels.cursor.femke)<4) || (panels.cursor.femke(1)<sxmin) || (panels.cursor.femke(4)>sxmax)
        dx = 0.2*(sxmax - sxmin);
        panels.cursor.femke = [sxmin+dx sxmin+2*dx sxmin+3*dx sxmin+4*dx];
end
panels.cursor.femke  = sort(panels.cursor.femke);
index(1:4) = 0;
for jj = 1:4
    index(jj) = find(xas>panels.cursor.femke(jj),1,'first');
end
times = panels.cursor.femke;
yval1 = mean(yas(index(1):panels.cursor.resample:index(2)));
yval2 = mean(yas(index(3):panels.cursor.resample:index(4)));
if panels.cursor.resolution>=1
    ydrm1 = std(yas(index(1):panels.cursor.resample:index(2)));
    ydrm2 = std(yas(index(3):panels.cursor.resample:index(4)));
    ylim1 = yval1+panels.cursor.resolution*ydrm1;
    ylim2 = yval2-panels.cursor.resolution*ydrm2;
    txt   = sprintf('Based on %u x stdev criterion',panels.cursor.resolution);
else
    dy    = yval2-yval1;
    ylim1 = yval1+panels.cursor.resolution*dy;
    ylim2 = yval2-panels.cursor.resolution*dy;
    txt   = sprintf('Based on %u%% criterion',round(100*panels.cursor.resolution));
end
die = find((yas(index(2):panels.cursor.resample:index(3))>ylim1) & (yas(index(2):panels.cursor.resample:index(3))<ylim2));
die = index(2) + die * panels.cursor.resample;
x1  = xas(index(2));
x2  = xas(index(3));
if length(die)<4
    y1 = yval1;
    y2 = yval2;
    slopex = [x1 x2];
    slopey = [y1 y2];
    xc1 = x1;
    xc2 = x2;
    c = [NaN,NaN];
else
    slopey = yas(die);
    slopex = xas(die);
    warning off
    c = robustfit(slopex,slopey);
    warning on
    y1 = c(1)+c(2)*x1;
    y2 = c(1)+c(2)*x2;
    xc1 = (yval1-c(1))/c(2);
    xc2 = (yval2-c(1))/c(2);
end
xmark = [xc1   (xc1+xc2)/2     xc2    sxmax];
ymark = [yval1 (yval1+yval2)/2 yval2];
femtes{1} = txt;
femtes{2} = lbuf.yas.unit;
femres(1) = yval1;
femres(2) = times(1)/1000;
femres(3) = times(2)/1000;
femres(4) = yval2;
femres(5) = times(3)/1000;
femres(6) = times(4)/1000;
femres(7) = xc1/1000;
femres(8) = xc2/1000;
femres(9) = c(2)*1000;
drmp = round(ymark(2));
if yval2>yval1
    lst = find((yas(index(3):end-1)>drmp) & (yas(index(3)+1:end)<=drmp));
else
    lst = find((yas(index(3):end-1)<drmp) & (yas(index(3)+1:end)>=drmp));
end
if isempty(lst)
    times(5)   = inf;
    femres(10) = NaN;
else
    times(5)   = xas(index(3)+lst(1));
    femres(10) = (times(5) - xmark(2))/1000;
end
ftxt = ' %s\n startlevel %6.1f (%s) %6.2f--%6.2f s\n  eindlevel %6.1f (%s) %6.2f--%6.2f s';
ftxt = [ftxt '\n\n  begin %8.2f s\n midden %8.2f s slope %8.3f %s/s\n    end %8.2f s\n\n duration %6.2f s'];
txt  = sprintf(ftxt,femtes{1},femres(1),femtes{2},femres(2:3),femres(4),femtes{2},femres(5:7),0.5*(femres(7)+femres(8)),femres(9),femtes{2},femres(8),femres(10)); 
panels.cursor.femtes = femtes;
panels.cursor.femres = femres;
TextLeft(gca,txt);
times = times/panels.timegain;
xmark = xmark/panels.timegain;
if wie==0
%     for ii = 1:length(panels.cursor.fline), if ishandle(panels.cursor.fline(ii)), delete(panels.cursor.fline); end; end
    panels.cursor.fline(1) = line('XData',[times(1) times(1)],'YData',ylims,'Color','b','LineStyle','--','LineWidth',1,'ButtonDownFcn',{@Femkeklik,1});
    panels.cursor.fline(2) = line('XData',[times(2) times(2)],'YData',ylims,'Color','g','LineStyle','--','LineWidth',1,'ButtonDownFcn',{@Femkeklik,2});
    panels.cursor.fline(3) = line('XData',[times(3) times(3)],'YData',ylims,'Color','r','LineStyle','--','LineWidth',1,'ButtonDownFcn',{@Femkeklik,3});
    panels.cursor.fline(4) = line('XData',[times(4) times(4)],'YData',ylims,'Color','m','LineStyle','--','LineWidth',1,'ButtonDownFcn',{@Femkeklik,4});
    panels.cursor.fline(5) = line('XData',[times(2) times(4)],'YData',[yval2 yval2],'Color','b','LineStyle','--','LineWidth',2);
    panels.cursor.fline(6) = line('XData',[times(2) times(4)],'YData',[ylim2 ylim2],'Color','b','LineStyle','--','LineWidth',1);
    panels.cursor.fline(7) = line('XData',[times(1) times(3)],'YData',[yval1 yval1],'Color','b','LineStyle','--','LineWidth',2);
    panels.cursor.fline(8) = line('XData',[times(1) times(3)],'YData',[ylim1 ylim1],'Color','b','LineStyle','--','LineWidth',1);
    panels.cursor.fline(9) = line('XData',slopex/panels.timegain,             'YData',slopey,       'Color','m','LineStyle','-','LineWidth',1);
    panels.cursor.fline(10)= line('XData',[x1 x2]/panels.timegain,            'YData',[y1 y2],      'Color','r','LineStyle','-','LineWidth',2);    
    panels.cursor.fline(11)= line('XData',xmark([1 3]),       'YData',ymark([1 3]),       'LineStyle','none','LineWidth',2,'Marker','o','Markersize',10,'MarkerFaceColor','g','MarkerEdgeColor','b');
    panels.cursor.fline(12)= line('XData',xmark(2),           'YData',ymark(2),           'LineStyle','none','LineWidth',2,'Marker','o','Markersize',10,'MarkerFaceColor','y','MarkerEdgeColor','b');
    panels.cursor.fline(13)= line('XData',xmark([2 4]),       'YData',[ymark(2) ymark(2)],'LineStyle','--',  'LineWidth',1,'Color','b');
    panels.cursor.fline(14)= line('XData',times(5),           'YData',ymark(2),           'LineStyle','none','LineWidth',2,'Marker','o','Markersize',10,'MarkerFaceColor','y','MarkerEdgeColor','b');
else
    set(panels.cursor.fline( 1),'XData',times([1 1]));
    set(panels.cursor.fline( 2),'XData',times([2 2]));
    set(panels.cursor.fline( 3),'XData',times([3 3]));
    set(panels.cursor.fline( 4),'XData',times([4 4]));
    set(panels.cursor.fline( 5),'XData',times([2 4]), 'YData',[yval2 yval2]);
    set(panels.cursor.fline( 6),'XData',times([2 4]), 'YData',[ylim2 ylim2]);
    set(panels.cursor.fline( 7),'XData',times([1 3]), 'YData',[yval1 yval1]);
    set(panels.cursor.fline( 8),'XData',times([1 3]), 'YData',[ylim1 ylim1]);
    set(panels.cursor.fline( 9),'XData',slopex/panels.timegain,       'YData',slopey);
    set(panels.cursor.fline(10),'XData',[x1 x2]/panels.timegain,      'YData',[y1 y2]);
    set(panels.cursor.fline(11),'XData',xmark([1 3]), 'YData',ymark([1 3]));
    set(panels.cursor.fline(12),'XData',xmark(2),     'YData',ymark(2));
    set(panels.cursor.fline(13),'XData',xmark([2 4]), 'YData',[ymark(2) ymark(2)]);
    set(panels.cursor.fline(14),'XData',times(5),     'YData',ymark(2));
end
drawnow;

function FemkeMove(src,evnt,nr)
global panels
[xpnt,ypnt,left,right] = getmouse;
xpnt = xpnt * panels.timegain;
tmp = get(gca,'XLim') * panels.timegain;
if left
    hlp(nr) = panels.cursor.femke(nr) - (panels.cursor.femke(nr) - xpnt);
    panels.cursor.femke(nr) = hlp(nr);
elseif right
    hlp = panels.cursor.femke - (panels.cursor.femke(nr) - xpnt);
    panels.cursor.femke = hlp;
end
if (hlp(nr)>=tmp(1))&&(hlp(nr)<=tmp(2)), FemkeShow(nr); end

function FemkeFinish(~,~)
set(gcf,'WindowButtonMotionFcn','','WindowButtonUpFcn','','BusyAction','queue')

function Femkeklik(~,~,nr)
set(gcf,'WindowButtonMotionFcn',{@FemkeMove,nr},'BusyAction','cancel','WindowButtonUpFcn',{@FemkeFinish})

function NRNklik(hObject,~,channelnr)
global Meting panels SEL IMG events
CMD = getPANEL('CMDpanel');
DB  = getPANEL('DBpanel');
[sxpnt,sypnt,left,right,shift,dubbel] = getmouse;
xpnt = sxpnt * panels.timegain;
if left && ~isempty(SEL) && ~strcmp(hObject.Type,'axes')
    lbuf = hObject.UserData;
    metnr = lbuf.wie.met;
    gbuf = hObject.Parent.UserData;
    if SEL.metvideo && SEL.mark.Value
        panels.video.cage = gbuf.grp(lbuf.wie.nr);
        panels.video.time = sxpnt * panels.timegain;
        SEL.reset.cursor  = panels.video.time;
        SEL.reset.segnr   = panels.segnr;
        SEL.cursor.color  = hObject.Color;
        SEL.time.String   = sprintf('%0.2f',panels.video.time/1000);
        [SEL.reset.start,SEL.reset.einde] = getdaqpars;
        set(SEL.cursor.handle,'Xdata',sxpnt * [1 1],'YData',lbuf.yas.scale([1,3]),'Color',SEL.cursor.color);
        showvideo;
        return
    end
    if ~isempty(DB) && dubbel
        startnewevent;
        DB.edit.UserData.mouse = true;
        left  = true;
        right = false;
    end
    if KnobIsRed(SEL.follow) && (gbuf.useselect==1)
        tmpnr = str2double(get(SEL.select3,'String'));
        set(SEL.select3,'String',sprintf('%u',channelnr));
        ratnr = Meting(metnr).ADC.scale(channelnr).Group;
        subnr = Meting(metnr).ADC.scale(channelnr).Subgroup;
        kies  = find(cell2mat(get([SEL.sth],'Value')));
        if ((ratnr<=length(SEL.sth)) && ~isempty(kies)) || (channelnr~=tmpnr)  % || (isempty(find(ismember(kies,ratnr)))))
            set(SEL.sth(kies),'Value',0);
            set(SEL.sth(ratnr),'Value',1);
            hlpplot = panels.plotter;
            hlpas = get(panels.root,'CurrentAxes');
            panels.plotter = [];
            cnt = 0;
            for jj = 1:4
                ww = round(str2double(get(CMD.window(jj),'String')));
                tt = get(CMD.txt(jj),'String');
                present = contains(tt,'select2') || contains(tt,'select3');
                if get(CMD.valid(jj),'Value') && (ww>0) && ~isempty(tt) && present
                    cnt = cnt + 1;
                    panels.plotter(cnt).window = ww;
                    panels.plotter(cnt).struct = '';
                    panels.plotter(cnt).mode   = tt;
                    panels.plotter(cnt).metnr  = metnr;
                    panels.plotter(cnt).subnr  = subnr;
                end
            end
            NRNshow(Meting);
            panels.plotter = hlpplot;
            set(panels.root,'CurrentAxes',hlpas);
            return
        end
    end
end
if ~isempty(DB) && DB.edit.UserData.mouse
    lbuf = hObject.UserData;
    metnr = lbuf.wie.met;
    if right
        events.tmp.last = sxpnt;
        DB.right.String = sprintf(panels.timefrmt,sxpnt);
    else
        events.tmp.first = sxpnt;
        DB.left.String = sprintf(panels.timefrmt,sxpnt);
    end
    events.tmp.kanaal = uint16(channelnr);
    ratname = Meting.ADC.scale(channelnr).Name;
    borders = strfind(ratname,'-');
    if isempty(borders)
        borders = strfind(ratname,' ');
        set(DB.grp,'String',ratname((borders(1)+1):(borders(2)-1)));
    else
        set(DB.grp,'String',ratname((borders(1)+1):(borders(end)-1)));
    end
    set(DB.filnr,'String',sprintf('%u', panels.filenr));
    set(DB.segnr,'String',sprintf('%u', panels.segnr));
    set(DB.chn,  'String',sprintf('%u', events.tmp.kanaal));
    if isempty(DB.edit.UserData.handle) || ~ishandle(DB.edit.UserData.handle(1))
        txt = 'defining';
        parent = gca;
        ylims = get(parent,'YLim');
        eventnr = str2double(get(DB.nr,'String'));
        DB.edit.UserData.handle(1) = line(events.tmp.first*[1 1], ylims,'Color','b','Parent',parent,...
                                          'LineStyle',':','LineWidth',2,'ButtonDownFcn',{@Eventklik,eventnr});
        DB.edit.UserData.handle(2) = line(events.tmp.last *[1 1], ylims,'Color','b','Parent',parent,...
                                          'LineStyle',':','LineWidth',2,'ButtonDownFcn',{@Eventklik,eventnr});
        DB.edit.UserData.handle(3) = text(events.tmp.first,ylims(1),txt,'Color','k','Parent',parent,...
                                          'VerticalAlignment','Bottom','FontSize',12,'Fontname','Courier');
    else
        set(DB.edit.UserData.handle(1),'XData',events.tmp.first*[1 1]);
        set(DB.edit.UserData.handle(2),'XData',events.tmp.last *[1 1]);
        pos = get(DB.edit.UserData.handle(3),'Position');
        pos(1) = events.tmp.first;
        set(DB.edit.UserData.handle(3),'Position',pos);
    end
elseif KnobIsRed(CMD.startknob) || KnobIsRed(CMD.eindknob)
    Zoomstack(CMD);
    [start,einde] = getdaqpars;
    if KnobIsRed(CMD.startknob)
        KnobGrey(CMD.startknob);
        start = xpnt;
    else
        KnobGrey(CMD.eindknob);
        einde = xpnt;
    end
    setdaqpars(start, einde);
    if ~isempty(DB), DB.edit.UserData.mouse = false; end
    set(panels.root,'Pointer','arrow');
    Redraw(1)
else
    if right || strcmp(hObject.Type,'axes')
        Zoomstack(CMD);
        CMD.autofull.Value = 0;
        [start,einde] = getdaqpars;
        x1 = xpnt;
        rbbox;
        cors = get(gca,'CurrentPoint');
        x2   = cors(1,1)*panels.timegain;
        if x1<x2
            start = x1;
            einde = x2;
        elseif x2<x1
            start = x2;
            einde = x1;
        end
        dozoom = true;
        if ~isempty(IMG.pnl.handle), dozoom = ~KnobIsRed(IMG.pnl.exclude); end
        if dozoom
            setdaqpars(start,einde);
            if ~isempty(DB), DB.edit.UserData.mouse = false; end
            set(panels.root,'Pointer','arrow');
            Redraw(1)
        else
            nxt = size(IMG.basic.exclude,1)+1;
            bldnrs = find((IMG.xas{1,1}>=start) & IMG.xas{1,1}<=einde)';
            IMG.basic.exclude(nxt,1:2) = bldnrs([1,end]);
            IMG_Callback(IMG.pnl.peaks,[])
        end
    else
        if ~isempty(hObject.UserData)
            metnr = hObject.UserData.wie.met;
            TopTime(Meting(metnr).abstime + (sxpnt*panels.timegain/(1000*24*60*60)),sxpnt,panels.timetxt);
        end
        CursorShow(hObject,sxpnt,sypnt,true,shift);
        set(panels.root,'WindowButtonUpFcn',{@CursorFinish},'WindowButtonMotionFcn',{@CursorMove,shift,hObject},'BusyAction','cancel');
    end
end

function showinhoud(tklik,right)
global Meting timeline
knop  = timeline.par(tklik,1);
idx0  = timeline.par(tklik,3);
if ~isstruct(Meting(idx0).result), return; end
idx1  = timeline.idx(tklik,2);
idx2  = timeline.idx(tklik,3);
chan  = timeline.idx(tklik,5); 
names = fieldnames(Meting(idx0).result);
resnaam = names{max(1,idx1)};
startnode = Meting(idx0).result.(resnaam);
basnode   = Meting(idx0).result.(resnaam).basis;
MEA = getPANEL('MEApanel');
if ~isempty(MEA)
    kanaal = MEA.green.UserData;
    kanaalidx = find(abs(basnode.kanaal)==kanaal);
elseif isfield(basnode,'kanaal') && ~isempty(basnode.kanaal)
    kanaal = basnode.kanaal(chan);
    kanaalidx = chan;
else
    kanaal = 1;
    kanaalidx = 1;
end
detitel = sprintf('%s/%s - from file: %s  kanaal %u',basnode.label{1},basnode.label{2},basnode.file,kanaal);
txt = [];
txt{1,1} = '';
cnt = 2;
if ((knop==8) || (knop==1)) && right
    txt{cnt,1} = sprintf('set: %s,  node: %s (%u),  struct: %s,', Meting(idx0).serienaam, Meting(idx0).nodenaam, idx0, resnaam);
    rows = size(basnode.metswp,2);
    txt{cnt,1} = sprintf('%s  #mets-swps-loops: %u',txt{cnt,1},rows);
    if isfield(basnode,'formulas')
        cnt = cnt + 2;
        txt{cnt,1} = 'Formulas:';
        for ii2 = 1:length(basnode.formulas)
            cnt = cnt + 1;
            txt{cnt,1} = sprintf('%3u: %s',ii2,basnode.formulas{ii2});
        end
    elseif isfield(startnode,'spkstats')
        txt{cnt,1} = sprintf('%s  #spikes: %u',txt{cnt,1},sum([startnode.nspks]));
    end
    cnt = cnt + 2;
    txt{cnt,1} = 'Plot instructions:';
    for ii2 = 1:length(basnode.plotter)
        cnt = cnt + 1;
        txt{cnt,1} = sprintf('  window(%02s), %s, %s',basnode.plotter(ii2).window,...
                                                      basnode.plotter(ii2).struct,...
                                                      basnode.plotter(ii2).mode);
    end
    if ~isempty(basnode.rechts)
        cnt = cnt + 2;
        txt{cnt,1} = 'Script for right moude click';
        for ii2 = 1:length(basnode.rechts)
            cnt = cnt + 1;
            txt{cnt,1} = sprintf(' %s',basnode.rechts{ii2});
       end
    end
    cnt = cnt + 2;
    txt{cnt,1} = 'Data:';
    if isfield(basnode,'kanaal') && ~isempty(basnode.kanaal)
        cnt = cnt + 1;
        txt{cnt,1} = ['multiple channels: ' sprintf(' %d',round(basnode.kanaal))];
    end
    subnames = fieldnames(startnode);
    for ii2 = 1:length(subnames)
        subnaam = subnames{ii2};
        [d2,d1] = size(startnode.(subnaam));
        if (d2*d1)==1, dimtxt = ''; else, dimtxt = sprintf('(%ux%u) ',d2,d1); end
        if isstruct(startnode.(subnaam)) && ~strcmp(subnaam,'basis')    &&...
                                            ~strcmp(subnaam,'scratch')  &&...
                                            ~strcmp(subnaam,'fitter')   &&...
                                            ~strcmp(subnaam,'spkstats') &&...
                                            ~strcmp(subnaam,'APs')
            subsubs = fieldnames(startnode.(subnaam));
            if (d2*d1)==1  
                for ii3 = 1:length(subsubs)
                    [d2,d1] = size(startnode.(subnaam).(subsubs{ii3}));
                    cnt = cnt + 1;
                    txt{cnt,1} = sprintf('--  %s.%s (%ux%u)',subnaam,subsubs{ii3},d2,d1);
                end
            else
                for ii3 = 1:length(subsubs)
                    cnt = cnt + 1;
                    txt{cnt,1} = sprintf('--  %s.%s %s',subnaam,subsubs{ii3},dimtxt);
                end
            end
        else
            switch subnaam
                case 'basis'
                    cnt = cnt + 1;
                    txt{cnt,1} = ['--  ' dimtxt subnaam];
                case 'scratch'
                    cnt = cnt + 1;
                    txt{cnt,1} = ['--  ' subnaam];
                case 'spkstats'
                    cnt = cnt + 1;
                    if isempty(startnode.spkstats)
                        txt{cnt,1} = sprintf('--  spikestats is empty');
                    else
                        txt{cnt,1} = sprintf('--  spikestats');
                        [n1,n2] = size(startnode.spkstats.idxs);
                        for ii = 1:n1
                            cnt = cnt + 1;
                            htxt = sprintf(' --  spiketrain: %u ',ii);
                            for iii = 1:n2
                                htxt = sprintf('%s (%u)',htxt,length(startnode.spkstats.idxs{ii,iii}));
                            end
                            txt{cnt,1} = htxt;
                        end
                    end
                case 'fitter'
                    cnt = cnt + 1;
                    if isempty(startnode.fitter)
                        txt{cnt,1} = sprintf('--  fitter is empty');
                    else
                        txt{cnt,1} = sprintf('--  fitter (%u)',d2);
                        for ii = 1:size(startnode.fitter,1)
                            cnt = cnt + 1;
                            if isempty(startnode.fitter{ii,1})
                                txt{cnt,1} = sprintf('     %+2u, no data to fit',ii);
                            else
                                txt{cnt,1} = sprintf('     %+2u, %-20s, %s, %s',ii,startnode.fitter{ii,1}.model,...
                                                                                   startnode.fitter{ii,1}.source.struct,...
                                                                                   startnode.fitter{ii,1}.source.mode);
                            end
                        end
                    end
                case 'APs'
                    cnt = cnt + 1;
                    if isempty(startnode.APs)
                        txt{cnt,1} = sprintf('--  APs is empty');
                    else
                        npnt = size(startnode.APs{end}.yas,1);
                        txt{cnt,1} = sprintf('--  %s (%u * %u)',subnaam,d2,npnt);
                        for ii = 1:size(startnode.APs,1)
                            cnt = cnt + 1;
                            if isempty(startnode.APs{ii,1})
                                txt{cnt,1} = sprintf('  -- %+3u, no APs in this trace',ii);
                            else
                                [nap1,nap2] = size(Meting(idx0).result.(resnaam).APs{ii}.yas);
                                txt{cnt,1}  = sprintf('  -- %+3u  APs',nap2);
                            end
                        end
                    end
                    cnt = cnt + 1;
                otherwise
                    cnt = cnt + 1;
                    if iscell(startnode.(subnaam))
                        txt{cnt,1} = sprintf('--  arrays of %s %s',subnaam,dimtxt);
                    else
                        txt{cnt,1} = sprintf('--  %s %s',subnaam,dimtxt);
                    end
            end
        end
    end
elseif (knop==7)
    txt{cnt,1} = sprintf('Meting(%u)',idx0);
    cnt = cnt + 1;
    txt{cnt,1} = sprintf('setnaam  : %s   nodenaam : %s  struct   : %s.fitter',Meting(idx0).serienaam,Meting(idx0).nodenaam,resnaam);
    cnt = cnt + 2;
    txt{cnt,1} = sprintf('Bron     : %s  %s',  startnode.fitter{idx2}.source.struct, startnode.fitter{idx2}.source.mode);
    cnt = cnt + 1;
    txt{cnt,1} = sprintf('Result   : %s   %s', startnode.fitter{idx2}.plotter.mode, startnode.fitter{idx2}.model);
    cnt = cnt + 1;
    txt{cnt,1} = sprintf('with:');
    for ii = 1:length(startnode.fitter{idx2,1}.names)
        cnt = cnt + 1;
        txt{cnt,1} = sprintf('%5s =  %7s,  %8.3f  (%0.3f)',startnode.fitter{idx2}.n{ii}, startnode.fitter{idx2}.names{ii},...
                                                           startnode.fitter{idx2}.v(ii), startnode.fitter{idx2}.dv(ii));
    end
    cnt = cnt + 1;
    txt{cnt,1} = sprintf('error    : %0.3f',startnode.fitter{idx2}.error);
else
    txt{2,1} = ' ser met nod swp lop    time';
    txt{3,1} = '                            ';
    cnt = 3;
    first = true;
    subnames = fieldnames(startnode);
    rows = size(basnode.metswp,1);
    for rownr = 1:rows
        seridx  = basnode.metswp(rownr,1);
        metidx  = basnode.metswp(rownr,2);
        nodidx  = basnode.metswp(rownr,5);
        swpidx  = basnode.metswp(rownr,3);
        lopidx  = basnode.metswp(rownr,4);
        swptijd = basnode.times(rownr);
        if max(basnode.times)>5000, frmt = ' %9.1f'; else, frmt = ' %9.2f'; end
        cnt = cnt + 1;                                                     
        txt{cnt,1} = sprintf(['%3u %3u %3u %3u %3u' frmt], seridx, metidx, nodidx, swpidx, lopidx, swptijd);
        for ii = 1:length(subnames)
            if strcmp(subnames{ii},'basis')
                continue
            elseif isempty(startnode.(subnames{ii}))
                continue;
            elseif iscell(startnode.(subnames{ii}))
                continue;
            elseif isstruct(startnode.(subnames{ii}))
                hlpnames = fieldnames(startnode.(subnames{ii}));
                for iii = 1:length(hlpnames)
                    subdim = size(startnode.(subnames{ii}).(hlpnames{iii}),1);
                    if subdim==rows
                        val = startnode.(subnames{ii}).(hlpnames{iii})(rownr,kanaalidx);
                        if islogical(val)
                            if first
                                txt{2} = [txt{2} sprintf('%7s',subnames{ii})];
                                txt{3} = [txt{3} sprintf('%7s',hlpnames{iii})];
                            end
                            txt{cnt} = sprintf('%s%6u ',txt{cnt},val);
                        else
                            if first
                                txt{2} = [txt{2} sprintf('%10s',subnames{ii})];
                                txt{3} = [txt{3} sprintf('%10s',hlpnames{iii})];
                            end
                            txt{cnt} = sprintf('%s%10.3f',txt{cnt},val);
                        end
                    end
                end
            else
                val = startnode.(subnames{ii})(rownr,kanaalidx);
                if islogical(val)
                    if first
                        txt{2} = [txt{2} sprintf('%7s',subnames{ii})];
                        txt{3} = [txt{3} sprintf('%7s','')];
                    end
                    txt{cnt} = sprintf('%s%6u ',txt{cnt},val);
                else
                    if first
                        txt{2} = [txt{2} sprintf('%10s',subnames{ii})];
                        txt{3} = [txt{3} sprintf('%10s','')];
                    end
                    txt{cnt} = sprintf('%s%10.3f',txt{cnt},val);
                end
            end
        end
        first = false;
    end
end
textpanel(txt,detitel)

function textpanel(txt,detitel)
global panels
wmax = 0; for ii = 1:length(txt), wmax = max(wmax,length(txt{ii})); end
modus = get(0,'Units');
set(0,'Units','characters');
maxscherm = get(0,'Screensize');
set(0,'Units',modus);
breed = min(1.55*(wmax+2)/maxscherm(3),1);
hoog  = min(1.25*(size(txt,1)-1)/maxscherm(4),0.915);
pos = [0.5-0.5*breed,0.965-hoog,breed,hoog];
if isempty(panels.h)
    panels.h = figure('Toolbar','none','IntegerHandle','off','Menubar','none','NumberTitle','Off',...
                      'CloseRequestFcn',@CloseManager,'Units','normalized','Name',detitel,...
                      'Position',pos);
else
    figure(panels.h)
    set(panels.h,'Name',detitel,'Position',pos);
end
uicontrol(panels.h,'Style','Listbox','Fontsize',10,'Fontname','Courier New','Units','normalized',...
                   'String',txt,'Position',[0,0,1,1]);

               
function [xp,yp,left,right,shift,dubb] = getmouse
Pnt = get(gca,'CurrentPoint');
xp = Pnt(1,1);
yp = Pnt(1,2);
left  = false;
shift = false;
right = false;
dubb  = false;
switch get(gcf,'SelectionType')
    case 'normal', left  = true;
    case 'alt',    right = true;
    case 'extend', shift = true;
    case 'open',   dubb  = true;
end

function TXTklik(~,~,index,name)
[MINI,minihandle] = getPANEL('MINIpanel');
set(MINI.number,'String',sprintf('%u',index));
if ~isempty(name)
    metstr = get(MINI.metidx,'String');
    [~,resnaam] = strtok(name,'@');
    die = find(strcmp(metstr,resnaam(2:end)));
    set(MINI.metidx,'Value',die);
end
set(minihandle,'UserData',MINI);
MINI_Callback(MINI.nmax,[]);
if get(CMD.zoom,'UserData'), Timeklik(CMD.zoom,[],0); end

function XYklik(src, evt, nr, name)
gbuf = get(gca,'UserData');
xas = get(gbuf.handles.trace(nr),'Xdata');
yas = get(gbuf.handles.trace(nr),'Ydata');
[xpnt,ypnt] = getmouse;
dist = (xas-xpnt).*(xas-xpnt) + (yas-ypnt).*(yas-ypnt);
[~,index] = min(dist);
TXTklik(src,evt,index,name);

function Timeklik(hObject, evt, type)
global panels Memoryset Meting timeline IMG
CMD = getPANEL('CMDpanel');
MEA = getPANEL('MEApanel');
Error("clear","klik");
iobj = gco;
if isempty(Meting) || isempty(timeline.xy), NRNtimeline; return; end
if isempty(timeline.kxy)
    die = find(timeline.par(:,1)==4,1,'first');
    if isempty(die), die = 1; end
    timeline.kxy  = timeline.xy (die,:);
    timeline.kpar = timeline.par(die,:);
    timeline.kidx = timeline.idx(die,:);
end
set(hObject,'BusyAction','cancel');
panels.abort = false;
if ischar(type) && strcmp(type,'boundery')
    [xpnt, ~, isleft, ~, ~, dubbel] = getmouse;
    if panels.online || dubbel
        timeline.boundery = [-inf inf];
    elseif isleft
        timeline.boundery(1) = xpnt;
    else
        timeline.boundery(2) = xpnt;
    end
    NRNtimeline;
    return
end
prvkxy  = timeline.kxy;
prvkpar = timeline.kpar;
prvkidx = timeline.kidx;
isleft  = timeline.left;
if ischar(type) && strcmp(type,'scroller')
    if ~isempty(MEA) && MEA.cursormode.Value
        [start,einde] = getdaqpars;
        step = 0.1 * (einde - start) * str2double(CMD.Scrollfraction.String) * sign(evt.VerticalScrollCount);
        meacursor(MEA,MEA.time.Value - step);
        hhh = get(gcf,'Children');
        hans = hhh(strcmp(get(hhh,'tag'),'meaprofile'));
        for han=hans', showprofile(han,{}); end
        return
    else
        if (isempty(Meting) && isempty(Memoryset)) || (~isempty(iobj) && (iobj==CMD.script)), return; end
        dnxt = -sign(evt.VerticalScrollCount);
        if get(CMD.zoom,'UserData') || (length(Meting(1).SEGMENT.name)>1)
            shift = (panels.zoom.tlst-panels.zoom.tbgn) * dnxt * str2double(get(CMD.Scrollfraction,'String'));
            setdaqpars(panels.zoom.tbgn + shift, panels.zoom.tlst + shift);
            NRNshow(Meting);
            return
        end
        deze = find((timeline.xy(:,1)==timeline.kxy(1)) & (timeline.xy(:,2)==timeline.kxy(2)));
        delist = find(timeline.par(:,1)==timeline.kpar(1));
        if isempty(deze) || isempty(delist), return; end
        idx = max(1,min(length(delist),find(delist==deze)));
        if ~isempty(panels.mouse)
            panels.mouse = max(1,panels.mouse+dnxt);
        else
            idx = max(1,min(length(delist),find(delist==deze)+dnxt));
        end
        tklik = delist(idx);
        timeline.kxy  = timeline.xy (tklik,:);
        timeline.kpar = timeline.par(tklik,:);
        timeline.kidx = timeline.idx(tklik,:);
    end
elseif (hObject==CMD.zoom) || (hObject==CMD.setleft) || (hObject==CMD.setright)
    nodenr = timeline.kpar(3);
    subnr  = timeline.kidx(3);
    done  = false;
    switch hObject
        case CMD.zoom
            Zoom(CMD,{});
            done = true;
        case CMD.setleft
            if ~isempty(Meting(1).SEGMENT.start)
                MemoryUpdate(panels.filenr,panels.segnr-1);
                NRNshow(Meting);
                return
            elseif get(CMD.zoom,'UserData')
                if isempty(Meting(nodenr).SEGMENT.name)
                    nodenr = max(1,nodenr - 1);
                elseif isempty(panels.segnr)
                    subnr = max(1,subnr - 1);
                else
                    panels.segnr = max(1,panels.segnr - 1);
                end
            elseif ~isempty(Memoryset)
                MemoryUpdate('fileprv');
            else
                nodenr = max(1,nodenr - 1);
            end
        case CMD.setright
            if ~isempty(Meting(1).SEGMENT.start) 
                MemoryUpdate(panels.filenr,panels.segnr+1);
                NRNshow(Meting);
                return;
            elseif get(CMD.zoom,'UserData')
                if isempty(Meting(nodenr).SEGMENT.name)
                    nodenr = min(length(Meting),nodenr + 1);
                elseif isempty(panels.segnr)
                    subnr = min(size(Meting(nodenr).adc,3),subnr + 1);
                else
                    panels.segnr = min(length(Meting(1).SEGMENT.name),panels.segnr + 1);
                end
            elseif ~isempty(Memoryset)
                MemoryUpdate('filenxt');
            else
                nodenr = min(length(Meting),nodenr + 1);
            end
    end
    if ~CMD.zoom.UserData,      CMD.zoom.String = 'Zoom';
    elseif panels.segnr>0,      CMD.zoom.String = sprintf('Seg(%u)',panels.segnr);
    elseif ~isempty(Memoryset), CMD.zoom.String = sprintf('Met(%u-%u)',nodenr,panels.filenr);
    else,                       CMD.zoom.String = sprintf('Met(%u)',nodenr);
    end
    if done, return; end
    timeline.kpar(3) = nodenr;
    timeline.kidx(3) = subnr;
elseif isnumeric(type)
    [xpnt,ypnt,isleft] = getmouse;
    hhh = (timeline.xy(:,1)-xpnt).^2 + (timeline.xy(:,2)-ypnt).^2;
    [~,tklik] = min(hhh);
    timeline.kxy  = timeline.xy (tklik,:);
    timeline.kpar = timeline.par(tklik,:);
    timeline.kidx = timeline.idx(tklik,:);
    timeline.left = isleft;
end
if KnobIsRed(CMD.kill)
    doit = false;
    switch timeline.kpar(1)
        case 1
            setnr = find(timeline.idx(:,1)==timeline.kidx(1));
            if ~isempty(setnr)
                nodes = unique(timeline.par(setnr,3));
                Meting(nodes) = [];
                doit = true;
            end
        case 4
            metnr = timeline.kpar(2);
            swpnr = timeline.kidx(3);
            Meting(metnr).adc(:,:,swpnr) = [];
            Meting(metnr).reltime(swpnr) = [];
            doit = true;
        case 6
            hlp = fieldnames(Meting(timeline.kpar(3)).result);
            name = hlp{timeline.kidx(2)};
            Meting(timeline.kpar(3)).result.(name) = [];
            if length(hlp)==1
                Meting(timeline.kpar(3)).result = [];
            else
                Meting(timeline.kpar(3)).result = rmfield(Meting(timeline.kpar(3)).result,name);
            end
            doit = true;
        case 9
            DB = getPANEL('DBpanel');
            if ~isempty(DB)
                Error('You cannot delete a file from the dbase!');
            else
                todel = timeline.kpar(3);
                Memoryset(todel) = [];
                if panels.filenr>todel, panels.filenr = panels.filenr-1; end
                Redraw;
                doit = true;
            end
    end
    if isleft
        KnobGrey(CMD.kill);
        set(gcf,'Pointer','arrow');
    end
    if doit, NRNtimeline; Redraw; end
    return
elseif ~isempty(timeline.kxy) && (timeline.kpar(1)==1)
    doloop = true;
    kend = NaN;
    if prvkpar(1)==9
        timeline.kpar(1) = 3;
    elseif timeline.kidx(1) == prvkidx(1)
        timeline.kxy  = prvkxy;
        timeline.kpar = prvkpar;
        timeline.kidx = prvkidx;
        timeline.left = isleft;
    end
else
    doloop = false;
    kend = 1;
end
type  = timeline.kpar(1);
node  = timeline.kpar(3);
setnr = find(timeline.idx(:,1)==timeline.kidx(1));
idx1 = timeline.kidx(2);
idx2 = timeline.kidx(3);
idx3 = timeline.kidx(4);
idx4 = timeline.kidx(5);
if KnobIsRed(CMD.kill)
    switch type
        case {2,3,5}, tmp = Meting(node).setnr;
                      Meting(node) = [];
                      if tmp && node<=length(Meting), Meting(node).setnr = true; end
        case 4, if Meting(node).EXTRA.MEAN.aver==1
                    Meting(node) = [];
                else
                	Meting(node).EXTRA.MEAN.aver = Meting(node).EXTRA.MEAN.aver-1;
                    Meting(node).reltime(idx1) = [];
                    Meting(node).adc(:,:,idx1) = [];
                end

        case 10,numbld = length(IMG.bld);
                if numbld<2
                    IMG.bld = [];
                    IMG.nam = [];
                else
                    for jj = subnr:numbld-1
                        IMG.bld(jj,1) = IMG.bld(jj+1);
                        IMG.nam(jj,1) = IMG.nam(jj+1);
                    end
                    IMG.bld(numbld) = [];
                    IMG.nam(numbld) = [];
                end
        otherwise
            Error('Cannot be deleted');
    end
    NRNtimeline;
    if isleft
        KnobGrey(CMD.kill);
        set(gcf,'Pointer','arrow');
    end
elseif ~isleft && (type==9) 
	[~, hlpname] = fileparts(Memoryset{idx1}.Meting(1).filename);
    SetMenu(sprintf('File(%u): %s',idx1,hlpname));
else
    switch type
        case  8, showinhoud(tklik,~isleft);
        case  9, MemoryUpdate(idx1,1);
                 [~,hlpname] = fileparts(Memoryset{idx1}.Meting(1).filename);
                 SetMenu(sprintf('File: %s',hlpname));
                 Redraw(1);
        case 10, panels.plotter = [];
                 panels.plotter.window = 9;
                 panels.plotter.struct = [];
                 panels.plotter.mode   = sprintf('foto(%u)',idx1);
                 panels.plotter.metnr  = idx1;
                 panels.plotter.subnr  = idx1;
                 WindowClear;  
                 NRNshow(Meting);
        case 11, MemoryUpdate(panels.filenr,idx2);
                 NRNshow(Meting);
        otherwise
            if doloop
                deset = intersect(setnr,find(timeline.par(:,1)==type));
                switch type
                    case 2,         if isempty(deset), type=4; deset=intersect(setnr,find(timeline.par(:,1)==4)); end
                    case {3,4,6,7}, if isempty(deset), type=2; deset=intersect(setnr,find(timeline.par(:,1)==2)); end
                    case 14, deset = intersect(setnr,find((timeline.par(:,1)==14) &...
                                                          (timeline.idx(:,3)==timeline.kidx(3)) &...
                                                          (timeline.idx(:,4)==timeline.kidx(4))));
                end
                if isempty(deset), return; end
                idx1 = timeline.idx(deset,2);
                idx2 = timeline.idx(deset,3);
                idx3 = timeline.idx(deset,4);
                idx4 = timeline.idx(deset,5);
                node = timeline.par(deset,3);
                kend = length(deset);
            end
            if get(CMD.autoclear,'Value'), WindowClear; end
            if ~isempty(node)
                for kk = 1:kend
                    if ~isempty(Meting(node(kk)).result)
                        resnames = fieldnames(Meting(node(kk)).result);
                        if ~isempty(resnames), resnaam = resnames{idx1}; end
                    end
                    switch type
                        case {2,3,4,5}
                            if (kend==1) && (type==4) && ~isempty(IMG.pnl.handle)
                                set(IMG.pnl.metnr,'String',sprintf('%u',node(1)));
                                set(IMG.pnl.swpnr,'String',sprintf('%u',idx1(1)));
                                IMG.flmnr = find( (IMG.basic.mets==node(1)) & (IMG.basic.swps==idx1(1)) );
                            end
                            if isleft
                                setplotter('cmdline',Meting,node(kk),idx2(kk));
                            else
                                panels.plotter = Meting(node(kk)).plotter;
                                for jj = 1:length(panels.plotter)
                                    switch type
                                        case 3, panels.plotter(jj).mode = [strrep(panels.plotter(jj).mode,'adc','avg') '/sem(1)'];
                                        case 4, panels.plotter(jj).mode =  strrep(panels.plotter(jj).mode,'adc','swp');
                                    end
                                    panels.plotter(jj).metnr  = node(kk);
                                    panels.plotter(jj).struct = idx2(kk);
                                    panels.plotter(jj).subnr  = 1;
                                end
                            end
                        case 6, if ~isempty(MEA)
                                    MEA.node.String = resnaam;
                                    MEA.green.Visible = 'on';
                                    MEA.greenon.Value = true;
                                    MEAelektrodes(MEA);
                                end
                                CMD.timidx1.String = sprintf('%u',node(kk));
                                CMD.timidx1.String = resnaam;
                                if isleft
                                    if ~isempty(Meting(node(kk)).result.(resnaam).basis.kanaal) && (idx4(kk)>0)
                                        channr = abs(Meting(node(kk)).result.(resnaam).basis.kanaal(idx4(kk)));
                                        setplotter('struct',Meting,node(kk),resnaam,channr);
                                        CMD.timidx2.String = sprintf('%u',idx4(kk));
                                    else
                                        setplotter('struct',Meting,node(kk),resnaam,idx1(kk));
                                        CMD.timidx2.String = sprintf('%u',idx1(kk));
                                    end
                                else
                                    Script_Run("Klik-Script",string(Meting(node(kk)).result.(resnaam).basis.rechts))
                                    return;
                                end
                        case 7, setplotter('fitter',Meting,node(kk),resnaam,idx2(kk));
                        case 13,if isempty(Meting(node(kk)).result) || ~isfield(Meting(node(kk)).result,resnaam) || isempty(Meting(node(kk)).result.(resnaam).APs), return; end
                                if isleft
                                    pltcmd = sprintf('APs(%u)',idx2(kk));
                                else
                                    switch get(CMD.mousemode,'Value')
                                        case {1,2,3,4,5}, pltcmd = sprintf('APs(%u,all)',   idx2(kk));
                                        case 6, return 
                                        case 7, pltcmd = sprintf('APs(%u,traces)',idx2(kk));
                                        case 8, pltcmd = sprintf('APs(%u,map)',   idx2(kk));
                                    end
                                end
                                panels.plotter = [];
                                panels.plotter.window = 9;
                                panels.plotter.mode   = pltcmd;
                                panels.plotter.struct = resnaam;
                                panels.plotter.metnr  = node(kk);
                                panels.plotter.subnr  = [];
                                panels.last.plotter = panels.plotter;
                        case 14,if isempty(Meting(node(kk)).result) || ~isfield(Meting(node(kk)).result,resnaam), return; end
                                subnames = fieldnames(Meting(node(kk)).result.(resnaam).means);
                                subname  = subnames{idx2(kk)};
                                metswp   = Meting(node(kk)).result.(resnaam).basis.metswp;
                                sets     = unique(metswp(:,1));
                                mets     = unique(metswp(:,2));
                                pltcmd = sprintf('means.%s',subname);
                                if isleft
                                    if (length(sets)>1) && (length(mets)>1), pltcmd = sprintf('%s(set(%u),met(%u))',pltcmd,idx3,idx4);
                                    elseif length(sets)>1,                   pltcmd = sprintf('%s(set(%u))',pltcmd,idx3);
                                    elseif length(mets)>1,                   pltcmd = sprintf('%s(met(%u))',pltcmd,idx4); end
                                else
                                    switch get(CMD.mousemode,'Value')
                                        case 3, if (length(mets)==1) && (length(sets)>1), else, pltcmd = sprintf('%s(set(%u))',pltcmd,idx3); end
                                        case 4, if (length(mets)==1) && (length(sets)>1), else, pltcmd = sprintf('%s(met(%u))',pltcmd,idx4); end
                                        otherwise, pltcmd = sprintf('%s(traces(%u,%u))',pltcmd,idx3,idx4);
                                    end
                                end
                                panels.plotter = [];
                                panels.plotter.window = 9;
                                panels.plotter.mode   = pltcmd;
                                panels.plotter.metnr  = node(kk);
                                panels.plotter.struct = resnaam;
                                panels.plotter.subnr  = subname;
                                panels.last.plotter   = panels.plotter;
                        case 15
                            panels.plotter = [];
                            panels.plotter.window = Meting(node(kk)).result.(resnaam).basis.plotter.window;
                            panels.plotter.mode   = Meting(node(kk)).result.(resnaam).basis.plotter.mode;
                            if idx3(kk)==0
                                txt1 = 'stat(';
                                if isleft
                                    txt2 = sprintf('stat(class(%u),',idx2(kk));
                                else
                                    txt2 = 'stat(class,';
                                end
                            elseif idx3(kk)>0
                                txt1 = 'cluster(';
                                if isleft
                                    txt2 = sprintf('cluster(cluster(%u,%u),',idx2(kk),idx3(kk));
                                else
                                    txt2 = sprintf('cluster(cluster(%u,%u),',idx2(kk),0);
                                end
                            end
                            panels.plotter.mode   = strrep(panels.plotter.mode,txt1,txt2);
                            panels.plotter.metnr  = 1;
                            panels.plotter.struct = resnaam;
                            panels.plotter.subnr  = [];
                            panels.last.plotter   = panels.plotter;
                        case 16
                            panels.plotter = [];
                            for jjj = 1:length(Meting(node(kk)).result.(resnaam).basis.plotter)
                                panels.plotter(jjj).window = Meting(node(kk)).result.(resnaam).basis.plotter(jjj).window;
                                panels.plotter(jjj).mode   = Meting(node(kk)).result.(resnaam).basis.plotter(jjj).mode;
                                panels.plotter(jjj).subnr  = [];
                                if strfind(panels.plotter(jjj).mode,'currents')
                                    panels.plotter(jjj).struct = resnaam;
                                    panels.plotter(jjj).metnr  = node;
                                    curs = fieldnames(Meting(node(kk)).result.(resnaam).dynamic);
                                    curs = curs(2:end);
                                    if isleft
                                        newcmd = sprintf('currents(mets(%u),sets(%u),currents(%s))',idx2,idx3,curs{idx4});
                                    else
                                        if get(CMD.mousemode,'Value')==3
                                            newcmd = sprintf('currents(currents(%s),mets(0),sets(%u))',curs{idx4},idx3);
                                        elseif get(CMD.mousemode,'Value')==5
                                            newcmd = sprintf('currents(currents(IT,IS,Ca,IK,IA,IC,IH),mets(%u),sets(%u))',idx2,idx3);
                                        else
                                            newcmd = sprintf('currents(currents(%s),mets(%u),sets(0))',curs{idx4},idx2);
                                        end
                                    end
                                    [~,options] = strtok(panels.plotter(jjj).mode,'/');
                                    panels.plotter(jjj).mode = [newcmd, options];
                                else
                                    if ~isleft, panels.plotter(jjj).mode = [panels.plotter(jjj).mode,'/allmets']; end
                                    panels.plotter(jjj).struct = [];
                                    panels.plotter(jjj).metnr  = Meting(node(kk)).result.(resnaam).basis.metswp(idx2,5);
                                end
                            end
                            panels.last.plotter = panels.plotter;
                        otherwise
                    end
                    NRNshow(Meting);
                    if panels.abort, break; end
                    drawnow
                    if type==14, break; end
                end
            end
            panels.abort = false;
    end
end
Error("box");
%
% ====== managing the timeline interaction ================================
%
function datatransform(CMD)
global Meting
doel = strcmp(CMD.transform.String,'<<<');
KnobRed(CMD.transform);
all  = [Meting(1).ADC.scale.Group];
grps = unique(all);
for idx = 1:length(grps)
    kans = find(all==grps(idx));
    if ~isempty(strfind(Meting(1).ADC.scale(kans(1)).Name,'artefact')), continue; end
    mtrx = CMD.transform.UserData{length(kans)};
    if doel, mtrx = inv(mtrx); end
    Meting(1).adc(:,kans) = int16(round(double(Meting(1).adc(:,kans))*mtrx));
    Waitbar(CMD,'show',idx/length(grps),'transform');
end
Waitbar(CMD,'hide');
if doel
    CMD.transform.String = '>>>'; KnobGrey(CMD.transform);
else
    CMD.transform.String = '<<<';
end
Redraw;

function DoDeftransform(CMD,parms)
if KnobIsRed(CMD.transform), datatransform(CMD); end
hlp = CMD.transform.UserData;
for jj = 1:length(parms)
    tmp = rsingle(parms{jj});
    [col,row] = size(tmp);
    if (col==row) && (col>1)
        hlp{col} = tmp';
    else
        Error('transform must be a n x n && n>1 matrix'); return;
    end
end
CMD.transform.UserData = hlp;
CMD.transform.Visible  = 'On';
datatransform(CMD);
                              
function Zoom(CMD,parms)
global panels
[parms,present] = ParseSpecial(parms,'sec'); if present, Timescale(CMD,'sec'); end
[parms,present] = ParseSpecial(parms,'ms');  if present, Timescale(CMD,'ms'); end
[parms,present] = ParseSpecial(parms,'on');
if present, CMD.zoom.UserData = true; else
    [parms,present] = ParseSpecial(parms,'off');
    if present, CMD.zoom.UserData = false; else
        CMD.zoom.UserData = ~CMD.zoom.UserData;
    end
end
if CMD.zoom.UserData
    set([CMD.timeset;CMD.timeline.Children],'Visible','Off');
    set(CMD.EEGset, 'Visible','On');
    if isempty(parms)
        showdaqpars;
    else
        hlp = rsingle(parms{1})*panels.timegain;
        if length(hlp)==1, hlp(2) = rsingle(parms{2})*panels.timegain; end
        start = max(panels.zoom.tnul,hlp(1));
        einde = min(panels.zoom.tend,hlp(2));
        setdaqpars(start,einde);
    end
else
    set(CMD.EEGset, 'Visible','Off');
    set([CMD.timeset;CMD.timeline.Children],'Visible','On');
    NRNtimeline;
end
%
% ---- Balance functions
%
function drawreflines
global panels
sylim = get(gca,'YLim'); 
ylin = [sylim NaN sylim repmat([NaN sylim NaN sylim],1,length(panels.balans.ref1)-1)];
xlin = ylin;
for jj = 1:6:6*length(panels.balans.ref1)
    xlin(jj+[0 1]) = panels.balans.ref1((jj+5)/6);
    xlin(jj+[3 4]) = panels.balans.ref2((jj+5)/6);
end
line('XData',xlin/panels.timegain,'YData',ylin,'Color','g','LineStyle',':','LineWidth',1);

function BalanceMove(src,evnt,handle)
DrawBalance(handle);
 
function BalanceFinish(src,evnt)
set(gcf,'Pointer','arrow','WindowButtonMotionFcn','','WindowButtonUpFcn','','BusyAction','queue');

function Balanceklik(src,evnt,handle)
set(gcf,'Pointer','custom','PointerShapeCData',ones(16)+NaN,'BusyAction','cancel', 'WindowButtonMotionFcn',{@BalanceMove,handle},'WindowButtonUpFcn',@BalanceFinish);

function DrawBalance(handle,varargin)
global Meting panels
initialize = nargin>1;
gbuf = get(handle,'UserData');
lbuf = get(gbuf.handles.trace(1),'UserData');
xas  = get(gbuf.handles.trace(1),'XData');
if initialize 
    if (panels.balans.xpnt<xas(1)) || (panels.balans.xpnt>xas(end))
        xpnt = 0.5*(xas(1)+xas(end));
    else
        xpnt = panels.balans.xpnt;
    end
else
    xpnt = getmouse;
end
panels.balans.xpnt = xpnt;
metnr = lbuf.wie.met;
swpnr = lbuf.wie.swp;
timestep = (xas(2)-xas(1))/panels.timegain;
pref1 = 1+round(panels.balans.ref1/timestep);
pref2 =   round(panels.balans.ref2/timestep);
dt    = panels.balans.res * timestep;
pnt   = round(max(1+xas(1)+dt, min(xas(end)-dt,xpnt))/timestep);
pnts  = (pnt-panels.balans.res):(pnt+panels.balans.res);
yref  = mean(mean(double(Meting(metnr).adc(pref1:pref2,13:end,swpnr)),1),3)' * Meting(metnr).ADC.scale(13).User/Meting(metnr).ADC.ints;
xref  = mean(double(Meting(metnr).dac(pref1:pref2,1:length(yref))),1)' * Meting(metnr).DAC.scale(1).User/Meting(metnr).DAC.ints;
yar   = mean(mean(double(Meting(metnr).adc(pnts,13:end,swpnr)),1),3)' * Meting(metnr).ADC.scale(13).User/Meting(metnr).ADC.ints;
xar   = mean(double(Meting(metnr).dac(pnts,1:length(yar))),1)' * Meting(metnr).DAC.scale(1).User/Meting(metnr).DAC.ints;
[~,~,~,ival] = regress(yar,[ones(length(xar),1) xar]);
outlier = find( (ival(:,1).*ival(:,2))>0);
used = 1:length(xar);
notused = [];
if ~isempty(outlier)
    notused       = used(outlier);
    used(outlier) = [];
end
xlim  = [min(xar(1),panels.balans.Ei)-5 max(xar(end),panels.balans.Ee)+5];
gr    = mean(mean(double(Meting(metnr).adc(pref1:pref2,7,swpnr)),1),3) * Meting(metnr).ADC.scale(7).User/Meting(metnr).ADC.ints;
Er    = mean(mean(double(Meting(metnr).adc(pref1:pref2,2,swpnr)),1),3) * Meting(metnr).ADC.scale(2).User/Meting(metnr).ADC.ints;
ylref = gr*(xlim-Er);
Es = mean(double(Meting(metnr).adc(pnt,1,swpnr)),3) * Meting(metnr).ADC.scale(1).User/Meting(metnr).ADC.ints;
gr = mean(double(Meting(metnr).adc(pnt,7,swpnr)),3) * Meting(metnr).ADC.scale(7).User/Meting(metnr).ADC.ints;
gi = mean(double(Meting(metnr).adc(pnt,8,swpnr)),3) * Meting(metnr).ADC.scale(8).User/Meting(metnr).ADC.ints;
ge = mean(double(Meting(metnr).adc(pnt,9,swpnr)),3) * Meting(metnr).ADC.scale(9).User/Meting(metnr).ADC.ints;
yi = gi * (xlim-panels.balans.Ei);
ye = ge * (xlim-panels.balans.Ee);
ytot = (gr+gi+ge) *(xlim-Es);
txt = ['\color{black}'   sprintf('IV at section at %6.1f %s\n',xpnt,panels.timetxt)...
       '\color{magenta}' sprintf('gr: %0.1f(nS) Er: %0.1f\n\n',gr,Er)...
       '\color{red}'     sprintf('gi: %0.1f(nS) inhibition\n',gi)...
       '\color{blue}'    sprintf('ge: %0.1f(nS) excitation',ge)];
sylim = lbuf.yas.scale([1 3]);
if initialize
    drawreflines;
    gbuf.handles.balcur = line('XData',xpnt*[1 1],'YData',gbuf.yscale,...
                                 'Color','b','LineStyle',':','LineWidth',1,'ButtonDownFcn',{@Balanceklik,handle});
    parms = varargin{1};
   [parms,present,ps] = ParseSpecial(parms,'window');
    if present, window = nsingle(ps{1}); else,window = 1; end
    getplothandle(window,true);
    set(gca,'XLim',xlim,'YLim',1.1*sylim);
    grid on
    box on
    gbuf.handles.balans = [];
    gbuf.handles.balans(01) = line('XData',xlim,'YData',[0 0],'Color','k','LineStyle','--','LineWidth',2);
    gbuf.handles.balans(02) = line('XData',[xlim NaN Er Er],'YData',[ylref NaN 1.1*sylim],'Color','m','LineStyle','--','LineWidth',1.5);
    gbuf.handles.balans(03) = line('XData',xref,'YData',yref, 'Color','r','LineStyle','none','LineWidth',1,'Marker','s','MarkerSize',10,'MarkerFaceColor','y','MarkerEdgeColor','r');
    gbuf.handles.balans(04) = line('XData',xlim, 'YData',yi,   'Color','r','LineStyle','-','LineWidth',2);
    gbuf.handles.balans(05) = line('XData',xlim, 'YData',ye,   'Color','b','LineStyle','-','LineWidth',2);
    gbuf.handles.balans(06) = line('XData',xlim, 'YData',ytot, 'Color','k','LineStyle','-','LineWidth',2);
    gbuf.handles.balans(07) = line('XData',xar(used),   'YData',yar(used),   'Color','m','LineStyle','none','LineWidth',2,'Marker','o','MarkerSize',10,'MarkerFaceColor','g','MarkerEdgeColor','k');
    gbuf.handles.balans(08) = line('XData',xar(notused),'YData',yar(notused),'Color','m','LineStyle','none','LineWidth',2,'Marker','o','MarkerSize',10,'MarkerFaceColor','w','MarkerEdgeColor','k');
    gbuf.handles.balans(09) = line('XData',Es,               'YData',0,'Color','g','MarkerFaceColor','w','Marker','o','MarkerSize',10,'LineWidth',3);
    gbuf.handles.balans(10) = line('XData',panels.balans.Ei, 'YData',0,'Color','r','MarkerFaceColor','w','Marker','o','MarkerSize',8,'LineWidth',3);
    gbuf.handles.balans(11) = line('XData',panels.balans.Ee, 'YData',0,'Color','b','MarkerFaceColor','w','Marker','o','MarkerSize',8,'LineWidth',3);
    gbuf.handles.balans(12) = text(xlim(1)+1,sylim(2),txt,'HorizontalAlignment','Left','VerticalAlignment','Top','Fontsize',10,'Fontname','Courier');
    set(handle,'UserData',gbuf);
else
    set(gbuf.handles.balcur,'XData',xpnt *[1 1]);
    set(gbuf.handles.balans(01),'XData',xlim);
    set(gbuf.handles.balans(02),'XData',[xlim NaN Er Er],'YData',[ylref NaN 1.1*sylim]);
    set(gbuf.handles.balans(03),'XData',xref, 'YData',yref);
    set(gbuf.handles.balans(04),'XData',xlim, 'YData',yi);
    set(gbuf.handles.balans(05),'XData',xlim, 'YData',ye);
    set(gbuf.handles.balans(06),'XData',xlim, 'YData',ytot);
    set(gbuf.handles.balans(07),'XData',xar(used),    'YData',yar(used));
    set(gbuf.handles.balans(08),'XData',xar(notused), 'YData',yar(notused));
    set(gbuf.handles.balans(09),'XData',Es);
    set(gbuf.handles.balans(10),'XData',panels.balans.Ei);
    set(gbuf.handles.balans(11),'XData',panels.balans.Ee);
    set(gbuf.handles.balans(12),'String',txt);
    panels.cursor.xpnt = xpnt;
    showshadow;
end
%
% ---- Cross functions
%
function showcross(handle,plt)
global panels
gbuf = get(handle,'UserData');
sxlim = get(gca,'XLim'); sxmin = sxlim(1); sxmax = sxlim(2);
sylim = get(gca,'YLim'); symin = sylim(1); symax = sylim(2);
if isempty(panels.cursor.cross)||(panels.cursor.cross(1)<=sxmin*panels.timegain)||(panels.cursor.cross(1)>=sxmax*panels.timegain)
    panels.cursor.cross = panels.timegain*sum(sxlim)/2;
end
xpnts = panels.cursor.cross(1)+panels.cursor.crossset;
xas = get(gbuf.handles.trace(1),'XData')';
xpnts = xpnts(xpnts<=xas(end));
index = zeros(length(xpnts),1);
for jj = 1:length(xpnts)
    index(jj,1) = find(xas>xpnts(jj),1,'first');
    if jj==1
        xlm = xpnts(1)*[1 1];
        ylm = [symin symax];
    else
        xlm = [xlm NaN xpnts(jj)*[1 1]];
        ylm = [ylm NaN symin symax];
    end
end
if isempty(panels.cursor.crosslines)
    panels.cursor.crosslines = line('XData',xlm,'YData',ylm,'Color','g','LineStyle','--','LineWidth',1,...
                                    'ButtonDownFcn',{@Crossklik,handle,plt});
    getplothandle(plt.crosswin,true);
else
    set(panels.cursor.crosslines,'XData',xlm,'YData',ylm);
end
lens = length(gbuf.handles.trace)+1;
xdata = NaN(length(xpnts)*lens,1); 
ydata = NaN(length(xpnts)*lens,1);
for jj = 1:lens-1
    lbuf = get(gbuf.handles.trace(jj),'UserData');
    yas  = get(gbuf.handles.trace(jj),'YData');
    xdata(jj:lens:end) = yas(index)-lbuf.yas.scale(2);
    ydata(jj:lens:end) = lens-jj;
end
if isempty(panels.cursor.handle3)
    panels.cursor.handle3 = line('XData',xdata,'YData',ydata,'Color','m',...
                                 'LineStyle','-','Marker','o','MarkerSize',6,'MarkerFaceColor','g','MarkerEdgeColor','m');
    line('XData',[0 0],'YData',[1 lens-1],'Color','b','LineStyle',':');
    grid on
else
    set(panels.cursor.handle3,'XData',xdata,'YData',ydata);
end
if isempty(panels.cursor.text3)
    if lens<3
        bot = -0.1;
        top = 2.1;
    else
        bot = 0.5;
        top = lens-0.5;
    end
    axis([gbuf.yscale(2)*[-1 1] bot top]); 
    panels.cursor.text3 = text(-gbuf.yscale(2),top,sprintf('  section at %6.3f %s',xpnts(1),panels.timetxt),...
                               'HorizontalAlignment','Left','Fontsize',10,'Fontname','Courier');
else
    set(panels.cursor.text3,'String',sprintf('  section at %6.3f %s',xpnts(1),panels.timetxt))
end

function CrossMove(src,evnt,handle,plt)
global panels
xpnt = getmouse;
panels.cursor.cross = xpnt;
showcross(handle,plt)
 
function CrossFinish(src,evnt)
set(gcf,'Pointer','arrow','WindowButtonMotionFcn','','WindowButtonUpFcn','','BusyAction','queue');

function Crossklik(src,evnt,handle,plt)
set(gcf,'Pointer','custom','PointerShapeCData',ones(16)+NaN,'BusyAction','cancel',...
        'WindowButtonMotionFcn',{@CrossMove,handle,plt},'WindowButtonUpFcn',{@CrossFinish});
%
% --  MEA  -- MEA analysis
%
function meacursor(MEA,time,varargin)
global panels
MEA.time.Value  = time;
MEA.time.String = strtrim(sprintf(panels.timefrmt,time/panels.timegain));
if isempty(MEA.time.UserData.cursor1) || ~isvalid(MEA.time.UserData.cursor1)
    if isempty(varargin), return; end
    winhandle = varargin{1};
    MEA.time.UserData.cursor1 = line('XData',time / panels.timegain * [1,1],'YData',winhandle.YLim,...
                                     'Color','c','LineStyle','-','LineWidth',1,'ButtonDownFcn',{@MEAklik});
    if ~isempty(winhandle.UserData.mea.shifts)
        xhlp = (time+winhandle.UserData.mea.shifts(1)) * [1 1];
        yhlp = winhandle.YLim;
        for jj=2:length(winhandle.UserData.mea.shifts)
            xhlp = [xhlp, NaN, (time+winhandle.UserData.mea.shifts(jj)) * [1 1]];
            yhlp = [yhlp, NaN, winhandle.YLim];
        end
        MEA.time.UserData.cursor3 = line('XData',xhlp / panels.timegain,'YData',yhlp,...
                                         'Color','c','LineStyle','--','LineWidth',1);
    end
else
    winhandle = MEA.time.UserData.cursor1.Parent;
    MEA.time.UserData.cursor1.XData = time / panels.timegain * [1,1];
    if ~isempty(winhandle.UserData.mea.shifts)
        xhlp = (time+winhandle.UserData.mea.shifts(1)) * [1 1];
        for jj=2:length(winhandle.UserData.mea.shifts)
            xhlp = [xhlp, NaN, (time+winhandle.UserData.mea.shifts(jj)) * [1 1]];
        end
        MEA.time.UserData.cursor3.XData = xhlp / panels.timegain;
    end
end

function MEAmove(~,~)
global panels Meting
[xpnt,~,~,~] = getmouse;
MEA = getPANEL('MEApanel');
point = 1+round(xpnt*panels.timegain*Meting(1).ADC.rate/1000);
if point~=MEA.time.UserData.last
    MEA.time.UserData.last = point; 
    meacursor(MEA,(point-1)*1000/Meting(1).ADC.rate);
end

function MEAfinish(~,~)
set(gcf,'BusyAction','queue','Pointer','arrow','WindowButtonMotionFcn','','WindowButtonUpFcn','');
Redraw;

function MEAklik(~,~)
set(gcf,'BusyAction','cancel','Pointer','circle','WindowButtonMotionFcn',{@MEAmove},'WindowButtonUpFcn',{@MEAfinish});

function MEAelektrodes(MEA)
set(MEA.black,'XData', MEA.xx(MEA.select.UserData==1),'YData',MEA.yy(MEA.select.UserData==1));
set(MEA.red,  'XData', MEA.xx(MEA.select.UserData==2),'YData',MEA.yy(MEA.select.UserData==2));
set(MEA.blue, 'XData', MEA.xx(MEA.select.UserData==3),'YData',MEA.yy(MEA.select.UserData==3));
set(MEA.green,'XData', MEA.xx(MEA.green.UserData),'YData',MEA.yy(MEA.green.UserData));

function MEA_Callback(hObject,~)
global panels Meting
CMD = getPANEL('CMDpanel');
MEA = getPANEL('MEApanel');
dt = 1000/Meting(1).ADC.rate;
selection = [MEA.image; MEA.surf;MEA.contour; MEA.gradient; MEA.csd; MEA.surf3D];
switch hObject
    case {MEA.grid, MEA.imgnr, MEA.method, MEA.colorbar, MEA.fixed, MEA.triggers, MEA.files}
    case MEA.time,  MEA.time.Value = str2double(MEA.time.String) * panels.timegain;
    case MEA.link,  MEAimage(CMD,MEA);
    case MEA.set,   MEA.link.UserData.select = MEA.select.UserData; KnobGrey(MEA.set);
    case MEA.get,   MEA.select.UserData = MEA.link.UserData.select;
    case MEA.drempel, MEAdrempel(MEA);
    case MEA.scale,   MEA.fixed.Value = 1;
    case MEA.allred,  MEA.select.UserData(:) = 2; MEA.mode1.String = 'tog';
    case MEA.allblue, MEA.select.UserData(:) = 3; MEA.mode2.String = 'tog';
    case {MEA.image;  MEA.surf; MEA.contour; MEA.gradient; MEA.csd; MEA.surf3D}
                      set(selection(selection~=hObject),'Value',0); hObject.Value=1;
    case {MEA.colormap; MEA.levels}, setcolormap(MEA.colormap.Value,round(str2double(MEA.levels.String)));
    case MEA.greenon, if MEA.greenon.Value, txt = 'on'; else, txt = 'off'; end; MEA.green.Visible = txt;
    case MEA.close
        switch questdlg('Close of Hide MEA panel?','Confirm','Close','Hide','Cancel','Cancel')
            case 'Close'
                ClosePanel('MEApanel');
                WindowClear;
                Meting = [];
                NRNtimeline;
            case 'Hide'
                set(MEA.handle,'Visible','Off');
            case 'Cancel'
        end
        return
    case MEA.save
        Waitbar(CMD,'show',0.5,'save MEA+img file');
        mea = MEA.link.UserData;
        Meting = DACcompress(Meting);
        Meting = MeanIni(Meting);
        [filepath,filename,~] = fileparts(panels.file.name);
        if (length(Meting)>1) || (size(Meting(1).adc,3)>1)
            save(fullfile(filepath,[filename '-extract.mat']),'Meting','mea','-v7.3');
        else
            save(fullfile(filepath,[filename '.mat']),'Meting','mea','-v7.3');
        end
        Waitbar(CMD,'hide');
    case MEA.modus
        if strcmp(hObject.String,'O')
            hObject.String = 'I';
            set(MEA.fields,'Visible','Off');
%           set(MEA.spikes,'Visible','On');
        else
            hObject.String = 'O';
%           set(MEA.spikes,'Visible','Off');
            set(MEA.fields,'Visible','On');
        end
        return
    case {MEA.mode1,MEA.mode2}
        if strcmp(hObject.String,'sin'), txt = 'tog'; else, txt = 'sin'; end
        hObject.String = txt;
        return
    case {MEA.vals1, MEA.vals2}
        MEA.select.UserData(:) = 1;
        MEA.select.UserData(round(str2double(MEA.vals1.String))) = 2;
        MEA.select.UserData(round(str2double(MEA.vals2.String))) = 3;
    case {MEA.super,MEA.conlvl}
        if MEA.super.Value
            set(selection,'Value',0);
            MEA.contour.Value=1;
        end
    case MEA.multi
        die = find(MEA.scale.UserData.max==round(str2double(MEA.scale.String)),1)+1;
        if isempty(die) || (die>length(MEA.scale.UserData.max)), die = 1; end
        MEA.scale.String = sprintf('%u',MEA.scale.UserData.max(die));
        MEA.fixed.Value  = true;
    case {MEA.angle1;MEA.sangle1;MEA.angle2;MEA.sangle2}
        switch hObject
            case MEA.angle1,  MEA.sangle1.Value = str2double(MEA.angle1.String);
            case MEA.angle2,  MEA.sangle2.Value = str2double(MEA.angle2.String);
            case MEA.sangle1, MEA.angle1.String = sprintf('%d',round(MEA.sangle1.Value));
            case MEA.sangle2, MEA.angle2.String = sprintf('%d',round(MEA.sangle2.Value));
        end
        view(MEA.sangle1.Value,MEA.sangle2.Value);
        hhh = get(gcf,'Children');
        hans = hhh(strcmp(get(hhh,'tag'),'meaprofile'));
        for han=hans', showprofile(han,{}); end
        return
    case {MEA.movietime;MEA.moviestep}
        MEA.movietime.Value = str2double(MEA.movietime.String) * panels.timegain;
        MEA.moviestep.Value = max(1,round(str2double(MEA.moviestep.String)));
        return
    case MEA.movie
        if KnobIsRed(MEA.movie)
            KnobGrey(MEA.movie);
            drawnow;
        else
            KnobRed(MEA.movie);
            WindowClear;
            Redraw;
            if MEA.moviesave.Value
                vid = VideoWriter('mea0001','MPEG-4');
                vid.FrameRate = 30;  % Default 30
                vid.Quality   = 95;  % Default 75
                open(vid);
            end
            hhh = get(gcf,'Children');
            hans = hhh(strcmp(get(hhh,'tag'),'meaprofile'));
            thold = MEA.time.Value; 
            start = round(thold/dt);
            pnts  = round(MEA.movietime.Value/dt);
            step  = max(1,round(MEA.moviestep.Value));
            for jj = start:step:start+pnts
                if isvalid(MEA.time.UserData.cursor2)
                    if jj==start, chold2 = MEA.time.UserData.cursor2.XData; end
                    ctime = (MEA.time.Value-MEA.time.UserData.tmin)/(MEA.time.UserData.tmax-MEA.time.UserData.tmin);
                    MEA.time.UserData.cursor2.XData = MEA.xxp + ctime;
                end
                if isvalid(MEA.time.UserData.cursor1)
                    if jj==start, chold1 = MEA.time.UserData.cursor1.XData; end
                    meacursor(MEA,jj*dt);
                end
                for han = hans'
                    showprofile(han,{}); 
                    if han.UserData.mea.offset==0
                        if (jj==start) || ~isvalid(than)
                            than = text(han,han.XLim(2),han.YLim(1),sprintf('%0.2f ms',(jj-start)*dt),...
                                        'FontSize',12,'HorizontalAlignment','right','VerticalAlignment','Top');
                        else
                            than.String = sprintf('%0.2f ms',(jj-start)*dt);
                        end
                    elseif (jj==start)
                        text(han,han.XLim(2),han.YLim(1),sprintf('%+0.1f ms',han.UserData.mea.offset),...
                                          'FontSize',12,'HorizontalAlignment','right','VerticalAlignment','Top');
                    end
                end
                MEA.time.Value  = MEA.time.Value + step*dt;
                MEA.time.String = strtrim(sprintf(panels.timefrmt, MEA.time.Value/panels.timegain));
                drawnow;
                if MEA.moviesave.Value
                   frame = getframe(gcf);
                   writeVideo(vid,frame);
                end
                if ~KnobIsRed(MEA.movie), break; end
            end
            meacursor(MEA,thold);
            if isvalid(MEA.time.UserData.cursor1), MEA.time.UserData.cursor1.XData = chold1; end
            if isvalid(MEA.time.UserData.cursor2), MEA.time.UserData.cursor2.XData = chold2; end
            if MEA.moviesave.Value, close(vid); end
            MEA.moviesave.Value = 0;
            KnobGrey(MEA.movie);
        end
        return
    case MEA.spatial
        MEA.link.UserData.size = str2double(split(string(MEA.spatial.String),"/"));
    case MEA.setback
        Meting.adc = Meting.raw;
        MEA.setback.Visible = 'Off';
    case MEA.filter
        if MEA.keeporg.Value
            Meting.raw = Meting.adc;
            MEA.setback.Visible = 'On';
        end
        metnr = 1;
        swpnr = 1;
        adcrate = Meting(metnr).ADC.rate;
        orde = str2double(MEA.orde.String);
        freq = str2double(MEA.freq.String);
        FF1  = 2*freq/adcrate;
        [facB,facA] = butter(orde,FF1,'high');
        [~,kanalen,~] = size(Meting(metnr).adc);
        gain= str2double(MEA.gain.String);
        for jj = 1:kanalen
            yas = filtfilt(facB,facA,gain * double(Meting(metnr).adc(:,jj,1)));
            Meting(metnr).adc(:,jj,1) = int16(round(yas));
            Waitbar(CMD,'show',jj/kanalen,'filter');
        end
        Waitbar(CMD,'hide');
    otherwise
        [xpnt, ypnt, left, right, shift, dubbel] = getmouse;
        if strcmp(hObject.Tag,'mosaic')
            index = find((MEA.xx==round(xpnt+0.5)) & (MEA.yy==round(ypnt)));
        elseif strcmp(hObject.Parent.Tag,'panel')
            index = find((MEA.xx==round(xpnt)) & (MEA.yy==round(ypnt)));
        end
        if strcmpi(MEA.green.Visible,'on')
            if MEA.select.UserData(index)>1
                MEA.green.UserData = index;
                MEA.vals0.String = sprintf('%u',index);
            end
        else
            if isempty(index), return; end
            if left
                mode = 2; issingle = strcmp(MEA.mode1.String,'sin');
            elseif right
                mode = 3; issingle = strcmp(MEA.mode2.String,'sin');
            end
            if issingle
                MEA.select.UserData(MEA.select.UserData==mode)=1;
            elseif MEA.select.UserData(index)==mode
                mode = 1; 
            end
            MEA.select.UserData(index)=mode;
            vals = find(MEA.select.UserData==2); if ~isempty(vals), MEA.vals1.String = sprintf('%u',vals(1)); end
            vals = find(MEA.select.UserData==3); if ~isempty(vals), MEA.vals2.String = sprintf('%u',vals(1)); end
        end
end
MEAelektrodes(MEA);
Redraw();

function showmosaic(handle,parms)
global Meting
CMD = getPANEL('CMDpanel');
MEA = getPANEL('MEApanel');
handle.Tag           = 'mosaic';
handle.ButtonDownFcn = @MEA_Callback;
metnr = handle.UserData.mea.metnr;
swpnr = handle.UserData.mea.swpnr;
if (swpnr==0) || (swpnr>size(Meting(metnr).adc,3)), handle.UserData.mea.swpnr=1; swpnr = 1; end
[tmin,tmax] = getdaqpars;
dt = 1000/Meting(metnr).ADC.rate;
px = MEA.time.Value/dt;
p1 = 1+round(tmin/dt);
p2 = round(tmax/dt);
[parms,docluster] = ParseSpecial(parms,'cluster');
[parms,dorate]    = ParseSpecial(parms,'rate');
[~,present,ps]    = ParseSpecial(parms,'skip'); if present, skip = nsingle(ps{1}); else, skip = []; end
if isempty(skip)
    reduce = getskip(CMD,0,p2-p1+1,10);
else
    reduce = skip;
end
if isempty(Meting(metnr).result), dorate = false; docluster = false; end
xtrace = (0:reduce:(p2-p1)) / (p2-p1+1);
ctime  = (px-p1)/(p2-p1+1);
yscale = 0.5*power(10,CMD.ADCgain.Value)* handle.UserData.mea.gain/32767;
kleur  = 'krbg';
if dorate && isempty(Meting(metnr).result), return; end
numtraces = length(MEA.xx);
nolines = isempty(handle.UserData.lines) || ~ishandle(handle.UserData.lines(1));
for jj=1:numtraces
    if (jj==1) && nolines 
        MEA.time.UserData.tmin = tmin;
        MEA.time.UserData.tmax = tmax;
        set(handle,'XTick',[],'YTick',[],'XColor',[1 1 1],'YColor',[1 1 1],...
                   'XLim',[0,max(MEA.xx)],'YLim',[0.5,max(MEA.yy)+0.5]);
        handle.UserData.lines = zeros(1,numtraces);
        line('XData',MEA.xplt,'YData',MEA.yplt,'LineStyle','-','Color','black','LineWidth',1);
        if docluster
            for jjj = 1:7
                line('XData',[0,8],'YData',[jjj,jjj]+0.5,'LineStyle','-','Color','black','LineWidth',1);
            end
        end
    end
    yas = [0,0];
    xas = [0,1];
    if dorate
        index = find(abs(Meting(metnr).result.(MEA.node.String).basis.kanaal)==jj);
        if ~isempty(index)
            yas = 0.05*Meting(metnr).result.(MEA.node.String).frate{index}(p1:reduce:p2) - 0.5;
            xas = xtrace;
        end
    elseif docluster
        index = find(abs(Meting(metnr).result.(MEA.node.String).basis.kanaal)==jj);
        if isempty(index), continue; end
        time = Meting(metnr).result.(MEA.node.String).times{index};
        klas = Meting(metnr).result.(MEA.node.String).class{index};
        orde = Meting(metnr).result.(MEA.node.String).order{index};
        hold = Meting(metnr).result.(MEA.node.String).thold(index);
        intervals = diff(time)*dt;
        xx = log10(intervals(1:end-1)) - log10(hold);
        yy = log10(intervals(2:end))   - log10(hold);
        if isempty(orde), orde = 1; end
        demark = 'krbmgyckrbmgyck';
    else
        if MEA.link.UserData.valid(jj)
            yas = yscale*double(Meting(metnr).adc(p1:reduce:p2,jj,swpnr));
            xas = xtrace;
        end
    end
    if docluster
        for jjj = 1:length(orde)
            line(MEA.xx(jj)-1  +(xx(klas==abs(orde(jjj)))/5),...
                 MEA.yy(jj)-0.5+(yy(klas==abs(orde(jjj)))/5),...
                 'LineStyle','none','Marker','o','Markersize',03,'Color',demark(jjj),'LineWidth',1);
        end
    elseif nolines
        handle.UserData.lines(jj,1) = line('XData',MEA.xx(jj)-1+xas,...
                                           'YData',MEA.yy(jj)+yas,...
                                           'Color',kleur(MEA.select.UserData(jj)),'Linewidth',0.5,....
                                           'ButtonDownFcn',@MEA_Callback);

    else
        set(handle.UserData.lines(jj),'XData',MEA.xx(jj)-1+xas,...
                                      'YData',MEA.yy(jj)+yas,...
                                      'Color',kleur(MEA.select.UserData(jj)));
    end
end
if nolines
    MEA.time.UserData.cursor2 = line('XData',MEA.xxp+ctime,'YData',MEA.yyp,'Color','c','LineWidth',0.5);
else
	MEA.time.UserData.cursor2.XData = MEA.xxp + ctime;
end
MEA.time.UserData.cursor2.Visible = handle.UserData.mea.cursor;
%
% External panels
%
function ClosePanel(varargin)
global SEL
killSEL = false; 
hhh = get(gcf,'Children');
tags = get(hhh,'tag');
die = [];
for jj = 1:length(varargin)
    hlp = varargin{jj};
    if strcmp(hlp,'SELpanel'), killSEL = true; end
    die = [die find(strcmp(tags,hlp))];
end
if ~isempty(die), delete(hhh(die)); end
if killSEL, SEL = []; end

function ShowPanel(name)
hhh = get(gcf,'Children');
tags = get(hhh,'tag');
die = find(strcmp(tags,name));
if ~isempty(die), set(hhh(die),'Visible','On'); end
%
%--- SEL  routines
%
function videozoom(~,~)
global panels SEL VIDEOobj
ymax = VIDEOobj.Height;
xmax = VIDEOobj.Width;
[xpnt,ypnt,~,~] = getmouse;
x1 = min(xmax,max(1,round(xpnt))); 
y1 = min(ymax,max(1,round(ypnt)));
rbbox;
point = get(gca,'CurrentPoint');
x2 = min(xmax,max(1,round(point(1,1))));
y2 = min(ymax,max(1,round(point(1,2))));
panels.video.zoom{panels.video.cage,1} = [min(y1,y2),max(y1,y2),min(x1,x2),max(x1,x2)];
delete(SEL.image)
SEL.image = [];
showvideo;

function [filename,camera] = videofilename
global panels Meting
if isempty(Meting(1).axon.CAM)
    filename = [];
    camera   = [];
else
    if isempty(panels.file.video)
        [filepath,filename,~] = fileparts(panels.file.name);
        [panels.file.video] = uigetdir(filepath,'give the video directory');
    else
        [~,filename,~] = fileparts(panels.file.name);
    end
    if isempty(panels.video.name)
        camera = Meting(1).axon.CAM{panels.video.cage,2};
    else
        camera = panels.video.name{panels.video.cage};
    end
    filename = fullfile(panels.file.video,[camera, '-', sprintf('%s%03u',filename,panels.segnr-1),'.mp4']);
end

function showvideo(varargin)
global VIDEOobj Meting panels SEL
if nargin>0, dosingle = false; else, dosingle = true; end
set([SEL.VLCrun, SEL.VLCstp],'Visible','Off');
[videofile,camera] = videofilename();
if isempty(videofile)
    set(SEL.mark,'String',' no video');
    WindowClear(SEL.window);
    VIDEOobj = [];
    set(SEL.mark,'String','no Video');
    return
end
if isempty(VIDEOobj) || (SEL.cage~=panels.video.cage) || (panels.video.segnr~=panels.segnr)
    try
        VIDEOobj = VideoReader(videofile);
    catch
        Error("tell",sprintf('Cannot find videofile\nFolder or Camera?\n\n%s\n%s',videofile,camera));
        return
    end
    set(SEL.mark,'String',camera);
    SEL.cage  = panels.video.cage;
    panels.video.segnr = panels.segnr;
end
speed = str2double(get(SEL.speed,'String'));
step  = 1000/VIDEOobj.FrameRate;
[bgn,lst] = getdaqpars;
duur = lst - bgn;
while KnobIsRed(SEL.run) || dosingle
    dosingle = false;
    if panels.video.time>(VIDEOobj.Duration*1000+panels.zoom.tnul)
        MemoryUpdate('segnxt');
        bgn = panels.zoom.tnul;
        lst = panels.zoom.tnul + duur;
        panels.video.time = panels.zoom.tnul;
        setdaqpars(bgn,lst);
        setplotter('last',Meting);
        NRNshow(Meting);
    elseif panels.video.time>lst
        bgn = bgn + duur;
        lst = lst + duur;
        setdaqpars(bgn,lst);
        setplotter('last',Meting);
        NRNshow(Meting);
    end
    VIDEOobj.CurrentTime = (panels.video.time-panels.zoom.tnul)/1000;
%     set(SEL.time,'String',sprintf('%0.2f',panels.video.time/1000));
%     set(SEL.cursor.handle,'Xdata',panels.video.time * [1 1]/panels.timegain);
    beeld = rgb2gray(readFrame(VIDEOobj));
    try
        if ~isempty(panels.video.zoom{panels.video.cage})
            zoom = panels.video.zoom{panels.video.cage};
            beeld = beeld(zoom(1):zoom(2),zoom(3):zoom(4));
        end
    catch
        panels.video.zoom{panels.video.cage,1} = [];
    end
    switch get(SEL.filter,'Value')
        case 2, beeld = imadjust(beeld);
        case 3, beeld = adapthisteq(beeld);
        case 4, beeld = histeq(beeld);
    end
    if isempty(SEL.image) || ~isvalid(SEL.image)
%         getplothandle(SEL.window,true);
        hhhh = figure(3);
        SEL.image = imshow(beeld,'Border','tight');
%         set(SEL.image,'ButtonDownFcn',{@videozoom,handles});
    else
        set(SEL.image,'CData',beeld);
    end
    drawnow limitrate
    panels.video.time = panels.video.time + step*speed;
end
set([SEL.VLCrun, SEL.VLCstp],'Visible','On');

function VLCtimer(~,~,curhan)
global panels SEL
panels.video.time = panels.video.time+200*str2double(get(SEL.speed,'String'));
set(curhan,'XData',panels.video.time * [1 1]/panels.timegain);
set(SEL.time,'String',sprintf('%0.2f',panels.video.time/1000));

function VLCstop()
global SEL VLCobj
if ~isempty(SEL.timer)
    stop(SEL.timer);
    delete(SEL.timer);
    SEL.timer = [];
end
KnobGrey(SEL.VLCrun)
set(SEL.VLCrun,'String','VLC: run');
if isvalid(VLCobj)
    VLCobj.stop;
    delete(VLCobj);
    clear VLCobj
    VLCobj = [];
end

function SEL_Callback(hObject,~,~)
global Memoryset Meting panels SEL VIDEOobj VLCobj
CMD = getPANEL('CMDpanel');
if hObject==SEL.close
    switch questdlg('Close of Hide SEL panel?','Confirm','Close','Hide','Cancel','Cancel')
        case 'Close'
            ClosePanel('SELpanel','DBpanel','STMpanel');
            if get(CMD.zoom,'UserData'), Timeklik(CMD.zoom,[],0); end
            WindowClear;
            Memoryset = [];
            Meting    = [];
            win = {'9';  '0';  '0';  '0'};
            txt = {'adc';'adc';'dac';'dac'};
            val = [1,0,0,0];
            panels.plotter = panels.plotter(1);
            for ii=1:4
                panels.plotter(ii).window = win{ii}; set(CMD.window(ii),'String',win{ii});
                panels.plotter(ii).mode   = txt{ii}; set(CMD.txt(ii),   'String',txt{ii});
                panels.plotter(ii).valid  = val(ii); set(CMD.valid(ii), 'Value', val(ii));
                panels.plotter(ii).struct = [];
                panels.plotter(ii).metnr  = 1;
                panels.plotter(ii).subnr  = 1;
            end 
            NRNtimeline;
        case 'Hide'
            set(handle,'Visible','Off');
        case 'Cancel'
    end
    return
end
if SEL.metvideo
    videocmd = true;
	switch hObject
        case {SEL.camlink,SEL.magni}, return;
        case SEL.mark,  ToggleRed_Callback(hObject);
        case SEL.time,  panels.video.time = str2double(get(SEL.time,'String'))*1000;
                        showvideo;
        case SEL.full,  panels.video.zoom{panels.video.cage} = [];
                        delete(SEL.image);
                        SEL.image = [];
                        showvideo;
        case SEL.reset.handle
                        panels.video.time = SEL.reset.cursor;
                        setdaqpars(SEL.reset.start,SEL.reset.einde);
                        NRNshow(Meting);
                        showvideo;
        case SEL.filter,showvideo;
        case SEL.run,   ToggleRed_Callback(hObject);
                        if KnobIsRed(hObject), showvideo('loop'); end
        case SEL.VLCstp, panels.video.VLCpos = round(get(figure(2),'Position'));
                         VLCstop(); VLCobj = []; set(SEL.VLCrun,'String','VLC run'); KnobGrey(SEL.VLCrun)
        case SEL.VLCrun, ToggleRed_Callback(hObject);
                        if KnobIsRed(hObject)
                            KnobRed(SEL.VLCrun)
                            set(SEL.VLCrun,'String','pauze');
                            curhan = findobj('Tag','VIDEOCURSOR');
                            set(curhan,'LineStyle','--','LineWidth',0.5);
                            videofile = videofilename();
                            if isempty(VLCobj)
                                VLCobj = myVLC(videofile,str2double(get(SEL.magni,'String')));
                                SEL.timer = timer('TimerFcn',{@VLCtimer,curhan},...
                                               'ExecutionMode','fixedRate',...
                                               'BusyMode',   'queue',...
                                               'Name',       'VLCtimer',...
                                               'Tag',        'VLCtimer',...
                                               'Period',     0.2,...
                                               'Startdelay', 0);
                            end
                            VLCobj.PlaySpeed            = str2double(get(SEL.speed,'String'));
                            VLCobj.CurrentPositionRatio = VIDEOobj.CurrentTime/VIDEOobj.Duration;
                            VLCobj.File                 = videofile;
                            VLCobj.play;
                            start(SEL.timer);
                            pause(0.3);
                            if ~isempty(panels.video.VLCpos), set(figure(2),'Position',panels.video.VLCpos); end
                        else
                            KnobGrey(SEL.VLCrun)
                            VLCobj.pause;
                            stop(SEL.timer)
                            set(SEL.VLCrun,'String','VLC-->');
                        end
        otherwise, videocmd = false;
	end
    if videocmd, return; end
end
done = true;
switch hObject
    case {SEL.art1,SEL.art2,SEL.select3}
    case SEL.follow
        ToggleRed_Callback(hObject);
        if KnobIsRed(hObject),set(SEL.modus2,'String','single'); end
    case SEL.all, set(SEL.rch(strcmp(get(SEL.rch,'Visible'),'on')),'Value',1);
                  set(SEL.modus1,'String','toggle');
    case SEL.linked
        if get(SEL.linked,'Value')
            for jj = 1:length(SEL.sth), if get(SEL.sth(jj),'Value'), set(SEL.rch(jj),'Value',1); end; end
        end
    case SEL.artrun
        script = SEL.artrun.UserData;
        if isempty(script)
            Error("tell","No artefact script loaded");
        else
            Script_Run("run segment script",string(script));
            Redraw
        end
    case {SEL.modus1,SEL.modus2}
        if strcmp(hObject.String,'toggle'), hObject.String = 'single'; else, hObject.String = 'toggle'; end
    otherwise
        if ~isempty(find(ismember(hObject,SEL.rch), 1))
            if strcmp(get(SEL.modus1,'String'),'single')
                set(SEL.rch,'Value',0);
                set(hObject,'Value',1);
            end
        elseif ~isempty(find(ismember(hObject,SEL.sth), 1))
            if strcmp(get(SEL.modus2,'String'),'single')
                set(SEL.sth,'Value',0);
                set(hObject,'Value',1);
                if SEL.metvideo && get(SEL.camlink,'Value')
                    panels.video.cage = find(SEL.sth==hObject);
                    SEL.cursor.color = get(SEL.rch(panels.video.cage),'ForegroundColor');
                    set(SEL.cursor.handle,'Color',SEL.cursor.color);
                    showvideo;
                end
                drawnow();
            end
            if get(SEL.linked,'Value'), Setrelais; end
        elseif ~isempty(find(ismember(hObject,SEL.chh), 1)) || ~isempty(find(ismember(hObject,SEL.sph), 1))
            if ~isempty(SEL.sph)
                for jj = 1:length(SEL.chh)
                    if ~get(SEL.chh(jj),'Value'), set(SEL.sph(jj),'Value',0); end
                end
            end
        else
            return
        end
end
if done && ~panels.online && ~KnobIsRed(CMD.EEGrunL) && ~KnobIsRed(CMD.EEGrunR)
    Redraw;
end
%
%--- DB routines
%
function resetevent
DB = getPANEL('DBpanel');
set(gcf,'Pointer','arrow');
DB.edit.UserData.mouse = false;
KnobGrey([DB.new, DB.del, DB.cancel, DB.accept]);                                                    

function startnewevent(varargin)
global events
draw = (nargin==1);
set(gcf,'Pointer','cross');
DB = getPANEL('DBpanel');
set(DB.showall,'Value',1);
if draw
    events.tmp.first  = NaN;
    events.tmp.last   = NaN;
    events.tmp.kanaal = uint16(0);
    set([DB.left DB.right],'String','NaN','Value',NaN);
    KnobBlue([DB.new, DB.del, DB.cancel, DB.accept]);
    Redraw;
else
    KnobBlue([DB.new, DB.del, DB.cancel, DB.accept]);
end

function DBclose
global Memoryset events
button = {'Yes';'Cancel'};
if strcmp(questdlg('Close and remove DBase','Confirm',button{1},button{2},button{2}),button{2}), return; end
DB = getPANEL('DBpanel');
if ~isempty(DB), delete(DB.handle); end
Memoryset = [];
events    = [];
Redraw(1);
                        
function DBasename
global events
DB = getPANEL('DBpanel');
[~,filename]= fileparts(events.dbase);
DB.save.String = sprintf('%s(%u)',filename,size(events.evt.key,1));

function DBsave(metvraag,Memoryset)
global events
try
    if metvraag || isempty(events.dbase)
        [filename,filepath] = uiputfile('*.mat','Save the full seizure dBase!',events.dbase);
        if filename==0, return; end
        events.dbase = fullfile(filepath,filename);
    end
    for jj = 1:length(Memoryset)
        Memoryset{jj}.Meting(1).adc  = [];
        Memoryset{jj}.Meting(1).dac  = [];
        Memoryset{jj}.Meting(1).cdac = [];
    end
    save(events.dbase,'Memoryset','events','-v7');
    DBasename;
catch
    Error("tell",'Save error, your dbase was not saved!');
end

function werkaf(parms,class)
global events
[parms,present,psh] = ParseSpecial(parms,'partext');  if present, events.class.txt{class,1} = ssingle(psh{1}); end
[parms,present,psh] = ParseSpecial(parms,'color');    if present, kleur = rsingle(psh{1}); else, kleur = [1,0,0]; end
events.class.clr(class,1:3) = kleur;
[parms,present,psh] = ParseSpecial(parms,'modus');
if present, idx = find(strcmp({'line';'lines';'patch'},psh{1}), 1); else, idx = 3; end
if isempty(idx), Error(' modus in class must be line/lines/patch'); return; else, events.class.mod(class) = idx; end
parms = ParseSpecial(parms,'channel');
[parms,events.class.grp(class,1)] = ParseSpecial(parms,'group');
[parms,events.class.dsp(class,1)] = ParseSpecial(parms,'disp');
[~,events.class.del(class,1)] = ParseSpecial(parms,'protect');

function DBevents(parms)
global events
if isempty(events.evt.key)
    key = 0;
else
    key = max(events.evt.key);
end
class = length(events.class.nam)+1;
[parms,present,psh] = ParseSpecial(parms,'name');
if present, events.class.nam{class} = ssingle(psh{1}); else, Error('you have to give class name'); return; end
werkaf(parms,class);
DB = getPANEL('DBpanel');
set(DB.class,'String',events.class.nam,'Value',class);
dirname = [events.segdir1,filesep,parms{1}];
for filenr = 1:length(events.files.name)
    name = fullfile(dirname,[events.files.name{filenr}(1:end-4),'event.mat']);
    S = load(name);
    for jjj = 1:length(S.events.first)
        key = key + 1;
        nr = length(events.evt.first)+1;
        events.evt.key(nr,1) = key;
        events.evt.clsnr(nr,1) = class;
        events.evt.filenr(nr,1) = filenr;
        events.evt.ratnr(nr,1)  = S.events.group(jjj);
        events.evt.kanaal(nr,1) = S.events.kanaal(jjj);
        events.evt.first(nr,1)  = S.events.first(jjj);
        events.evt.last(nr,1)   = S.events.last(jjj);
        events.evt.amp(nr,1)    = NaN;
    end
end

function DBclass(parms)
global events
if isempty(events.class.nam), return; end
class = find(strcmp(events.class.nam,parms{1}), 1);
if isempty(class)
    class = length(events.class.nam) + 1;
    events.class.nam{class} = events.class.nam{class-1};
else
    [parms,present,psh] = ParseSpecial(parms,'name');
    if present, events.class.nam{class} = ssingle(psh{1}); end
end
[parms,present,psh] = ParseSpecial(parms,'name');
if present, events.class.nam{class,1} = ssingle(psh{1}); end
werkaf(parms,class);
DB = getPANEL('DBpanel');
set(DB.class,'String',events.class.nam,'Value',class);

function DBload(parms)
global panels cache Memoryset Meting events
CMD = getPANEL('CMDpanel');
cache = [];
cache.status = false;
KnobGrey(CMD.cache);
set(CMD.cachelevel,'String','0');
[parms,present,ps] = ParseSpecial(parms,'cache');  
if present
    [ps,present] = ParseSpecial(ps,'on');
    if present
        cache.status = true;
        KnobRed(CMD.cache);
    end
    set(CMD.cachemax,'String',sprintf('%0.1f',rsingle(ps{1})));
end
[parms,docorrect] = ParseSpecial(parms,'correcttimes');
try
    default = events.dbase;
catch
    default = '*.mat';
end
[filenames,filepath] = uigetfile({'*.mat'},'Load dBase or add NRN (+seg) files',default,'MultiSelect','on');
if iscell(filenames)
    nfiles    = length(filenames);
    filenames = sort(filenames);
    events    = [];
elseif filenames==0
    return  
else
    hlpname = fullfile(filepath,filenames);
    S = load(hlpname);
    if isfield(S,'Meting')
        filenames = [];
        filenames{1} = hlpname;
        clear S
        nfiles = 1;
	else
        nfiles = 0;
        Memoryset = [];
        if S.Memoryset{1}.Meting(1).version<1000000
            for jj = 1:length(S.Memoryset)
                Memoryset{jj,1}.Meting = ConvertMat(S.Memoryset{jj}.Meting);
            end
        end
        events = S.events;
        if isfield(events,'panel'), events = rmfield(events,'panel'); end
        events.dbase   = hlpname;
        if isfield(events,'segdir')
            events.segdir1 = [];
            events.segdir2 = [];
            events = rmfield(events,'segdir');
        end
        if isfield(events.stim,'select')
            events.stim.amps = zeros(length(events.stim.filenr),length(events.rats.filenrs));
            for j1 = 1:size(events.stim.amps,1)
                select = events.stim.select(j1);
                if select>0
                    j2 = 1;
                    while select>1
                        j2 = j2 + 1;
                        select = select/2;
                    end
                    events.stim.amps(j1,j2) = events.stim.amp(j1);
                end
            end
            events.stim = rmfield(events.stim,'select');
            events.stim = rmfield(events.stim,'amp');
        end
        if isfield(events.rats,'chans')
            allgrps = [Memoryset{1}.Meting(1).ADC.scale.Group]';
            events.rats.index = NaN(size(events.files.name,1),length(allgrps));
            for filenr = 1:size(events.files.name,1)
                allgrps = [Memoryset{filenr}.Meting(1).ADC.scale.Group]';
                names = {Memoryset{filenr}.Meting(1).ADC.scale.Name};
                grps = unique(allgrps);
                for ratnr = 1:size(grps)
                    channels = find(allgrps==grps(ratnr));
                    if isempty(channels), continue; end
                    ratname = names{channels(1)};
                    if contains(ratname,'X') || contains(ratname,'xx'), continue; end
                    borders = strfind(ratname,'-');
                    if isempty(borders)
                        borders = strfind(ratname,' ');
                        ratname = ratname((borders(1)+1):(borders(2)-1));
                    else
                        ratname = ratname((borders(1)+1):(borders(end)-1));
                    end
                    die     = find(strcmp(events.rats.name,ratname),1);
                    events.rats.index(filenr,channels) = deal(die);
                end
            end
            events.rats = rmfield(events.rats,'chans');
        end
        if isfield(events,'clstxt')
            events.class = [];
            valids = unique(events.evt.clsnr);
            for jj = 1:length(valids)
                events.evt.clsnr(events.evt.clsnr==valids(jj)) = jj;
                events.class.nam{jj,1}   = events.clstxt{valids(jj)};
                events.class.clr(jj,1:3) = [0.85,1,1];
                events.class.mod(jj,1)   = 1;
                events.class.txt{jj,1}   = '';
                events.class.grp(jj,1)   = false;
                events.class.dsp(jj,1)   = true;
                events.class.del(jj,1)   = true;
            end
            events.evt     = rmfield(events.evt,{'comnr';'efirst';'elast'});
            events.evt.amp = NaN(size(events.evt.key));
            if ~isempty(events.stim.filenr)
                newcls = length(events.class.grp)+1;
                events.class.nam{newcls} = 'stimulus';
                events.class.clr(newcls,1:3) = [0.85,1,1];
                events.class.grp(newcls) = true;
                events.class.mod(newcls) = 3;
                events.class.txt{newcls} = 'Amp:';
                events.class.dsp(newcls) = true;
                events.class.del(newcls) = true;
                newkey = max(events.evt.key);
                nr = length(events.evt.key);
                for jj = 1:length(events.stim.filenr)
                    newkey = newkey + 1;
                    nr = nr + 1;
                    events.evt.key(nr)    = newkey;
                    events.evt.clsnr(nr)  = newcls;
                    events.evt.filenr(nr) = events.stim.filenr(jj);
                    events.evt.ratnr(nr)  = find(events.stim.amps(jj,:)>0);
                    events.evt.kanaal(nr) = 2*events.evt.ratnr(nr);
                    events.evt.first(nr)  = events.stim.tbgn(jj);
                    events.evt.last(nr)   = events.stim.tlst(jj);
                    events.evt.amp(nr)    = events.stim.amps(jj,events.evt.ratnr(nr));
                end
            end
            events = rmfield(events,{'comtxt';'clstxt';'clsdft';'stim'});
        end
        panels.filenr = 0;
        panels.segnr = 0;
        events.tmp = struct('first',NaN,'last',NaN,'kanaal',1);
    end
    clear S;
end
filenr = 0;
lasttime = 0;
for jjjj = 1:nfiles
    denaam = filenames{jjjj};
    panels.file.name = fullfile(filepath,denaam);
    if Getmatfile, continue; end
%     S = load(panels.file.name);
%     Meting = S.Meting;
%     clear S;
    [YY,MM,DD] = datevec(Meting.abstime);
    if docorrect
        if (YY==2016)||(YY==2017),   else
            Meting.abstime = lasttime;
            if isempty(Meting.SEGMENT.start)
                Meting.SEGMENT.time = Meting.abstime;
            else
                Meting.SEGMENT.time = Meting.abstime + Meting.SEGMENT.start/(60*60*24);
            end
        end
        if ~isempty(Meting.SEGMENT.eind)
            lasttime = Meting.abstime + (Meting.SEGMENT.eind(end)+(1/Meting.ADC.rate))/(60*60*24);
        end
    end
    if length(Meting)>1
        fprintf('move %s with %u nodes to EPs\n',denaam,length(Meting));
        movefile(panels.file.name,strrep(panels.file.name,'EEG','EPs'));
        continue;
    end
    if ~isempty(Meting.adc)
        segnaam = strrep(panels.file.name,'.mat','000.SEG');
        fid = fopen(segnaam,'w'); 
        fwrite(fid,Meting.adc','int16');
        fclose(fid);
        [~,name] = fileparts(segnaam);
        Meting.SEGMENT.name{1} = [name '.SEG'];
        Meting.SEGMENT.time  = Meting.abstime;
        Meting.SEGMENT.start = 0;
        Meting.SEGMENT.eind  = 1000*(size(Meting.adc,1)-1)/Meting.ADC.rate;
        Meting.adc = [];
        fprintf('Segment extracted from %s\n',denaam);
    end
    if ~isempty(Meting.SEGMENT.name) && isempty(Meting.SEGMENT.name{1})
        [~,name] = fileparts(panels.file.name);
        Meting.SEGMENT.name{1} = [name '000.SEG'];
        MemoryUpdate('correct');
        Meting.SEGMENT.time  = Meting.abstime;
        Meting.SEGMENT.start = 0;
        Meting.SEGMENT.eind  = 1000*(size(Meting.adc,1)-1)/Meting.ADC.rate;
        Meting.adc = [];
        fprintf('%s was linked to %s\n',Meting.SEGMENT.name{1},denaam);
    end
    for ii = 1:length(Meting.ADC.scale)
        if isempty(Meting.ADC.scale(ii).Name)
            Meting.ADC.scale(ii) = Meting.ADC.scale(ii-1);
            fprintf('%s has corrupt channel %u, took the previous one, check!\n',denaam,ii);
        end
    end
    filenr = filenr + 1;
    Meting(1).filename = denaam;
    if filenr==1
        Memoryset    = [];
        events       = struct('dbase','','segdir1','','segdir2','');
        events.class = struct('nam',[],'txt',[],'clr',[],'mod',[],'grp',[],'dsp',[],'del',[]);
        events.files = struct('name','','time',[]);
        events.sgmt  = struct('start',[],'eind',[],'filenr',[],'segnr',[]);
        events.rats  = struct('name',[],'filenrs',[],'index',zeros(nfiles,1));
        events.evt   = struct('key',0,'clsnr',[],'filenr',[],'ratnr',[],'kanaal',[],'first',[],'last',[],'amp',[]);
        events.tmp   = struct('first',NaN,'last',NaN,'kanaal',1);
    end
    if isempty(find(strcmp(events.files.name,denaam), 1))
        events.files.name{filenr,1}   = denaam;
        events.files.time(filenr,1:2) = Meting.SEGMENT.time(1) + [0,Meting.SEGMENT.eind(end)/(60*60*24)];
        nlen = length(Meting.SEGMENT.time);
        events.sgmt.start (end+(1:nlen),1) = Meting.SEGMENT.start * 1000;
        events.sgmt.eind  (end+(1:nlen),1) = Meting.SEGMENT.eind  * 1000;
        events.sgmt.filenr(end+(1:nlen),1) = filenr * ones(nlen,1);
        events.sgmt.segnr (end+(1:nlen),1) = (1:nlen)';
        grps = [Meting.ADC.scale.Group]';
        events.rats.index(filenr,1:length(grps)) = NaN(1,length(grps));
        grps = unique(grps);
        for ii = 1:length(grps)
            channels = find([Meting.ADC.scale.Group]==grps(ii));
            ratname  = Meting.ADC.scale(channels(1)).Name;
            if contains(ratname,'X') || contains(ratname,'xx'), continue; end
            borders  = strfind(ratname,'-');
            if isempty(borders)
                borders  = strfind(ratname,' ');
                ratname  = ratname((borders(1)+1):(borders(2)-1));
            else
                ratname  = ratname((borders(1)+1):(borders(end)-1));
            end
            ratnr    = find(strcmp(events.rats.name,ratname),1);
            if isempty(ratnr), ratnr = length(events.rats.name) + 1; end
            if ratnr>length(events.rats.name)
                events.rats.name{ratnr,1}    = ratname;
                events.rats.filenrs{ratnr,1} = filenr;
            else
                events.rats.filenrs{ratnr,1} = unique([events.rats.filenrs{ratnr} filenr]);
            end
            events.rats.index(filenr,channels) = deal(ratnr);
        end
        MemoryUpdate('addtomemory')
    end
end
WindowClear;
Openpanel('DBpanel', @DB_Callback, events);
Openpanel('SELpanel',@SEL_Callback,Memoryset{1}.Meting(1).ADC.scale,false,false);
DBasename;
if get(CMD.zoom,'UserData'), Timeklik(CMD.zoom,[],0); end
panels.filenr = 0;
panels.segnr = 0;
MemoryUpdate('basic');
Redraw(1);
% DBsave(false,Memoryset);

function STM_Callback(hObject,~,~)
global panels SEL axon Memoryset Meting
CMD = getPANEL('CMDpanel');
STM = getPANEL('STMpanel');
switch hObject
    case STM.close
        switch questdlg('Close of Hide STM panel?','Confirm','Close','Hide','Cancel','Cancel')
            case 'Close'
                ClosePanel('SELpanel','STMpanel');
                if get(CMD.zoom,'UserData'), Timeklik(CMD.zoom,[],0); end
                WindowClear;
                Memoryset = [];
                Meting    = [];
                NRNtimeline;
            case 'Hide'
                set(handle,'Visible','Off');
            case 'Cancel'
        end
        return
    case STM.stop
        set(SEL.sth,'Value',0);
        Setrelais;
        hlp = timerfindall;
        if ~isempty(hlp)
            stop(hlp);
            delete(hlp);
        end
        KnobGrey(panels.runhandles);
    case STM.upby
        axon.SEA.inc = str2double(get(STM.upby,'String'));
        if isnan(axon.SEA.inc), axon.SEA.inc = 0; end
        set(STM.upby,'String',sprintf('%0.3f',axon.SEA.inc));
    case STM.tetamp
        axon.SEA.tetamp = str2double(get(STM.tetamp,'String'));
        if isnan(axon.SEA.tetamp), axon.SEA.tetamp = 0; end
        set(STM.tetamp,'String',sprintf('%0.3f',axon.SEA.tetamp));
    case STM.doup
        axon.SEA.tetamp = max(-20,min(20,axon.SEA.tetamp + axon.SEA.inc));
        set(STM.tetamp,'String',sprintf('%0.3f',axon.SEA.tetamp));
    case STM.dozero
        axon.SEA.tetamp = 0;
        set(STM.tetamp,'String','0');
end
set(stmhandle,'UserData',STM);

function DBedit(DB)
global events
ToggleRed_Callback(DB.edit);
if KnobIsRed(DB.edit)
    set([DB.run,DB.sort],'Visible','Off');
    set([DB.editgroup],'Visible','On');
    hh = events.class.clr(DB.class.Value,:);
    DB.clscolor.String = [num2str(hh(1)),',',num2str(hh(2)),',',num2str(hh(3))];
    DB.clsmode.Value = events.class.mod(DB.class.Value);
    DB.clsgrp.Value  = events.class.grp(DB.class.Value);
    DB.clsdsp.Value  = events.class.dsp(DB.class.Value);
    DB.clsdel.Value  = events.class.del(DB.class.Value);
else
    set([DB.editgroup],'Visible','Off');
    set([DB.run,DB.sort],'Visible','On');
end

function DB_Callback(hObject,~,~)
global panels SEL events Memoryset Meting cache
doredraw = false;
CMD = getPANEL('CMDpanel');
DB  = getPANEL('DBpanel');
eventnr  = str2double(get(DB.nr,'String'));
eventmax = length(events.evt.first);
switch hObject
    case DB.close
        switch questdlg('Close of Hide DB panel?','Confirm','Close','Hide','Cancel','Cancel')
            case 'Close'
                ClosePanel('SELpanel','DBpanel');
                if get(CMD.zoom,'UserData'), Timeklik(CMD.zoom,[],0); end
                cache = [];
                cache.status = false;
                CMD.cachelevel.String = '0';
                KnobGrey(CMD.cache);
                WindowClear;
                Memoryset = [];
                Meting    = [];
                NRNtimeline;
            case 'Hide'
                set(DB.handle,'Visible','Off');
            case 'Cancel'
        end
        return
    case DB.save,    DBsave(true,Memoryset);
    case DB.showall, EventShow
    case DB.borders
        if hObject.Value
            off = [DB.left,DB.right];
            on  = [DB.marlft,DB.marrgt];
        else
            on  = [DB.left,DB.right];
            off = [DB.marlft,DB.marrgt];
        end
        set(off, 'Visible','Off');
        set(on,'Visible','On');
        EventShow;
    case DB.marlft, if ~contains(get(DB.marlft,'String'),'%')
                        DB.marlft.Value = panels.timegain*str2double(DB.marlft.String);
                    end
    case DB.marrgt, if ~contains(get(DB.marrgt,'String'),'%')
                        DB.marrgt.Value = panels.timegain*str2double(DB.marrgt.String);
                    end
    case DB.left
        events.evt.first(eventnr) = str2double(get(hObject,'String'))*panels.timegain;
        set(hObject,'Value',events.evt.first(eventnr));
    case DB.right
        events.evt.last(eventnr)  = str2double(get(hObject,'String'))*panels.timegain;
        set(hObject,'Value',events.evt.last(eventnr)); 
    case DB.key
        key = str2double(DB.key.String);
        eventnr = find((events.evt.key==key),1);
        if isempty(eventnr)
            Error("tell",sprintf('key %u does not exist',key));
        else
            DB.nr.String = sprintf('%u',eventnr);
            EventShow;
        end
    case DB.sort
        KnobRed(hObject);
        pause(0.1);
        filenrs = unique(events.evt.filenr)';
        volgorde = [];
        for jjj = filenrs
            idx = find(events.evt.filenr==jjj);
            [~,hlp]  = sort(events.evt.first(idx));
            volgorde = [volgorde; idx(hlp)];
        end
        names = fieldnames(events.evt);
        for jj = 1:length(names)
            events.evt.(names{jj}) = events.evt.(names{jj})(volgorde);
        end
        KnobGrey(hObject);
    case {DB.onecls; DB.onerat}
    case {DB.run; DB.nr; DB.forward; DB.backward; DB.bbw; DB.class; DB.select;}
        if hObject==DB.run
            ToggleRed_Callback(DB.run);
            if ~KnobIsRed(DB.run), return; end
        end
        if hObject==DB.class,  DB.onecls.Value = true; end
        if hObject==DB.select, DB.onerat.Value = true; end
        if eventmax==0, return; end
        eventnr = max(1,min(eventmax,eventnr));
        clsnr = DB.class.Value;
        ratnr = DB.select.UserData(DB.select.Value);
        if DB.onecls.Value && DB.onerat.Value
            valids = find((events.evt.clsnr==clsnr)&(events.evt.ratnr==ratnr));
        elseif DB.onecls.Value
            valids = find(events.evt.clsnr==clsnr);
        elseif DB.onerat.Value
            valids = find(events.evt.ratnr==ratnr);
        else
            valids = 1:eventmax;
        end
        idx = find(valids>=eventnr,1);
        if isempty(idx), idx = valids(1); end
        while true
            if (hObject==DB.forward) || (hObject==DB.run)
                if idx==length(valids), idx = 1; else, idx = idx + 1; end
                eventnr = valids(idx);
            elseif hObject==DB.bbw
                eventnr = valids(1);
            elseif hObject==DB.backward
                if idx==1, eventnr = valids(end); else, eventnr = valids(idx-1); end
            else
                eventnr = valids(idx);
            end
            set(DB.nr,'String',sprintf('%u',eventnr));
            set(CMD.autofull,'Value',0);
            EventShow;
            if ~KnobIsRed(DB.run), break; end
        end
    case DB.edit, DBedit(DB);

    case DB.del
        if strcmp(questdlg(sprintf('remove nr/key:  %u / %u ?', eventnr, events.evt.key(eventnr)),'Confirm','Yes','Cancel','Cancel'),'Cancel')
            return
        else
            names = fieldnames(events.evt);
            for jj = 1:length(names)
                events.evt.(names{jj})(eventnr) = [];
            end
            if isempty(events.evt.key)
                eventnr = 0;
                events.evt.key = 0;
            end
            DB.nr.String = sprintf('%u',min(eventnr,length(events.evt.key)));
            DBedit(DB);
            EventShow;
        end
    case DB.accept
    case DB.cancel, resetevent;
    case {DB.clscolor; DB.clsmode; DB.clsgrp; DB.clsdsp; DB.clsdel}
        class = DB.class.Value;
        events.class.clr(class,:) = rsingle(strrep(DB.clscolor.String,',',', '));
        events.class.mod(class) = DB.clsmode.Value;
        events.class.grp(class) = DB.clsgrp.Value;
        events.class.dsp(class) = DB.clsdsp.Value;
        events.class.del(class) = DB.clsdel.Value;
        EventShow;
    case DB.new, startnewevent;
%   
    otherwise
        if ~isempty(find(ismember(hObject,SEL.rch), 1))
            if strcmp(get(SEL.modus1,'String'),'single'), set(SEL.rch,'Value',0); set(hObject,'Value',1);end
            doredraw = true;
        elseif ~isempty(find(ismember(hObject,SEL.sth), 1))
            if strcmp(get(SEL.modus2,'String'),'single'), set(SEL.sth,'Value',0); end
            set(hObject,'Value',1);
            doredraw = true;
        end
end
if doredraw && ~KnobIsRed(CMD.EEGrunL) && ~KnobIsRed(CMD.EEGrunR)
    Redraw;
end
%
%--- MINI analysis routines
%
function showminis(xas,metnr,swpnr,channel,toff,nxmin,nxmax,gain,offset)
global panels minis
if channel~=minis.channel, return; end
MINI = getPANEL('MINIpanel'); if isempty(MINI) || ~get(MINI.minion,'Value'), return; end
h2 = get(gca,'Children');
set(h2(1),'Color',[0 0 0],'LineWidth',0.5);
line('XData',xas,'YData',gain * double(minis.trace1{metnr,swpnr}(nxmin:nxmax)) + offset,'Color','r','LineWidth',1);
line('XData',xas,'YData',gain * double(minis.trace2{metnr,swpnr}(nxmin:nxmax)) + offset,'Color','g','LineWidth',1);
h2 = get(gca,'Children'); set(gca,'Children', h2([3 1 2 4:length(h2)]));
xlims = get(gca,'XLim');
if abs(minis.drempel(1))<32767
    line('XData',xlims,'YData',offset + gain*double(minis.drempel(1))*[1 1],'Color','b','LineStyle','--');
end
if abs(minis.drempel(2))<32767
    line('XData',xlims,'YData',offset + gain*double(minis.drempel(2))*[1 1],'Color','b','LineStyle','--');
end
tmpminis = minis.minis{metnr,swpnr};
if isempty(tmpminis), return; end
dt = 1000/minis.rate;
select = find((tmpminis(:,3)>(xas(1)*panels.timegain/dt))&(tmpminis(:,3)<(xas(end)*panels.timegain/dt)));
line('XData',(tmpminis(select,3)-1)*dt / panels.timegain,...
     'YData',offset+gain*minis.trace0{metnr,swpnr}(tmpminis(select,3)),...
     'MarkerFaceColor','g','MarkerEdgeColor','r','Marker','o','MarkerSize',11,'LineWidth',2,'LineStyle','none');
line('XData',(tmpminis(select,2)-1)*dt / panels.timegain,...
     'YData',offset+gain*minis.trace2{metnr,swpnr}(tmpminis(select,2)),...
     'MarkerFaceColor','w','MarkerEdgeColor','g','Marker','o','MarkerSize',9,'LineWidth',2,'LineStyle','none');
line('XData',(tmpminis(select,4)-1)*dt / panels.timegain,...
     'YData',offset+gain*minis.trace2{metnr,swpnr}(tmpminis(select,4)),...
     'MarkerFaceColor','w','MarkerEdgeColor','g','Marker','s','MarkerSize',9,'LineWidth',2,'LineStyle','none');
line('XData',(tmpminis(select,2)-1)*dt / panels.timegain,...
     'YData',offset+gain*minis.trace0{metnr,swpnr}(tmpminis(select,2)),...
     'MarkerFaceColor','y','MarkerEdgeColor','r','Marker','o','MarkerSize',9,'LineWidth',2,'LineStyle','none');
line('XData',(tmpminis(select,1)-1)*dt / panels.timegain,...
     'YData',offset +0 * select,...
     'MarkerFaceColor','w','MarkerEdgeColor','b','Marker','o','MarkerSize',9,'LineWidth',1,'LineStyle','none');
line('XData',(tmpminis(select,5)-1)*dt / panels.timegain,...
     'YData',offset+gain*minis.trace0{metnr,swpnr}(tmpminis(select,5)),...
     'MarkerFaceColor','y','MarkerEdgeColor','b','Marker','s','MarkerSize',9,'LineWidth',1,'LineStyle','none');
if length(select)<25
    for jj = 1:length(select)
        die = select(jj);
        xt0 = (tmpminis(die,1)-1)*dt / panels.timegain;
        text(xt0,0, sprintf('%u\n',die),'Color','k','HorizontalAlignment','Left', 'VerticalAlignment','Bottom',...
                    'Fontsize',14,'Fontname','Courier','ButtonDownFcn',{@TXTklik,die,[]});
        xx = (tmpminis(die,2)-1)*dt / panels.timegain;
        dx = 1.25*dt*(tmpminis(die,3)-tmpminis(die,2))/panels.timegain;
        yy = gain*minis.trace0{metnr,swpnr}(tmpminis(die,2));
        dy = gain*double(tmpminis(die,7)) * dx * panels.timegain;
        line('XData',[xx-dx xx xx+dx],'YData',offset + [yy-dy yy yy+dy],'Color','k','LineStyle','-');
        if ~isempty(minis.xfit)
            tnul = (tmpminis(die,3)-1)*dt;
            yfit = tmpminis(die,9)*exp(minis.xfit/(-1*tmpminis(die,10)));
            line('XData',(tnul + minis.xfit)/panels.timegain,'YData',offset + gain * yfit,...
                 'Color','r','LineWidth',2,'LineStyle','--');
        end
    end
end

function MINI_Callback(hObject,~,handles)
global panels minis Meting
CMD = getPANEL('CMDpanel');
[MINI,minihandle] = getPANEL('MINIpanel'); 
if (hObject==MINI.close)
    button = {'Yes';'Cancel'};
    if strcmp(questdlg('Close en delete MINI?','Confirm',button{1},button{2},button{2}),button{1})
        minis = [];
        delete(minihandle);
    end
    return
end
nres = find(strcmp({Meting.serienaam},get(MINI.struct,'String')));
idx    = get(MINI.metidx,'Value');
metstr = get(MINI.metidx,'String');
structname = metstr{idx};
select = get(MINI.sort,'String');
selval = get(MINI.sort,'Value');
if selval~=minis.sort
    [fld1,fld2] = strtok(select{selval},'.');
    fld1 = strtrim(fld1);
    for jj = 1:length(metstr)
        metnr = minis.metswp(jj,1);
        swpnr = minis.metswp(jj,2);
        hlpstruct = strtrim(metstr{jj});
        if selval==1
            minis.minis{metnr,swpnr}(:,13) = 1:size(Meting(nres).result.(hlpstruct).basis.metswp,1);
        else
            if isempty(fld2)
                values = Meting(nres).result.(hlpstruct).(fld1);
            else
                values = Meting(nres).result.(hlpstruct).(fld1).(strtrim(fld2(2:end)));
            end
            [~,tmp] = sort(abs(squeeze(values)),'ascend');
            minis.minis{metnr,swpnr}(:,13) = tmp;
        end
    end
    minis.sort = selval;
end
metnr = minis.metswp(idx,1);
swpnr = minis.metswp(idx,2);
maxmini = size(minis.minis{metnr,swpnr},1);
set(MINI.minis,'String',sprintf('%u',maxmini));
mininr  = str2double(get(MINI.number,'String'));
if mininr>maxmini
    mininr = maxmini;
    set(MINI.number,'String',sprintf('%u',mininr));
end
doredraw = true;
parms = [];
switch hObject
%     case {MINI.marg1, MINI.marg2, MINI.number, MINI.minion}
    case MINI.down10,   mininr = 1;
    case MINI.up10,     mininr = maxmini;
    case MINI.down01,   if mininr>1,       mininr = mininr-1; end
    case MINI.up01,     if mininr<maxmini, mininr = mininr+1; end
    case MINI.local,    doredraw = get(MINI.local,'Value');
    case MINI.del,      minis.minis{metnr,swpnr}(mininr,:) = []; mininr = min(max(1,mininr),maxmini);
    case {MINI.nmax,MINI.metidx,MINI.adcwin,MINI.adc}   
                        set([MINI.minion,MINI.local],'Value',1);
                        WindowClear;
                        panels.plotter = [];
                        panels.plotter.metnr = metnr;
                        panels.plotter.subnr = swpnr;
                        panels.plotter.window = get(MINI.adcwin,'String');
                        panels.plotter.sruct  = '';
                        panels.plotter.mode   = get(MINI.adc,'String');
                        if ~get(CMD.zoom,'UserData'), Timeklik(CMD.zoom,[],0); end
    otherwise
end
if (hObject==MINI.hiswin)||(hObject==MINI.hisbin)||(hObject==MINI.rtnwin)||(hObject==MINI.sort)||(hObject==MINI.metidx)
   if isempty(minis.cmd), return; else,hObject = minis.cmd; end
else
    minis.cmd = [];
end
switch hObject
    case {MINI.timbrs, MINI.timebin, MINI.trace}
        minis.cmd = MINI.trace;
        WindowClear;
        parms{end+1,1} = sprintf('window(%u)', str2double(get(MINI.timwin,'String')));
        parms{end+1,1} = sprintf('yas(%s@%s:%s)',Meting(nres).serienaam,structname,strtrim(select{get(MINI.sort,'Value')}));
        if get(MINI.timbrs,'Value'), parms{end+1} = sprintf('binsize(%s)',get(MINI.timebin,'String')); end
        KnobRed(MINI.trace);
        DoTrace(parms);
        KnobGrey(MINI.trace);
    case {MINI.rtnfit, MINI.return}
        minis.cmd = MINI.return;
        WindowClear;
        if get(MINI.rtnfit,'Value')
            parms{end+1,1} = 'window([2,3,4,5])';
        else
            parms{end+1,1} = sprintf('window(%u)',str2double(get(MINI.rtnwin,'String')));
        end
        parms{end+1,1} = 'window([2,3,4,5])';   % sprintf(,str2double(get(MINI.rtnwin,'String')));
        parms{end+1,1} = sprintf('yas(%s@%s:time)',Meting(nres).serienaam,structname);
        parms{end+1,1} = sprintf('nbins(%s)',get(MINI.hisbin,'String'));
        KnobRed(MINI.return);
        DoReturn(parms);
        KnobGrey(MINI.return);
    case {MINI.nrmfit, MINI.gamfit, MINI.expfit, MINI.histo}
        minis.cmd = MINI.histo;
        WindowClear;
        parms{end+1,1} = sprintf('window(%u)',str2double(get(MINI.hiswin,'String')));
        parms{end+1,1} = sprintf('source(yas(%s@%s:%s))',Meting(nres).serienaam,structname,strtrim(select{get(MINI.sort,'Value')}));
        parms{end+1,1} = sprintf('nbins(%s)',get(MINI.hisbin,'String'));
        parms{end+1,1} = 'scale(x(0,inf))';
        if get(MINI.nrmfit,'Value'), parms{end+1,1} = 'nrmfit'; end
        if get(MINI.gamfit,'Value'), parms{end+1,1} = 'gamfit'; end
        if get(MINI.expfit,'Value'), parms{end+1,1} = 'expfit'; end
        KnobRed(MINI.histo);
        DoHist(parms,handles);
        KnobGrey(MINI.histo);
    otherwise
        if KnobIsRed(MINI.runup)
            KnobGrey(MINI.runup);
        elseif KnobIsRed(MINI.rundn)
            KnobGrey(MINI.rundn);
        else
            if (hObject==MINI.runup) || (hObject==MINI.rundn), KnobRed(hObject); doredraw=true; end
            lmargin = str2double(get(MINI.marg1,'String'));
            rmargin = str2double(get(MINI.marg2,'String'));
            mmm = Meting(nres).result.(structname);
            minitime = Meting(nres).result.(structname  ).basis.times;
            while true
                index = minis.minis{metnr,swpnr}(mininr,13);
                set(MINI.number,'String', sprintf('%u',mininr));
                set(MINI.idx,   'String', sprintf('%u',index));        
                set(MINI.nmax,  'String', sprintf('Mini %u',maxmini));
                set(MINI.pars,  'String', sprintf(['Mini nr %u\n time: %0.3f s\n amp : %0.1f pA\n'...
                                                   'Slopes\n one: %0.1f pA/ms\n t2p: %0.1f ms\n two: %0.1f pA/ms\n tau: %0.1f ms'],...
                                                   index,minitime(index)/1000,  mmm.amplitude(index),mmm.slopeone(index),...
                                                      mmm.t2peak(index),mmm.slopetwo(index), mmm.decay.tau(index)));
                if doredraw
                    minis.cmd = MINI.nmax;
                    if get(MINI.local,'Value')
                        lok = (minis.minis{metnr,swpnr}(index,3)-1)*1000/minis.rate;
                        bgn = max(panels.zoom.tnul,lok - lmargin);
                        lst = min(panels.zoom.tend,lok + rmargin);
                        setdaqpars(bgn,lst);
                    end
                    panels.plotter.metnr = metnr;
                    panels.plotter.swpnr = swpnr;
                    Redraw;
                    if KnobIsRed(MINI.runup)
                        DoTestwait(0.2);
                        if mininr==maxmini, mininr = 1; else,mininr = mininr+1; end
                    elseif KnobIsRed(MINI.rundn)
                        DoTestwait(0.2);
                        if mininr==1, mininr = maxmini; else,mininr = mininr-1; end
                    else
                    	break;
                    end
                else
                    KnobGrey(CMD.macrohide);
                    minis.cmd = [];
                    break;
                end
            end
        end
end
Error("box");

function DoMinis(parms)
global panels Memoryset Meting minis
[parms,sets,mets,swps]   = ParseList(parms);
[~,present,psd]      = ParseSpecial(parms,'threshold'); if present, hlp = rsingle(psd{1}); if isnan(hlp(1)), return; end; end
[parms,present,pstarget] = ParseSpecial(parms,'target');
if present
    [pstarget,present,ps] = ParseSpecial(pstarget,'root');
    if present
        names = ssingle(ps{1});
        [fld1,fld2] = strtok(names,'@');
        fld2 = fld2(2:end);
    else
        Error('target need root'); return
    end
else
    Error('Minis need target'); return
end
MINI = Openpanel('MINIpanel',@MINI_Callback);
minis = [];
[parms,present,ps] = ParseSpecial(parms,'adcs');
if present, channel = nsingle(ps{1}); else,channel = 1; end
minis.channel = channel;
minis.metswp  = [];
minis.sort    = [];
minis.cmd     = [];
minis.rate    = Meting(mets(1)).ADC.rate;
minis.unit    = Meting(mets(1)).ADC.scale(channel).Units;
minis.gain    = Meting(mets(1)).ADC.scale(channel).User/Meting(mets(1)).ADC.ints;
minis.abstime = Meting(mets(1)).abstime;
[parms,minis.range] = ParseTijd(parms,'range',1); if isempty(minis.range), minis.range = [-inf,inf]; end
[parms,mininterval] = ParseTijd(parms,'mininterval',1);
[parms,search]      = ParseTijd(parms,'search',1);   if isempty(search), search = 0; end
[parms,dooutlier,outlier] = ParseSpecial(parms,'outlier'); if dooutlier, outlier = rsingle(outlier{1}); else,outlier = 2.5; end
[parms,dofit,psfit]       = ParseSpecial(parms,'fitdecay');
if dofit
    [psfit,present,psh] = ParseSpecial(psfit,'glimit'); if present, glimit = rsingle(psh{1}); else,glimit = 0; end
    [psfit,dofixamp]    = ParseSpecial(psfit,'fixamp');
    tdecay = rsingle(psfit{1});
else
    minis.xfit = [];
end
[parms,dofilter0,psf] = ParseSpecial(parms,'trace0');  if dofilter0, filter0 = ParseFilter(psf); end
[parms,dofilter1,psf] = ParseSpecial(parms,'trace1');  if dofilter1, filter1 = ParseFilter(psf); end
[parms,dofilter2,psf] = ParseSpecial(parms,'trace2');
if dofilter2, filter2 = ParseFilter(psf); else, Error('Minis need second derivative filter'); return; end
drempel = [0 inf];
[parms,present,psd] = ParseSpecial(parms,'threshold');
if present
    if strfind(psd{1},'auto')
        drempel(1) = minis.fstd * minis.vstd;
    elseif strfind(psd{1},'sd')
        minis.vstd = minis.gain * std(single(Meting(metnr).adc(bgn:lst,channel,swpnr)));
        drempel(1) = rsingle(strrep(psd{1},'sd',sprintf('%0.8f',minis.vstd)));
    else
        hlp = rsingle(psd{1});
        if length(hlp)==1
            if hlp>0
                hlp = [hlp inf];
            else
                hlp = [hlp -inf];
            end
        end
        drempel = hlp;
        if length(psd)>1
            hlp = rsingle(psd{2});
            if length(hlp)==1
                if hlp>=0, hlp = [hlp inf]; else,hlp = [hlp -inf]; end
            end
            drempel(3:4) = hlp;
        end
    end
end
minis.drempel = min(single(intmax('int16')),max (single(intmin('int16')),single(drempel/minis.gain)));
search = round(search * minis.rate / 1000);
for kkk = 1:length(mets)
    setnr = sets(kkk);
    metnr = mets(kkk);
    swpnr = swps(kkk);
    minis.rate = Meting(metnr).ADC.rate;
    dt = 1000/minis.rate;
    trace0 = double(Meting(metnr).adc(:,channel,swpnr));
    if dofilter0, trace0 = FilterTrace(trace0,filter0,minis.rate); end
    if dofilter1, trace1 = FilterTrace(trace0,filter1,minis.rate); else,trace1 = trace0; end
                  trace2 = FilterTrace(trace1,filter2,minis.rate);
    minis.trace0{metnr,swpnr} = trace0;
    minis.trace1{metnr,swpnr} = trace1;
    minis.trace2{metnr,swpnr} = trace2;
    r1 = max(minis.range(1),panels.zoom.tnul);
    r2 = min(minis.range(2),panels.zoom.tnul+(size(Meting(metnr).adc,1)-1)*dt);
    bgn = 1+round((r1 - panels.zoom.tnul) / dt);
    lst = 1+round((r2 - panels.zoom.tnul) / dt);
    spks = bgn-1+Crossings(trace1(bgn:lst),minis.drempel(1:2));
    if isempty(spks), continue; end
    minlen = abs(2*search(1));
    maxlen = length(trace1)-4*search(2);
    spks   = spks((spks>minlen)&(spks<maxlen));
    if isempty(spks), continue; end
    minis.borders = Meting(metnr).EXTRA.borders;
    tmpminis = zeros(length(spks),13);
    if isempty(minis.metswp)
        minis.metswp(1,1:2) = [metnr,swpnr];
    else
        minis.metswp(end+1,1:2) = [metnr,swpnr];
    end
    for jj = 1:length(spks)
        p0 = spks(jj);
        if jj<length(spks), pend = min(spks(jj+1),(p0+search(2))); else,pend = min(length(trace0),(p0+search(2))); end
        [peak,pres] = min(trace0(p0:pend));
        peak = double(peak);
        p3 = p0 - 1 + pres;
        pbgn = p0 + search(1);
        [aslp1,pres] = min(double(trace2(pbgn:p3)));
        p2 = pbgn - 1 + pres;
        p1 = p2 - round(trace0(p2)/(aslp1*dt));
        pend = p0 + search(2);
        [aslp2,pres] = max(trace2(p3:pend));
        p4 = p3 - 1 + pres;
        p5 = max(1,p4 - round(trace0(p4)/(aslp2*dt)));
        tmpminis(jj,1:8) = double([p1, p2, p3, p4, p5, peak, aslp1, aslp2]);
        if mod(jj,50)==1
            Waitbar(CMD,'show',jj/length(spks),sprintf('detect & analyse minis: %u',jj));
            set(MINI.minis,'String',sprintf('%u',jj));
        end
        drawnow;
    end
    if dooutlier              % op rising slope?
        yy = double(tmpminis(:,7));
        yb = mean(yy)+outlier*std(yy);
        exclude1 = find(yy>yb);
        yy = double(tmpminis(:,8));
        yb = mean(yy)+2*outlier*std(yy);
        exclude2 = find(yy>yb);
        exclude = [exclude1; exclude2];
        tmpminis(exclude,:) = [];
    end
    remove = [];
    if ~isempty(mininterval)
        tekort = find(diff(tmpminis(:,3))<(mininterval/dt));
        for jj = 1:length(tekort)
            amp1 = abs(tmpminis(tekort(jj),  6));
            amp2 = abs(tmpminis(tekort(jj)+1,6));
            if amp2>amp1
                remove(end+1) = tekort(jj);
            else
                remove(end+1) = tekort(jj) + 1;
            end
        end
    end
    if ~isempty(remove), tmpminis(remove,:) = []; end
    nummin = size(tmpminis,1);
    if dofit
        minis.xfit = (0:dt:tdecay)'; 
        fparms{1,1} = 'Expo(1)';
        fparms{2,1} = sprintf('fitrange([0, %6.2f, 0])',tdecay);
        fparms{3,1} = 'nologger';
        for jj = 1:nummin
            p3 = tmpminis(jj,3);
            amp = trace0(p3);
            if dofixamp, fparms{4,1} = sprintf(sprintf('fixamp(%0.6f)',amp)); end
            if jj==nummin
                xmax = round(min(length(minis.xfit),length(trace0)-p3));
            else
                p2 = tmpminis(jj+1,2);
                xmax = min(length(minis.xfit), p2-p3 );
            end
            if xmax>3
                yfit = trace0(p3 - 1 + (1:xmax));
                rfit = Fitfunctie(minis.xfit(1:xmax),yfit,fparms);
                if Error || ~rfit.valid, return; end
                if isempty(rfit.v)
                    tmpminis(jj,9:12) = deal(NaN);
                else
                    tmpminis(jj,09) = NaN;      % amp;
                    tmpminis(jj,12) = rfit.error;
                    if rfit.error<glimit
                        tmpminis(jj,10) = NaN;
                        tmpminis(jj,11) = NaN;
                    else
                        tmpminis(jj,10) = abs(rfit.v(1));
                        tmpminis(jj,11) = rfit.dv(1);
                    end
                end
            end
            if true %mod(jj,5)==0
                Waitbar(CMD,'show',jj/nummin,sprintf('trace %u, fit decay: %u',metnr,jj));
            end
            if panels.abort
                minis.xfit = [];
                break;
            end
        end
    end
    if panels.abort, break; end
    if (length(mets)>1) && (kkk==1), thlp = ',delnode'; else,thlp = ''; end
    tmp = [];
    tmp{1} = sprintf('target(root(%s@%s%u%u%s),%s)',fld1,fld2,metnr,swpnr,thlp,pstarget{1});
    [~,nres,stcname,nodename] = INIresultbasis(CMD,tmp,1);
    if Error, return; end
    slen = size(tmpminis,1);
    tmpminis (:,13) = 1:slen;
    minis.sort = 1;
    Meting(nres).result.(stcname).basis.metswp = ones(slen,1) * [setnr, metnr, swpnr, 0, metnr, size(Meting(metnr).adc,1)*1000/Meting(metnr).ADC.rate];
    Meting(nres).result.(stcname).basis.metswp(:,4) = 1:slen;
    Meting(nres).result.(stcname).basis.times = (tmpminis(:,3)-1)*dt/1000;
    Meting(nres).result.(stcname).basis.Times = ones(slen,1) * Meting(metnr).abstime + (Meting(metnr).reltime(swpnr)/(24*60*60));
    if slen<3
        Meting(nres).result.(stcname).rate  (1:slen,1) = NaN(slen,1);
    else
        Meting(nres).result.(stcname).rate  (1:slen,1) = [NaN; (2000/dt)./(tmpminis(3:end,3)-tmpminis(1:end-2,3)); NaN];
    end
    Meting(nres).result.(stcname).interval  (1:slen,1) = [diff(tmpminis(:,3))*dt/1000; NaN];
    Meting(nres).result.(stcname).class     (1:slen,1) = ones(slen,1);
    Meting(nres).result.(stcname).amplitude (1:slen,1) = abs(minis.gain * trace0(tmpminis(:,3)));
    Meting(nres).result.(stcname).slopeone  (1:slen,1) = abs(minis.gain * trace2(tmpminis(:,2)));
    Meting(nres).result.(stcname).t2peak    (1:slen,1) = (tmpminis(:,3)-tmpminis(:,1))*dt;
    Meting(nres).result.(stcname).slopetwo  (1:slen,1) = abs(minis.gain * trace2(tmpminis(:,4)));
    Meting(nres).result.(stcname).decay.amp (1:slen,1) = abs(minis.gain * tmpminis(:,9));
    Meting(nres).result.(stcname).decay.tau (1:slen,1) = abs(tmpminis(:,10));
    Meting(nres).result.(stcname).decay.dtau(1:slen,1) = tmpminis(:,11);
    Meting(nres).result.(stcname).decay.gof (1:slen,1) = tmpminis(:,12);
    set(MINI.minis,'String',sprintf('%u',size(tmpminis,1)));
    minis.minis {metnr,swpnr} = tmpminis;
end
Waitbar(CMD,'hide');
if panels.abort, return; end
set(MINI.struct,'String',nodename);
set(MINI.metidx,'String',fieldnames(Meting(nres).result),'Value',1);
prs = fieldnames(Meting(nres).result.(stcname));
txt = cell(length(prs)-1,1);
cnt = 1;
txt{1} = '  time';
for jj = 4:length(prs)
    if isstruct(Meting(nres).result.(stcname).(prs{jj}))
        tmps = fieldnames(Meting(nres).result.(stcname).(prs{jj}));
        for jjj = 1:length(tmps)
            cnt = cnt + 1;
            txt{cnt} = ['  ' prs{jj} '.' tmps{jjj}];
        end
    else
        cnt = cnt + 1;
        txt{cnt} = [' ' prs{jj}];
    end
end
set(MINI.sort,'String',txt,'Value',1);
set(minihandle,'UserData',MINI);
NRNtimeline;
setplotter('struct',Meting,nres,stcname,1);
NRNshow(Meting);
if ~isempty(Memoryset), MemoryUpdate('refresh'); end
hlpnames = fieldnames(Meting(nres).result);
for jj = 1:length(hlpnames)
    InsertinLog(CMD,hlpnames{jj},Meting(nres).result.(hlpnames{jj}),[]);
end
%
%--- IMG & img: Imaging analysis routines
%
function DoIMGtool(parms)
global IMG
[~,present,ps] = ParseSpecial(parms,'img'); if present, imgnr = nsingle(ps{1}); else, imgnr = 1; end
beeld = IMG.bld{min(size(IMG.bld,1),max(1,imgnr))};
if ~isempty(IMG.zoomx), beeld = beeld(IMG.zoomy(1):IMG.zoomy(2),IMG.zoomx(1):IMG.zoomx(2)); end
imtool(beeld);

function IMGini(makesimple)
global IMG
img = getPANEL('IMGpanel');
if makesimple
    IMG = struct('bld',[],'nam',[],'pnl',struct('handle',[]) );
else
    IMG = struct('bld',[],'nam',[],'pnl',struct('handle',[]),...
                 'flm',[],'bgd',[],'xas',[],'flmnr',1,'roinr',1,'calib',0.1625,...
                 'classes',[],'defcls',1,'refimg',2,...
                 'xpnt',[],'ypnt',[],'old',[],'zoomx',[],'zoomy',[],'parms',[10,8,2,8,0],...  % minh,mint,mind,orde,level
                 'basic',  struct('hisname',[],'exclude',[],'back',0,'fitrange',[],'equ',true,'mets',1,'swps',1,'frms',1),...
                 'object', struct('class',1,'bw',[],'bwx',[],'bwy',[],'center',[],'mass',[],'d2plak',[],'d2stim',[],'raw',[],'base',[],'pnts',[],'parms',[]),...
                 'handles',struct('trace',[],'levels',[],'peaks',[],'time',[]));
    IMG.classes = {'astrocyte';'plaque';'stimulus'};
end

function IMGselect(~,~,roinr)
global IMG
set(IMG.pnl.roinr,'String',sprintf('%u',roinr));
IMG_Callback(IMG.pnl.roinr,[])

function IMGcursor(~)
global graf IMG
[xpnt,ypnt,left] = getmouse;
xpnt = min(max(round(xpnt)+IMG.zoomx(1)-1,IMG.zoomx(1)),IMG.zoomx(2));
ypnt = min(max(round(ypnt)+IMG.zoomy(1)-1,IMG.zoomy(1)),IMG.zoomy(2));
if (IMG.xpnt~=xpnt) || (IMG.ypnt~=ypnt)
    if left
        set(IMG.pnl.xcor,'String',sprintf('%4u',xpnt));
        set(IMG.pnl.ycor,'String',sprintf('%4u',ypnt));
        set(IMG.pnl.value,'String',sprintf('%5u',IMG.flm{IMG.flmnr}(ypnt,xpnt) ));
        die = find(graf.cursor>0)';
        for jj = 1:length(die)
            idx = die(jj);
            set(graf(idx).cursor,'XData',xpnt-IMG.zoomx(1)+1,'YData',ypnt-IMG.zoomy(1)+1,'Visible','On');
%             gbuf = get(graf.handle(idx),'UserData');
%             set(gbuf.handles.Ctxt,'String',sprintf('%u',IMG.bld{graf.bld(idx)}(ypnt,xpnt)));
        end
        if ~isempty(IMG.handles.trace)
            if ~ishandle(IMG.handles.trace), Error('handle invalid'); return; end
            yas = double(squeeze(IMG.flm{IMG.flmnr}(ypnt,xpnt,:)));
            if get(IMG.pnl.roiyscl,'Value')
                ylims = get( get(IMG.handles.trace,'Parent'),'YLim');
                yas = ylims(2) + (yas-max(yas)) * (ylims(2)-ylims(1))/(max(yas)-min(yas));
            end
            set(IMG.handles.trace,'YData',yas);
            if ishandle(IMG.handles.levels)
                set(IMG.handles.levels,'XData',[[0,inf],               NaN,[0,inf]],...
                                       'YData',[[1,1]*double(min(yas)),NaN,[1,1]*double(max(yas))]);
            end
        end
    else
        xhlp = xpnt-IMG.zoomx(1)+1;
        yhlp = ypnt-IMG.zoomy(1)+1;
        if isempty(IMG.pnl.zmhandle)
            IMG.old = [IMG.xpnt IMG.ypnt];
            IMG.pnl.x0 = xhlp;
            IMG.pnl.y0 = yhlp;
            IMG.pnl.zmhandle = line(xhlp*[1,1,1,1,1],...
                                    xhlp*[1,1,1,1,1],...
                                    'Color','w','LineStyle','--','Linewidth',1);
        else
            set(IMG.pnl.zmhandle,'XData',[IMG.pnl.x0,xhlp,xhlp,IMG.pnl.x0,IMG.pnl.x0],...
                                 'YData',[IMG.pnl.y0,IMG.pnl.y0,yhlp,yhlp,IMG.pnl.y0]);
        end
    end
    IMG.xpnt = xpnt;
    IMG.ypnt = ypnt;
end

function IMGMove(hObject,evnt)
IMGcursor(hObject);
if Error("box"), IMGFinish(hObject,evnt); end
 
function IMGFinish(~,~)
global panels graf IMG
set(panels.root,'Pointer','arrow','WindowButtonMotionFcn','','WindowButtonUpFcn','','BusyAction','cancel');
set(graf.cursor(graf.cursor>0),'Marker','o');
if ~isempty(IMG.pnl.zmhandle)
    xxs = get(IMG.pnl.zmhandle,'Xdata');
    yys = get(IMG.pnl.zmhandle,'Ydata');
    IMG.zoomx = IMG.zoomx(1) - 1 + sort([xxs(1) xxs(2)]);
    if diff(IMG.zoomx)<10, IMG.zoomx(2) = IMG.zoomx(1) + 10; end
    IMG.zoomy = IMG.zoomy(1) - 1 + sort([yys(1) yys(3)]);
    if diff(IMG.zoomy)<10, IMG.zoomy(2) = IMG.zoomy(1) + 10; end
    if (IMG.old(1)>=IMG.zoomx(1)) && (IMG.old(1)<=IMG.zoomx(2)) &&  (IMG.old(2)>=IMG.zoomy(1)) && (IMG.old(2)<=IMG.zoomy(2))
        IMG.xpnt = IMG.old(1);
        IMG.ypnt = IMG.old(2);
    else
        IMG.xpnt = round(mean(IMG.zoomx));
        IMG.ypnt = round(mean(IMG.zoomy));
    end
    IMG.pnl.zmhandle = [];
    Redraw;
end

function IMGklik(hObject,~,~)
global panels graf IMG Meting
CMD = getPANEL('CMDpanel');
ashandle = gca;
grafnr = find([graf.handle]==gca);
if graf(grafnr).cursor==0, return; end
roinr = str2double(get(IMG.pnl.roinr,'String'));
IMG.pnl.zmhandle = [];
if KnobIsRed(IMG.pnl.manual)
    set(graf(grafnr).cursor,'Visible','Off');
    IMGmodus(roinr);
    switch get(IMG.pnl.poly,'Value')
        case 1, selhandle = imfreehand;
        case 2, selhandle = imellipse;
        case 3, selhandle = impoly;
    end
    position = wait(selhandle);
    DoMusic(0);
    bbb = get(graf(grafnr).handle,'Children');
    die = find(strcmp(get(get(graf(grafnr).handle,'Children'),'Type'),'image'));
    [~,bwim] = roifill(int16(get(bbb(die),'CData')),position(:,1),position(:,2));
    delete(selhandle);
    KnobGrey(IMG.pnl.manual);
    set(graf(grafnr).cursor,'Visible','on');
    IMG.bld{5} = false(size(IMG.bld{5}));
    IMG.bld{5}(IMG.zoomy(1):IMG.zoomy(2),IMG.zoomx(1):IMG.zoomx(2)) = bwim;
    IMGroi (roinr,true);
    IMGpeaks(roinr);
    Redraw;
else
    if ishandle(IMG.handles.peaks), set(IMG.handles.peaks,'Xdata',-1,'Ydata',0); end
    if roinr>0
        IMGmodus(1);
        for nr = 1:size(IMG.object,1), IMG.object(nr,1).pnts = []; end
        panels.plotter = [];
        nplot  = 0;
        for jj = 4:-1:1
            ww = round(str2double(get(CMD.window(jj),'String')));
            tt = get(CMD.txt(jj),'String');
            if get(CMD.valid(jj),'Value') && (ww>0) && ~isempty(tt) && ~contains(tt,'foto') && ~contains(tt,'movie')
                nplot = nplot + 1;
                panels.plotter(nplot).window = ww;
                panels.plotter(nplot).struct = '';
                panels.plotter(nplot).mode   = tt;
                panels.plotter(nplot).metnr = IMG.basic.mets(IMG.flmnr);
                panels.plotter(nplot).subnr = IMG.basic.swps(IMG.flmnr);
            end
        end
        NRNshow(Meting);
        set(gcf,'CurrentAxes',ashandle);
    end
    IMGcursor(hObject);
    if ~Error
        set(graf(grafnr).cursor,'Marker','+');
        set(gcf,'Pointer','custom','PointerShapeCData',ones(16)+NaN,'BusyAction','cancel',...
                'WindowButtonMotionFcn',{@IMGMove},'WindowButtonUpFcn',{@IMGFinish});
    end
end

function ROIMove(~,~)
global panels IMG graf
pnt = getmouse;
index = find(IMG.xas{IMG.flmnr,1}>=pnt*panels.timegain,1,'first');
if index~=get(IMG.pnl.time,'Value')
    CMD = getPANEL('CMDpanel');
    IMGframetime(index)
    xpnt = round(str2double(get(IMG.pnl.xcor,'String')));
    ypnt = round(str2double(get(IMG.pnl.ycor,'String')));
    die = [];
    for jj = 1:4
        ww = round(str2double(get(CMD.window(jj),'String')));
        tt = get(CMD.txt(jj),'String');
        if get(CMD.valid(jj),'Value') && (ww>0) && ~isempty(tt) && ~contains(tt,'foto') && contains(tt,'movie')
            handle = graf.handle(graf.window==ww);
            hhh = get(handle,'Children');
            die = find(strcmp(get(hhh,'Type'),'image'),1);
            break;
        end
    end
    if ~isempty(die)
        if isempty(IMG.zoomx)
            set(hhh(die),'Cdata',squeeze(IMG.flm{IMG.flmnr}(:,:,index)));
        else
            set(hhh(die),'Cdata',squeeze(IMG.flm{IMG.flmnr}(IMG.zoomy(1):IMG.zoomy(2),IMG.zoomx(1):IMG.zoomx(2),index)));
        end
        amplitude = IMG.flm{IMG.flmnr}(ypnt,xpnt,index);
        set(IMG.pnl.value,'String',sprintf('%5u',amplitude));
        TextRight(handle,amplitude);
        drawnow;
    end
end
 
function ROIFinish(~,~,~)
global IMG
set(panels.root,'Pointer','arrow','WindowButtonMotionFcn','','WindowButtonUpFcn','','BusyAction','cancel');
IMG.bld{1} = squeeze(IMG.flm{IMG.flmnr}(:,:,get(IMG.pnl.time,'Value')));

function ROIklik(~,~,handles)
set(panels.root,'Pointer','custom','PointerShapeCData',ones(16)+NaN,'BusyAction','cancel',...
                    'WindowButtonMotionFcn',@ROIMove,'WindowButtonUpFcn',{@ROIFinish,handles});

function breakem = getHISfile(filename)
global panels IMG
breakem = 0;
errortext = HISread(filename);
if isempty(errortext)
    IMG.basic.hisname = filename;
else
    filename = strrep(panels.file.name,'.mat','.HIS');
    errortext = HISread(filename);
    if isempty(errortext)
        IMG.basic.hisname = filename;
    else
        [hisname,path] = uigetfile({'*.his';'*.mat';'*.*'},'Cannot find the HIS file',filename,'MultiSelect','off');
        if path(1)==0
            breakem = 1;
        else
            filename = fullfile(path,hisname);
            errortext = HISread(filename);
            if isempty(errortext)
                IMG.basic.hisname = filename;
            else
                Error(errortext);
                breakem = 2;
            end
        end
    end
end

function DoIMGopen(parms)
global panels IMG Meting
CMD = getPANEL('CMDpanel');
[filenames,path] = uigetfile({'*.*';'*.mat';'*.mat;*.tif;*.tiff;*.bmp;*.HIS'},'Select a (set of) -img file',panels.file.name,'MultiSelect','on');
if path(1)==0, return; end
IMGini(false);
parms = ParseSpecial(parms,'ms'); [parms,present] = ParseSpecial(parms,'sec'); if present, tgain = 1000; else, tgain = 1; end
[parms,present,ps] = ParseSpecial(parms,'calibration'); if present, IMG.calib = rsingle(ps{1}); end
[parms,present,ps] = ParseSpecial(parms,'refimage');    if present, IMG.refimg = nsingle(ps{1}); end
[parms,present,ps] = ParseSpecial(parms,'classes');     if present, hlp = stringset(ps{1}); for jj=1:length(hlp), IMG.classes{jj+3}=hlp{jj}; end; IMG.defcls=nsingle(ps{2}); end
[parms,present,ps] = ParseSpecial(parms,'time');  if present, dacparms{1}= ['dacs(' ssingle(ps{1}) ')']; else, dacparms{1}= 'dacs(Camera)'; end
[parms,present,ps] = ParseSpecial(parms,'minh');  if present, IMG.parms(1) = rsingle(ps{1}); end
[parms,present,ps] = ParseSpecial(parms,'mint');  if present, IMG.parms(2) = rsingle(ps{1}); end
[parms,present,ps] = ParseSpecial(parms,'mind');  if present, IMG.parms(3) = rsingle(ps{1}); end
[parms,present,ps] = ParseSpecial(parms,'orde');  if present, IMG.parms(4) = rsingle(ps{1}); end
[parms,present,ps] = ParseSpecial(parms,'level'); if present, IMG.parms(5) = rsingle(ps{1}); end
[parms,metart,artps] = ParseSpecial(parms,'art');
Openpanel('IMGpanel',@IMG_Callback);
if iscell(filenames) && length(filenames)>1
    b1 = setfind(filenames,'.HIS');
    if isempty(b1)
        Error('You need a HIS file for this cmd'); return
    elseif length(b1)>1
        Error('Only one HIS file at a time please'); return
    end
    IMG.basic.hisname = fullfile(path,filenames{b1});
    b1 = setfind(filenames,'.mat');
    if isempty(b1), Error('Cannot analyse his/bmp/tif without the NRN.mat for timing'); return; end
    set(CMD.includefotos,'Value',0);
    panels.file.name = fullfile(path,filenames{b1});
    Getmatfile;
    panels.cursor.absnul = Meting(1).abstime;
    if get(CMD.autofull,'Value')
        setdaqpars(panels.zoom.tnul,panels.zoom.tend);
    end
    flm = 1;
    for metnr = 1:length(Meting)
        [~,chanr] = ParseDACs(dacparms,Meting(metnr));
        if ~isempty(chanr)
            Meting(metnr) = DACexpand(Meting(metnr));
            numframes = length(find((Meting(metnr).dac(1:end-1,chanr)==0) & (Meting(metnr).dac(2:end,chanr)>0)));
            signal = Meting(metnr).dac(:,chanr);
            level  = round(mean(signal));
            up = find((signal(1:end-1)<level) & (signal(2:end)>=level));
            dn = find((signal(1:end-1)>=level) & (signal(2:end)<level));
            [~,~,numswp] = size(Meting(metnr).adc);
            for swpnr = 1:numswp
                IMG.xas{flm,1} = [500.0 * (up+dn)/Meting(metnr).DAC.rate];
                IMG.basic.mets(flm,1) = metnr;
                IMG.basic.swps(flm,1) = swpnr;
                IMG.basic.frms(flm,1) = numframes;
                IMG.basic.fitrange(flm,1:2) = [1,length(IMG.xas{flm,1})];
                flm = flm + 1;
            end
        end
    end
    if getHISfile(IMG.basic.hisname)~=0, return; end
    [~,fnaam,~] = fileparts(IMG.basic.hisname);
    for imgnr = 1:5, IMG.bld{imgnr,1} = IMG.flm{1}(:,:,1); end
    IMG.nam{1,1} = fnaam;
    IMG.nam{2,1} = 'mean movie';
    IMG.nam{3,1} = 'min movie'  ;
    IMG.nam{4,1} = 'max movie';
    IMG.nam{5,1} = 'BW movie';
    imgnr = 6;
    imgsize =size(IMG.bld{1,1});
    b1 = setfind(filenames,'.TIF');
    for jj = 1:length(b1)
        [~,fnaam,~] = fileparts(filenames{b1(jj)});
        IMG.bld{imgnr,1} = imread(fullfile(path,filenames{b1(jj)}));
        if size(IMG.bld{imgnr,1},3)>1, IMG.bld{imgnr,1} = 10 * uint16(IMG.bld{imgnr,1}(:,:,1));  end
        IMG.basic.equ = isequal(imgsize(1:2), size(IMG.bld{imgnr}));
        IMG.nam{imgnr,1} = fnaam;
        imgnr = imgnr + 1;
    end
    b1 = setfind(filenames,'.BMP');
    for jj = 1:length(b1)
        [~,fnaam,~] = fileparts(filenames{b1(jj)});
        IMG.bld{imgnr,1} = BMPread(fullfile(path,filenames{b1(jj)}));
        if size(IMG.bld{imgnr,1},3)>1, IMG.bld{imgnr,1} = 10 * uint16(IMG.bld{imgnr,1}(:,:,1));  end
        IMG.basic.equ = isequal(imgsize(1:2), size(IMG.bld{imgnr}));
        IMG.nam{imgnr,1} = fnaam;
        imgnr = imgnr + 1;
    end
else
    img = [];
    panels.file.name = fullfile(path,filenames);
    try
        load(panels.file.name);
    catch
        Error(sprintf('can not open \n%s',filenames)); return;
    end
    if ~isempty(img)
        cnt = 1;
        for jj = 1:2:length(img.fitpar)
            IMG.basic.fitrange(cnt,1:2) = img.fitpar(jj:jj+1);
            cnt = cnt + 1;
        end
        IMG.classes = img.classification;
        IMG.bld = img.bld;
        IMG.nam = img.nam;
        IMG.xas{1} = img.xas;
        IMG.basic.equ  = img.equ;
        IMG.basic.mets = img.cmd.mets;
        IMG.basic.swps = img.cmd.swps;
        IMG.basic.frms = img.cmd.cams;
    end
    if isfield(IMG.basic,'hisname') && ~isempty(IMG.basic.hisname)
        [path,~,~] = fileparts(IMG.basic.hisname);
    end
    IMG.basic.hisname = fullfile(path,[img.nam{1},'.HIS']);
    switch getHISfile(IMG.basic.hisname)
        case 1, IMG.flm{1}        = img.bld{1};
                IMG.flm{1}(:,:,2) = img.bld{1};
                IMG.flm{1}(:,:,2) = img.bld{1};
        case 2, Error("box"); return
    end
end
if metart
    [artps,present,ps] = ParseSpecial(artps,'FindDAC'); if present, DoFindDAC(ps); end
    [artps,present,ps] = ParseSpecial(artps,'avg');
    if present, navg = nsingle(ps{1}); else, navg = 1; end
    for flmnr = 1:length(IMG.flm)
        flen = size(IMG.flm{flmnr},3);
        for ii = 1:length(artps)
            times = rsingle(artps{ii})*tgain;
            bldnrs = find((IMG.xas{flmnr,1}>=times(1)) & IMG.xas{flmnr,1}<times(2))';
            if bldnrs(1)==1
                avgset = (bldnrs(end)+1):(bldnrs(end)+navg);
            elseif bldnrs(end)==flen
                avgset = (bldnrs(1)-navg):(bldnrs(1)-1);
            else
                avgset = [(bldnrs(1)-navg):(bldnrs(1)-1),(bldnrs(end)+1):(bldnrs(end)+navg)];
            end
            beeld = uint16(round(mean(double(IMG.flm{flmnr}(:,:,avgset)),3)));
            for jj = bldnrs, IMG.flm{flmnr}(:,:,jj) = beeld; end
        end
    end
end
[parms,present,ps] = ParseSpecial(parms,'bgdfilter');
if present, IMG.basic.back = nsingle(ps{1}); else, IMG.basic.back = 1; end
beeld = uint32(0*IMG.flm{1}(:,:,1));
total = 0;
for flmnr = 1:length(IMG.basic.mets)
    [d1,d2,flmlen] = size(IMG.flm{flmnr});
    background = zeros(flmlen,1);
    for frame = 1:flmlen
        bld = squeeze(IMG.flm{flmnr}(:,:,frame));
        background(frame) = sum(bld(:),'double');
        beeld = beeld + uint32(bld);
        if mod(frame,100)==1
            Waitbar(CMD,'show',frame/flmlen,sprintf('background %u',frame));
        end
    end
    background = background/(d1*d2);
    if IMG.basic.back>1
        background = round(conv(background,ones(IMG.basic.back,1)/IMG.basic.back,'same'));
        background(1:IMG.basic.back) = background(IMG.basic.back+1);
        background((end-IMG.basic.back):end) = background(end-IMG.basic.back-1);
    end
    background = round(background);
    IMG.bgd{flmnr,1} = background;
    hlp = uint16(background);
    for frame = 1:flmlen
        IMG.flm{flmnr}(:,:,frame) = IMG.flm{flmnr}(:,:,frame) - hlp(frame);
        if mod(frame,100)==1
            Waitbar(CMD,'show',frame/flmlen,sprintf('subtract background %u',frame));
        end
    end
    if flmnr==1
        Waitbar(CMD,'show',0,'determine min');
        IMG.bld{3,1} = min(IMG.flm{flmnr},[],3);
        Waitbar(CMD,'show',0.3,'determine max');
        IMG.bld{4,1} = max(IMG.flm{flmnr},[],3);
    else
        Waitbar(CMD,'show',1,'determine min and max');
        IMG.bld{3,1} = min(IMG.bld{3,1}, min(IMG.flm{flmnr},[],3));
        IMG.bld{4,1} = max(IMG.bld{4,1}, max(IMG.flm{flmnr},[],3));
    end
    total = total + flmlen;
end
IMG.bld{1,1} = IMG.flm{1}(:,:,1);
IMG.bld{2,1} = uint16(beeld/total);
IMG.bld{3,1} = IMG.bld{3,1};
IMG.bld{4,1} = IMG.bld{4,1};
IMG.bld{5,1} = false(size(IMG.bld{1}));
Waitbar(CMD,'hide');
IMG.nam{2,1} = 'mean movie';
IMG.nam{3,1} = 'min movie';
IMG.nam{4,1} = 'max movie';
IMG.nam{5,1} = 'BW movie';
[parms,present,ps] = ParseSpecial(parms,'baseline');
if present
    IMG.basic.fitrange = [];
    xas = IMG.xas{1,1};
    for jj = 1:length(ps)
        times = rsingle(ps{jj})*tgain;
        if length(times)~=2, Error('Times to be given in start-end pairs'); return; end
        times(isinf(times)) = xas(end);
        bldnrs = find((xas>=times(1)) & xas<=times(2))';
        IMG.basic.fitrange(jj,1:2) = bldnrs([1,end]);
    end
end
if ~isempty(img)
    for roinr = 2:length(img.res)
        IMG.object(1,roinr).class       = img.roi(roinr).class;
        IMG.object(1,roinr).parms(1:5)  = [img.roi(roinr).parms(1:3),6,img.roi(roinr).parms(4)];
        if isempty(img.roi(roinr).bw)
            IMG.object(1,roinr).bwx    = [];
            IMG.object(1,roinr).bwy    = [];
            IMG.object(1,roinr).bw     = [];
            IMG.object(1,roinr).center = [];
            IMG.object(1,roinr).mass   = [];
            IMG.object(1,roinr).d2plak = [];
            IMG.object(1,roinr).d2stim = [];
            IMG.object(1,roinr).raw    = [];
            IMG.object(1,roinr).pnts   = [];
        else
            IMG.object(1,roinr).bw  = img.roi(roinr).bw;
            IMG.object(1,roinr).bwx = img.roi(roinr).bwx(1:2);
            IMG.object(1,roinr).bwy = img.roi(roinr).bwy(1:2);
            IMGroi(roinr,false);
            if IMG.object(1,roinr).class==1
                IMGsignal(roinr,false);
                IMGpeaks(roinr);
            end
        end
    end
end
% if ~isempty(IMG.basic.fitrange)
%     refnr = IMG.basic.fitrange(1,1);
%     for frame = 1:refnr;
%         IMG.flm{1}(:,:,frame) = IMG.flm{1}(:,:,refnr);
%     end
%     refnr = IMG.basic.fitrange(end,2);
%     for frame = refnr:size(IMG.flm{1},3)
%         IMG.flm{1}(:,:,frame) = IMG.flm{1}(:,:,refnr);
%     end
% end
IMG.zoomx = [1,size(IMG.bld{1},2)];
IMG.zoomy = [1,size(IMG.bld{1},1)];
IMG.xpnt  = round(mean(IMG.zoomx));
IMG.ypnt  = round(mean(IMG.zoomy));
IMG.old   = [IMG.xpnt IMG.ypnt];
set(IMG.pnl.metnr,'String','1');
set(IMG.pnl.swpnr,'String','1');
IMG.flmnr = 1;
set(IMG.pnl.rois, 'String',sprintf('ROI finder %u',length(IMG.object)));
idx = round((1+size(IMG.flm{1,1},3))/2);
set(IMG.pnl.time,'Value',idx,'String',sprintf('%5.2f',IMG.xas{1,1}(idx)/1000));
IMGmodus(1);
panels.cursor.absnul = Meting(1).abstime;
setmaxpars(Meting(1),'adc');
showfilename(CMD,IMG.nam{1});
NRNtimeline;

function DoIMGsave(parms,IMG,Meting)
global panels
[parms,doask] = ParseSpecial(parms,'ask');
Checksavedirectory(doask);
savename = fullfile(panels.file.savepath,[IMG.nam{1},'.mat']);
for metnr = 1:length(Meting), Meting(metnr).dac = []; end
IMG.flm   = [];
IMG.handles.trace  = [];
IMG.handles.levels = [];
IMG.handles.peaks  = [];
IMG.handles.time   = [];
IMG.pnl = [];
save(savename,'IMG','Meting');
DoMusic(0);

function IMGframetime(index)
global panels IMG
flmnr = 1;
index = min(max(1,index),length(IMG.xas{flmnr,1}));
set(IMG.pnl.time,'Value',index,'String',sprintf('%5.1f',IMG.xas{flmnr,1}(index)/1000));
if ishandle(IMG.handles.time), set(IMG.handles.time,'XData',[1 1]*IMG.xas{flmnr,1}(index)/panels.timegain); end

function IMGpeaks(roinr)
global IMG
appx = [128,64,32,16,8];
yas = IMG.object(roinr).raw;
signaal = yas;
for ii = 1:size(IMG.basic.fitrange,1)
    mask = false(length(yas),1);
    pp = IMG.basic.fitrange(ii,1:2);
    mask(pp(1):pp(2)) = true;
    if ~isempty(IMG.basic.exclude)
        for jj = 1:size(IMG.basic.exclude,1)
            mask(IMG.basic.exclude(jj,1):IMG.basic.exclude(jj,2)) = false;
        end
    end
    yas = IMG.object(roinr).raw(mask);
    xas = IMG.xas{1}(mask);
    xas = xas - mean(xas);
    xas = xas/xas(end);
    yfit = polyfit(xas,yas,4);
    ybas = polyval(yfit,xas);
    for jj = 1:length(appx)
        mask2 = (yas-ybas)<appx(jj);
        yfit = polyfit(xas(mask2),yas(mask2),IMG.object(roinr).parms(4));
        ybas = polyval(yfit,xas);
    end
    signaal(mask) = ybas;
end
IMG.object(roinr).base = signaal;
change = 100 * (IMG.object(roinr).raw ./ IMG.object(roinr).base) - 100;
pp = IMG.object(roinr).parms;
pnts = peakfinder(change,pp(1),pp(2),max(1,round(pp(3)*1000/(IMG.xas{1}(2)-IMG.xas{1}(1)))));
IMG.object(roinr).pnts = pnts;

function IMGsignal(roinr,fromimg)
global IMG
if fromimg
    [yys,xxs] = find(IMG.bld{5}==1);
else
	[yys,xxs] = find(IMG.object(roinr).bw);
	xxs = xxs + IMG.object(roinr).bwx(1)-1;
    yys = yys + IMG.object(roinr).bwy(1)-1;
end
if isempty(xxs), Error("tell",'Define ROI'); return; end
yas = zeros(size(IMG.flm{1},3),1);
for jj = 1:length(xxs), yas = yas + double(squeeze(IMG.flm{1}(yys(jj),xxs(jj),:))); end
IMG.object(roinr).raw = yas/length(xxs);

function IMGroi(roinr,fromimg)
global IMG
if fromimg
    [yys,xxs] = find(IMG.bld{5}==1);
    if isempty(xxs)
        IMG.object(roinr).bw     = [];
        IMG.object(roinr).bwx    = [];
        IMG.object(roinr).bwy    = [];
        IMG.object(roinr).center = [];
        IMG.object(roinr).mass   = [];
        Error("tell",'Define ROI');
        return;
    end
    x1 = min(xxs);
    x2 = max(xxs);
    y1 = min(yys);
    y2 = max(yys);
    IMG.object(roinr).bw = IMG.bld{5}(y1:y2,x1:x2);
    IMG.object(roinr).bwx = [x1 x2];
    IMG.object(roinr).bwy = [y1 y2];
else
    [yys,xxs] = find(IMG.object(roinr).bw);
    xxs = xxs + IMG.object(roinr).bwx(1)-1;
    yys = yys + IMG.object(roinr).bwy(1)-1;
    x1 = min(xxs);
    x2 = max(xxs);
    y1 = min(yys);
    y2 = max(yys);
end
hlp = uint16(IMG.object(roinr).bw).*IMG.bld{IMG.refimg}(y1:y2,x1:x2);
[~,idx] = max(hlp(:));
xm = floor((idx-1)/size(hlp,1));
ym = idx - xm*size(hlp,1);
IMG.object(roinr).center = [sum(xxs), sum(yys)]/length(xxs);
IMG.object(roinr).mass   = [x1+xm,    y1+ym-1];

function IMGshowclass(class)
global IMG
set(IMG.pnl.bullet,'Value',0);
set(IMG.pnl.bullet(class),'Value',1);
set(IMG.pnl.class,'string',IMG.classes{class});

function IMGmodus(roinr)
global IMG
roimax = length(IMG.object);
roinr = max(0,min(roimax,roinr));
movon = 'off';
delon = 'off';
pkson = 'off';
accon = 'off';
neer  = 'off';
if roinr==0
elseif roinr==1
    IMGshowclass(IMG.defcls);
    IMG.object(1).class = IMG.defcls; 
    IMG.object(1).parms = IMG.parms; 
    neer = 'on';
    if KnobIsRed(IMG.pnl.peaks) || ~isempty(IMG.object(roinr).bw), accon = 'on'; end
    set(IMG.pnl.minh, 'String',sprintf('%0.2f',IMG.parms(1)));
    set(IMG.pnl.mint, 'String',sprintf('%0.2f',IMG.parms(2)));
    set(IMG.pnl.mind, 'String',sprintf('%0.2f',IMG.parms(3)));
    set(IMG.pnl.orde, 'String',sprintf('%5u',  IMG.parms(4)));
    set(IMG.pnl.level,'String',sprintf('%5u',  IMG.parms(5)));
elseif roinr>1
    IMGshowclass(IMG.object(roinr).class);
    if roimax>1
        delon = 'on'; 
        if roinr<roimax, movon = 'on'; end
    end
    set(IMG.pnl.minh, 'String',sprintf('%0.2f',IMG.object(roinr).parms(1)));
    set(IMG.pnl.mint, 'String',sprintf('%0.2f',IMG.object(roinr).parms(2)));
    set(IMG.pnl.mind, 'String',sprintf('%0.2f',IMG.object(roinr).parms(3)));
    set(IMG.pnl.orde, 'String',sprintf('%5u',  IMG.object(roinr).parms(4)));
    set(IMG.pnl.level,'String',sprintf('%5u',  IMG.object(roinr).parms(5)));
    if IMG.object(roinr).class==1, pkson ='on'; end
end
set(IMG.pnl.roinr,  'String',  sprintf('%u',roinr));
set(IMG.pnl.rois,   'String',  sprintf('ROI finder %u',roimax));
set(IMG.pnl.move,   'Visible', movon);
set(IMG.pnl.delete, 'Visible', delon);
set(IMG.pnl.peaks,  'Visible', pkson);
set(IMG.pnl.accept, 'Visible', accon);
set(IMG.pnl.omlaag, 'Visible', neer);

function IMGd2p(astronrs,plaknrs,stimnrs)
global IMG
for ii = 1:length(plaknrs)
    [yys,xxs] = find(IMG.object(plaknrs(ii)).bw==1);
    yys = yys + IMG.object(plaknrs(ii)).bwy(1)-1;
    xxs = xxs + IMG.object(plaknrs(ii)).bwx(1)-1;
    for astro = astronrs
        xa = IMG.object(astro).center(1);
        ya = IMG.object(astro).center(2);
        [dist,index] = min((yys-ya).^2 + (xxs-xa).^2);
        IMG.object(astro).d2plak(ii,1:3) = [xxs(index),yys(index),realsqrt(dist)*IMG.calib];
    end
end
for ii = 1:length(stimnrs)
    [yys,xxs] = find(IMG.object(stimnrs(ii)).bw==1);
    yys = yys + IMG.object(stimnrs(ii)).bwy(1)-1;
    xxs = xxs + IMG.object(stimnrs(ii)).bwx(1)-1;
    for astro = astronrs
        xa = IMG.object(astro).center(1);
        ya = IMG.object(astro).center(2);
        [dist,index] = min((yys-ya).^2 + (xxs-xa).^2);
        IMG.object(astro).d2stim(ii,1:3) = [xxs(index),yys(index),realsqrt(dist)*IMG.calib];
    end
end

function IMG_Callback(hObject,~,handles)
global IMG graf Meting
CMD = getPANEL('CMDpanel');
roinr  = str2double(get(IMG.pnl.roinr,'String'));
roimax = length(IMG.object);
if KnobIsRed(IMG.pnl.movie), KnobGrey(IMG.pnl.movie); return; end
IMGbs = cell(length(IMG.pnl.bullet),1);
for jj = 1:length(IMG.pnl.bullet), IMGbs{jj}=IMG.pnl.bullet(jj); end
switch hObject
    case IMG.pnl.margin
    case IMGbs,             for jj = 1:length(IMGbs), if IMGbs{jj}==hObject, IMGshowclass(jj); break; end; end
    case {IMG.pnl.metnr,IMG.pnl.swpnr}, IMG.flmnr = find((IMG.basic.mets==str2double(get(IMG.pnl.metnr,'String'))) & ((IMG.basic.swps==str2double(get(IMG.pnl.swpnr,'String')))));
    case {IMG.pnl.imin,IMG.pnl.imax},   set(IMG.pnl.auto,'Value',0); KnobBlue([IMG.pnl.imin,IMG.pnl.imax]);
    case IMG.pnl.close,     if strcmp(questdlg('Close+delete IMG?','Confirm','Yes','Cancel','Cancel'),'Yes'), IMGini(true); end; return;
    case IMG.pnl.auto,      if get(hObject,'Value'), KnobWhite([IMG.pnl.imin,IMG.pnl.imax]); else, KnobBlue([IMG.pnl.imin,IMG.pnl.imax]); end       
    case IMG.pnl.manual,    ToggleRed_Callback(hObject); return
    case IMG.pnl.exclude,   ToggleRed_Callback(hObject);
                            if KnobIsGrey(hObject), IMG.basic.exclude = []; IMG_Callback(IMG.pnl.peaks,[],handles); return; end
    case IMG.pnl.class,     txt = inputdlg('give the name of the new class or cancel):','Database new class',1,{},'on');
                            if ~isempty(txt)
                                IMG.basic.classes{end+1} = txt;
                                set(IMG.pnl.class,'String',txt);  
                                set(IMG.pnl.bullet,'Value',0);
                                hlp = get(IMG.pnl.bullet(end));
                                IMG.pnl.bullet(end+1) = uicontrol('Parent',hlp.Parent,...
                                                    'Units',           hlp.Units,...
                                                    'FontUnits',       hlp.FontUnits,...
                                                    'BackgroundColor', hlp.BackgroundColor,...
                                                    'Callback',        hlp.Callback,...
                                                    'FontName',        hlp.FontName,...
                                                    'FontSize',        hlp.FontSize,...
                                                    'Position',        hlp.Position + [0.0875,0,0,0],...
                                                    'String','',...
                                                    'Style','radiobutton',...
                                                    'TooltipString','selected class',...
                                                    'Value',1,...
                                                    'Tag','');
                            end
                            return
    case IMG.pnl.time,      val = str2double(get(IMG.pnl.time,'String')) * 1000;
                            if val<=IMG.xas{IMG.flmnr,1}(1)
                                idx = 1;
                            elseif val>=IMG.xas{IMG.flmnr,1}(end)
                                idx = size(IMG.flm{IMG.flmnr},3);
                            else
                                idx = find(IMG.xas{IMG.flmnr,1}>=val,1,'first');
                            end
                            IMG.bld{1} = squeeze(IMG.flm{IMG.flmnr}(:,:,idx));
                            IMGframetime(idx)
    case IMG.pnl.full,      IMG.zoomx = [1,size(IMG.bld{1},2)];
                            IMG.zoomy = [1,size(IMG.bld{1},1)];
                            IMGmodus(1)
    case IMG.pnl.zoomout,   [my,mx,mz] = size(IMG.flm{1});
                            dx = round(diff(IMG.zoomx)/4);
                            dy = round(diff(IMG.zoomy)/4);
                            IMG.zoomx(1:2) = [max(1,min(mx,IMG.zoomx(1)-dx)) max(1,min(mx,IMG.zoomx(2)+dx))];
                            IMG.zoomy(1:2) = [max(1,min(my,IMG.zoomy(1)-dy)) max(1,min(my,IMG.zoomy(2)+dy))];
    case IMG.pnl.move,      IMG.object(:,roimax+1) = IMG.object(:,roinr);
                            IMG.object(roinr) = [];
                            IMGmodus(roimax)
                            DoMusic(0);
    case IMG.pnl.delete,    IMG.object(roinr) = [];
                            IMGmodus(roinr)
                            DoMusic(0);
	case IMG.pnl.accept,    roinr = roimax+1;
                            IMG.object(roinr) = IMG.object(1);
                            IMGmodus(roinr);
                            cls = [IMG.object(2:end).class];
                            astronrs = 1+find(cls==1);
                            plaknrs  = 1+find(cls==2);
                            stimnrs  = 1+find(cls==3);
                            switch IMG.object(1).class
                                case 1, IMGd2p(roinr,plaknrs,stimnrs)
                                case 2, IMGd2p(astronrs,roinr,[])
                                case 3, IMGd2p(astronrs,[],roinr)
                            end
                            DoMusic(0);
                            return
    case IMG.pnl.erodil,    if roinr>1, Error("tell",'voorlopig alleen even voor roi 1!'); return; end
                            r = str2double(get(IMG.pnl.shplen,'String'));
                            switch get(IMG.pnl.shape,'Value')
                                case 1, SE =strel('disk',r);
                                case 2, SE =strel('square',r);
                                case 3, SE =strel('octagon',r);
                                case 4, SE =strel('diamond',r);
                            end
                            IMG.bld{5} = imerode (IMG.bld{5},SE);
                            IMG.bld{5} = imdilate(IMG.bld{5},SE);
                            IMGroi (roinr,true);
                            IMGpeaks(roinr);
                            DoMusic(0);
    case {IMG.pnl.roinr,IMG.pnl.next,IMG.pnl.prev,IMG.pnl.roiall,IMG.pnl.cursor}
                            switch hObject
                                case IMG.pnl.roiall, IMGmodus(0);
                                case IMG.pnl.cursor, IMGmodus(1); roinr = 1;
                                case IMG.pnl.prev,   if roinr>2, roinr = roinr-1; else, roinr = roimax; end; IMGmodus(roinr);
                                case IMG.pnl.next,   if roinr<roimax, roinr = roinr+1; else, roinr = 2; end; IMGmodus(roinr);
                                case IMG.pnl.roinr,  IMGmodus(roinr);
                                otherwise
                            end
                            if roinr>0
                                if isempty(IMG.object(roinr).bw)
                                    IMG.zoomx = [1,size(IMG.bld{1},2)];
                                    IMG.zoomy = [1,size(IMG.bld{1},1)];
                                else
                                    margin = round(str2double(get(IMG.pnl.margin,'String')));
                                    [my,mx] = size(IMG.bld{1});
                                    IMG.zoomx(1:2) = [max(1,min(mx,IMG.object(roinr).bwx(1)-margin))  max(1,min(mx,IMG.object(roinr).bwx(2)+margin))];
                                    IMG.zoomy(1:2) = [max(1,min(my,IMG.object(roinr).bwy(1)-margin))  max(1,min(my,IMG.object(roinr).bwy(2)+margin))];
                                end
                            end
    case {IMG.pnl.level,IMG.pnl.down10,IMG.pnl.down01,IMG.pnl.up01,IMG.pnl.up10}
                            level = str2double(get(IMG.pnl.level,'String'));
                            switch hObject
                                case IMG.pnl.down10, level = level - 10;
                                case IMG.pnl.down01, level = level - 1;
                                case IMG.pnl.up01,   level = level + 1;
                                case IMG.pnl.up10,   level = level + 10;
                            end
                            set(IMG.pnl.level,'String',sprintf('%u',level));
                            IMGmodus(roinr);
                            IMGroi(roinr,true);
                            IMGpeaks(roinr);
    case IMG.pnl.omlaag,    if KnobIsRed(hObject)
                                KnobGrey(hObject); return
                            else
                                hhh = get(graf.handle(graf.bld==5),'Children');
                                bwimage = hhh(strcmp(get(hhh,'Type'),'image'));
                                beeld = IMG.bld{IMG.refimg}(IMG.zoomy(1):IMG.zoomy(2),IMG.zoomx(1):IMG.zoomx(2));
                                level = double(max(beeld(:)));
                                ylims = 0.925 * get(get(IMG.handles.trace,'Parent'),'YLim');
                                if ishandle(IMG.handles.peaks), set(IMG.handles.peaks,'XData',[],'YData',[]); end
                                lastsize = 0;
                                KnobRed(hObject);
                                while KnobIsRed(hObject)
                                    level = level-1;
                                    bwim = imbinarize(beeld,level/(256*256-1));
                                    yas0 = 0*double(bwim(1,1,:));
                                    [yys,xxs] = find(bwim==1);
                                    newsize = length(xxs);
                                    if newsize>lastsize
                                        lastsize = newsize;
                                        set(IMG.pnl.level,'String',sprintf('%5u',round(level)));
                                        set(bwimage,'Cdata',bwim);
                                        yas = yas0; for jj = 1:newsize, yas = yas + double(squeeze(IMG.flm{IMG.flmnr}(IMG.zoomy(1)+yys(jj)-1,IMG.zoomx(1)+xxs(jj)-1,:))); end
                                        yas = yas / newsize;
                                        set(IMG.handles.trace,'YData',ylims(2) + (yas-max(yas)) * (ylims(2)-ylims(1))/(max(yas)-min(yas)));
                                        drawnow;
                                    end
                                end
                                IMG.object(roinr).parms(6) = level;
                                IMG.bld{5} = false(size(IMG.bld{5}));
                                IMG.bld{5}(IMG.zoomy(1):IMG.zoomy(2),IMG.zoomx(1):IMG.zoomx(2)) = bwim;
                                IMGroi(roinr,true);
                                IMGsignal(roinr,true);
                                IMGpeaks(roinr);
                                return;
                            end
    case {IMG.pnl.peaks,IMG.pnl.minh,IMG.pnl.mind,IMG.pnl.mint,IMG.pnl.orde}
                            if roinr>0
                                IMG.object(roinr).parms(1:3) = [str2double(get(IMG.pnl.minh,'String')),...
                                                                str2double(get(IMG.pnl.mint,'String')),...
                                                                str2double(get(IMG.pnl.mind,'String'))];
                                IMG.object(roinr).parms(4)   = str2double(get(IMG.pnl.orde,'String'));
                                IMGpeaks(roinr);
                            end
    case IMG.pnl.movie, setplotter('cmdline',Meting,str2double(get(IMG.pnl.metnr,'String')),str2double(get(IMG.pnl.swpnr,'String')));
                        NRNshow(Meting);
                        KnobRed(hObject);
                        pstart = get(IMG.pnl.time,'Value');
                        imin  = str2double(get(IMG.pnl.imin, 'String'));
                        imax  = str2double(get(IMG.pnl.imax, 'String'));
                        view1 = str2double(get(IMG.pnl.view1,'String'));
                        view2 = str2double(get(IMG.pnl.view2,'String'));
                        spfil = round(str2double(get(IMG.pnl.filter,'String')));
                        resol = str2double(get(IMG.pnl.resol,'String'));
                        gain  = power(10,get(CMD.ADCgain,'Value'));
                        if get(IMG.pnl.roi3D,'Value'), spfil = max(spfil,resol); end
                        if spfil>1, filter = ones(spfil,spfil,'double')/(spfil*spfil); end
                        hhh = get(graf.handle(graf.bld==1),'Children');
                        himage = hhh(strcmp(get(hhh,'Type'),'image'));
                        [my,mx,nframes] = size(IMG.flm{IMG.flmnr});
                        if isempty(IMG.zoomx)
                            yres = 1:resol:my;
                            xres = 1:resol:mx;
                        else
                            yres = IMG.zoomy(1):resol:IMG.zoomy(2);
                            xres = IMG.zoomx(1):resol:IMG.zoomx(2);
                        end
                        beeld = double(squeeze(IMG.flm{IMG.flmnr}(yres,xres,pstart)));
                        if get(IMG.pnl.roi3D,'Value')
                            axes(get(himage,'Parent'));
                            cla;
                            himage = surface(double(beeld),'Edgecolor','none');
                            axis normal
                            axis off
                            set(get(himage,'Parent'),'ZLim',[imin,imin+(imax-imin)/gain],'CLim',[imin,imax], 'Xlim',[1,length(xres)],'YLim',[1,length(yres)]);
                            view(view1,view2);
                        end
                        if get(IMG.pnl.color,'Value'), colormap(jet(255)); end
                        if get(IMG.pnl.avi,'Value')
                            [filepath,filename] = fileparts(IMG.basic.hisname);
                            myvideo = VideoWriter(fullfile(filepath,[filename sprintf('-%s.avi',get(IMG.pnl.avinr,'String'))]));
                            myvideo.Quality   = 100;
                            myvideo.FrameRate = round(str2double(get(IMG.pnl.frame,'String')));
                            open(myvideo);
                            set(IMG.pnl.avinr,'String',sprintf('%u',1+str2double(get(IMG.pnl.avinr,'String'))));
                        end
                        for jj = pstart:1:length(IMG.xas{IMG.flmnr,1})
                            IMGframetime(jj)
                            if spfil>1
                                beeld = conv2(double(squeeze(IMG.flm{IMG.flmnr}(:,:,jj))),filter,'valid');
                                beeld = beeld(yres,xres);
                            else
                                beeld = double(squeeze(IMG.flm{IMG.flmnr}(yres,xres,jj)));
                            end
                            if get(IMG.pnl.roi3D,'Value')
                                set(himage,'Cdata',beeld,'Zdata',gain*beeld);
                                if get(IMG.pnl.avi,'Value')
                                    frame = getframe(get(himage,'Parent'));
                                    writeVideo(myvideo,frame);
                                end
                            else
                                set(himage,'Cdata',beeld);
                                if get(IMG.pnl.avi,'Value')
                                    writeVideo(myvideo,ind2rgb(round(beeld-imin),jet(imax-imin)))
                                end
                            end
                            drawnow;
                            if ~KnobIsRed(hObject), break; end
                        end
                        if get(IMG.pnl.avi,'Value'), close(myvideo); end
                        IMGframetime(pstart);
                        KnobGrey(hObject);
                        return
    otherwise
end
Redraw;
%
% --- NRN plotting
%
function plt = ontleed(textin,Mets)
global panels SEL EEG spikes p
CMD = getPANEL('CMDpanel');
Org.p = p;
if isfield(Mets,'p') && ~isempty(Mets.p)
    fldnames = fieldnames(Mets.p);
    for jj = 1:length(fldnames)
        if ~isfield(p,fldnames{jj})
            p.(fldnames{jj}) = Mets.p.(fldnames{jj});
        end
    end
end
plt = struct('mode',[],'subs',[],'str',[],'subnaam','','parms',[],'modepar',[],'modepars',[],...
             'chns',[],'gain',1,'dual',[],'mea',"",...
             'skip',[],'clear','always','acorr',false,'corrpar',[9 0],'invert',false,'imp',0,...
             'diff',0,'legend',true,'fitnr',1,'std','none','stdgain',1,'null',true,'shift',[],...
             'useselect',0,'spkstats',false,'laserspikes',[],'seizure',false,...
             'back',[],'resample',1,'balance',[],'interactive',false,'video',[],...
             'dynamic',false,'dynapar',[],'cursor',false,...
             'cross',false,'crosswin',6,'crossset',0,'xylin',true,'xyevent',false,...
             'femke',false,'xyrange',[],'selection',false,'ballines',false,'contour',0,...
             'vline',[],'vlinecol','','symbol',[],'shadow',false,'grid',false,'veld',[],...
             'color',[],'marker','odphx+*s^v><','markersize',10,'line',[1,2,3,4],'width',0.5,...
             'nivo', [],'units',false,'template',false,'scale',[],'filter',[]);
if iscell(textin), textin = char(textin{1}); end 
plt.str = textin;
cmds = ParseSimple(strrep(textin,'/',','));
if Error, return; end
[cmds,present,ps] = ParseSpecial(cmds,'video'); if present, plt.video = nsingle(ps{1}); end
axnamplifier = panels.amplifier;
[cmds,metamp,ps] = ParseSpecial(cmds,'amplifier');
if metamp, if nsingle(ps{1})==2, axnamplifier = 'AXON2'; else, axnamplifier = 'AXON1'; end; end
[cmds,plt.scale]  = ParseScale(cmds);  if Error, return; end
[cmds,plt.filter] = ParseFilter(cmds); if Error, return; end
fout = [];
plt.subs = cmds;

for ii = 1:length(cmds)
    lstcmd = cmds{ii};
    if ~isempty(strfind(cmds{ii},'!')), continue; end
    if length(strfind(cmds{ii},'('))~=length(strfind(cmds{ii},')')), fout = 'bracket () mismatch'; break; end
    if length(strfind(cmds{ii},'['))~=length(strfind(cmds{ii},']')), fout = 'bracket [] mismatch'; break; end
    
    [cmd,parms] = ParseCmd(cmds{ii});
    if isempty(plt.subnaam)
        [cmd,plt.subnaam] = strtok(cmd,'.');
        if ~isempty(plt.subnaam), plt.subnaam =plt.subnaam(2:end); end
    end
%     tgain = 1; [parms,present] = ParseSpecial(parms,'sec'); if present, tgain = 1000; end
	nparms = length(parms);
    switch cmd
        case {'none','setx','sety','localmax','localmin'}
        case 'veld',        plt.veld(1:5) = 0;
                            [parms,present] = ParseSpecial(parms,'calib');
                            if present, plt.veld(5) = true; end
                            plt.veld(1:4) = rsingle(parms{1});
        case 'seizure',     plt.seizure = true;
        case 'units',       plt.units = true;
                            plt.parms = parms;
        case 'monitor',     plt.parms = parms;
                            plt.parms{end+1} = cmd;
        case 'interactive',	plt.interactive = true;

        case 'currents',    plt.mode  = 'dynamic';
                            plt.parms = parms;
        case 'dynamic',     plt.dynamic = true;
                            plt.dynapar = parms;
        case 'contour',     plt.contour = nsingle(parms{1});
        case 'cursor',      plt.cursor  = true;
        case 'mosaic',      plt.mode = cmd;
                            plt.parms = parms;
        case {'sweeps','means','APs','APm','profile'}
                              plt.mode = cmd;
                              plt.parms = parms;
        case {'movie';'foto'},plt.mode = 'foto';
                              plt.parms = parms;
                              if strcmp(cmd,'movie'), plt.parms{end+1} = cmd; end
        case 'roi',         plt.mode = cmd;
                            plt.marker = 'none';
                            plt.line   = '-';
                            plt.parms = parms;
        case 'skip',        plt.skip = max(1,nsingle(parms{1}));
        case 'invert',      plt.invert = true;
        case 'gain',        plt.gain = 0*plt.chns+rsingle(parms{1});
        case 'dual',        [~,plt.dual] = ParseTwo(plt.subs,'dual');
                            if isempty(plt.dual), plt.dual = 1; end
        case {'dac';'adc';'avg';'swp'}
                    plt.mode   = cmd;
                    plt.marker = 'none';
                    plt.line   = '-';
                    if strcmp(cmd,'dac')
                        kanalen = 1:length(Mets.DAC.HWchn);
                    else
                        kanalen = 1:length(Mets.ADC.HWchn);
                    end
                    if isempty(kanalen)
                        break;
                    end
                    plt.gain = 0 * kanalen + 1;
                    plt.chns = kanalen;
                    [parms,domear,psmea1] = ParseSpecial(parms,'mear');
                    [parms,domeab,psmea2] = ParseSpecial(parms,'meab');
                    [parms,domeag]        = ParseSpecial(parms,'meag');
                    [parms,domeas]        = ParseSpecial(parms,'meas');
                    if domear || domeab || domeag || domeas
                        MEA = getPANEL('MEApanel');
                        idx = [];
                        vals1 = find(MEA.select.UserData==2);
                        klur1(1:length(vals1)) = 'r';
                        vals2 = find(MEA.select.UserData==3);
                        klur2(1:length(vals2)) = 'b';
                        if domear
                            if ~isempty(psmea1), idx = nsingle(psmea1{1}); end
                            plt.chns  = vals1;
                            plt.color = klur1;
                            plt.mea   = "mear";
                        elseif domeab
                            if ~isempty(psmea2), idx = nsingle(psmea2{1}); end
                            plt.chns  = vals2;
                            plt.color = klur2;
                            plt.mea   = "meab";
                        elseif domeag
                            plt.chns  = MEA.green.UserData;
                            plt.color = 'k';
                            plt.mea   = "meag";
                        else
                            hlp1=sort(vals1);
                            hlp2=sort(vals2);
                            plt.chns = [hlp1;hlp2]';
                            plt.color = [klur1,klur2];
                        end
                        if ~isempty(idx)
                            plt.chns  = plt.chns(idx);
                            plt.color = plt.color(idx);
                        end
                    else
                        [parms,pres1]      = ParseSpecial(parms,'select1');
                        [parms,pres2,psh2] = ParseSpecial(parms,'select2');
                        [parms,pres3]      = ParseSpecial(parms,'select3');
                        if pres1 || pres2 || pres3
                            if isempty(SEL)
                                Openpanel('SELpanel',@SEL_Callback,Mets.ADC.scale,false,~isempty(plt.video));
                            end
                            if ~isempty(SEL)
                                if pres1, plt.useselect = 1; end
                                if pres2, plt.useselect = 2; end
                                ShowPanel('SELpanel');
                                if panels.online && ~isempty(EEG.Meting)
                                    plt.chns = kanalen;
                                else
                                    if ~panels.online, ShowPanel('DBpanel'); end
                                    if pres1
                                        [plt.chns,useselect2] = SelectChannels(true(1,length(kanalen)),Mets.ADC.scale);
                                    elseif pres2
                                        [useselect1,plt.chns] = SelectChannels(true(1,length(kanalen)),Mets.ADC.scale);
                                        if ~isempty(psh2)
                                            chlp = nsingle(psh2{1});
                                            if chlp(1)~=0, plt.chns = plt.chns(chlp); end
                                        end
                                    elseif pres3
                                        plt.chns = str2double(SEL.select3.String);
                                    end
                                end
                            end
                        elseif ~isempty(parms)
                            hlp = nsingle(parms{1});
                            if ~isempty(hlp(hlp==0))
                                plt.chns = kanalen;
                            else
                                plt.chns = [];
                                for jj = 1:length(hlp)
                                    if ~isempty(find(kanalen == hlp(jj), 1))
                                        plt.chns = [plt.chns hlp(jj)];
                                    end
                                end
                            end
                            if length(parms)>1, parms{1} = parms{2}; else,parms = []; end
                            try
                                if ~isempty(Mets.EXTRA.(axnamplifier).pars)
                                    if strcmp(cmd,'dac')
                                        plt.chns = Mets.EXTRA.(axnamplifier).pars.dac(plt.chns);
                                    else
                                        plt.chns = Mets.EXTRA.(axnamplifier).pars.adc(plt.chns);
                                    end
                                end
                            catch
                            end
                        elseif ~isempty(Mets.EXTRA.(axnamplifier).pars)
                            if strcmp(cmd,'dac')
                                plt.chns = Mets.EXTRA.(axnamplifier).pars.dac;
                            else
                                plt.chns = Mets.EXTRA.(axnamplifier).pars.adc;
                            end
                        end
                    end
                    if isempty(plt.chns), plt.mode = 'none'; end
                    if ~isempty(parms)
                        hlp = rsingle(parms{1});
                        if length(hlp)==1
                            plt.gain = hlp + (0 * kanalen);
                        else
                            plt.gain(1:length(hlp)) = hlp;
                        end
                    end
        case {'allmets','alltraces'}
                            plt.modepar = cmd;  
                            if ~isempty(parms), plt.modepars = nsingle(parms{1}); end
        case {'allswps','allswp'}
                            plt.modepar = 'allswps';  
                            if ~isempty(parms), plt.modepars = nsingle(parms{1}); end
        case {'prvswp','prvmet'}
                            plt.modepar = cmd;
        case {'std';'sem'},  plt.std = cmd; if ~isempty(parms), plt.stdgain = rsingle(parms{1}); end
        case 'phase',       plt.mode = cmd;
                            plt.chns = nsingle(parms{1});
        case 'imp',         if isempty(parms), plt.imp = 1; else, plt.imp = nsingle(parms{1}); end
        case 'hist',        plt.mode = cmd;
                            plt.parms = parms;
        case 'laserspikes', if ~isempty(parms), plt.laserspikes = rsingle(parms{1}); else, plt.laserspikes = 0; end
        case 'spikes'
        case 'spikestats',  plt.spkstats = true;
        case 'spectrum',    plt.mode = cmd;
        case 'spectrogram', plt.mode = cmd;
        case 'xy',          plt.mode = cmd;
                            plt.parms = parms;
        case 'fit',         plt.mode = cmd;
                            if ~isempty(parms), plt.fitnr = nsingle(parms{1}); end
                            plt.parms = parms;
        case 'event',       plt.mode  = 'xy';
                            plt.xycmd = cmd;
                            plt.gain = 1;
                            plt.xylin = ~strcmp(cmd,'event');
                            for jj = 1:5, plt.xypar{jj} = 1; end
                            for jj = 1:nparms, plt.xypar{jj} = nsingle(parms{jj})'; end
                            plt.xyxas = (nparms==1);
                            if nparms==6, plt.xyrange = rsingle(parms{6}); end
        case 'acorr',       plt.acorr = true;
                            plt.corrpar(1) = nsingle(parms{1});
                            plt.corrpar(2) = rsingle(parms{2});
        case 'colormap',    try eval(cmds{ii}); catch fout = sprintf('Error in colormap %s',cmds{ii}); break; end
        case {'never';'first';'always'}, plt.clear = cmd;
        case 'blank',       plt.gain(nsingle(parms{1})) = 0;
        case 'shadow',      plt.shadow = true;
        case 'cross',       plt.cross = true; 
                            if nparms>0
                                plt.crosswin = nsingle(parms{1});
                            else
                                fout = 'cross needs window'; break;
                            end
                            if nparms>1
                                hlp = rsingle(parms{2});
                                if hlp(1)>0, panels.cursor.cross = hlp(1)*panels.timegain; end
                            end
                            if nparms>2
                                panels.cursor.crossset = rsingle(parms{3})*panels.timegain;
                            else
                                panels.cursor.crossset = 0;
                            end
        case 'balance', plt.balance = parms;
                        hlp = plt.chns(plt.chns>12);
                        if isempty(hlp), break; else, plt.chns = hlp; end
        case 'ballines',plt.ballines = true;
        case 'femke',   plt.femke = true;
                        if nparms>0, plt.resolution = rsingle(parms{1}); else,plt.resolution = 2; end
                        if plt.resample>1, SkipOff(CMD,plt.resample); end
        case 'xyevent', plt.xyevent = true;
                        plt.crosswin = [];
                        if nparms>0, plt.crosswin = nsingle(parms{1}); end
                        if nparms>1, plt.gain     = rsingle(parms{2}); end
                        if ~isempty(spikes.template), plt.metmean = true; end
        case 'shift',   plt.shift  = 0;
        case 'select',  plt.selection = true;
        case 'grid'  ,  plt.grid   = true;            
        case 'nonull',  plt.null   = false;
        case 'nolegend',plt.legend = false;
        case 'legend',  plt.legend = true;           % alleen voor compatibiliteit....
        case 'symbol',  plt.symbol  = rsingle(parms{1});
        case {'color'; 'colors'}
                        if isempty(parms), plt.color = 'r';  else,plt.color = ssingle(parms{1});  end
        case {'marker';'markers'}
                        if isempty(parms)
                            plt.marker = 'o';
                        else
                            plt.marker = ssingle(parms{1});
                            if length(parms)>1, plt.markersize = rsingle(parms{2}); end
                        end
        case 'nomarker',plt.marker = 'none';
        case 'width',   plt.width = rsingle(parms{1});
        case 'nivo',    plt.nivo  = rsingle(parms{1});
        case 'noline',  plt.xylin = false;   
        case 'line',    if strcmp(plt.mode,'xy')
                            plt.xylin = true;
                        else
                            plt.line = [];
                            try
                                for jj = 1:length(parms)
                                    plt.line(jj) = find(strcmp(ssingle(parms{jj}),{'-';':';'--';'-.';'none'}));
                                end
                            catch
                                if nparms>0, plt.vline    = rsingle(parms{1})*panels.timegain; end
                                if nparms>1, plt.vlinecol = ssingle(parms{2}); else,plt.vlinecol = 'k'; end
                            end
                        end
        case 'vline',   if nparms>0, plt.vline    = rsingle(parms{1})*panels.timegain; end
                        if nparms>1, plt.vlinecol = ssingle(parms{2}); else,plt.vlinecol = 'k'; end
        case 'resample',plt.resample = nsingle(parms{1}); if plt.femke, SkipOff(CMD,plt.resample); end
        case {'zoom';'zoomlines'}
                p1 = panels.zoom.tbgn;
                p2 = panels.zoom.tlst;
                p3 = p2-p1;
                mid   = 0.5*(p1+p2);
                range = p3*(p2-p1);
                range = [mid-range/2 mid+range/2];
                if strcmp(cmd,'zoom')
                    plt.scale.x(1:2) = range(1:2)*panels.timegain;
                else
                    plt.vline    = range;
                    plt.vlinecol = 'rr';
                end    
        case 'diff',    plt.diff = 1;
        case 'dif2',    plt.diff = 3;
        case 'csd',     plt.diff = 2; 
        case 'spectra', plt.mode  = 'xy';
                        plt.xycmd = cmd;
                        plt.xypar = parms;
        case {'adapt';'brighten';'equalize'}
        case {'';' ';'  '}
%         case 'template',if ~isempty(spikes.template)
%                             plt.template = true;
%                             if ~isempty(spikes.tmpnul)
%                                 plt.zero = [[spikes.tmpnul(1) spikes.tmpnul(2)]*1000/spikes.adcrate, 1];
%                             end
%                         end
        otherwise
            fout = sprintf('Unknown modifier %s',cmds{ii}); break;
    end
end
p = Org.p;
if ~isempty(fout)
    Error(sprintf('\n%s in:\n\n%s\n\nCommand:\n%s',fout,lstcmd,textin));
end

function [parms,default] = selecteer(parms,name,default)
[parms,present,ps] = ParseSpecial(parms,name);
if present
    hlp = nsingle(ps{1}); if hlp(1)~=0, default = intersect(default,hlp); end
    if length(ps)>1, hlp = nsingle(ps{2}); default = setdiff(default,hlp); end
end

function tmplist = DoList(parms)
global Memoryset Meting panels cmdlist
listnrs = [];
maxentry = 0;
for nodenr = 1:length(Meting)
    if isempty(Meting(nodenr).adc)
        maxentry = maxentry + 1;
    else
        [~,~,maxswps] = size(Meting(nodenr).adc);
        maxentry = maxentry + maxswps;
    end
end
tmplist = zeros(maxentry,4);
cnt = 0;
setnr = 0;
for nodenr = 1:length(Meting)
    if Meting(nodenr).setnr==1
        setnr = setnr + 1;
        metnr = 0;
    end
    metnr = metnr+1;
    if isempty(Meting(nodenr).adc)
        cnt = cnt + 1;
        tmplist(cnt,1:4) = [setnr, metnr, 0, nodenr];
    else
        [~,~,maxswps] = size(Meting(nodenr).adc);
        hlp = ones(maxswps,1);
        tmplist(cnt + (1:maxswps)',1:4) = [setnr*hlp, metnr*hlp, (1:maxswps)', nodenr*hlp];
        cnt = cnt + maxswps;
    end
end
serienames = {Meting(tmplist((tmplist(:,2)==1) & (tmplist(:,3)==1),4)).serienaam}';
[parms,dorename,psn] = ParseSpecial(parms,'rename');
[parms,dospikes,pss] = ParseSpecial(parms,'spikes');
[parms,dosort,  psh] = ParseSpecial(parms,'sort');
[parms,doextract]    = ParseSpecial(parms,'extract');
[parms,dosplit]      = ParseSpecial(parms,'split');
[parms,doreverse]    = ParseSpecial(parms,'reverse');
[parms,doperset]     = ParseSpecial(parms,'perset');
[~,donodes]      = ParseSpecial(parms,'nodes'); if donodes, [parms,nodes] = selecteer(parms,'nodes',unique(tmplist(:,4))); end
[parms,swps]         = selecteer(parms,'swps',unique(tmplist(:,3)));
[parms,mets]         = selecteer(parms,'mets',unique(tmplist(:,2)));
[parms,sets]         = selecteer(parms,'sets',unique(tmplist(:,1)));
[parms,pres1,ps]     = ParseSpecial(parms,'find');  if pres1, names = stringset(ssingle(ps{1})); end
[parms,pres2,ps]     = ParseSpecial(parms,'match'); if pres2, names = stringset(ssingle(ps{1})); end
switch length(parms)
	case 2, listnrs = nsingle(parms{1});
            names = stringset(ssingle(parms{2}));
            pres1 = true;
    case 1,	try
                listnrs = nsingle(parms{1});
            catch
                listnrs = [];
                names = stringset(ssingle(parms{1}));
                pres1 = true;
            end
end
if pres1 || pres2
    sets = [];
    for j2 = 1:length(names)
        for j1 = 1:length(serienames)
            if pres1
                if ~isempty(strfind(serienames{j1},names{j2})), sets = [sets; j1]; end
            elseif pres2
                if strcmp(serienames{j1},names{j2}), sets = [sets; j1]; end
            end
        end
    end
end
valid = false(size(tmplist,1),1);
vswps = valid;
for jj = 1:length(swps)
    vswps = vswps | (tmplist(:,3)==swps(jj));
end
if donodes
    for jj = 1:length(nodes)
        valid = valid | (tmplist(:,4)==nodes(jj));
    end
else
    for j2 = 1:length(sets)
        for j1 = 1:length(mets)
            valid = valid | ((tmplist(:,1)==sets(j2)) & (tmplist(:,2)==mets(j1)));
        end
    end
end
tmplist = tmplist(valid & vswps,1:4);
if dosort
    [psh,present] = ParseSpecial(psh,'down');
    if present, direction = 'descend'; else, direction = 'ascend'; end
    [psh,present,ps] = ParseSpecial(psh,'dacs');
    if present
        channel = nsingle(ps{1});
    else
        Error('sort in List needs dacs'); return
    end
    [~,present,ps] = ParseSpecial(psh,'time');
    if present
        point = rsingle(ps{1});
    else
        Error('sort in List needs time'); return
    end
    values = NaN(size(tmplist,1),1);
    for jj = 1:size(tmplist,1)
        metnr = tmplist(jj,2);
        pnt = 1+round(point * Meting(metnr).DAC.rate / 1000);
        Meting(metnr) = DACexpand(Meting(metnr));
        if pnt<size(Meting(metnr).dac,1), values(jj) = Meting(metnr).dac(pnt,channel); end
    end
    [~,index] = sort(values,direction);
    tmplist = tmplist(index,:);
end
if dospikes
    [pss,present,ps] = ParseSpecial(pss,'adcs');
    if present
        channel = nsingle(ps{1});
    else
        Error('spikes in List needs adcs'); return
    end
    [pss,present,ps] = ParseSpecial(pss,'level');
    if present
        level = rsingle(ps{1}); if length(level)==1, level = [level inf]; end
    else
        Error('spikes in List needs level'); return
    end
    [pss,present] = ParseSpecial(pss,'include');
    if present
        include = true;
    else
        [pss,present] = ParseSpecial(pss,'exclude');
        if present
            include = false;
        else
            Error('spikes in List needs include/exclude'); return
        end
    end
    [pss,gebied] = ParseTijd(pss,'range,1');
    if isempty(gebied), gebied = [-inf inf]; end
    metspikes = true(size(tmplist,1),1);
    for jj = 1:size(tmplist,1)
        metnr = tmplist(jj,2);
        sadc = Meting(metnr).ADC.scale(channel).User/Meting(metnr).ADC.ints;
        adcdrempel = int16(round((min(single(intmax('int16')),max (single(intmin('int16')),single(level/sadc)) ))));
        if isinf(gebied)
            spks = Crossings(Meting(metnr).adc(:,channel),adcdrempel);
        else
            bgn = 1+round(gebied(1) * Meting(metnr).DAC.rate / 1000);
            lst = 1+round(gebied(2) * Meting(metnr).DAC.rate / 1000);
            spks = Crossings(Meting(metnr).adc(bgn:lst,channel),adcdrempel);
        end
        if isempty(spks), metspikes(jj) = false; end
    end
    if ~include, metspikes = ~metspikes; end
    tmplist = tmplist(metspikes,:);
end
if doextract || dosplit
    nodes =tmplist(:,4);
    hlp2 = Meting(1).filename;
    if dosplit
        antinodes = setxor([1:length(Meting)],[nodes]);
        if isempty(Memoryset)
            Met1 = Meting(antinodes);
            Met1(1).filename = hlp2;
            Met2 = Meting(nodes);
            [Met2.setnr] = deal(false);
            Met2(1).setnr = true;
            Met2(1).filename = hlp2;
            Memoryset{1,1}.Meting = Met1;
%             Memoryset{1,1}.Photo  = img;
            Memoryset{2,1}.Meting = Met2;
%             Memoryset{2,1}.Photo  = img;
            Meting = Met1;
            panels.filenr = 1;
        else
            for jj = length(Memoryset):-1:panels.filenr
                Memoryset(jj+1,1) = Memoryset(jj,1);
            end
            Memoryset{panels.filenr+1,1}.Meting = Meting(nodes);
            Memoryset{panels.filenr+1,1}.Meting(1).setnr = true;
            for jj = 2:length(nodes), Memoryset{panels.filenr+1,1}.Meting(jj).setnr = false; end
            Memoryset{panels.filenr+1,1}.Meting(1).filename = hlp2;
            Meting = Meting(antinodes);
        end
    else
        Meting = Meting(nodes);
    end
    Meting(1).filename = hlp2;
    if ~isempty(Memoryset), MemoryUpdate('refresh'); end
    tmplist = ones(length(Meting),3);
    tmplist(:,2) = 1:length(Meting);
    NRNtimeline;
end
if doreverse, tmplist = tmplist(end:-1:1,:); end
if ~isempty(listnrs), for jj = listnrs, cmdlist{jj} = tmplist; end; end
if dorename
    newname = ssingle(psn{1});
    nodes   = unique(tmplist(:,2));
    for jj = 1:length(nodes), Meting(nodes(jj)).serienaam = newname; end
end
%
% ====== Display NRN elements =================================================
%
function txt = txtcolor(letter)
index = strfind('brmkcgyw',letter);
naam = {'blue';'red';'magenta';'black';'cyan';'green';'yellow';'white'};
txt = ['\color{' naam{index} '}'];

function TextYAS(handle,txt,varargin)
if nargin>2, fontsize = varargin{1}; else, fontsize = 10; end
hhs = get(handle,'Children');
set(hhs(strcmp(get(hhs,'Tag'),'LEGYAS')),'String',[txt,' '],'FontSize',fontsize);

function TextLeft(handle,txt,varargin)
if nargin>2, fontsize = varargin{1}; else, fontsize = 10; end
hhs = get(handle,'Children');
set(hhs(strcmp(get(hhs,'Tag'),'TOPLFT')),'String',txt,'FontSize',fontsize);

function TextRight(handle,txt,varargin)
if nargin>2, fontsize = varargin{1}; else, fontsize = 10; end
txt = strrep(txt,'/',',');
parts = ParseSimple(txt);
txt = [];
for jj = 1:length(parts)
    if strcmp(parts{jj},'!'), continue; end
    if strcmp(parts{jj}(1:3),'xy(')
        txt = sprintf('%s\nxy(...)',txt);
    elseif strncmp(parts{jj},'scale',5)
        txt = sprintf('%s\nscale(...)',txt);
    elseif strncmp(parts{jj},'dynamic',7)
        txt = sprintf('%s\ndynamic(...)',txt);
    elseif strncmp(parts{jj},'spikestats',10)
        txt = sprintf('%s\nspikestats(...)',txt);
    elseif jj==1
        txt = parts{jj};
    else
        txt = sprintf('%s\n%s',txt,parts{jj});
    end
end
hhs = get(handle,'Children');
set(hhs(strcmp(get(hhs,'Tag'),'TOPRGT')),'String',txt,'FontSize',fontsize);

function drawspiketraces(handle,Mets,mets,swps,metspikes)
children = get(handle,'Children');
delines = find(strcmp(get(children,'Tag'),'mark'));
if ~isempty(delines)
    delete(children(delines));
    children = get(handle,'Children');
end
delines = find(strcmp(get(children,'Tag'),'trace'));
if isempty(delines), return; end
lbuf      = get(children(delines(1)),'UserData');
buttondwn = get(children(delines(1)),'ButtonDownFcn');
xas       = get(children(delines(1)),'XData')';
delete(children(delines));
lst = 1+round((diff(handle.XLim)/(xas(2)-xas(1))));
xas = xas(1:lst);
xx = [];
yy = [];
chn   = lbuf.wie.chn;
bgn   = 1+round(xas(1)/(xas(2)-xas(1)));
lst   = bgn+length(xas)-1;
scale = Mets(mets(1)).ADC.scale(chn).User/double(Mets(mets(1)).ADC.ints);
for j1 = 1:length(mets)
    for j2 = 1:length(swps)
        lbuf.wie.chn = chn;
        lbuf.wie.met = mets(j1);
        lbuf.wie.swp = swps(j2);
        yhlp = scale * double(Mets(mets(j1)).adc(bgn:lst,chn,swps(j2)));
        if isempty(xx)
            xx = xas;
            yy = yhlp;
        else
            xx = [xx; NaN; xas];
            yy = [yy; NaN; yhlp];
        end
    end
end
line(xx,yy,'Color','k','LineWidth',0.5,'Tag','trace','ButtonDownFcn',buttondwn,'UserData',lbuf);
if metspikes && (length(mets)==1) && (length(swps)==1) 
    for j1=1:length(Mets)
        if ~isempty(Mets(j1).result)
            names = fieldnames(Mets(j1).result);
            for j2=1:length(names)
                fields = fieldnames(Mets(j1).result.(names{j2}));
                idx = find(strcmp(fields,'spkstats'), 1);
                if ~isempty(idx)
                    adcdt = Mets(j1).result.(names{j2}).spkstats.dt;
                    spks  = Mets(j1).result.(names{j2}).spkstats.idxs{mets(1),swps(1)};
                    p1 = round(handle.XLim(1)/adcdt);
                    p2 = round(handle.XLim(2)/adcdt);
                    spks = spks((spks>=p1) & (spks<=p2))-p1;
                    if ~isempty(spks)
                        line('XData',xx(spks),'YData',yy(spks),'Tag','mark','Color','b',...
                             'LineWidth',1.5,'LineStyle','none','Marker','o','MarkerSize',8);
                    end
                end
            end
        end
    end
end

function SpikeStatKlik(~,~,Mets,index,handle)
global panels
[~,ypnt,isleft] = getmouse;
dist = (index(:,1)-ypnt).^2;
[~,die] = min(dist);
hObject = findobj('Tag','traceindex');
if index(die,2)==0
    switch panels.SpikeStatMode
        case 1, panels.SpikeStatMode = 2;
        case 2, panels.SpikeStatMode = 3;
        case 3, panels.SpikeStatMode = 1;
    end
    Redraw;
elseif isleft
    drawspiketraces(handle,Mets,index(die,2),index(die,3),true);
    xx = handle.XLim;
    x1 = xx(1);
    x2 = xx(2);
    dy = 0.5*(index(2,1)-index(1,1));
    y1 = index(die,1)-dy;
    y2 = index(die,1)+dy;
    if isempty(hObject)
        patch([x1,x1,x2,x2,x1],[y1,y2,y2,y1,y1],[1,1,0.4],...
               'LineStyle','none','Tag','traceindex','FaceColor',[1,1,0.6]);
        correctorder(handle);
    else
        set(hObject,'XData',[x1,x1,x2,x2,x1],'YData',[y1,y2,y2,y1,y1],'FaceColor',[1,1,0.6]);
    end
else
    drawspiketraces(handle,Mets,unique(index(1:end-1,2)),unique(index(1:end-1,3)),false);
    if ~isempty(hObject), delete(hObject); end
end

function showspikestats(Mets,nodenr,swpnr,handle,plt)
global panels timeline
[~,present,parms] = ParseSpecial(plt.subs,'spikestats');
if ~present, return; end
name =ssingle(parms{1});
[nodenaam,resnaam] = strtok(name,'@');
resnaam = resnaam(2:end);
nres = find(strcmp({Mets.serienaam},nodenaam));
if isempty(nres) || ~isfield(Mets(nres).result,resnaam), return; end
adcdt    = Mets(nres).result.(resnaam).spkstats.dt;
tracelen = Mets(nres).result.(resnaam).spkstats.tracelen;
index = find((Mets(nres).result.(resnaam).basis.metswp(:,5)==nodenr)&...
             (Mets(nres).result.(resnaam).basis.metswp(:,3)==swpnr));
if isempty(index), return; end
[parms,present,psm] = ParseSpecial(parms,'cluster');
if ~present, Error('Spikestats needs cluster(xx,xx)'); return; end
[psm,width]      = ParseOne(psm,'width',0.5);
[psm,fraction]   = ParseOne(psm,'fraction',0.5);
[psm,present,ps] = ParseSpecial(psm,'cluster');
if isempty(ps), return; end
idx2 = nsingle(ps{1});
idx3 = nsingle(ps{2});
if idx3==0, idx3 = 1:size(Mets(nres).result.(resnaam).spkstats.cluster,2); end
timeline.par(:,4) = 0;
tracebot = handle.YLim(1);
handle.YLim(1) = (1+(1/fraction))*tracebot;
cnt = 0; index = [];
xx = [];   yy = [];
xz = [];   yz = [];
xrel = []; yrel = [];
xdet = []; ydet = [];
yy0 = 0.25;
for j0=1:length(idx3)
    cluster = Mets(nres).result.(resnaam).spkstats.cluster(idx2,idx3(j0));
    if isempty(cluster.set), continue; end
    ystart = yy0;
    mark = (timeline.idx(:,3)==idx2) & (timeline.idx(:,4)==idx3(j0));
    timeline.par(mark,4) = 9;
    if j0==1
        drawspiketraces(handle,Mets,cluster.set(1),1,false);
        TextLeft(handle,cluster.txt);
    end
    for j1=1:length(cluster.set)
        mark = (timeline.par(:,1)==4) & (timeline.idx(:,2)==cluster.set(j1));
        timeline.par(mark,4) = 9;
        metnr = cluster.set(j1);
        for j2 = 1:size(Mets(nres).result.(resnaam).spkstats.idxs,2)
            cnt = cnt + 1;
            index(cnt,1:3) = [yy0+0.45,metnr,j2];
            spktimes = Mets(nres).result.(resnaam).spkstats.idxs{metnr,j2};
            xxh = NaN(3*length(spktimes)+1,1);
            yyh = zeros(3*length(spktimes)+1,1);
            xxh(1:3:3*length(spktimes)) = spktimes;
            xxh(2:3:3*length(spktimes)) = spktimes;
            yyh(1:3:3*length(spktimes)) = yy0+0*spktimes;
            yyh(2:3:3*length(spktimes)) = yy0+0.9+0*spktimes;
            xx = [xx; xxh;];
            yy = [yy; yyh];
            yy0 = yy0 + 1;
        end
        yy0 = yy0 + 0.25;
    end
    xhlp = zeros(4*length(cluster.tim)+2,1);
    len = length(xhlp);
    yhlp = xhlp;
    xhlp(end) = tracelen;
    xhlp(2:4:(len-1),1) = cluster.tim - cluster.acc;
    xhlp(3:4:(len-1),1) = cluster.tim - cluster.acc;
    xhlp(4:4:(len-1),1) = cluster.tim + cluster.acc;
    xhlp(5:4:(len-1),1) = cluster.tim + cluster.acc;
    yhlp(3:4:(len-1),1) = cluster.rel;
    yhlp(4:4:(len-1),1) = cluster.rel;
    xrel = [xrel; xhlp; NaN];
    yrel = [yrel; ystart + yhlp*(yy0-ystart); NaN];
    yhlp = zeros(4*length(cluster.tim)+2,1);
    xhlp(2:4:(len-1),1) = cluster.van;
    xhlp(3:4:(len-1),1) = cluster.van;
    yhlp(3:4:(len-1),1) = 0.075;
    xhlp(4:4:(len-1),1) = cluster.tot;
    yhlp(4:4:(len-1),1) = 0.075;
    xhlp(5:4:(len-1),1) = cluster.tot;
    xdet = [xdet; xhlp; NaN];
    ydet = [ydet; ystart + yhlp*(yy0-ystart); NaN];
    if j0<length(idx3)
        yy0 = yy0 + 0.25;
        xz = [xz handle.XLim NaN];
        yz = [yz yy0*[1 1]   NaN];
    end
end
cnt = cnt + 1; index(cnt,1:3) = [yy0+0.45,0,0];
yy   = handle.YLim(1)+yy  *(tracebot-handle.YLim(1))/yy0;
yrel = handle.YLim(1)+yrel*(tracebot-handle.YLim(1))/yy0;
ydet = handle.YLim(1)+ydet*(tracebot-handle.YLim(1))/yy0;
index(:,1) = handle.YLim(1)+index(:,1)*(tracebot-handle.YLim(1))/yy0;
if panels.SpikeStatMode==1
    line('XData',xdet*adcdt/panels.timegain,'YData',ydet,'Color','b','LineWidth',1,'LineStyle',':');
    line('XData',xrel*adcdt/panels.timegain,'YData',yrel,'Color','r','LineWidth',1,'LineStyle','-');
    kleur = 'g';
elseif length(idx3)>1
    line('XData',xz,'YData',handle.YLim(1)+yz*(tracebot-handle.YLim(1))/yy0,'Color','m','LineWidth',1,'LineStyle','--');
    kleur = 'm';
else
    kleur = 'k';
end
line('XData',  xx*adcdt/panels.timegain,'YData',yy,    'Color','k','LineWidth',width,'LineStyle','-');
line('XData',handle.XLim,'YData',-handle.YLim(2)*[1,1],'Color',kleur,'LineWidth',3);
text(handle.XLim(1),-0.85*handle.YLim(2),' Change mode','Color',kleur,...
     'FontSize',16,'ButtonDownFcn',{@SpikeStatKlik,Mets,index,handle});
set(handle,'ButtonDownFcn',{@SpikeStatKlik,Mets,index,handle});
rodestippen;
[~,dostat,psh] = ParseSpecial(parms,'hist');
if dostat
    [psh,perevent]    = ParseSpecial(psh,'event');
    [~,present,hlp] = ParseSpecial(psh,'win');
    if present
        win1 = nsingle(hlp{1});
        if length(hlp)>1, win2 = nsingle(hlp{2}); else, win2=[]; end
    end
    kleur ='krbcm';
    if ~isempty(win1)
        handle1 = getplothandle(win1,true);
        if panels.SpikeStatMode==1
            txt = ' Reliability PDF';
            for j0=1:length(idx3)
                cluster = Mets(nres).result.(resnaam).spkstats.cluster(idx2,idx3(j0));
                if isempty(cluster.set) || isempty(cluster.distribution), continue; end
                txt = [txt txtcolor(kleur(j0)) sprintf('\n %s (%u)',cluster.txt,length(cluster.rel))];
                nbins = 1/min(diff(unique(cluster.rel)));
                hh = histogram(cluster.rel-1/(2*nbins),0:1/nbins:1,'Normalization','pdf');
                hh.FaceColor = 'y';
                hh.Parent.XLim = [0,1];
                if perevent, hh.BinCounts = hh.BinCounts.*(1:length(hh.BinCounts)); end
                if j0>1
                    hh.DisplayStyle='stairs';
                    hh.LineWidth = 2;
                    hh.EdgeColor = kleur(j0);
                end
                hold on
            end
            handle1.YLim(1) = 0;
            text(0,handle1.YLim(2),txt,'FontSize',11,'VerticalAlignment','top');
        elseif panels.SpikeStatMode==2
            hh = [];
            txt = ' ISI distribution (logx)';
            for j0=1:length(idx3)
                cluster = Mets(nres).result.(resnaam).spkstats.cluster(idx2,idx3(j0));
                if isempty(cluster.set) || isempty(cluster.distribution), continue; end
                txt = [txt txtcolor(kleur(j0)) sprintf('\n %s (%u)',cluster.txt,length(cluster.distribution))];
                hh = histogram(log10(adcdt*cluster.distribution),'Normalization','pdf');
                hh.FaceColor = 'y';
                if j0>1
                    hh.DisplayStyle='stairs';
                    hh.LineWidth = 2;
                    hh.EdgeColor = kleur(j0);
                end
                hold on
            end
            if ~isempty(hh)
                text((hh.Parent.XLim(1)),handle1.YLim(2),txt,'FontSize',11,'VerticalAlignment','top');
            end
        elseif panels.SpikeStatMode==3
            merged = [];
            for jj = 1:length(idx3)
                deset = Mets(nres).result.(resnaam).spkstats.cluster(idx2(1),idx3(jj)).set;
                spikes = Mets(nres).result.(resnaam).spkstats.idxs(deset,:);
                [n1,n2] = size(spikes);
                for j1 = 1:n1
                    for j2 = 1:n2
                        merged = [merged; spikes{j1,j2}];
                    end
                end
            end
            if length(merged)<6, return; end
            intervals = diff(sort(merged));
            intervals(intervals==0) = 1;
            rng(5);
            intervals = intervals-1+rand(length(intervals),1);
            XX = [log10(adcdt*intervals(1:end-1)) log10(adcdt*intervals(2:end))];
            [idx1,centers1] = kmeans(XX,3,'replicates',10);
            silvalue1 = mean(silhouette(XX,idx1));
            [idx,centers] = kmeans(XX,4,'replicates',10);
            silvalue = mean(silhouette(XX,idx));
            nclus = 4;
            if silvalue1>silvalue
                nclus    = 3;
                idx      = idx1;
                centers  = centers1;
                hlp = silvalue;
                silvalue = silvalue1;
                silvalue1 = hlp;
            end
            afstand = zeros(nclus,1);
            for jj = 1:nclus
                afstand(jj) = (centers(jj,1)+2)^2+(centers(jj,2)+2)^2;
            end
            [~,index] = sort(afstand);
            kleur1 = {'ok','ob','or','oc'};
            kleur2 = {'oy','or','ob','om'};
            for jj = 1:nclus
                deze = index(jj);
                plot(XX((idx==deze),1),XX((idx==deze),2),kleur1{jj},'LineStyle','none');
                hold on
                plot(centers(deze,1),centers(deze,2),kleur2{jj},'Markersize',14,'LineWidth',5);
                hold on
            end
            grens = log10(2*Mets(nres).result.(resnaam).spkstats.venster);
            plot([-2,3],[grens,grens],'g',[grens,grens],[-2,3],'g','LineWidth',2);
            axis([-2,3,-2,3]);
            text(handle1.XLim(2),handle1.YLim(2),sprintf('Silhouette(>0.65): %4.3f (%4.3f) ',silvalue,silvalue1),...
                 'FontSize',12,'VerticalAlignment','top','HorizontalAlignment','right');
        end
	else
%             yy = [];
%             zz = [];
%             for jj = 1:length(klasse)
%                 y = Mets(nres).result.(resnaam).spkstats.reliabil{klasse(jj)};
%                 z = jj+0*y;
%                 yy = [yy; y];
%                 zz = [zz; z];
%             end
%              curfig = gcf;
%             [p,tbl,stats] = kruskalwallis(yy,zz);
%             [c,m,h,nms]   = multcompare(stats);
%             curfig.CurrentAxes = handle;
    end
    if ~isempty(win2)
        if panels.SpikeStatMode==1
            handle2 = getplothandle(win2,true);
            txt =' Accuracy versus Reliability';
            for j0=1:length(idx3)
                cluster = Mets(nres).result.(resnaam).spkstats.cluster(idx2,idx3(j0));
                if isempty(cluster.set) || isempty(cluster.distribution), continue; end
                txt = [txt txtcolor(kleur(j0)) sprintf('\n %s',cluster.txt)];
                nbins = 1/min(diff(unique(cluster.rel)));
                xx = cluster.rel-(1/(2*nbins));
                yy = cluster.acc;
                plot(xx,yy,'o','Markersize',6,'Linewidth',0.5,'Color',kleur(j0));
                idx = sort(xx);
                xpnt = unique(idx);
                ypnt = 0*xpnt;
                for jj = 1:length(xpnt)
                    ypnt(jj) = mean(yy(xx==xpnt(jj)));
                end
                hold on
                plot(xpnt,ypnt,'o','Markersize',10,'Linewidth',1,'LineStyle',':','Color',kleur(j0));
            end
            handle2.XLim = [0,1];
            handle2.YLim(1) = 0;
            text(0,handle2.YLim(2),txt,'FontSize',11,'VerticalAlignment','top');
        elseif panels.SpikeStatMode==3
            handle2 = getplothandle(win2,true);
            sens = Mets(nres).result.(resnaam).spkstats.sensitivity;
            maxy = max(1.5*sens.clusters);
            adcdt = Mets(nres).result.(resnaam).spkstats.dt;
            if isempty(sens), return; end
            loglog(adcdt*sens.intervals,sens.clusters,'b',...
                   adcdt*sens.intervals,sens.clusters-sens.singles,'r',...
                   'LineWidth',2);
            axis([adcdt,max(sens.intervals),1,maxy]);
            hold on
            grens = 2*Mets(nres).result.(resnaam).spkstats.venster;
            plot([grens,grens],[1,maxy],'g','LineWidth',2);
            txt = ['#clusters as f(windowsize) ms ' ...
                   txtcolor('b') sprintf('\n %s','all clusters ')...
                   txtcolor('r') sprintf('\n %s','minus singles ')];
            text(handle2.XLim(2),handle2.YLim(2),txt,...
                 'FontSize',11,'VerticalAlignment','top','HorizontalAlignment','right');
        end
    end
end    

function showtemplate(xas)
global panels spikes
DB = getPANEL('DBpanel'); if isempty(DB), return; end
ylims = get(gca,'YLim');
die   = str2double(get(DB.nr,'String'));
xtr   = xas(1) + (0:length(spikes.template)-1)*(xas(2)-xas(1));
ytr   = spikes.gain(die)*spikes.template;
line('Xdata',xtr,'Ydata',ytr,'Color','r','LineWidth',2);
if ~isempty(spikes.tmprng)
    line('XData',[spikes.tmprng(1)*[1 1] NaN spikes.tmprng(2)*[1 1]]*1000/(spikes.adcrate*panels.timegain),...
         'YData',[ylims(1) ylims(2) NaN ylims(1) ylims(2)],...
         'Color','r','LineStyle','--','LineWidth',1);
end
text(xtrace(1),0.95*ylims(2),sprintf('  event:%u  gain:%0.2f  off:%0.2f  amp:%0.2f  error:%0.3f',...
                                  die,spikes.gain(die),spikes.off(die),spikes.fact(die),spikes.err(die)),...
                                  'Color','k','HorizontalAlignment','left','Fontsize',6,'Fontname','Courier');

function showspectrogram(handle,plt)
global graf
[plt.subs,present,parms] = ParseSpecial(plt.subs,'spectrogram');
legright = parms{1}; for jj = 2:length(parms), legright = [legright '/' parms{jj}]; end
[parms,present,ps] = ParseSpecial(parms,'origin');
if present
    origin = nsingle(ps{1});
    source = find([graf.window]==origin);
    if isempty(source)
        Error('Origin window does not exist');
        return
    end
    gbuf = get(graf(source).handle,'UserData');
    if isempty(gbuf.handles.trace)
        Error('There is no data in the trace window'); return
    end
    lbuf = get(gbuf.handles.trace(1),'UserData');
    if lbuf.xas.idx(2)>1
        TextLeft(handle,'No spectrogram with skip>1',18); return
    end
    switch lbuf.xas.unit
        case 'ms',  timegain = 1;
        case 'sec', timegain = 1000;
        case 'min', timegain = 60 * 1000;
        case 'hrs', timegain = 60*60*1000;
    end
    xas   = get(gbuf.handles.trace(1),'XData')' * timegain;
    trace = get(gbuf.handles.trace(1),'YData')';
else
    Error('define spectrogram origin window'); return
end
[parms,scale]       = ParseScale(parms);
if Error, return; end
[parms,present,ps]  = ParseSpecial(parms,'contours');  if present, contours = nsingle(ps{1}); else,contours = []; end
[parms,spectlen]    = ParseTijd(parms,'resolution',1); if isempty(spectlen), spectlen = round((xas(end) - xas(1))/20); end
[parms,present,ps]  = ParseSpecial(parms,'overlap');
if present, overlap = min(max(0.05,rsingle(ps{1})),0.95); else,overlap = 0.5; end
[parms,present,ps]  = ParseSpecial(parms,'smooth'); if present, smooth  = rsingle(ps{1}); else, smooth = []; end
[parms,present,ps]  = ParseSpecial(parms,'view');    if present, view = rsingle(ps{1}); else,view = [0,90]; end
if length(xas)>2500000
    button = 'Skip';
    if strcmp(button,questdlg(sprintf('spectrogram of %u points takes long!',length(xas)),'Spectrogram',button,'Do it',button));
        ltxt = 'too many points';
        return
    end
end
% ltxt = sprintf('\n use frame\n span %7.1f s\n at   %7.1f s\n%0.3f--%0.3f %s',(t2-t1)/1000,t1/1000,[t1 t2]/panels.timegain,lbuf.xas.unit);
dt = xas(2)-xas(1);
nmax = round(spectlen(1)/dt);
NFFT = 2;
while NFFT<nmax
    NFFT = NFFT*2;
end
if (NFFT-nmax)>(nmax-(NFFT/2)), NFFT = NFFT/2; end
NFFT2 = round(overlap * NFFT);
[y, fas, tas, qq]= spectrogram(trace,blackmanharris(NFFT),NFFT2,NFFT,1000/dt);
qq = abs(qq);
if strcmp(scale.logz,'log')
    qq = log10(qq);
end
if ~isempty(smooth)
    ff = ones(smooth(2),smooth(1));
    qq = conv2(qq,ff/sum(ff(:)),'same');
end
deltat = tas(1)*1000/timegain;
tas = (xas(1) +  tas*1000)/timegain;
tmin = tas(1)-deltat;
tmax = tas(end) + deltat;
[ymin,ymax] = scalexy(scale.y,scale.dy,fas(1),fas(end));
ypmax = find(fas>=ymax,1,'first');
if isempty(contours)
    surf(handle,tas,fas(1:ypmax),qq(1:ypmax,:),'EdgeColor','none');
else
    contourf(handle,tas,fas(1:ypmax),qq(1:ypmax,:),contours,'EdgeColor','none');
end
set(handle,'Yscale',scale.logy,'XLim',[tmin,tmax],'YLim',[ymin,ymax],'View',view);
[cmin,cmax] = scalexy(scale.z,scale.dz,min(min(qq)),max(max(qq)));
set(handle,'CLim',[cmin,cmax]);
    
function spectrum = makespectra(spectrum)
NFFT   = spectrum.NFFT;
NFFTd2 = spectrum.NFFT/2;
starts = NFFTd2 * (0:(spectrum.nseg-1)); % + round((size(spectrum.trace,1) - ((spectrum.nseg+1)*NFFTd2))/2);
for jj = 1:size(spectrum.trace,2)
    for ii = 1:spectrum.nseg
        yoff = mean(spectrum.trace(starts(ii)+(1:NFFT),jj));
        if spectrum.trend && ~isempty(spectrum.window)
            trace = detrend(spectrum.window.*(spectrum.trace(starts(ii)+(1:NFFT),jj)-yoff));
        elseif spectrum.trend
            trace = detrend(spectrum.trace(starts(ii)+(1:NFFT),jj));
        elseif ~isempty(spectrum.window)
            trace = spectrum.window.*spectrum.trace(starts(ii)+(1:NFFT),jj);
        else
            trace = spectrum.trace(starts(ii)+(1:NFFT),jj);
        end
        spt = fft(trace);
        pwr = abs(spt(1:(1+NFFTd2))/length(trace)).^2;
        pwr(2:end) = 2*pwr(2:end);
        if ii==1
            pwrs = pwr;
            sds  = pwr.*pwr;
        else
            pwrs = pwrs + pwr;
            sds  = sds  + pwr.*pwr;
        end
    end
    sgain = 2 * length(pwrs)/spectrum.nseg;
    if spectrum.nseg==1
        spectrum.sds(:,jj) = sgain * pwrs(2:end);
    else
        spectrum.sds(:,jj) = 2 * sgain * realsqrt(abs((sds(2:end) - (pwrs(2:end).^2/spectrum.nseg)))/(spectrum.nseg-1));
    end
    spectrum.pwr(:,jj) = sgain * pwrs(2:end);
end
if size(spectrum.trace,2)>1
    if spectrum.winnr(1)>0
        fase = unwrap(angle(fft(spectrum.trace(:,1)))-angle(fft(spectrum.trace(:,2))));
        fase = fase(1:floor(1+length(spectrum.trace(:,1))/2));
        fas  = (spectrum.rate/(1+length(spectrum.trace(:,1)))) * (0:length(fase)-1)';
        spectrum.phs = 0 * spectrum.fas;
        df = 0.5*(spectrum.fas(2)-spectrum.fas(1));
        for jj = 1:length(spectrum.fas)
            lower  = spectrum.fas(jj)-df;
            higher = spectrum.fas(jj)+df;
            spectrum.phs(jj) = mean(fase((fas>lower)&(fas<higher)));
        end
    end
    if spectrum.winnr(2)>0
        ff = mscohere(spectrum.trace(:,1),spectrum.trace(:,2),spectrum.window,NFFTd2,NFFT,spectrum.rate);
        spectrum.coh = ff(1:length(spectrum.fas));
    end
    if spectrum.winnr(3)>0
        spectrum.trf = spectrum.pwr(:,2)./spectrum.pwr(:,1);
    end
end

function showspectra(handle,plt)
global panels SEL graf
[plt.subs,present,parms] = ParseSpecial(plt.subs,'spectrum');
legright = parms{1}; for jj = 2:length(parms), legright = [legright '/' parms{jj}]; end
[parms,present,ps] = ParseSpecial(parms,'origin');
if ~present, Error('Specify origin window for spectrum'); return; end
origin = nsingle(ps{1});
source = find([graf.window]==origin);
if isempty(source)
    Error(sprintf('Source window %u does not exist',origin));
    return
end
orgbuf = get(graf(source).handle,'UserData');
if isempty(orgbuf.handles.trace), return; end
lbuf = get(orgbuf.handles.trace(1),'UserData');
if lbuf.xas.idx(2)>1
    TextLeft(handle,'No spectra with skip>1',18);
    return;
end
switch lbuf.xas.unit
    case 'ms',  timegain = 1;
    case 'sec', timegain = 1000;
    case 'min', timegain = 60 * 1000;
    case 'hrs', timegain = 60*60*1000;
end
xas = get(orgbuf.handles.trace(1),'XData')' * timegain/1000;
channels = [];
if length(ps)>1
    if strcmp(ps{2},'select')
        if ~isempty(SEL)
            elhs = cell2mat(get(SEL.chh,'Value'))';
            spcs = cell2mat(get(SEL.sph,'Value'))';
            channels = [];
            cnt = 0;
            for jj = 1:4
                if elhs(jj)
                    cnt = cnt + 1;
                    if spcs(jj)
                        channels = [channels cnt];
                    end
                end
            end
        end
    else
        channels = nsingle(ps{2});
        if channels==0, channels = 1:length(orgbuf.handles.trace); end
    end
    if isempty(channels), return; end
end
if isempty(channels), channels = 1:length(orgbuf.handles.trace); end
dt = xas(2)-xas(1);
spectrum = struct('fas',  [],...
                  'window',[],...
                  'winnr',[0,0,0],...
                  'trend',true,...
                  'NFFT', [],...
                  'nseg', [],...
                  'rate', 1/dt,...
                  'color',[],...
                  'pwr',  [],...
                  'sds',  [],...
                  'phs',  [],...
                  'coh',  [],...
                  'trf',  []);
[parms,segtime] = ParseTijd(parms,'resolution',1000); if isempty(segtime), segtime = inf; end
segtime         = min(segtime,xas(end)-xas(1));
[parms,present] = ParseSpecial(parms,'2voud');
if present
    nmax = round(segtime/dt);
    NFFT = 2;
    while NFFT<nmax
        NFFT = NFFT*2;
    end
    if (NFFT-nmax)>(nmax-(NFFT/2)), NFFT = NFFT/2; end
else
    NFFT = 2 * floor(segtime/(2*dt));
end
spectrum.NFFT  = NFFT;
spectrum.nseg  = floor(2*length(xas)/spectrum.NFFT)-1;
spectrum.trace = zeros(length(xas),length(channels));
spectrum.color = zeros(3,length(channels));
spectrum.fas   = (1/segtime) * (1:(spectrum.NFFT/2))';
cnt = 0;
for jj = 1:length(channels)
    chan = channels(jj);
    if chan>length(orgbuf.handles.trace), continue; end
    cnt = cnt + 1;
    spectrum.color(1:3,cnt) = get(orgbuf.handles.trace(chan),'Color');
    spectrum.trace(:,cnt)   = get(orgbuf.handles.trace(chan),'YData')';
    spectrum.trace(:,cnt)   = spectrum.trace(:,cnt) - mean(spectrum.trace(:,cnt));
end
[parms,present,ps] = ParseSpecial(parms,'phase');     if present, spectrum.winnr(1) = nsingle(ps{1}); end
[parms,present,ps] = ParseSpecial(parms,'coherence'); if present, spectrum.winnr(2) = nsingle(ps{1}); end
[parms,present,ps] = ParseSpecial(parms,'transfer');  if present, spectrum.winnr(3) = nsingle(ps{1}); end
[parms,present]    = ParseSpecial(parms,'nowindow');
if ~present, spectrum.window = blackmanharris(spectrum.NFFT);  spectrum.window = spectrum.window/mean(realsqrt(spectrum.window)); end
[parms,spectrum.trend] = ParseSpecial(parms,'notrend'); spectrum.trend  = ~spectrum.trend;
spectrum = makespectra(spectrum);
if ~Error
    drawspectra(parms,handle,spectrum,legright)
end

function drawspectra(parms,handle,spectrum,legright)
global SEL
gbuf = get(handle,'UserData');
[parms,scale]  = ParseScale(parms);
if Error, return; end
[parms,metsem] = ParseSpecial(parms,'sem');
if ~isempty(SEL)
    overrule = get(SEL.k50Hz,'Value');
    if isempty(overrule), overrule = true; end
else
    overrule = true;
end
[parms,present,ps] = ParseSpecial(parms,'kill');
kill = [];
if present && overrule
    if length(ps)<2
        Error('kill needs center & width');
        return
    else
        center = rsingle(ps{1});
        width  = rsingle(ps{2});
        kill = find((spectrum.fas>=center - width) & (spectrum.fas<=(center + width)));
    end
end
[parms,present,ps] = ParseSpecial(parms,'smooth');
if present
    smooth = rsingle(ps{1});
    clen = find(spectrum.fas>=smooth,1,'first');
    if clen>1
        cfilter = ones(clen,1)/clen;
        spectrum.fas = conv(spectrum.fas,cfilter,'same');
        for jj = 1:size(spectrum.pwr,2)
            spectrum.pwr(:,jj) = conv(spectrum.pwr(:,jj),cfilter,'same');
            spectrum.sds(:,jj) = conv(spectrum.sds(:,jj),cfilter,'same');
        end
    end
end
% gbuf.yunit = {'mV2/Hz';'mV2/Hz'};
if strcmp(scale.logx,'log')
    if scale.x(1)<=0,     scale.x(1) = spectrum.fas(1); end
    if isinf(scale.x(2)), scale.x(2) = spectrum.fas(end); end
end
if strcmp(scale.logy,'log') && (scale.y(1)<=0), scale.y(1) = 0; end
set(handle,'XScale' ,scale.logx,'YScale',scale.logy,'XLim',scale.x(1:2),'YLim',scale.y(1:2));
p1 = find(spectrum.fas>=scale.x(1),1,'first');
p2 = find(spectrum.fas<=scale.x(2),1,'last');
maxy = 0;
for jj = 1:size(spectrum.pwr,2)
    if ~isempty(kill)
        b = spectrum.pwr(kill(1),jj);
        a = (spectrum.pwr(kill(end),jj)-b)/(length(kill)-1);
        spectrum.pwr(kill,jj) = a*(kill-kill(1))+b;
        spectrum.sds(kill,jj) = 0.5 * (spectrum.sds(kill(1),jj)+spectrum.sds(kill(end),jj));
    end
    if metsem
        patch ([spectrum.fas(p1:p2);                             spectrum.fas(p2:-1:p1)],...
               [spectrum.pwr(p1:p2,jj)+spectrum.sds(p1:p2,jj); spectrum.pwr(p2:-1:p1,jj)],...
               [0.7 0.7 0.7],...
               'EdgeColor','none');
    end
    gbuf.handles.trace(jj) = line(spectrum.fas(p1:p2),spectrum.pwr(p1:p2,jj),'Color',spectrum.color(:,jj),'Linewidth',0.5,...
                                     'ButtonDownFcn',{@NRNklik,jj});
    if isinf(scale.y(2)), maxy = max(maxy,max(spectrum.pwr(p1:p2,jj))); end
end
if isinf(scale.y(2)), set(handle,'YLim',[scale.y(1),1.05*maxy]); end
if size(spectrum.pwr,2)>1, correctorder(handle); end
TextRight(handle,legright,14);
TextLeft(handle,'Power-Spectra',14);
set(handle,'UserData',gbuf);
grid on
if spectrum.winnr(1)>0
    winhandle = getplothandle(spectrum.winnr(1),true);
    set(winhandle,'XScale',scale.logx,'XLim',scale.x(1:2),'YLim',[-180 180]);
    grid on
    line(spectrum.fas,spectrum.phs,'Color','g','Linewidth',2,'ButtonDownFcn',{@NRNklik,1});
%     ylims = get(gca,'YLim');
%     gbuf.type       = sprintf('\nphase difference (%s)',timetext);
%     gbuf.yas        = fase;
%     gbuf.yunit{1,1} = 'rad';
%     gbuf = showLR(gbuf,sfxmin,sfxmax,ylims(2),gbuf.type,stxt);
%     set(panels.spectra.win(3),'UserData',gbuf);
end
if spectrum.winnr(2)>0
    winhandle = getplothandle(spectrum.winnr(2),true);
    set(winhandle,'XScale',scale.logx,'XLim',scale.x(1:2),'YLim',[0 1]);
    grid on
    line(spectrum.fas,spectrum.coh,'Color','c','Linewidth',2,'ButtonDownFcn',{@NRNklik,1});
%     gbuf.type       = sprintf('\ncoherence (%s)',timetext);
%     gbuf.yas        = cxy;
%     gbuf.yunit{1,1} = 'norm';
%     gbuf = showLR(gbuf,sfxmin,sfxmax,0.99,gbuf.type,stxt);
%     set(panels.spectra.win(2),'UserData',gbuf);
end
if spectrum.winnr(3)>0
    winhandle = getplothandle(spectrum.winnr(3),true);
    set(winhandle,'XScale',scale.logx,'XLim',scale.x(1:2),'YScale',scale.logy);
    grid on
    line(spectrum.fas,spectrum.trf,'Color','b','Linewidth',2,'ButtonDownFcn',{@NRNklik,1});
%     gbuf.type       = sprintf('\ntransfer function (%s)',timetext);
%     gbuf.yas        = trf;
%     gbuf.yunit{1,1} = 'Normalized';
%     gbuf = showLR(gbuf,sfxmin,sfxmax,sfymax,gbuf.type,stxt);
%     set(panels.spectra.win(4),'UserData',gbuf);
end

function showpwr(trace1,sxmin,adcrate,ylim,wid)
global panels
dt  = 1000/(adcrate*panels.timegain);
xas = sxmin +(0:length(trace1)-1)'*dt;
trace = cumsum(trace1.^2);
if ~isinf(pltpwr(1))
    shift = 2*round(0.5*pltpwr(1)/dt);
    trace = trace(1+shift:end)-trace(1:end-shift);
end
gain = 0.95*pltpwr(2)*(ylim(2)-ylim(1)) / max(trace);
line(0.5*shift*dt+xas(1:length(trace)),ylim(1)+gain*trace,'Color','b','LineWidth',wid);

function drawlines(points,colors)
global panels
if isempty(points), return; end
if isempty(colors)
    colors = 'k';
elseif length(colors)>length(points)
    colors = colors(1:length(points));
end
ylims = get(gca,'YLim');
for jjj = 1:length(colors)
    xln = points(jjj)*[1 1];
    yln = ylims;
    for iii = (jjj+length(colors)):length(colors):length(points)
        xln = [xln NaN points(iii)*[1 1]];
        yln = [yln NaN ylims];
    end
    line('XData',xln/panels.timegain,'YData',yln,'Color',colors(jjj),'LineStyle','--','LineWidth',1);
end

function [smin,smax] = scalexy(vals,dvals,xymin,xymax)
if isempty(dvals), dvals = [0,0]; end
smin = -inf;
smax = inf;
if isinf(vals(1)) && isinf(vals(2))
    dxy = (xymax-xymin);
    if ~isinf(dxy)
        smin = xymin - abs(dvals(1) * dxy);
        smax = xymax + abs(dvals(2) * dxy);
    end
elseif isinf(vals(1))
    smax = vals(2);
    if ~isinf(xymin)
        smin = xymin - abs(dvals(1) * (smax-xymin));
    end
elseif isinf(vals(2))
    smin = vals(1);
    if ~isinf(xymax)
        smax = xymax + abs(dvals(2) * (xymax-smin));
    end
else
    smin = vals(1);
    smax = vals(2);
end
if smin == smax
    smin = smin - 0.5;
    smax = smax + 0.5;
end

function showshadow
global panels
if ~isempty(panels.cursor.xpnt) && ~isempty(panels.cursor.shadow)
    for jj = 1:length(panels.cursor.shadow)
        set(panels.cursor.shadow(jj),'XData',panels.cursor.xpnt(1)*[1 1]);
    end
end

function showphase(handle,plt,Mets,plotter)
global panels
metnr = max(1,min(length(Mets),plotter.metnr));
swpnr = max(1,min(size(Mets(metnr).adc,3),plotter.subnr));
kanalen = intersect(plt.chns,1:size(Mets(metnr).adc,2));
dt = 1000/Mets(metnr).ADC.rate;
[~,present,ps] = ParseSpecial(plt.subs,'phase');
if present
    dh = max(1,round(rsingle(ps{2})/dt));
else
    dh = 1;
end
bgn = 1+round(panels.zoom.tbgn / dt);
lst = 1+round(panels.zoom.tlst / dt);
for jj = 1:length(kanalen)
    kanaal = kanalen(jj);
    kleur  = plt.color(jj);
    trace = double(Mets(metnr).adc(bgn:lst,kanaal,swpnr)) * Mets(metnr).ADC.scale(kanaal).User/Mets(metnr).ADC.ints;
    dtrace = trace;
    dtrace((dh+1):(end-dh)) = (trace((2*dh+1):end) - trace(1:(end-2*dh)))/(dh*dt);
    dtrace(1:dh) = 0;
    dtrace((end-dh):end) = 0;
    plot(trace,dtrace,kleur);
    hold on
end
plot(plt.scale.x,[0,0]);
plot([0,0],plt.scale.y);
axis([plt.scale.x, plt.scale.y]);

function showfoto(handle,plt)
global graf IMG timeline
if ~isfield(IMG,'bld') || isempty(IMG.bld), TextLeft(handle,'  No fotos',18); return; end
parms = plt.subs;
[parms,dozero,ps] = ParseSpecial(parms,'zero');  if dozero, if isempty(ps), imgnul = 3; else, imgnul = nsingle(ps{1}); end; end
[parms,domovie]   = ParseSpecial(parms,'movie'); if domovie, imgnr = 1; end
[parms,dofoto,ps] = ParseSpecial(parms,'foto');  if dofoto, imgnr = nsingle(ps{1}); else,imgr = 1; end
imgnr = max(1,min(imgnr,length(IMG.bld)));
txt1 = sprintf('%u-%s',imgnr,IMG.nam{imgnr});
txt2 = '';
gbuf = get(handle,'UserData');
timeline.par((timeline.par(:,1)==10) & (timeline.idx(:,2)==imgnr),4) = gbuf.window;
rodestippen;
grafnr = find([graf.handle]==handle);
graf(grafnr).bld = imgnr;
if isempty(IMG.pnl.handle)
    beeld = IMG.bld{imgnr};
else
    flmtime = get(IMG.pnl.time,'Value');
    roinr   = str2double(get(IMG.pnl.roinr,'String'));
    roimax  = length(IMG.object);
    if domovie
        beeld = squeeze(IMG.flm{IMG.flmnr}(:,:,flmtime));
        IMG.bld{1} = beeld;
    else
        beeld = IMG.bld{imgnr};
    end
end
[parms,present] = ParseSpecial(parms,'adapt');    if present, beeld = adapthisteq(beeld); txt2 = 'adapt'; end
[parms,present] = ParseSpecial(parms,'brighten'); if present, beeld = imadjust(beeld); txt2 = 'brighten'; end
[parms,present] = ParseSpecial(parms,'equalize'); if present, beeld = histeq(beeld); txt2 = 'equalize'; end
[parms,present,ps] = ParseSpecial(parms,'filter');
if present
    nf = nsingle(ps{1});
    kernel = ones(nf,nf)/(nf*nf);
    beeld = uint16(conv2(double(beeld),kernel,'same'));
    txt2 = sprintf('filter(%u)',nf);
end
if isempty(IMG.pnl.handle)
    imshow(beeld,[],'Parent',handle);
    return
end
imin = str2double(get(IMG.pnl.imin,'String'));
imax = str2double(get(IMG.pnl.imax,'String'));
txt4 = sprintf('%u',beeld(IMG.ypnt,IMG.xpnt));
if (imgnr<6) || IMG.basic.equ
    if dozero && (imgnr<5)
        beeld = beeld(IMG.zoomy(1):IMG.zoomy(2),IMG.zoomx(1):IMG.zoomx(2)) - IMG.bld{imgnul}(IMG.zoomy(1):IMG.zoomy(2),IMG.zoomx(1):IMG.zoomx(2));
    else
        beeld = beeld(IMG.zoomy(1):IMG.zoomy(2),IMG.zoomx(1):IMG.zoomx(2));
    end
end
txt3 = sprintf('%u x %u',size(beeld,2),size(beeld,1) );
if imgnr==1
    if get(IMG.pnl.auto,'Value')
        imin = min(beeld(:));
        set(IMG.pnl.imin,'String',sprintf('%u',imin));
        imax = max(beeld(:));
        set(IMG.pnl.imax,'String',sprintf('%u',imax));
    end
    grafhandle = imshow(beeld,[imin,imax],'Parent',handle);
elseif imgnr==5
    if (roinr==0)
        if roimax<2, return; end
        bgn = 2;
        lst = roimax;
    else
        bgn = roinr;
        lst = bgn;
    end
    beeld = false(size(IMG.bld{IMG.refimg}));
    for jj = bgn:lst
        if ~isempty(IMG.object(jj).bw)
            beeld(IMG.object(jj).bwy(1):IMG.object(jj).bwy(2),IMG.object(jj).bwx(1):IMG.object(jj).bwx(2)) = IMG.object(jj).bw;
        end
    end
    if bgn==1
        beeld = beeld(IMG.zoomy(1):IMG.zoomy(2),IMG.zoomx(1):IMG.zoomx(2));
    else
        [yys,xxs] = find(beeld==1);
        margin = round(str2double(get(IMG.pnl.margin,'String')));
        [my,mx] = size(IMG.bld{1});
        IMG.zoomx = [max(1,min(xxs)-margin),min(my,max(xxs)+margin)];
        IMG.zoomy = [max(1,min(yys)-margin),min(mx,max(yys)+margin)];
        beeld     = beeld(IMG.zoomy(1):IMG.zoomy(2),IMG.zoomx(1):IMG.zoomx(2));
    end
    if (roinr>1) && ((IMG.object(roinr).class==2) || (IMG.object(roinr).class==3))
        orgbld = IMG.bld{IMG.refimg}(IMG.zoomy(1):IMG.zoomy(2),IMG.zoomx(1):IMG.zoomx(2));
        amin = min(orgbld(beeld));
        amax = max(orgbld(beeld));
        grafhandle = imshow(double(beeld).*double(orgbld),[amin amax],'Parent',handle);
    else
        grafhandle = imshow(beeld,'Parent',handle);
    end
    for jj = bgn:lst
        kleur = 'w';
        if isempty(IMG.object(jj).bwx), continue; end
        line(IMG.object(jj).center(1)-IMG.zoomx(1)+1  ,IMG.object(jj).center(2)-IMG.zoomy(1)+1,...
             'MarkerFaceColor','none','MarkerEdgeColor','c','Marker','o','MarkerSize',24,'Linewidth',2,...
             'ButtonDownFcn',{@IMGselect,jj});
       if bgn==lst
            if IMG.object(jj).class==1
                line(IMG.object(jj).mass(1)-IMG.zoomx(1)+1,IMG.object(jj).mass(2)-IMG.zoomy(1)+1,...
                     'MarkerFaceColor','r','MarkerEdgeColor','r','Marker','o','MarkerSize',12,'Linewidth',1,...
                     'ButtonDownFcn',{@IMGklik,jj});
            end
        end
        if roinr==0
            for hhh = 1:size(IMG.object(jj).d2plak,1)
                kleur = 'g';
                line([IMG.object(jj).center(1)  IMG.object(jj).d2plak(hhh,1)]-IMG.zoomx(1)+1,...
                     [IMG.object(jj).center(2)  IMG.object(jj).d2plak(hhh,2)]-IMG.zoomy(1)+1,...
                     'Color',kleur,'Linewidth',2,'LineStyle',':');
            end
            for hhh = 1:size(IMG.object(jj).d2stim,1)
                kleur = 'y';
                line([IMG.object(jj).center(1)  IMG.object(jj).d2stim(hhh,1)]-IMG.zoomx(1)+1,...
                     [IMG.object(jj).center(2)  IMG.object(jj).d2stim(hhh,2)]-IMGzoomy(1)+1,...
                     'Color',kleur,'Linewidth',2,'LineStyle',':');
            end
        end
        text(IMG.object(jj).bwx(2)-IMG.zoomx(1)+2,IMG.object(jj).bwy(1)-IMG.zoomy(1),sprintf('%u',jj),...
             'Color',kleur,'HorizontalAlignment','Left','VerticalAlignment','Bottom','Fontsize',16,'Fontname','Courier');
    end
    if roinr==0
        txt3 = sprintf('%u x %u',size(beeld,2),size(beeld,1) );
    end
else
    schaal = [];
    [parms,isfixed,ps] = ParseSpecial(parms,'fixed');
    if isfixed
        if isempty(ps)
            schaal = [imin imax];
        else
            schaal = [rsingle(ps{1}),rsingle(ps{2})];
        end
    end
    grafhandle = imshow(beeld,schaal,'Parent',handle);
end
if ~isempty(grafhandle), set(grafhandle,'ButtonDownFcn',{@IMGklik,imgnr}); end
if get(IMG.pnl.color,'Value'), colormap(jet(128)); end
if ~isempty(IMG) && ((imgnr<6) || IMG.basic.equ)
    graf(grafnr).cursor=line(IMG.xpnt-IMG.zoomx(1)+1, IMG.ypnt-IMG.zoomy(1)+1,...
                             'MarkerFaceColor','none','MarkerEdgeColor','g','Marker','o','MarkerSize',18,...
                             'Linewidth',2,'ButtonDownFcn',{@IMGklik,imgnr});
else
    graf(grafnr).cursor = 0;
end
set(handle,'UserData',gbuf);

function showmeans(handle,plt,Mets,plotter)
global timeline
nres = plotter.metnr;
if nres>length(Mets), TextLeft(handle,sprintf('Meting does not have node %u',nres),16); return; end
CMD = getPANEL('CMDpanel');
resname  = plotter.struct;
if ~isfield(Mets(nres).result,resname), TextLeft(handle,sprintf('%s is not present in means',resname),16); return; end
parms    = ParseSimple(strrep(plt.str,'/',','));
dotraces = false;
[parms,doavg,ps1] = ParseSpecial(parms,'means');
if ~doavg
    [parms,dotraces,ps2] = ParseSpecial(parms,'traces');
    if dotraces
        subname = ps2{1};
        sets    = nsingle(ps2{2});
        mets    = nsingle(ps2{3});
    else
        [parms,present,ps1] = ParseSpecial(parms,'sweeps');
        if ~present, Error( 'showmeans needs means,sweeps,traces'); return; end
    end
end
if ~dotraces, subname = ps1{1}; end
if ~isfield(Mets(nres).result.(resname),subname), TextLeft(handle,sprintf('%s is not defined',subname)); return; end
metswp = Mets(nres).result.(resname).basis.metswp;

sets = unique(metswp(:,1)); if length(sets)>1, [parms,present,ps2] = ParseSpecial(parms,"set"); if present, sets = nsingle(ps2{1}); end; end
mets = unique(metswp(:,2)); if length(mets)>1, [parms,present,ps2] = ParseSpecial(parms,'met'); if present, mets = nsingle(ps2{1}); end; end
swps = unique(metswp(:,3)); 
lops = unique(metswp(:,4)); if length(lops)>1, [parms,present,ps2] = ParseSpecial(parms,'lop'); if present, lops = nsingle(ps2{1}); end; end
nods = unique(metswp(:,5)); if length(nods)>1, [parms,present,ps2] = ParseSpecial(parms,'nod'); if present, nods = nsingle(ps2{1}); end; end

residx = find(strcmp(fieldnames(Mets(nres).result),resname));
subidx = find(strcmp(fieldnames(Mets(nres).result.(resname)),subname));
[parms,width]     = ParseOne(parms,'width',0.5);
[parms,plt.scale] = ParseScale(parms);  
if Error, return; end
if doavg
    SWP = Mets(nres).result.(resname).(subname).SWPm;
else
    SWP = Mets(nres).result.(resname).(subname).SWPs;
end
[numpnts,numtraces] = size(SWP);
xas = Mets(nres).result.(resname).(subname).xas(1) * (0:(numpnts-1))';
units = 'mV';  %  Mets(nres).result.(resname).means.(subname).yunit;
if isfield(Mets(nres).result.(resname),subname)
    options = Mets(nres).result.(resname).(subname);
else
    options = [];
end
split = 1-(realpow(10,get(CMD.ADCseparator,'Value'))-0.01)/0.99;
gain  = power(10,get(CMD.ADCgain,'Value'));
if doavg
    ymax = 2* max(SWP);
elseif ~isinf(plt.scale.y(2))
    ymax = plt.scale.y(2)/gain;
else
    ymax = Mets(nres).result.(resname).(subname).yscale(2)/gain;
end
axis([xas(1),xas(end),[-1,1]*ymax]);
line(xas([1,end]),[0,0],'Color','k','LineWidth',1,'LineStyle',':');
gbuf  = get(handle,'UserData');
valid = true(numtraces,1);
if isfield(options,'missers'), valid = valid & ~options.missers; end
if isfield(options,'outlier'), valid = valid & ~options.outlier; end
if isfield(options,'spikers'), valid = valid & ~options.spikers; end
if isfield(options,'nospike'), valid = valid & ~options.nospike; end
ntot = 0;
nmis = [];
nout = [];
nspk = [];
mspk = [];
for j3 = 1:length(lops)
    for j2 = 1:length(sets)
        for j1 = 1:length(mets)
            traces = (metswp(:,4)==lops(j3)) & (metswp(:,1)==sets(j2)) & (metswp(:,2)==mets(j1));
            ntot = ntot + sum(traces);
            index = valid & traces;
            if sum(index)==0, TextLeft(handle,sprintf('set: %u, met %u do not exist',sets(j2),mets(j1)),16); return; end
            if length(index)>1, offset = (-1:2/(length(index)-1):1)*split*ymax; else, offset = 0; end
            if doavg
                line(xas,SWP,'Color','b','LineWidth',width,'LineStyle','-');
                TextLeft(handle,'mean EP trace');
                xnul = Mets(nres).result.(resname).(subname).xas(2);
                x = Mets(nres).result.(resname).(subname).kkwrange-xnul;
                patch([x(1),x(1),x(2),x(2),x(1)],[-ymax,ymax,ymax,-ymax,-ymax],[0.9,1,0.9],'LineStyle','none');
                correctorder(handle)
            elseif dotraces
                if isempty(options)
                    line(xas,SWP(:,index),'Color',choose(ntot,plt.color),'LineWidth',width,'LineStyle','-');
                else
                    index2 = (metswp(:,4)==lops(j3)) & (metswp(:,1)==sets(j2)) & (metswp(:,2)==mets(j1));
                    if isfield(options,'missers')
                        select = index2 & options.missers;
                        if sum(select)>0
                            line(xas,SWP(:,select),'Color','c','LineWidth',width,'LineStyle','-');
                            if isempty(nmis), nmis = 0; end; nmis = nmis + sum(select);
                        end
                    end
                    if isfield(options,'spikers')
                        select = index2 & options.spikers;
                        if sum(select)>0
                            line(xas,SWP(:,select),'Color','g','LineWidth',width,'LineStyle','-');
                            if isempty(nspk), nspk = 0; end; nspk = nspk + sum(select);
                        end
                    end
                    if isfield(options,'nospike')
                        select = index2 & options.nospike;
                        if sum(select)>0
                            line(xas,SWP(:,select),'Color','g','LineWidth',width,'LineStyle','-');
                            if isempty(mspk), nspk = 0; end; nspk = nspk + sum(select);
                        end
                    end
                    if isfield(options,'outlier')
                        select = index2 & options.outlier;
                        if sum(select)>0
                            line(xas,SWP(:,select),'Color','r','LineWidth',width,'LineStyle','-');
                            if isempty(nout), nout = 0; end; nout = nout + sum(select);
                        end
                    end
                    line(xas,SWPs(:,index),'Color','b','LineWidth',width,'LineStyle','-');
                end
%                 if dogr1, txt = [txt txtcolor('g'), sprintf('\n%s(%0.1f)'  ,'  spikers',  100*spkr/(ntot-nmis))]; end
%                 if dogr2, txt = [txt txtcolor('g'), sprintf('\n%s(%0.1f%%)','  nospike',100*nspk/(ntot-nmis))]; end
            else
                yas = mean(SWP(:,index),2);
                if length(swps)>1
                    sem = std(SWP(:,index),0,2)/realsqrt(sum(index));
                    patch([xas; xas(end:-1:1)],[yas+sem; yas(end:-1:1)-sem(end:-1:1)],[0.8,0.8,1.0],'LineStyle','none');
                end
                line(xas,yas,'Color',choose(ntot,plt.color),'LineWidth',width,'LineStyle','-');
            end
            mark = (timeline.par(:,1)==14) & ...
                   (timeline.idx(:,2)==residx) & ...
                   (timeline.idx(:,3)==subidx) & ...
                   (timeline.idx(:,4)==sets(j2)) & ...
                   (timeline.idx(:,5)==mets(j1));
            timeline.par(mark,4) = gbuf.window;
            rodestippen;
        end
    end
end
if dotraces
    txt = [txtcolor('b')                         sprintf(' sweeps (ntot=%u)',ntot)];
    if ~isempty(nmis), txt = [txt txtcolor('c'), sprintf('\n missers (%0.1f%%)',100*nmis/ntot)]; end
    if ~isempty(nspk), txt = [txt txtcolor('g'), sprintf('\n spikers (%0.1f%%)',100*nspk/ntot)]; end
    if ~isempty(mspk), txt = [txt txtcolor('g'), sprintf('\n nospike (%0.1f%%)',100*mspk/ntot)]; end
    if ~isempty(nout), txt = [txt txtcolor('r'), sprintf('\n outlier (%0.1f%%)',100*nout/ntot)]; end
    TextLeft(handle,txt);
    if ~isinf(Mets(nres).result.(resname).(subname).outrange(1))
        x = Mets(nres).result.(resname).(subname).outrange;
        patch([x(1),x(1),x(2),x(2),x(1)],[-ymax,ymax,ymax,-ymax,-ymax],[0.9,1,0.9],'LineStyle','none');
        correctorder(handle)
    end
end
if length(swps)>1, correctorder(handle); end 
TextRight(handle,plt.str)
TextYAS  (handle,units);

function showdynamic(handle,plt,Mets,plotter)
global timeline
gbuf = get(handle,'UserData');
% pos  = get(handle,'Position'); pos(3)=0.975*pos(3); set(handle,'Position',pos);
if isempty(plotter.struct)
    done = false;
    for nres = 1:length(Mets)
        if ~isempty(Mets(nres).result)
            names = fieldnames(Mets(nres).result);
            for jj = 1:length(names)
                if isfield(Mets(nres).result.(names{jj}),'dynamic')
                    resnaam = names{jj};
                    done = true;
                    break
                end
            end
        end
        if done, break; end
    end
    if ~done, return; end
else
    resnaam = plotter.struct;
    nres    = plotter.metnr;
    if nres>length(Mets), return; end
end
idx0 = find(strcmp(fieldnames(Mets(nres).result),resnaam));
[parms,linecolors] = ParseSpecial(plt.parms,'colors');
[parms,present,ps] = ParseSpecial(parms,'sets');
if present,idx1 = nsingle(ps{1}); end
if idx1==0,idx1 = unique(Mets(nres).result.(resnaam).basis.metswp(:,1)); end
use1 = false(size(Mets(nres).result.(resnaam).basis.metswp,1),1);
for jj = 1:length(idx1)
    use1 = use1 | (Mets(nres).result.(resnaam).basis.metswp(:,1)==idx1(jj));
end
[parms,present,ps] = ParseSpecial(parms,'mets');
if present, idx2 = nsingle(ps{1}); end
if idx2==0, idx2 = unique(Mets(nres).result.(resnaam).basis.metswp(:,2)); end
use2 = false(size(Mets(nres).result.(resnaam).basis.metswp,1),1);
for jj = 1:length(idx2)
    use2 = use2 | (Mets(nres).result.(resnaam).basis.metswp(:,2)==idx2(jj));
end
names = fieldnames(Mets(nres).result.(resnaam).dynamic);
names = names(2:end);
[parms,present,curtxt] = ParseSpecial(parms,'currents');
if ~present, return; end
as0 = false; ylim0 = [-150,150];
as1 = false; ylim1 = [0,inf];
as2 = false; ylim2 = [-inf,0];
as3 = false; ylim3 = [-inf, inf];
as4 = false; ylim4 = [0,inf];
for jj = 1:length(curtxt)
    [curtxt{jj},hlp] = ParseCmd(curtxt{jj});
    switch curtxt{jj}
        case {'Vm'},           as0 = true; if ~isempty(hlp), ylim0(1) = rsingle(hlp{1}); ylim0(2) = rsingle(hlp{2}); end
        case {'IA';'IK';'IC'}, as1 = true; if ~isempty(hlp), ylim1(2) = rsingle(hlp{1}); end
        case {'IS';'IT'},      as2 = true; if ~isempty(hlp), ylim2(1) = rsingle(hlp{1}); end
        case {'IH'},           as3 = true; if ~isempty(hlp), ylim3(1) = rsingle(hlp{1}); ylim3(2) = rsingle(hlp{2}); end    
        case {'Ca'},           as4 = true; if ~isempty(hlp), ylim4(2) = rsingle(hlp{1}); end
    end
end
both = (as1+as2+as3+as4)>1;
time  = Mets(nres).result.(resnaam).dynamic.varia.time;
[sxmin,sxmax] = scalexy(plt.scale.x,plt.scale.dx,time(1),time(end));
t1 = sprintf(' %s\n %s\n\n',Mets(nres).result.(resnaam).dynamic.varia.model,...
                            Mets(nres).result.(resnaam).dynamic.varia.drf);
t0 = [];
t2 = [];
nrs = [];
for jj = 1:length(curtxt)
    switch curtxt{jj}
        case 'Vm', kleur = '-k'; t0 = ['\color',   sprintf('{black}\n Vm')];     if both, yyaxis left; end;  ylim = ylim0;
        case 'IK', kleur = '-c'; t1 = [t1 '\color',sprintf('{cyan} IK\n')];      if both, yyaxis left; end;  ylim = ylim1;
        case 'IA', kleur = '-b'; t1 = [t1 '\color',sprintf('{blue} IA\n')];      if both, yyaxis left; end;  ylim = ylim1;
        case 'IC', kleur = '-r'; t1 = [t1 '\color',sprintf('{red} IC\n')];       if both, yyaxis left; end;  ylim = ylim1;
        case 'IH', kleur = '-m'; t2 = ['\color',sprintf('{magenta}\n\n\n IH ')]; if both, yyaxis right; end; ylim = ylim3; handle.YColor = [1,0,1];
        case 'Ca', kleur = '-r'; t2 = ['\color',sprintf('{red}\n\n\n [Ca]i ')];  if both, yyaxis right; end; ylim = ylim4; handle.YColor = [1,0,0];
        case 'IT', kleur = '-b'; t1 = [t1 '\color',sprintf('{blue} IT\n')];      if both, if as1, yyaxis right; else, yyaxis left; end; end; ylim = ylim2;
        case 'IS', kleur = '-c'; t1 = [t1 '\color',sprintf('{cyan} IS\n')];      if both, if as1, yyaxis right; else, yyaxis left; end; end; ylim = ylim2;
    end 
    nrs(jj) = find(strcmp(names,curtxt{jj}));
    names = fieldnames(Mets(nres).result.(resnaam).dynamic); names = names(2:end);
    gain  = Mets(nres).result.(resnaam).dynamic.varia.norm(strcmp(names,curtxt{jj}));
    trace = gain*Mets(nres).result.(resnaam).dynamic.(curtxt{jj})(:,use1 & use2);
    if (size(trace,2)>1) && linecolors
        plot(time,trace);
    else
        plot(time,trace,kleur);
    end
    hold on
    if plt.grid, grid on; end
    if isinf(ylim(1)), ylim(1) = handle.YLim(1); end
    if isinf(ylim(2)), ylim(2) = handle.YLim(2); end
    axis([sxmin sxmax ylim]);
end
if isempty(t0)
    if ~isempty(t1), text(handle.XLim(1),handle.YLim(2),t1,'HorizontalAlignment','Left', 'VerticalAlignment','Top','Fontsize',12,'Fontname','Courier'); end
    if ~isempty(t2), text(handle.XLim(2),handle.YLim(2),t2,'HorizontalAlignment','Right','VerticalAlignment','Top','Fontsize',12,'Fontname','Courier'); end
else
    text(handle.XLim(1),handle.YLim(2),t0,'HorizontalAlignment','Left', 'VerticalAlignment','Top','Fontsize',12,'Fontname','Courier');
end
mark = [];
for j1 = 1:length(idx1)
    for j2 = 1:length(idx2)
        for j3 = 1:length(nrs)
            mark = [mark, find( (timeline.par(:,1)==16) & (timeline.idx(:,2)==idx0) &...
                                                          (timeline.idx(:,4)==idx1(j1)) &...
                                                          (timeline.idx(:,3)==idx2(j2)) &...
                                                          (timeline.idx(:,5)==nrs(j3)))];
        end
    end
end
timeline.par(mark,4) = gbuf.window;
rodestippen;

function showAPs(handle,plt,Mets,plotter)
global timeline
gbuf = get(handle,'UserData');
resnaam = plotter.struct;
nres    = plotter.metnr;
if nres>length(Mets), return; end
residx = find(strcmp(fieldnames(Mets(nres).result),resnaam));
[parms,present,ps] = ParseSpecial(plt.parms,'all');
if present
    spknr = [];
    for jj = 1:length(Mets(nres).result.(resnaam).APs)
        if ~isempty(Mets(nres).result.(resnaam).APs{jj}), spknr = [spknr,jj]; end
    end
    domap = false;
    dotraces = false;
else
    [parms,dotraces] = ParseSpecial(parms,'traces');
    [parms,domap]    = ParseSpecial(parms,'map');
    spknr = nsingle(parms{1});
end
handle.XLim = Mets(nres).result.(resnaam).APs{spknr(1)}.tas([1,end]);
if domap && (size(Mets(nres).result.(resnaam).APs{spknr}.yas,2)>1)
    contourf(handle,Mets(nres).result.(resnaam).APs{spknr}.tas,...
                    Mets(nres).result.(resnaam).APs{spknr}.xas,...
                    Mets(nres).result.(resnaam).APs{spknr}.yas',128);
    handle.YLim = Mets(nres).result.(resnaam).basis.APscale(3:4);
    handle.ZLim = Mets(nres).result.(resnaam).basis.APscale(5:6);
    mark = find((timeline.par(:,1)==13) & (timeline.idx(:,2)==residx) & (timeline.idx(:,3)==spknr)& (timeline.idx(:,4)==1));
elseif dotraces
    handle.YLim = Mets(nres).result.(resnaam).basis.APscale(5:6);
    line(Mets(nres).result.(resnaam).APs{spknr}.tas,...
         Mets(nres).result.(resnaam).APs{spknr}.yas,...
         'Color','b','LineWidth',1,'LineStyle','-');
    mark = find((timeline.par(:,1)==13) & (timeline.idx(:,2)==residx) & (timeline.idx(:,3)==spknr)& (timeline.idx(:,4)==1));
else
    handle.YLim = Mets(nres).result.(resnaam).basis.APscale(5:6);
    mark = [];
    for nr = 1:length(spknr)
        APs = Mets(nres).result.(resnaam).APs{spknr(nr)};
        patch([APs.tas; APs.tas(end:-1:1)],...
              [APs.yavg+APs.ystd; APs.yavg(end:-1:1)-APs.ystd(end:-1:1)],...
              [0.8,0.8,1],'LineStyle','none');
        line(Mets(nres).result.(resnaam).APs{spknr(nr)}.tas,...
             Mets(nres).result.(resnaam).APs{spknr(nr)}.yavg,...
             'Color','b','LineWidth',1,'LineStyle','-');
        mark = [mark, find((timeline.par(:,1)==13) & (timeline.idx(:,2)==residx) & (timeline.idx(:,3)==spknr(nr)) & (timeline.idx(:,4)==1))];
    end
    correctorder(handle);
end
timeline.par(mark,4) = gbuf.window;
rodestippen;

function showfit(handle,plt,Mets,plotter)
global timeline
gbuf = get(handle,'UserData');
if (length(Mets)<plotter.metnr) || ...
   isempty(Mets(plotter.metnr).result) || ...
   ~isfield(Mets(plotter.metnr).result,plotter.struct) || ...
   ~isfield(Mets(plotter.metnr).result.(plotter.struct),'fitter')
    return;
end
[~,fitnr] = ParseOne(plt.subs,'fit',1);
rfit = Mets(plotter.metnr).result.(plotter.struct).fitter{fitnr,1};
[sxmin,sxmax] = scalexy(plt.scale.x,plt.scale.dx,min(rfit.xorg),max(rfit.xorg));
[symin,symax] = scalexy(plt.scale.y,plt.scale.dy,min(rfit.yorg),max(rfit.yorg));
axis([sxmin sxmax symin symax]);
if rfit.segments
    splits = find(rfit.xorg(1:end-1)>rfit.xorg(2:end));
    line(rfit.xorg(1:splits),    rfit.yorg(1:splits),    'Color','b','Marker','o','Markersize',10,'LineWidth',2,'LineStyle','none');
    line(rfit.xorg(splits+1:end),rfit.yorg(splits+1:end),'Color','r','Marker','o','Markersize',10,'LineWidth',2,'LineStyle','none');
    splits = find(rfit.xeva(1:end-1)>rfit.xeva(2:end));
    line(rfit.xeva(1:splits),    rfit.yeva(1:splits),    'Color','b','LineWidth',plt.width,'LineStyle','-');
    line(rfit.xeva(splits+1:end),rfit.yeva(splits+1:end),'Color','r','LineWidth',plt.width,'LineStyle','-');
else
    line(rfit.xeva,rfit.yeva,'Color','b','LineWidth',plt.width,'LineStyle','-');
    line(rfit.xorg,rfit.yorg,'Color','r','Marker','o','MarkerSize',8,'LineWidth',2,'LineStyle','none');
end
if plt.grid, grid on; end
for jj = 1:length(rfit.range)
    if ~isinf(rfit.range(jj))
        line('XData',[rfit.range(jj) rfit.range(jj)],'YData',[symin symax],'Color','m','LineStyle',':','LineWidth',2);
    end
end
TextLeft(handle,Fittekst(rfit),8);
resnr = plotter.metnr;
snr = find(strcmp(fieldnames(Mets(resnr).result),plotter.struct));
timeline.par((timeline.par(:,1)==7) & (timeline.par(:,3)==resnr) & (timeline.idx(:,2)==snr) & (timeline.idx(:,3)==fitnr),4) = gbuf.window;
rodestippen;

function value = choose(cnt,selector)
if strcmp(selector,'none')
    value = 'none';
elseif isempty(selector)
    selector = 'krbmcgy';
    value = selector(1 + mod(cnt-1,length(selector)));
elseif ischar(selector)
    value = selector(1 + mod(cnt-1,length(selector)));
else
    index = selector(1 + mod(cnt-1,length(selector)));
    hhh = {'-';':';'--';'-.';'none'};
    value = hhh{index};
end

function res = splitnode(strin)
res = struct('lgd',"",'node',"",'struct',"",'flds',"");
res.lgd = split(string(strin),":");
if length(res.lgd)>1
    res.struct = split(res.lgd(1),"@");
    if length(res.lgd)>1
        res.node   = res.struct(1);
        res.struct = res.struct(2);
    end
    res.lgd = res.lgd(2);
end
res.flds = split(res.lgd,".");

function showXY(handle,plt,Mets,plotter)
global Memoryset Formula timeline
gbuf  = handle.UserData;
resnr = plotter.metnr;
if (resnr>length(Mets)) || isempty(Mets(resnr).result)
    TextLeft(handle,sprintf('node %u does not exits',resnr));
    Error("clear","");
    return
end
CMD = getPANEL('CMDpanel');
MEA = getPANEL('MEApanel');
datloc = struct('nres',[],...
                'node',  string(Mets(resnr).nodenaam),...
                'struct',string(plotter.struct),...
                'flds',  "",...
                'kanidx',plotter.subnr);
parms = plt.parms;
[parms,doavg]  = ParseSpecial(parms,'avg');
[parms,doabs]  = ParseSpecial(parms,'abs');
[parms,domlvl] = ParseSpecial(parms,'mlvl');
[parms,doslvl] = ParseSpecial(parms,'slvl');
[parms,convol] = ParseOne(parms,'convol',[]);
if strcmp(plt.mode,'xy')
    CMD.label1.String = Mets(resnr).result.(plotter.struct).basis.label{1};
    CMD.label2.String = Mets(resnr).result.(plotter.struct).basis.label{2};
    if ~isempty(MEA)
        datloc.kanidx = find(abs(Mets(resnr).result.(plotter.struct).basis.kanaal)==MEA.green.UserData);
        if isempty(datloc.kanidx), Error(sprintf('channel %u was not analyzed',MEA.green.UserData)); return; end
    elseif isfield(Mets(resnr).result.(plotter.struct).basis,'kanaal') && (length(Mets(resnr).result.(plotter.struct).basis.kanaal)>1)
        datloc.kanidx = find(abs(Mets(resnr).result.(plotter.struct).basis.kanaal)==plotter.subnr);
    else
        datloc.kanidx = 1;
    end

    [~,data,datloc] = fetchdata(parms,Mets,datloc);
    if Error, return; end

    xlegend = string(data.xtxt{1});
    ylegend = string(data.ytxt{1});
    if ~isempty(MEA) && MEA.files.Value
        xx = splitnode(data.xtxt{1});
        yy = splitnode(data.ytxt{1});
        nxt = 1;
        for jj = 1:length(Memoryset)
            switch length(xx.flds)
                case 1, xnode = Memoryset{jj}.Meting(datloc.nres).result.(xx.struct).(xx.flds(1));
                case 2, xnode = Memoryset{jj}.Meting(datloc.nres).result.(xx.struct).(xx.flds(1)).(xx.flds(2));
                case 3, xnode = Memoryset{jj}.Meting(datloc.nres).result.(xx.struct).(xx.flds(1)).(xx.flds(2)).(xx.flds(3));
            end
            switch length(yy.flds)
                case 1, ynode = Memoryset{jj}.Meting(datloc.nres).result.(yy.struct).(yy.flds(1));
                case 2, ynode = Memoryset{jj}.Meting(datloc.nres).result.(yy.struct).(yy.flds(1)).(yy.flds(2));
                case 3, ynode = Memoryset{jj}.Meting(datloc.nres).result.(yy.struct).(yy.flds(1)).(yy.flds(2)).(yy.flds(3));
            end
            if datloc.kanidx>size(ynode,2), continue; end
            data.xas {nxt,1} = xnode(:,datloc.kanidx);
            data.yas {nxt,1} = ynode(:,datloc.kanidx);
            data.sets{nxt,1} = data.sets{1,1};
            data.mets{nxt,1} = data.mets{1,1};
            data.swps{nxt,1} = data.swps{1,1};
            lbl = string(Memoryset{jj}.Meting(datloc.nres).result.(yy.struct).basis.label{1});
            if nxt==1
                ylegend = lbl+"  "+ylegend;
            else
                data.ytxt{nxt,1} = lbl;
            end
            nxt = nxt + 1;
        end
    end
%    
%     if
    Ltxt = '';
    sxmin = inf;
    sxmax = -inf;
    symin = inf;
    symax = -inf;
    for jj = 1:length(data.yas)
        xas = data.xas{min(jj,length(data.xas))};
        yas = data.yas{jj};
        if doabs, yas = abs(yas); end
        if length(xas)~=length(yas)
            Error("clear",''); TextLeft(handle,sprintf('xy mismatch for %s',data.ytxt{jj})); return
        end

        if strcmp(plt.marker,'none'), mrk = 'none'; else, mrk = choose(jj,plt.marker); end
        if plt.xylin, stl = choose(jj,plt.line); else, stl = 'none'; end
        if doavg
            mets = data.mets{jj};
            mset = unique(mets);
            xv = zeros(length(mset),1); 
            yv = xv;
            ys = yv;
            for kk = 1:length(mset)
                idx = (mets==mset(kk));
                xv(kk) = mean(xas(idx),'omitnan');
                yv(kk) = mean(yas(idx),'omitnan');
                if sum(idx)>1, ys(kk) = std(yas(idx),0,'omitnan')/realsqrt(sum(idx)-1); end
            end
            sel = ~isnan(xv) & ~isnan(yv);
            xh = xv(sel);
            yh = yv(sel);
            sh = ys(sel);
            patch ([xh; xh(end:-1:1)],[yh+sh; yh(end:-1:1)-sh(end:-1:1)],[0.8 0.8 0.8],'EdgeColor','none');
            line('Xdata',xv,'Ydata',yv,'Color',choose(jj,plt.color),...
                 'LineStyle',stl,'LineWidth',plt.width,'Marker',mrk,'Markersize',4);
            stl = 'none';
        end
        gbuf.handles.trace(jj) = line('Xdata',xas,'Ydata',yas,'Color',choose(jj,plt.color),...
                                      'LineStyle',stl,'LineWidth',plt.width,...
                                      'Marker',mrk,'Markersize',0.8*plt.markersize);
        sxmin = min([sxmin,min(xas)]);
        sxmax = max([sxmax,max(xas)]);
        symin = min([symin,min(yas)]);
        symax = max([symax,max(yas)]);


        if plt.interactive
            name = [datloc.node '@' datloc.struct];
            set(gbuf.handles.trace(jj),'ButtonDownFcn',{@XYklik,jj,name});
        end
        if Formula.on, Formula.handle = gbuf.handles.trace(jj); end
        if plt.legend
            if jj==1
                Ltxt = sprintf(' x: %s (n=%u)\n y: %s\n',xlegend,sum(~isnan(yas)),ylegend);
            else
                Ltxt = sprintf('%s %s   %s\n',Ltxt,txtcolor(choose(jj,plt.color)),data.ytxt{jj});
            end
        end
    end
    [sxmin,sxmax] = scalexy(plt.scale.x,plt.scale.dx,sxmin,sxmax);
    if strcmp(plt.scale.logx,'log')
        if sxmin<=0, sxmin = min(tmpx); end
        handle.XScale = 'log';
    end
    [symin,symax] = scalexy(plt.scale.y,plt.scale.dy,symin,symax);
    if strcmp(plt.scale.logy,'log')
        if symin<=0, symin = min(tmpy); end
        handle.YScale = 'log';
    end
    axis([min([sxmin,sxmax]),max([sxmin,sxmax]),min([symin,symax]),max([symin,symax])]);
    snr = find(strcmp(fieldnames(Mets(resnr).result),plotter.struct));
    index = (timeline.par(:,1)==6) & (timeline.par(:,3)==resnr) & (timeline.idx(:,2)==snr);
    if plotter.subnr>0
        die = find(Mets(resnr).result.(plotter.struct).basis.kanaal==plotter.subnr);
        if ~isempty(die), index = index & (timeline.idx(:,5)==die); end
    end
    timeline.par(index,4) = gbuf.window;
    rodestippen;
	if doavg, correctorder(handle); end
    
elseif strcmp(plt.mode,'xyz')
    if isempty(Mets(resnr).result) || isempty(Mets(resnr).result{1}.yas)
        txt = 'No 3D data vailable';
    else
        sxmin = [];
        txt = 'Sensitivity';
        pos = get(handle,'position');
        set(handle,'position',[pos(1)+0.05*pos(3)  pos(2)+0.05*pos(4) 0.97*pos(3) 0.95*pos(4)]);
        die = plt.xypar{1};
        contourf(Mets(resnr).result{1}.xas, Mets(resnr).result{1}.yas,...
                 Mets(resnr).result{1}.xy(:,:,die),plt.xypar{2});
         switch die
             case {1,2},   deset = 1:2;
             case {3,4,5}, deset = die;
         end
        cmin = min(min(min(Mets(resnr).result{1}.xy(:,:,deset))));
        cmax = max(max(max(Mets(resnr).result{1}.xy(:,:,deset))));
        caxis([cmin cmax]);
        xlabel(Mets(resnr).result{1}.dispx,'FontSize',12);
        ylabel(Mets(resnr).result{1}.dispy,'FontSize',12);
        text(max(Mets(resnr).result{1}.xas),max(Mets(resnr).result{1}.yas),Mets(resnr).result{1}.disp3{die},...
                'Color','w','HorizontalAlignment','Right','VerticalAlignment','Top','Fontsize',16,'Fontname','Courier','FontWeight','bold');
        colorbar;
    end
    xxx = get(handle,'Xlim');
    yyy = get(handle,'Ylim');
    text(xxx(1),yyy(2),txt,'Color','k','HorizontalAlignment','Left', 'VerticalAlignment','Top','Fontsize',16,'Fontname','Courier','FontWeight','bold');
elseif strcmp(plt.mode,'spectra')

end
if ~isempty(sxmin)
    TextLeft (handle,Ltxt);
    TextRight(handle,plotter.mode);
    if plt.grid, grid on; end
    drawlines(plt.vline,plt.vlinecol);
end
set(handle,'UserData',gbuf);

function showmonitor(handle,plt,Mets,metnr,swpnr,xas,yas,gain,offset)
global graf
[~,metfit]     = ParseSpecial(plt.parms,'fit'); 
[~,docontrol]  = ParseSpecial(plt.parms,'control');
[~,dotesting]  = ParseSpecial(plt.parms,'testing');
[~,dopairing]  = ParseSpecial(plt.parms,'spiking');
[~,present,ps] = ParseSpecial(plt.parms,'scale');
if present, scale = [rsingle(ps{1}),rsingle(ps{2})]; else,scale = []; end
[~,doxas,ps]  = ParseSpecial(plt.parms,'xas');
if doxas, horizontal = rsingle(ps{1}); end
[~,present,ps] = ParseSpecial(plt.parms,'range');
if present, pnts = [find(xas>=rsingle(ps{1}),1,'first'),find(xas>rsingle(ps{2}),1,'first')]; else,pnts = []; end
[~,present,ps] = ParseSpecial(plt.parms,'zero');
if present, zero = [find(xas>=rsingle(ps{1}),1,'first'),find(xas>rsingle(ps{2}),1,'first')]; else,zero = []; end
[~,present,ps] = ParseSpecial(plt.parms,'window');
if present
    winnr  = nsingle(ps{1});
    winidx = find([graf.window]==winnr,1);
    if isempty(winidx)
        if dotesting, return; end
        kkw = struct('win',[],'bgnspk',[],'bgntst',[],'range1',[1,length(xas)],'range2',[1,length(xas)],'txt',[],'zero',[],...
                     'nulhan',[],'stdhan',[],'bashan',[],'pothan',[],'amphan',[],'spkhan1',[],'spkhan2',[],'Ltxt',[],...
                     'yref',[],'yy',[],'time',[],'amps',[],'nspks',0,'spks1',[],'spks2',[],'spkfind',[]);
        kkw.txt{1,1} = '';                                
        kkw.txt{2,1} = '';
        kkw.txt{3,1} = '';
        kkw.win = getplothandle(winnr,true);
        if ~isempty(scale), set(kkw.win,'YLim',scale); end
    else
        kkw = get(graf(winidx).handle,'UserData');
    end
else
    Error('kkw needs window'); return;
end
if isempty(kkw.time)
    if ~isempty(pnts), kkw.range1 = pnts; end
    if ~isempty(zero), kkw.zero   = zero; end
    kkw.nulhan  = line('XData',[0,0],'YData',[100,100],'Color','b','LineStyle',':');
    kkw.bashan  = line('XData',0,'YData',0,'Color','r','LineStyle','--');
    kkw.stdhan  = line('XData',0,'YData',0,'Color','b','LineStyle',':');
    kkw.pothan  = line('XData',0,'YData',0,'Color','r','LineStyle','--');
    kkw.amphan  = line('XData',kkw.time,'YData',kkw.amps,'Marker','o','MarkerSize',9,...
                       'MarkerFaceColor','b','MarkerEdgeColor','y','LineStyle','none');
    kkw.spkhan1 = line('XData',kkw.time,'YData',kkw.spks1,'Marker','s','MarkerSize',9,...
                       'MarkerFaceColor','g','MarkerEdgeColor','y','LineStyle','none');
    kkw.spkhan2 = line('XData',kkw.time,'YData',kkw.spks2,'Marker','s','MarkerSize',9,...
                       'MarkerFaceColor','r','MarkerEdgeColor','y','LineStyle','none');
    kkw.Ltxt    = text(0,scale(2),'','Color','k','Fontsize',14,'Fontname','Courier',...
                                     'HorizontalAlignment','Left','VerticalAlignment','Top');
    set(get(handle,'Parent'),'CurrentAxes',handle);
end
yorg = get(handle,'Ylim');
if doxas
    kkw.time (end+1) = horizontal(length(kkw.time)+1);
    xbas = [min(horizontal),max(horizontal)];
else
    kkw.time (end+1) = Mets(metnr).reltime(swpnr);
    xbas = [min(kkw.time),max(kkw.time)];
end
if diff(xbas)==0, xbas = xbas + [-1 1]; end
set(kkw.win,'XLim',xbas);
ylim = get(kkw.win,'YLim');
pos = get(kkw.Ltxt,'Position');
set(kkw.Ltxt,'Position',[xbas(1) ylim(2),pos(3)]);
set(kkw.nulhan,'Xdata',xbas);
kkw.amps (end+1) = NaN;
kkw.spks1(end+1) = NaN;
kkw.spks2(end+1) = NaN;
if dopairing
    if ~isempty(pnts), kkw.range2 = pnts; end
    if isempty(kkw.bgnspk), kkw.bgnspk = length(kkw.time); end
    kkw.nspks = kkw.nspks + 1;
    [~,present,ps] = ParseSpecial(plt.parms,'level');
    if present
        line('XData',[xas(kkw.range2(1)*[1,1])',NaN,xas(kkw.range2(2)*[1,1])'],...
             'YData',[yorg,NaN,yorg],'LineStyle','--','Color','g');
        pnt = kkw.range2(1)-1+find(yas(kkw.range2(1):kkw.range2(2))>=rsingle(ps{1}),1,'first');
        if isempty(pnt)
            kkw.spks2(end) = 1;
        else
            kkw.spks1(end) = 1;
            line('XData',xas(pnt),'YData',offset+gain*yas(pnt),'Marker','o','MarkerSize',8,...
                 'MarkerFaceColor','g','MarkerEdgeColor','w','LineStyle','none');
        end
    else
        Error('kkw needs window'); return;
    end
    succesrate = 100 * nansum(kkw.spks1) / kkw.nspks;
    set(kkw.spkhan1,'Xdata',kkw.time,'YData',kkw.spks1 * succesrate);
    set(kkw.spkhan2,'Xdata',kkw.time,'YData',kkw.spks2 * (100-succesrate));
    kkw.txt{2} = sprintf('   succesrate: %3.0f %%',succesrate);
else
    line('XData',[xas(kkw.range1(1)*[1,1])',NaN,xas(kkw.range1(2)*[1,1])'],...
         'YData',[yorg,NaN,yorg],'LineStyle','--','Color','r');
    if isempty(kkw.zero)
        kkw.yy(:,end+1) = yas(kkw.range1(1):kkw.range1(2));
    else
        kkw.yy(:,end+1) = yas(kkw.range1(1):kkw.range1(2))- mean(yas(kkw.zero(1):kkw.zero(2)));
    end
    if docontrol
        kkw.yref = mean(kkw.yy,2);
        kkw.sxx  = sum(kkw.yref.*kkw.yref);
        for jjj = 1:length(kkw.time), kkw.amps(jjj) = 100*sum(kkw.yref.*kkw.yy(:,jjj))/kkw.sxx; end
        if (length(kkw.time)>2) && metfit
            brob = robustfit(kkw.time,kkw.amps);
            kkw.txt{1} = sprintf('   regression: %5.2f',brob(2));
            set(kkw.bashan,'Xdata',xbas,'Ydata',brob(1)+brob(2)*xbas);
            ybas = 100 + std(kkw.amps) * [-1,-1,NaN,1,1];
            set(kkw.stdhan,'XData',[xbas,NaN,xbas],'YData',ybas);
        end
    elseif dotesting
        if isempty(kkw.bgntst), kkw.bgntst = length(kkw.time); end
        kkw.amps(end) = 100*sum(kkw.yref.*kkw.yy(:,end))/kkw.sxx;
        potentiation  = mean(kkw.amps(kkw.bgntst:end));
        xtst = [kkw.time(kkw.bgntst),kkw.time(end)];
        set(kkw.pothan,'Xdata',xtst,'YData',potentiation*[1,1]);
        kkw.txt{3} = sprintf(' potentiation: %3.0f %%',potentiation);
    end
    set(kkw.amphan,'Xdata',kkw.time,'YData',kkw.amps);
end
set(kkw.Ltxt,'String',kkw.txt);
set(kkw.win, 'UserData',kkw);

function dynamicsdirect(handle,Mets,metnr,swpnr,plt)
global panels
[~,resolution]     = ParseOne(plt.dynapar,'resolution',1);
[~,doGHK]          = ParseSpecial(plt.dynapar,'GHK');
[parms,doPrinz]    = ParseSpecial(plt.dynapar,'Prinz'); if doPrinz, model = 'Prinz'; else, model = 'McCormick'; end
[parms,present,ps] = ParseSpecial(parms,'amps');        if present, gains  = rsingle(ps{1}); end
myset = find([Mets.setnr]==1);
gains = zeros(length(myset),4);
for jj = 1:length(myset)
    hlp = myset(jj);
    gains(jj,:) = round(Mets(hlp).EXTRA.(panels.amplifier).RPgains .* Mets(hlp).EXTRA.(panels.amplifier).state .* Mets(hlp).EXTRA.(panels.amplifier).clamp);
end
for jj = 1:4
    txt{jj} = sprintf(' %+4u',gains(:,jj));
end
text(handle.XLim(1),handle.YLim(1),sprintf('\nIK:%s\nIA:%s\nIC:%s\nIH:%s',txt{1},txt{2},txt{3},txt{4}),...
     'HorizontalAlignment','Left','VerticalAlignment','Bottom','Fontsize',8,'Fontname','Courier');
jj = find(myset<=metnr,1,'last');
gains = gains(jj,:);
xlims = get(handle,'XLim');
vchan = Mets(metnr).EXTRA.(panels.amplifier).pars.adc(1);
Vm    = double(Mets(metnr).adc(:,vchan,swpnr))*Mets(metnr).ADC.scale(vchan).User/double(Mets(metnr).ADC.ints);
dt    = 1000/Mets(metnr).ADC.rate;
if doPrinz
    cc = dynamicP(Vm(1:resolution:end),resolution*dt,doGHK);
else
    cc = dynamicH(Vm(1:resolution:end),resolution*dt,doGHK);
end
ttt = sprintf(' %s\n %s\n\n',cc.varia.model,cc.varia.drf);
[parms,present,ps] = ParseSpecial(parms,'Sum');
if present 
    
    hhh = getplothandle(nsingle(ps{1}),true);
    yas = gains(1)*cc.IK+gains(2)*cc.IA+gains(3)*cc.IC+gains(4)*cc.IH;
    plot(cc.varia.time,yas,'-k');
    [ps,hhh.YLim] = ParseTwo(ps,'ylim',hhh.YLim);
end
[parms,present,ps] = ParseSpecial(parms,'K');
if present && (sum(gains)~=0)
    tt = ttt;
    hhh = getplothandle(nsingle(ps{1}),true);
%     pos = get(hhh,'Position'); pos(3) = 0.975* pos(3); set(hhh,'Position',pos);
    if gains(4)~=0, yyaxis left; end
    hhh.YColor = [0,0,1];
    if gains(1)~=0
        plot(cc.varia.time,gains(1)*cc.IK,'-b');
        hold on
        tt = [tt '\color',sprintf('{blue} IK: %+5u\n',gains(1))];
    end
    if gains(2)~=0
        plot(cc.varia.time,gains(2)*cc.IA,'-c');
        hold on
        tt = [tt '\color',sprintf('{cyan} IA: %+5u\n',gains(2))];
    end
    if gains(3)~=0
        plot(cc.varia.time,gains(3)*cc.IC,'-r');
        tt = [tt '\color',sprintf('{red} IC: %+5u\n',gains(3))];
    end
    set(hhh,'Xlim',xlims);
    [ps,hhh.YLim(2)] = ParseOne(ps,'Cmax',hhh.YLim(2));
    text(hhh.XLim(1),hhh.YLim(2),tt,'HorizontalAlignment','Left','VerticalAlignment','Top','Fontsize',11,'Fontname','Courier');
    if gains(4)~=0
        yyaxis right
        plot(cc.varia.time,gains(4)*cc.IH,'-m');
        hold on
        [ps,hhh.YLim] = ParseTwo(ps,'CH',hhh.YLim);
        hhh.YColor = [1,0,1];
        text(hhh.XLim(2),hhh.YLim(2),['\color',sprintf('{magenta}\n%+5u IH ',gains(4))],...
             'HorizontalAlignment','Right','VerticalAlignment','Top','Fontsize',12,'Fontname','Courier');
    end
end
[parms,present,ps] = ParseSpecial(parms,'Ca');
if present
    tt = ttt;
    hhh = getplothandle(nsingle(ps{1}),true);
    set(hhh,'Xlim',xlims);
%     pos = get(hhh,'Position'); pos(3) = 0.975* pos(3); set(hhh,'Position',pos);
    yyaxis left
    plot(cc.varia.time,cc.IT,'-c',cc.varia.time,cc.IS,'-b');
    [ps,hhh.YLim(1)] = ParseOne(ps,'Cmin',1.5 * min(min(cc.IT),min(cc.IS)));
    hhh.YLim(2) = 0;
    hhh.YColor = [0,0,1];
    text(hhh.XLim(1),hhh.YLim(2),[ttt,'\color',sprintf('{blue} ICaT\n',model),'\color',sprintf('{cyan} ICaS\n')],...
         'HorizontalAlignment','Left','VerticalAlignment','Top','Fontsize',12,'Fontname','Courier');
    yyaxis right
    plot(cc.varia.time,cc.Ca,'r');
    [~,hhh.YLim(2)] = ParseOne(ps,'Camax',1.5 * max(cc.Ca));
    hhh.YLim(1) = 0;
    hhh.YColor  = [1,0,0];
    text(hhh.XLim(2),hhh.YLim(2),['\color',sprintf('{red}\n [Ca]i ')],...
         'HorizontalAlignment','Right','VerticalAlignment','Top','Fontsize',12,'Fontname','Courier');
end
%
%   MEA routines
%
function showprofile(handle,parms)
global Meting
keepdata = handle.UserData;
MEA = getPANEL('MEApanel');
[parms,present,ps] = ParseSpecial(parms,'delay');
if present, handle.UserData.mea.offset = rsingle(ps{1}); else, handle.UserData.mea.offset = 0; end
if MEA.image.Value
    if isempty(MEA.link.UserData.bld)
        axis off
        TextLeft(handle,'No images present',16);
    else
        imshow(MEA.link.UserData.bld{min(MEA.imgnr.Value,length(MEA.link.UserData.bld))},...
               'Parent',handle,'XData',[1 8],'YData',[1 8]);
    end
    handle.Tag      = 'meaprofile';
    handle.UserData = keepdata;
    return
end
metnr  = handle.UserData.mea.metnr;
swpnr  = handle.UserData.mea.swpnr;
offset = handle.UserData.mea.offset;
ngrid  = str2double(MEA.grid.String);
nlevel = str2double(MEA.levels.String);
xlin   = linspace(min(MEA.xx),max(MEA.xx),8);
ylin   = linspace(min(MEA.yy),max(MEA.yy),8);
ylin   = ylin(end:-1:1);
[xgrid,ygrid] = meshgrid(xlin,ylin);
dotrace = true;
if contains(string(parms),["std","plus","minus","SN","ratio"])
    dotrace = false;
    plus  = MEA.link.UserData.plus';
    minus = -MEA.link.UserData.minus';
    [parms,present] = ParseSpecial(parms,"std");   if present, profile = MEA.link.UserData.std'; end
    [parms,present] = ParseSpecial(parms,"plus");  if present, profile = plus; end
    [parms,present] = ParseSpecial(parms,"minus"); if present, profile = minus; end
    [parms,present] = ParseSpecial(parms,"SN");    if present, profile = plus./MEA.link.UserData.std'; end
    [parms,present] = ParseSpecial(parms,"ratio"); if present, profile = 100*(plus-minus)./(plus+minus); end
    map = zeros(594,3);
    nlevel = zeros(12,1);
    hlp = jet(11);
    cnt = 0;
    for jj = 1:11
        for ii = 1:(jj*9)
            cnt = cnt + 1;
            map(cnt,1:3) = hlp(jj,1:3);
        end
        nlevel(jj+1) = cnt;
    end
    minlevel = min(profile(:));
    maxlevel = max(profile(:));
    nlevel = minlevel + nlevel*(maxlevel-minlevel)/nlevel(12);
    if ~isempty(MEA.link.UserData.thres)
        weg = find(MEA.link.UserData.thres>=nlevel);
        if ~isempty(weg)
            nlevel(weg(end)) = MEA.link.UserData.thres;
            if length(weg)>1
                nlevel(weg(1:end-1)) = [];
            end
        end
    end
    colormap (map);
else
        point = 1+round((MEA.time.Value+offset)*Meting(metnr).ADC.rate/1000);
        if swpnr==0
            profile = mean(double(Meting(metnr).adc(point,:,:)),3);
        else
            profile = double(Meting(metnr).adc(point,:,swpnr));
        end
%     end
    setcolormap(MEA.colormap.Value,round(str2double(MEA.levels.String)));
end
profile = [NaN profile(1:6) NaN profile(7:54) NaN profile(55:60) NaN];
maximg = max(profile(:));
minimg = min(profile(:));  
if get(MEA.fixed,'Value')
    range = str2double(MEA.scale.String);
else
    range = max(abs(maximg),abs(minimg));
    MEA.scale.String = sprintf('%4.0f',range);
end
if (minimg<0) && (maximg>0)
    mearange = [-range,range];
elseif minimg>=0
    mearange = [0 range];
elseif maximg<=0
    mearange = [-range 0];
end
profile = reshape(profile,8,8);
if ngrid>1
    profile(1,1) = round(0.5*(profile(1,2)+profile(2,1)));
    profile(1,8) = round(0.5*(profile(2,8)+profile(1,7)));
    profile(5,1) = round((profile(4,1)+profile(6,1)+profile(5,2))/3.0);
    profile(8,8) = round(0.5*(profile(8,7)+profile(7,8)));
    profile(8,1) = round(0.5*(profile(8,2)+profile(7,1)));
    xlin = linspace(min(MEA.xx),max(MEA.xx),ngrid*8);
    ylin = linspace(min(MEA.yy),max(MEA.yy),ngrid*8);
    ylin = ylin(end:-1:1);
    [xbgrid,ybgrid] = meshgrid(xlin,ylin);
	bprofile = griddata(xgrid,ygrid,profile,xbgrid,ybgrid,'cubic');
    profile = bprofile;
    xgrid = xbgrid;
    ygrid = ybgrid;
end
MEAdx = [min(min(xgrid)) max(max(xgrid))];
MEAdy = [min(min(ygrid)) max(max(ygrid))];
if MEA.surf3D.Value
    die = find(strcmp(get(handle.Children,'Type'),'surface'));
    if ~isempty(die), delete(handle.Children(die)); end
    surface(handle,xgrid,ygrid,profile,'LineStyle',':');
    axis(handle,[MEAdx+[-0.5,0.5] MEAdy+[-0.5,0.5] mearange],'off');
    view(handle,str2double(MEA.angle1.String),str2double(MEA.angle2.String));
    handle.Tag = 'meaprofile';
    drawnow;
else
    if MEA.surf.Value
        die = find(strcmp(get(handle.Children,'Type'),'surface'));
        if ~isempty(die), delete(handle.Children(die)); end
        surface(handle,xgrid,ygrid,profile,'LineStyle','none');
        view(handle,0,90);
    elseif MEA.contour.Value
        if MEA.super.Value
            ymin = min(ygrid(:));
            ymax = max(ygrid(:));
            cntr = find(strcmp(get(handle.Children,'Type'),'contour'),1);
            imgr = find(strcmp(get(handle.Children,'Type'),'image'  ),1);
            if isempty(imgr)
                hold off
                imgnr = min(MEA.imgnr.Value,length(MEA.link.UserData.bld));
                imshow(MEA.link.UserData.bld{imgnr},'Parent',handle,'XData',[min(xgrid(:)) max(xgrid(:))],'YData',[ymin ymax ]);
                hold on
            end
            if ~isempty(cntr), delete(handle.Children(cntr)); end
            [~,C] = contour(handle,xgrid,ymin+ymax-ygrid,profile,nlevel,'LineWidth',2,'LineStyle','-');
            if MEA.conlvl.Value
                C.LabelSpacing = 1000;
                C.ShowText = 'On';
            end
            hold on
            axis(handle,'off','square');
            caxis(handle,mearange);
            handle.Tag      = 'meaprofile';
            handle.UserData = keepdata;
            if MEA.colorbar.Value, colorbar('WestOutside','FontSize',7); end
            return
        else
            contourf(handle,xgrid,ygrid,profile,nlevel,'LineWidth',0.5,'LineStyle','-');
            view(handle,0,90);
        end
    elseif MEA.gradient.Value
        [px,py] = gradient(-profile,10/ngrid);
        contourf(handle,xlin,ylin,profile,nlevel,'LineWidth',0.5,'LineStyle','none');
        hold on;
        hh = quiver(handle,xlin,ylin,px,py);
        hh.LineWidth = 1.0;
        hh.Color     = [0 0 0];
        hold on;
        view(handle,0,90);
    elseif MEA.csd.Value
        w2 = 1/sqrt(2);
        B = [-w2 -1 -w2; -1 4+4*w2 -1;-w2 -1 -w2];
        hlp = zeros(length(profile)+4);
        hlp(3:end-2,3:end-2) = profile;
        hlp(:,1)     = hlp(:,3);
        hlp(:,2)     = hlp(:,3);
        hlp(1,:)     = hlp(3,:);
        hlp(2,:)     = hlp(3,:);
        hlp(:,end)   = hlp(:,end-2);
        hlp(:,end-1) = hlp(:,end-2);
        hlp(1,:)     = hlp(3,:);
        hlp(2,:)     = hlp(3,:);
        hlp(end,:)   = hlp(end-2,:);
        hlp(end-1,:) = hlp(end-2,:);
        hlp = conv2(hlp,B,'same');
        hlp = conv2(hlp,0.25*[1 1;1 1],'same');
        profile = hlp(3:end-2,3:end-2);
        surf(handle,xgrid,ygrid,profile,'LineStyle','none');
    end
    axis(handle,[MEAdx MEAdy],'xy','off','square');
    caxis(handle,mearange);
    handle.Tag      = 'meaprofile';
    handle.UserData = keepdata;
end
if MEA.colorbar.Value, colorbar('WestOutside','FontSize',7); end

function [spktxt] = showunits(spktxt,parms,Node,kanaalnr,dx,nxmin,reduce,nxmax,xas,yas,gain,offset,kleur)
global panels
if isempty(Node), return; end
wins = [];
MEA = getPANEL('MEApanel');
name = string(fieldnames(Node));
MEA.node.String = name(1);
Node = Node.(name(1));
[~,~,parms] = ParseSpecial(parms,'units');
[parms,present,ps1] = ParseSpecial(parms,'marker');   if present, usize = rsingle(ps1{1}); else, usize = 6; end
[parms,dorate,ps1] = ParseSpecial(parms,'rate');      if dorate, win1 = nsingle(ps1{1}); wins = win1; end
[parms,doamp, ps2] = ParseSpecial(parms,'amplitude'); if doamp,  win2 = nsingle(ps2{1}); wins = [wins,win2]; end
[parms,doint, ps3] = ParseSpecial(parms,'interval');  if doint,  win3 = nsingle(ps3{1}); wins = [wins,win3]; end
[~,    doret, ps4] = ParseSpecial(parms,'cluster');   if doret,  win4 = nsingle(ps4{1}); wins = [wins,win4]; end
kanaalindex = find(abs(Node.basis.kanaal==kanaalnr),1);
if isempty(kanaalindex), WindowClear(wins); return; end
rate = Node.frate{kanaalindex};
pspk = Node.times{kanaalindex};
klas = Node.class{kanaalindex};
ordr = Node.order{kanaalindex};
silu = Node.silou(kanaalindex);
crit = Node.critr(kanaalindex);
hold = Node.thold(kanaalindex);
drmp = Node.level(kanaalindex);
dt   = Node.dt(kanaalindex);
line('XData',([nxmin nxmax]-1)*dx,'YData',drmp*[1,1]+offset,'Color','m','LineStyle','--','LineWidth',0.5);
if isempty(pspk)
    spktxt = sprintf('%s\n chn %03u: no spikes',spktxt,kanaalnr); WindowClear(wins); return
end
intervals = dt * diff(double(pspk));
spktxt = sprintf('%s\n chn %03u: %u spikes',spktxt,kanaalnr,length(pspk));
pp0 = round(panels.zoom.tbgn/(dx*panels.timegain));
idx = pspk((pspk>=nxmin) & (pspk<=nxmax));
switch kleur
    case 'r', kleur = 'b';
    case 'b', kleur = 'r';
    otherwise, kleur ='k';
end
if ~isempty(idx)
    line('XData',xas(idx-pp0),'YData',gain*yas(idx-pp0)+offset,'Color',kleur,'Marker','o','Markersize',usize,'LineStyle','none','LineWidth',1);
    if dorate && (win1>0)
        handle = getplothandle(win1,true);
        handle.XLim = (([nxmin,nxmax])-1)*dt*panels.timegain;
        handle.YLim = [0, 1.2*max(rate)];
        line('XData',((nxmin:reduce:nxmax)-1)*dt*panels.timegain,'YData',rate(nxmin:reduce:nxmax),'Color',kleur,'LineStyle','-','LineWidth',1);
    end
    if doamp  && (win2>0)
        handle = getplothandle(win2,true);
        hh = histogram(sort(amplitude,'descend'));
        [~,present,psh] = ParseSpecial(ps2,'bin');
        if present, hh.NumBins = nsingle(psh{1}); end
        hh.Parent.YLim(2) = 1.1 * hh.Parent.YLim(2);
        hh.Parent.XLim(1) = 0;
        text(handle.XLim(1),handle.YLim(2),'amplitude distribution','Fontsize',12,'Fontname','Courier','Color','k',...
                                           'HorizontalAlignment','Left','VerticalAlignment','Top');
    end
    if doint && (win3>0)
        getplothandle(win3,true);
        hh = histogram(intervals);
        [ps3,present,psh] = ParseSpecial(ps3,'bin'); if present, hh.NumBins = nsingle(psh{1}); end
        [ps3,present,psh] = ParseSpecial(ps3,'xmax'); if present, xmax = rsingle(psh{1}); else, xmax =hh.Parent.XLim(2); end
        hh.Parent.YLim(2) = 1.1 * hh.Parent.YLim(2);
        [~,dolog] = ParseSpecial(ps3,'log');
        if dolog
            hh.BinEdges(1) = 0.3 * hh.BinEdges(2);
            hh.Parent.XScale = 'log';
            hh.Parent.XLim = [hold xmax];
            hh.Parent.YLim(2)= 1.1*max(hh.BinCounts(2:end));
        else
            hh.Parent.XLim = [0,xmax];
        end
        text(hh.Parent.XLim(1),hh.Parent.YLim(2),' interval distribution','Fontsize',12,'Fontname','Courier','Color','k',...
                                           'HorizontalAlignment','Left','VerticalAlignment','Top');
    end
    if doret && (win4>0) && ~isempty(klas)
        handle = getplothandle(win4,true);
        set(handle,'XScale','log','Xgrid','on','YScale','log','Ygrid','on');
        intervals = dt*diff(pspk)';
        hlpxy = [intervals(1:end-1),intervals(2:end)];
        if silu>crit
            numcluster = length(ordr);
            centers = zeros(numcluster,3);
            htxt = sprintf(' %u clusters(>%3.2f) silhouette %4.3f',numcluster,crit,silu);
            for jj = 1:numcluster
                centers(jj,1) = round(realpow(10,mean(log10(hlpxy(klas==jj,1)))));
                centers(jj,2) = round(realpow(10,mean(log10(hlpxy(klas==jj,2)))));
                centers(jj,3) = sum(klas==jj);
            end
            demark = 'rbmgyckrbmgyck';
            almark = 'brgmkkybrgmkky';
            for jjj = 1:numcluster
                jj = abs(ordr(jjj));
                if centers(jj,3)>0
                    line(hlpxy(klas==jj,1),hlpxy(klas==jj,2),'LineStyle','none','Marker','o','Markersize',05,'Color',demark(jjj),'LineWidth',1);
                    line(centers(jj,1),centers(jj,2),        'LineStyle','none','Marker','o','Markersize',18,'Color',almark(jjj),'LineWidth',2);
                    if ordr(jjj)>0
                        htxt = sprintf('%s\n clr: %u,%6.2f Hz(n=%u)',htxt,jjj,1000./mean(hlpxy(klas==jj,1)),centers(jj,3));
                    end
                end
            end
            for jj = 1:numcluster
                text(centers(abs(ordr(jj)),1),centers(abs(ordr(jj)),2),sprintf('   cls %u',jj),'Fontsize',14,'FontWeight','bold','Color','k');
            end
        else
            line(hlpxy(:,1),hlpxy(:,2),'LineStyle','none','Marker','o','Markersize',5,'Color','k','LineWidth',0.5);
            htxt = sprintf('No clusters((<%3.2f)) silhouette %4.3f\n mean freq %6.2f Hz(n=%u)',crit,silu,1000./mean(hlpxy(:,1)),length(hlpxy(:,1)));
        end
        handle.XLim(1) = 0.9*hold;
        handle.YLim(1) = 0.9*hold;
        text(handle.XLim(1),handle.YLim(2),htxt,'Fontsize',10,'Fontname','Courier','Color','k',...
                                           'HorizontalAlignment','Left','VerticalAlignment','Top');
    end
end

function SkipOn(CMD)
CMD.skip.String = 'skip';
    
function SkipOff(CMD,nr)
CMD.skip.String = 'all';
if ~isempty(nr), CMD.skipnr.String = sprintf('%u',round(nr)); end

function  reduce = getskip(CMD,nxmin,nxmax,factor)
reduce = 1;
maxpnts = 500000/factor;
skipval = round(str2double(CMD.skipnr.String));
if CMD.skipnr.Value && ~strcmp(CMD.skip.String,'skip')  && ((nxmax-nxmin)>maxpnts)
    switch questdlg(sprintf('Draw all %lu Million points?',round(factor*(nxmax-nxmin)/(1024*1024))),...
                    "Lots to draw!","donot ask","draw all","use skip","use skip")
        case "draw all",   CMD.skip.String = 'skip'; CMD.skipnr.String = '1';
        case "donot ask", CMD.skipnr.Value = 0; SkipOff(CMD,1);
        case "use skip",   CMD.skip.String = 'skip';
        otherwise
    end
end
if strcmp(CMD.skip.String,'skip')
    reduce = max(1,round((nxmax-nxmin+1)/maxpnts));
else
    reduce = max(1,skipval);
end
CMD.skipnr.String = sprintf('%u',reduce);

function showtraces(handle,plt,Mets,metnr,swpnr,marker)
global panels SEL IMG timeline Formula spikes events
handle.ButtonDownFcn = {@NRNklik,NaN};
gbuf = handle.UserData;
gbuf.xpnt   = [];
gbuf.zero   = [];
gbuf.grp    = [];
gbuf.subgrp = [];
gbuf.yfixed = [];
doroi = false;
doavg = false;
spktxt = [];
switch plt.mode
    case 'avg'
        plt.mode = 'adc';
        doavg = true;
    case 'swp'
        plt.mode = 'adc';
    case 'roi'
        doroi = true;
        plt.mode = 'adc';
        if ~isfield(IMG,'flm') || isempty(IMG.flm), Error('Mets does not contain movie'); return; end
        roinr  = str2double(get(IMG.pnl.roinr,'String'));
        roimax = length(IMG.object);
        [plt.parms,dogain,psgain] = ParseSpecial(plt.parms,'gain');
        [plt.parms,nopeaks]       = ParseSpecial(plt.parms,'nopeaks');
        [plt.parms,present]       = ParseSpecial(plt.parms,'raw'); if present, doraw = true; else,doraw = get(IMG.pnl.raw,'Value'); end
        [plt.parms,present]       = ParseSpecial(plt.parms,'select');
        if present
            if roinr==0
                plt.chns = 1:roimax;
                plt.chns = plt.chns([IMG.object.class]==1);
                plt.chns = plt.chns(plt.chns~=1);
            else
                plt.chns = roinr;
            end
        else
            plt.chns = 1:roimax;
            if ~isempty(plt.parms)
                hlp = nsingle(plt.parms{1});
                if hlp == 0
                    plt.chns = 2:roimax;
                else
                    plt.chns = hlp;
                end
            end
        end
        if isempty(plt.chns), return; end
        plt.gain = 1 + 0 * plt.chns;
        if dogain
            hlp = rsingle(psgain{1});
            if length(hlp)==1
                plt.gain = hlp * plt.gain;
            else
                plt.gain(1:length(hlp)) = hlp;
            end
        end
    otherwise
end
CMD = getPANEL('CMDpanel');
if strcmp(plt.mode,'adc')
    gbuf.adcseparation = (realpow(10,get(CMD.ADCseparator,'Value'))-0.01)/0.99;
    gbuf.adcbasisgain  = power(10,get(CMD.ADCgain,'Value'));
    if doroi
        reduce = 1;
        xas = IMG.xas{IMG.flmnr,1}/panels.timegain;
        dx  = xas(2)-xas(1);
        adcrate = 1000/dx;
        [sxmin,sxmax] = getdaqpars;
        sxmin = sxmin/panels.timegain;
        sxmax = sxmax/panels.timegain;
    else
        if isempty(Mets(metnr).adc), DoMusic(2); return; end
        adcrate = Mets(metnr).ADC.rate;
        [maxlen, ~, maxswps] = size(Mets(metnr).adc);
        if isempty(swpnr)
            swpnr = 1;
        else
            swpnr = max(1,min(maxswps,swpnr));
        end
        if maxswps==1
            doavg = false;
            type = 2;
        elseif doavg
            type = 3;
            swpnr = 1;
        else
            type = 4;
        end
        if ~isempty(gbuf.window)
            CMD.timidx1.String = sprintf('%u',metnr);
            if type==4, CMD.timidx2.String = sprintf('%u',swpnr(1)); end
            for jj = 1:length(swpnr)
                if type==4
                    timeline.par((timeline.par(:,1)==type) & (timeline.par(:,3)==metnr) & (timeline.idx(:,3)==swpnr(jj)),4) = gbuf.window;
                else
                    timeline.par((timeline.par(:,1)==type) & (timeline.par(:,3)==metnr),4) = gbuf.window;
                end
                rodestippen;
            end
        end
        dx = 1000/adcrate;
    end
elseif strcmp(plt.mode,'dac')
    dacseparation = (realpow(10,get(CMD.DACseparator,'Value'))-0.01)/0.99;
    dacbasisgain  = power(10,get(CMD.DACgain,'Value'));
    dacrate       = Mets(metnr).DAC.rate;
    if isempty(Mets(metnr).dac) && isempty(Mets(metnr).cdac), DoMusic(2); return; end
    if ~isempty(gbuf.window)
        timeline.par((timeline.par(:,1)==5) & (timeline.par(:,3)==metnr),4) = gbuf.window;
        rodestippen
    end
    Mets(metnr) = DACexpand(Mets(metnr));
    [maxlen,~] = size(Mets(metnr).dac);
    dx = 1000/dacrate;
end
if ~doroi
    if ~isinf(plt.scale.x(1))
        minpoints = 1 + round(plt.scale.x(1)/dx);
    elseif get(CMD.zoom,'UserData') || (get(CMD.autofull,'Value')==0)
        minpoints = 1 + round((panels.zoom.tbgn-panels.zoom.tnul)/dx);
    else
        minpoints = -inf;
    end
    if ~isinf(plt.scale.x(2))
        maxpoints = round(plt.scale.x(2)/dx);
    elseif get(CMD.zoom,'UserData') || (get(CMD.autofull,'Value')==0)
        maxpoints = 1+round((panels.zoom.tlst-panels.zoom.tnul)/dx);
    else
        maxpoints = inf;
    end
    setdaqpars(panels.zoom.tnul+dx*(minpoints-1),panels.zoom.tnul+dx*(maxpoints));
    if (minpoints==maxpoints) || (minpoints>=maxlen) || (maxpoints<=1)
        setmaxpars(Mets(metnr),plt.mode);
        [~,teind] = getdaqpars;
        minpoints = 1;
        maxpoints = teind/dx;
    end
    nxmin = max(1,minpoints);    
    nxmax = min(maxlen,maxpoints);
    if nxmin>=nxmax, DoMusic(2); return; end
    if isempty(plt.skip)
        reduce = getskip(CMD,nxmin,nxmax,1);
    else
        reduce = plt.skip;
    end
    nnn = (nxmin:reduce:nxmax)';
    xas   = (panels.zoom.tnul + (nnn-1) * dx) / panels.timegain;
    sxmin = xas(1);
    sxmax = xas(end);
end
dx = dx / panels.timegain;
if strcmp(plt.mode,'adc')|| strcmp(plt.mode,'avg')
    patchon = false;
    if ~isempty(plt.shift)
        plt.shift = xas(1);
        sxmin     = sxmin - plt.shift;
        sxmax     = sxmax - plt.shift;
        xas       = xas   - plt.shift;
        toff      = nxmin;
    else
        toff = 0;
    end
    numtrace = length(plt.chns);
    if plt.diff==2
        numtrace = numtrace-1;
    end
    if isinf(plt.scale.y(2))
        gbuf.yfixed = [];
        if doroi
            if doraw
                symax = 32767/abs(plt.gain(1) * gbuf.adcbasisgain);
            else
                symax = 100/abs(plt.gain(1) * gbuf.adcbasisgain);
            end
        else
            symax = Mets(metnr).ADC.scale(plt.chns(1)).User / abs(plt.gain(1) * gbuf.adcbasisgain);
        end
    else
        gbuf.yfixed = plt.scale.y(2);
        symax = plt.scale.y(2);
    end
    if isempty(plt.dual)
        symin = -symax - 2 * symax * gbuf.adcseparation * (numtrace-1);
    else
        symin = -symax;
    end
    gbuf.yscale = [symin symax];
    axis(handle,[sxmin sxmax symin symax]);
    if panels.online
        gbuf.handles.vline = line('XData',[],'YData',[],'Color','b','LineStyle',':','LineWidth',1);
    else
        T0 = datevec(Mets(metnr).abstime);
        CMD_wait(sprintf('%02u:%02u:%5.3f %02u-%02u-%04u ',T0([4 5 6]),T0([3 2 1])));
        drawlines(Mets(metnr).EXTRA.borders.bgn,'r');
        drawlines(Mets(metnr).EXTRA.borders.end,'b');
        drawlines(panels.lines,panels.linecolor);
        drawlines(plt.vline,plt.vlinecol);
        if plt.selection && ~isempty(panels.selection)  
            xx = [];
            yy = [];
            for jj = 1:size(panels.selection,1)
                xx = [xx; panels.selection(jj,1); panels.selection(jj,1); panels.selection(jj,2); panels.selection(jj,2); panels.selection(jj,2)];
                yy = [yy; symax; symin; symin; symax; symax];
            end
            patch(xx/panels.timegain,yy,[0.8 0.95 0.95],'EdgeColor','k','LineStyle',':');
            patchon = true;
        end
    end
    metSD = false;
    gbuf.zero = [];
    
    [dozero,showzero,p1p2] = ParseZero(plt.filter);
    if dozero
        if isinf(p1p2)
            p1p2 = [1,maxlen];
        else
            if isempty(plt.shift), soff = 0; else, soff = plt.shift; end
            p1p2 = round((p1p2 - panels.zoom.tnul + soff * panels.timegain) * adcrate /1000);
        end
        if (p1p2(1)<1) || (p1p2(2)>maxlen)
            TextLeft(handle,'Zero outside selected trace times',12);
        else
            gbuf.zero = p1p2;
            if showzero
                line('XData',[p1p2(1)*[1,1] NaN p1p2(2)*[1,1]]*dx/panels.timegain,...
                     'YData',[symin symax   NaN symin symax],...
                     'Color','b','LineStyle','--','LineWidth',1);
            end
        end
    end
    channelout = 0;
    for tracenr=1:numtrace
        channelout = channelout+1;
        maxswp = size(Mets(metnr).adc,3);
        hlpset = cumsum([Mets.setnr]);
        metset =find(hlpset==hlpset(metnr));
        overlay = 1;
        swps = swpnr;
        mets = metnr;
        if isempty(plt.modepar)
            tmpswp = swps;
            tmpmet = mets;
            overlay = 0;
            for jj1 = 1:length(tmpswp)
                for jj2 = 1:length(tmpmet)
                    overlay = overlay + 1;
                    swps(overlay) = tmpswp(jj1);
                    mets(overlay) = tmpmet(jj2);
                end 
            end
        else
            switch plt.modepar
                case 'alltraces',overlay = 0;
                                for jj1 = 1:maxswp
                                    for jj2 = metset
                                        overlay = overlay + 1;
                                        swps(overlay) = jj1;
                                        mets(overlay) = jj2;
                                    end 
                                end
                case 'allswps',  if isempty(plt.modepars)
                                    swps = [swpnr setxor(swpnr,1:maxswp)];
                                else
                                    swps = [swpnr plt.modepars(plt.modepars<=maxswp)];
                                end
                                mets = 0*swps + metnr;
                                overlay = length(swps);
                case 'allmets', if isempty(plt.modepars)
                                    mets = [metnr setxor(metnr,metset)];
                                else
                                    mets = [metnr plt.modepars(plt.modepars<=max(metset))];
                                end
                                swps = 0*mets + swpnr;
                                overlay = length(mets);
                case 'prvswp',  if swpnr>1
                                    overlay = 2;
                                    swps = [swpnr swpnr-1];
                                    mets = [metnr metnr];
                                end
                case 'prvmet',  if metnr>1
                                    overlay = 2;
                                    mets = [metnr metnr-1];
                                    swps = [swpnr swpnr]; 
                                end
            end
        end
        for meer = overlay:-1:1
            swpnr     = swps(meer);
            metnr     = mets(meer);
            channelin = plt.chns(tracenr);
            if ~doroi
                if channelin<length(Mets(metnr).ADC.scale), channelnxt = channelin + 1; else, channelnxt = []; end
                if channelin>1,                             channelprv = channelin - 1; else, channelprv = []; end
            end
            lbuf = [];
            if doavg
                lbuf.type = 'avg';
            else
                lbuf.type = 'swp';
            end
            lbuf.twolines = [];
            lbuf.wie.chn = channelin;
            lbuf.wie.nr  = channelout;
            lbuf.wie.met = metnr;
            lbuf.wie.swp = swpnr;
            lbuf.xas.name = 'time';
            lbuf.xas.unit = panels.timetxt;
            lbuf.yas.pltgain = plt.gain(channelout);
            if doroi
                hlpname = sprintf('roi(%u)',channelin);
                lbuf.xas.idx     = [1,1,length(IMG.xas{IMG.flmnr,1})];
                lbuf.yas.unit    = '%';
                lbuf.yas.adcgain = 1;
            else
                hlpname = Mets(metnr).ADC.scale(channelin).Name;
                lbuf.xas.idx  = [nnn(1),nnn(2)-nnn(1),nnn(end)];
                lbuf.yas.unit = Mets(metnr).ADC.scale(channelin).Units;
                if doavg
                    lbuf.yas.adcgain = 1;
                else
                    lbuf.yas.adcgain = Mets(metnr).ADC.scale(channelin).User/Mets(metnr).ADC.ints;
                end
            end
            if isempty(gbuf.yfixed)
                if doroi
                    maxy = symax;
                else
                    maxy = Mets(metnr).ADC.scale(channelin).User / abs(lbuf.yas.pltgain * gbuf.adcbasisgain);
                end
            else
                maxy = gbuf.yfixed;
            end
            lbuf.yas.scale = [2 * maxy * (1-numtrace) * gbuf.adcseparation - maxy,...
                              2 * maxy * gbuf.adcseparation * (1-channelout),...
                              maxy];
            gain   = lbuf.yas.adcgain  * gbuf.yscale(2) / lbuf.yas.scale(3);
            offset = lbuf.yas.scale(2) * gbuf.yscale(2) / lbuf.yas.scale(3);
            switch plt.diff
                case 0, channelname =  hlpname;
                case 1, channelname = [hlpname '-' Mets(metnr).ADC.scale(channelin+1).Name];
                case 2, channelname = [hlpname ' (csd)'];
                case 3, channelname = [hlpname ' (differential)'];
            end
            tracezero = 0;
            if doroi
                yas = 0*xas;
                [numflm,numroi] = size(IMG.object);
                if (channelin<=numroi) && (IMG.flmnr<=numflm)
                    if (channelin==1) && ~strcmp(get(IMG.pnl.peaks,'Visible'),'on')
                        yas = double(squeeze(IMG.flm{IMG.flmnr}(IMG.ypnt,IMG.xpnt,:)));
                        if get(IMG.pnl.roiyscl,'Value')
                            yas = symax + (yas-max(yas)) * (symax-symin)/(max(yas)-min(yas));
                        end
                        IMG.object(IMG.flmnr,1).raw = yas;
                    else
                        if ~isempty(IMG.object(IMG.flmnr,channelin).raw)
                            if doraw
                               yas = IMG.object(IMG.flmnr,channelin).raw + IMG.bgd{IMG.flmnr,1};
                               symin = 0;
                               axis(handle,[sxmin sxmax symin symax]);
                            else
                               yas = 100 * (IMG.object(IMG.flmnr,channelin).raw ./ IMG.object(IMG.flmnr,channelin).base) - 100;
                            end
                        end
                    end
                end
            elseif doavg
                traces = double(squeeze(Mets(metnr).adc(:,channelin,:)));
                schaal = Mets(metnr).ADC.scale(channelin).User/Mets(metnr).ADC.ints;
                if ~isempty(gbuf.zero)
                    for jjj = 1:size(traces,2)
                        traces(:,jjj) = traces(:,jjj) - mean(traces(gbuf.zero(1):gbuf.zero(2),jjj));
                    end
                end
                yas = mean(traces(nxmin:nxmax,:),2) * schaal;
                if strcmp(plt.std,'sd') || strcmp(plt.std,'sem')
                    metSD = true;
                    if strcmp(plt.std,'sd')
                        sdf = schaal * abs(plt.stdgain);
                    else
                        sdf = schaal * abs(plt.stdgain) / realsqrt(size(traces,2));
                    end
                    ysem = std(traces(nxmin:nxmax,:),0,2) * sdf;
                end
            else
                if isempty(gbuf.zero)
                    yas = double(squeeze(Mets(metnr).adc(nxmin:nxmax,channelin,swpnr)));
                    if strcmp(channelname,'RPi'), yas = 10*(3412-yas); end
                else
                    tracezero = mean(double(squeeze(Mets(metnr).adc(gbuf.zero(1):gbuf.zero(2),channelin,swpnr))));
                    yas = double(squeeze(Mets(metnr).adc(nxmin:nxmax,channelin,swpnr)))-tracezero;
                end
                if plt.diff==2
                    if ~isempty(channelprv) && ~isempty(channelnxt)
                        yas = 2*yas - double(squeeze(Mets(metnr).adc(nxmin:nxmax,channelprv,swpnr))) - double(squeeze(Mets(metnr).adc(nxmin:nxmax,channelnxt,swpnr)));
                    else
                        yas = 0 * yas;
                    end
                elseif (plt.diff>0) && ~isempty(channelnxt)
                    if ~isempty(gbuf.zero)
                        tracezero = mean(double(Mets(metnr).adc(gbuf.zero(1):gbuf.zero(2),channelnxt,swpnr)));
                    end
                 	yas = yas - double(squeeze(Mets(metnr).adc(nxmin:nxmax,channelnxt,swpnr))) + tracezero;
                end
            end
            if(length(unique(mets))>1) && (length(unique(swps))>1)
                kleur = 'k';
            elseif overlay>1
                if meer==1, kleur = 'r'; else,kleur = 'k'; end
            elseif get(CMD.group,'Value') && isempty(plt.color)
                kleur = Mets(metnr).ADC.scale(channelin).Color;
            else
                kleur = choose(channelout,plt.color);
            end
            if ~isempty(plt.filter)
                if reduce>1
                    TextLeft(handle,'No (display) filtering with skip>1',16)
                else
                    yas = FilterTrace(yas,plt.filter,adcrate,xas,gain);
                end
            end
            if metSD
                yhlp1 = yas + ysem;
                yhlp2 = yas - ysem;
                if plt.stdgain<=0
                    line('XData',xas,'YData',gain * yhlp2 + offset,'Color','r','LineStyle',':','LineWidth',1);
                    line('XData',xas,'YData',gain * yhlp1 + offset,'Color','r','LineStyle',':','LineWidth',1);
                else
                    pos = getpixelposition(handle);
                    fac = round(0.5*length(xas)/pos(3));
                    if fac>1
                        patch([downsample(xas,fac);  downsample(xas(end:-1:1),fac)], gain * [downsample(yhlp1,fac); downsample(yhlp2(end:-1:1),fac)] + offset,...
                              [0.7 0.7 0.7],'Edgecolor' ,'none');
                    else
                        patch([xas; xas(end:-1:1)],gain * [yhlp1; yhlp2(end:-1:1)]+offset,[0.7 0.7 0.7],'Edgecolor' ,'none');
                    end
                    patchon = true;
                end
            end
            if ~isempty(plt.dual)
                if tracenr>1
                    offset = 0;
                    yyaxis right
                    if length(plt.dual)==2
                        axis([sxmin,sxmax,plt.dual]);
                    end
                end
            end
            gbuf.offsets(channelout) = offset;
            if ~isempty(plt.nivo)
                line('XData',[sxmin sxmax NaN sxmin sxmax],'YData',plt.nivo*[1 1 NaN -1 -1],'Color','r','LineWidth',1,'LineStyle','--');
            end
            if plt.null
                gbuf.handles.nul(channelout) = line('XData',[sxmin sxmax],'YData',offset*[1 1],...
                                                    'Tag','zeroline','Color',kleur,'LineWidth',1,'LineStyle',':',...
                                                    'UserData',lbuf,'ButtonDownFcn',{@NRNklik,channelin});
            end
            gbuf.handles.names(channelout) = text(sxmin,offset,[' ' channelname],...
                                  'HorizontalAlignment','Left','VerticalAlignment','Bottom','Color',kleur,'Fontsize',10,...
                                  'Fontname','Courier','HitTest','off','Interpreter','none');
            if marker<0, lijntype = 'none'; else, lijntype = '-'; end
            if plt.invert, teken = -1; else, teken = 1; end
            gbuf.handles.trace(channelout) = line('XData',xas,'YData',gain*teken*yas(1:reduce:end)+offset,...
                                                  'Tag','trace','Color',kleur,'LineStyle',lijntype,'LineWidth',plt.width,...
                                                  'Marker',choose(channelout,plt.marker),'MarkerSize',6,...
                                                  'UserData',lbuf,'ButtonDownFcn',{@NRNklik,channelin});
            [~,present1,ps1] = ParseSpecial(plt.subs,'localmax'); if present1, ps = ps1; tek = 1;  end
            [~,present2,ps2] = ParseSpecial(plt.subs,'localmin'); if present2, ps = ps2; tek = -1; end
            if present1 || present2
                minsep = max(1,round(rsingle(ps{1})/(dx*panels.timegain)));
                minprom = rsingle(ps{2})/gain;
                line('XData',xas([1,end]),'YData',gain*tek*minprom*[1,1]+offset,'LineStyle','--','LineWidth',1,'Color','b');
                p1 = 1;
                p2 = 0;
                N = ceil(length(yas)/100000);
                ystep = round(length(yas)/ceil(length(yas)/100000));
                while p2<length(yas)
                    p2 = min(length(yas),p2+ystep);
                    if present1
                        index(p1:p2) = islocalmax(yas(p1:p2),'MinSeparation',minsep,'MinProminence',minprom);
                    else
                        index(p1:p2) = islocalmin(yas(p1:p2),'MinSeparation',minsep,'MinProminence',minprom);
                    end
                    p1 = p2+1;
                end
                line('XData',xas(index),'YData',gain*teken*yas(index)+offset,...
                     'Color',kleur,'LineStyle','none','LineWidth',plt.width,'Marker','o','MarkerSize',6);
                [~,present,psh] = ParseSpecial(ps,'rate');
                if present
                    [psh,fmax] = ParseOne(psh,'full',10);
                    [~,filter2] = ParseFilter(psh);
                    adcrate = 1000/(dx*panels.timegain);
                    spks = find(index);
                    rate = double(index);
                    if length(spks)>1
                        for jjj = 1:length(spks)-1
                            rate(spks(jjj):spks(jjj+1)) = adcrate/(spks(jjj+1)-spks(jjj));
                        end
                        if ~isempty(filter2)
                            rate = FilterTrace(rate,filter2,adcrate);
                        end
                        line('XData',xas,'YData',(rate*handle.YLim(2)/fmax)+offset,'Color','r','LineWidth',2);
                    end
                end
            end
            if doroi
                if ~isempty(IMG.basic.exclude)
                    xx = [];
                    yy = [];
                    for jj = 1:size(IMG.basic.exclude,1)
                        x1 = xas(IMG.basic.exclude(jj,1));
                        x2 = xas(IMG.basic.exclude(jj,2));
                        xx = [xx; x1;    x1;    x2;    x2;    x2];
                        yy = [yy; symax; symin; symin; symax; symax];
                    end
                    patch(xx,yy,[0.95 0.9 0.95],'EdgeColor','k','LineStyle',':');
                    hhh = get(gca,'Children');
                    set(gca,'Children',[hhh(2:end); hhh(1)])
                end
                if nopeaks
                    xpp = -1;
                    ypp = 0;
                    xpl = [get(gca,'XLIM')  NaN, get(gca,'XLIM')];
                    ypl = [[1,1]*min(yas),  NaN, [1,1]*max(yas)]*gain;
                else
                    xpp = [];
                    ypp = [];
                    xpl = [];
                    ypl = [];
                    if doraw
                        if ~isempty(IMG.object(IMG.flmnr,1).base)
                            line(IMG.xas{IMG.flmnr,1}/panels.timegain,(IMG.object(IMG.flmnr,1).base + IMG.bgd{IMG.flmnr,1}) * gain + offset,...
                                 'Color','r','LineStyle','-','LineWidth',1);
                        end
                        if ~isempty(IMG.bgd{IMG.flmnr,1})
                            line(IMG.xas{IMG.flmnr,1}/panels.timegain,IMG.bgd{IMG.flmnr,1} * gain + offset,...
                                 'Color','b','LineStyle','-','LineWidth',1);
                        end
                    else
                        xpl = get(gca,'XLIM');
                        ypl = IMG.object(channelin).parms(1)*[1 1] * gain;
                    end
                    if ~isempty(IMG.object(IMG.flmnr,channelin).pnts)
                        pnts = IMG.object(IMG.flmnr,channelin).pnts;
                        xpp = IMG.xas{IMG.flmnr}(pnts)/panels.timegain;
                        if doraw
                            ypp = IMG.object(IMG.flmnr,channelin).raw(pnts) + IMG.bgd{IMG.flmnr}(pnts); 
                        else
                            ypp = 100 * (IMG.object(IMG.flmnr,channelin).raw(pnts) ./ IMG.object(IMG.flmnr,channelin).base(pnts)) - 100;
                        end
                    end
                    ypp = ypp * gain + offset;
                end
                IMG.handles.trace  = gbuf.handles.trace(channelout);
                if (roinr~=0) && (IMG.object(channelin).class==1)
                    IMG.handles.levels = line(xpl,ypl,'Color','r','LineStyle','-','LineWidth',1);
                end
                IMG.handles.peaks = line(xpp,ypp,'Color','r','LineStyle','none','LineWidth',2,'Marker','o','MarkerSize',12);
                if channelout==1
                    IMG.handles.time = line(str2double(get(IMG.pnl.time,'String')) * (1000/panels.timegain) * [1 1],[symin symax],...
                                           'Color','b','LineStyle',':','LineWidth',2,'ButtonDownFcn',{@ROIklik});
                end
                gbuf.grp(channelout)    = channelout;
                gbuf.subgrp(channelout) = 1;
            else
                gbuf.grp(channelout)    = Mets(metnr).ADC.scale(channelin).Group;
                gbuf.subgrp(channelout) = Mets(metnr).ADC.scale(channelin).Subgroup;
            end
            if ~isempty(plt.laserspikes)
                ylims = get(handle,'Ylim');
                if isfield(Mets(metnr),'lasers') && ~isempty(Mets(metnr).lasers) && ~isempty(Mets(metnr).lasers{1}.times)
                    xxx = Mets(metnr).lasers{1}.times(1)*[1 1];
                    yyy = ylims;
                    for jjj = 2:length(Mets(metnr).lasers{1}.times)
                        xxx = [xxx NaN Mets(metnr).lasers{1}.times(jjj)*[1 1]];
                        yyy = [yyy NaN ylims];
                    end
                    line('XData',xxx,'YData',yyy,'Color','r','LineWidth',1,'LineStyle','--');
                end
%                 if isfield(Mets(metnr),'spikes') && ~isempty(Mets(metnr).spikes) && ~isempty(Mets(metnr).spikes{swpnr})
%                     line('XData',Mets(metnr).spikes{swpnr}.times,...
%                          'YData',Mets(metnr).spikes{swpnr}.peaks,...
%                          'Color','b','LineWidth',2,'LineStyle','none','Marker','o','MarkerSize',9);
%                     if meer==overlay
%                         amp0 = ylims(2);
%                         for jjj = 1:length(Mets(metnr).spikes)
%                             amp0 = amp0 - 0.015*diff(ylims);
%                             line('XData',Mets(metnr).spikes{jjj}.times,...
%                                  'YData',amp0 + 0*Mets(metnr).spikes{jjj}.times,...
%                                  'Color','b','LineWidth',1,'LineStyle','none','Marker','o','MarkerSize',8);
%                         end
%                         if plt.laserspikes>0
%                             dt = 1000/Mets(metnr).ADC.rate;
%                             gauss = exp(-((0:round(2*plt.laserspikes/dt)-1)*dt/plt.laserspikes).^2);
%                             gauss = [gauss(end:-1:2) gauss]';
%                             trace = zeros(size(Mets(metnr).adc,1),1);
%                             for jjj = 1:length(Mets(metnr).spikes)
%                                 pnts = round(Mets(metnr).spikes{jjj}.times/dt);
%                                 trace(pnts) = 1;
%                             end
%                             trace = conv(trace,gauss,'same');
%                             line('XData',dt*(0:length(trace)-1),...
%                                  'YData',ylims(1) + 0.2*diff(ylims)*trace/max(trace),...
%                                  'Color','b','LineWidth',1,'LineStyle','-');
%                         end
%                     end
%                 end
            end
            if ~isempty(plt.symbol)
                if iscell(plt.symbol)
                    index = 1+round((plt.symbol{channelout}-sxmin)/dx);
                    index = index((index>0) & (index<=size(yas,1)));
                    if ~isempty(index)
                        line('XData',sxmin + (index-1) * dx,'YData',gain * yas(index) + offset,...
                             'Marker','o','MarkerSize',9,'MarkerFaceColor','none','MarkerEdgeColor',kleur,...
                             'LineStyle','none','LineWidth',2,'UserData',lbuf,'ButtonDownFcn',{@NRNklik,channelout});
                    end
                else
                    index = 1+round((plt.symbol-sxmin)/dx);
                    line('XData',sxmin + (index-1) * dx,'YData',gain * yas(index) + offset,...
                          'Marker','o','MarkerSize',8,'MarkerFaceColor','r','MarkerEdgeColor','r',...
                          'LineStyle','none','UserData',lbuf,'ButtonDownFcn',{@NRNklik,channelout});
                end
            end
            if Formula.on && (channelout == 1)
                Formula.handle = gbuf.handles.trace(channelout);
                Formula.unit   = lbuf.yas.unit;
            end
            if plt.template && (channelin==spikes.adcchan)
                showtemplate(xas);
            end
            MINI = getPANEL('MINIpanel');
            if ~isempty(MINI)
                showminis(xas,metnr,swpnr,channelin,toff,nxmin,nxmax,gain,offset);
            end
            if plt.seizure
                showseizure(xas,channelin,toff,nxmin,nxmax,gain,offset);
            end
            if ~isempty(plt.veld)
%                
            end
            if plt.units
                spktxt = showunits(spktxt,plt.subs,Mets(metnr).result,channelin,dx,nxmin,reduce,nxmax,xas,yas,gain,offset,kleur);
            end
        end
    end
    if panels.online && ~isempty(plt.parms)
        [~,present] = ParseSpecial(plt.parms,'monitor');
        if present
            showmonitor(handle,plt,Mets,metnr,swpnr,xas,yas,gain,offset);
        end
    end
    if plt.acorr
        getplothandle(plt.corrpar(1),true);
        np = round(0.5*plt.corrpar(2)/gbuf.xas.sx(2));
        yyy = xcorr(yas,2*np);
        yyy = yyy(2*np+1:end);
        ttt = gbuf.xas.sx(2) * (0:(length(yyy)-1))';
        bbb = regress(yyy,[ones(length(ttt),1) ttt]);
        plot(ttt,yyy,'b');
        hold on
        plot([ttt(1) ttt(end)],bbb(1)+bbb(2)*[ttt(1) ttt(end)],'r');
        axis([ttt(1) ttt(end) min(yyy) max(yyy)]);
        set(get(handle,'Parent'),'CurrentAxes',handle);
    end
    if ~panels.online
        showevents(plt.chns,gbuf.offsets);
    end
    if plt.grid, grid on; end
    if doroi
        TextRight(handle,"dF by F (%)");
    else
        hhh = split(string(Mets(metnr).nodenaam),"(");
        TextRight(handle,hhh(1)+"-"+plt.str);
    end
    if plt.spkstats
        showspikestats(Mets,metnr,swpnr,handle,plt);
        fig.CurrentAxes = handle;
    end
    TextYAS(handle,lbuf.yas.unit);
    if plt.shadow
        panels.cursor.shadow(end+1) = line('XData',[-inf -inf],'YData',[symin symax],'Color','b','LineStyle','--','LineWidth',1);
    end
    if plt.imp>0
        TextLeft(handle,ShowImpedance(Mets(metnr),plt.imp),12);
    elseif ~isempty(spktxt)
        TextLeft(handle,spktxt,10);
    end
    if plt.dynamic && ~isempty(Mets(metnr).EXTRA.(panels.amplifier).clamp)
        dynamicsdirect(handle,Mets,metnr,swpnr,plt)
    end
    set(get(handle,'Parent'),'CurrentAxes',handle);
    if ~isempty(plt.video) && ~isempty(SEL)
        SEL.cursor.handle = line(panels.video.time * [1 1]/panels.timegain,lbuf.yas.scale([1,3]),...
                                 'Tag','VIDEOCURSOR','Color',SEL.cursor.color,'LineStyle',':','LineWidth',1);
        SEL.grfhandle = handle;
        SEL.window = plt.video;
    end
    DB = getPANEL('DBpanel');
    if ~isempty(DB) && DB.edit.UserData.mouse
        eventnr = str2double(get(DB.nr,'String'));
        DB.edit.UserData.handle(1) = line(events.tmp.first*[1 1], [symin symax],'Color','b',...
                                          'LineStyle',':','LineWidth',2,'ButtonDownFcn',{@Eventklik,eventnr});
        DB.edit.UserData.handle(2) = line(events.tmp.last *[1 1], [symin symax],'Color','b',...
                                          'LineStyle',':','LineWidth',2,'ButtonDownFcn',{@Eventklik,eventnr});
        DB.edit.UserData.handle(3) = text(events.tmp.first,symin,'defined','Color','k',...
                                          'VerticalAlignment','Bottom','FontSize',12,'Fontname','Courier');
    end
    if plt.femke
        panels.cursor.resample   = plt.resample;
        panels.cursor.resolution = plt.resolution;
        FemkeShow(0)
    end
    if plt.cursor
        MEA = getPANEL('MEApanel');
        tmp = MEA.time.Value/panels.timegain;
        if (tmp<=(nxmin-1)*dx) || (tmp>=(nxmax-1)*dx), tmp = 0.5*(nxmin+nxmax)*dx; end
        meacursor(MEA,tmp*panels.timegain,handle);
        MEA.movietime.String = strtrim(sprintf(panels.timefrmt,MEA.movietime.Value/panels.timegain));
        if MEA.triggers.Value && ~isempty(MEA.link.UserData.trg)
            tms = dx * MEA.link.UserData.trg((MEA.link.UserData.trg>=nxmin) & (MEA.link.UserData.trg<=nxmax));
            if ~isempty(tms)
                tmx = [tms(1),tms(1)];
                tmy = [symin,symax];
                for jj = 2:length(tms)
                    tmx = [tmx,NaN,tms(jj),tms(jj)];
                    tmy = [tmy,NaN,symin,symax];
                end
                line('XData',tmx,'YData',tmy,'Color','b','LineStyle','-','LineWidth',0.5);
            end
        end
    end
    if plt.cross
        panels.cursor.crosslines = [];
        panels.cursor.handle3    = [];
        panels.cursor.text3      = [];
        showcross(handle,plt);
    end
    if ~isempty(plt.balance) && (length(Mets(metnr).ADC.scale)>13)
        drawreflines;
        DrawBalance(handle,plt.balance);
    elseif plt.ballines
        drawreflines;
    end
    if patchon, correctorder(handle); end
elseif  strcmp(plt.mode,'dac')
    if ~(isempty(Mets(metnr).dac) && isempty(Mets(metnr).cdac))
        numtrace = length(plt.chns);
        if isinf(plt.scale.y(2))
            gbuf.yfixed = [];
            symax = Mets(metnr).DAC.scale(plt.chns(1)).User/abs(plt.gain(1)* dacbasisgain);
        else
            gbuf.yfixed = plt.scale.y(2);
            symax = plt.scale.y(2);
        end
        symin = -symax - 2 * symax * dacseparation * (numtrace-1);
        axis(handle,[sxmin sxmax symin symax]);
        gbuf.yscale = [symin symax];
        if panels.online
            gbuf.handles.vline = line('XData',[],'YData',[], 'Color','r','LineStyle',':','LineWidth',1);
        end
        daclen = size(Mets(metnr).dac,1);
        [dozero,showzero,p1p2] = ParseZero(plt.filter);
        if dozero
            if isinf(p1p2)
                p1p2 = [1,daclen];
            else
                p1p2 = round((p1p2 - panels.zoom.tnul) * dacrate /1000);
                p1p2 = [max(1,p1p2(1)) min(daclen,p1p2(2))];
            end
            gbuf.zero = p1p2;
            if showzero
                line('XData',[p1p2(1)*[1,1] NaN p1p2(2)*[1,1]]*(xas(2)-xas(1))/panels.timegain,...
                     'YData',[symin symax NaN symin symax],'Color','b','LineStyle','--','LineWidth',1);
            end
        else
            gbuf.zero = [];
        end
        if strcmp(plt.modepar,'allmets')
            if numtrace>1, Error("tell",'You cannot combine allmets with multiple DAC channels'); return; end
            mets  = cumsum([Mets.setnr]);
            setnr = mets(metnr);
            deset = find(mets==setnr);
            Mets(deset) = DACexpand(Mets(deset));
        else
            deset = metnr;  
        end
        for metnr = deset
            for tracenr = 1:numtrace
                channelnr = plt.chns(tracenr);
                lbuf = [];
                lbuf.type = 'dac';
                lbuf.wie.chn = channelnr;
                lbuf.wie.nr  = tracenr;
                lbuf.wie.met = metnr;
                lbuf.wie.swp = 1;
                lbuf.xas.name    = 'time';
                lbuf.xas.unit    = panels.timetxt;
                lbuf.xas.idx     = [nxmin,nnn(2)-nnn(1),nxmax];
                lbuf.yas.unit    = Mets(metnr).DAC.scale(channelnr).Units;
                lbuf.yas.adcgain = Mets(metnr).DAC.scale(channelnr).User/Mets(metnr).DAC.ints;
                lbuf.yas.pltgain = plt.gain(tracenr);
                if isempty(gbuf.yfixed)
                    maxy = Mets(metnr).DAC.scale(channelnr).User / abs(lbuf.yas.pltgain * dacbasisgain);
                else
                    maxy = gbuf.yfixed;
                end
                lbuf.yas.scale = [-maxy - 2 * maxy * dacseparation * (numtrace-1),...
                                  2 * maxy * dacseparation * (1-tracenr),...
                                  maxy];
                gain   = lbuf.yas.adcgain  * gbuf.yscale(2) / lbuf.yas.scale(3);
                offset = lbuf.yas.scale(2) * gbuf.yscale(2) / lbuf.yas.scale(3);
                if isempty(gbuf.zero), tracezero = 0; else
                    tracezero = mean(double(Mets(metnr).dac(gbuf.zero(1):gbuf.zero(2),channelnr)));
                end
                yas = double(Mets(metnr).dac(nxmin:nxmax,channelnr)) - tracezero;
                if ~isempty(plt.filter)
                    yas = FilterTrace(yas,plt.filter,dacrate,xas,gain);
                end
                if get(CMD.group,'Value')
                    kleur = Mets(metnr).DAC.scale(channelnr).Color;
                else
                    kleur = choose(tracenr,plt.color);
                end
                if plt.null && (metnr==deset(1))
                    gbuf.handles.nul(tracenr) = line('XData',[sxmin sxmax],'YData',offset*[1 1],...
                                                        'Color',kleur,'LineWidth',1,'LineStyle',':');
                end
                if (metnr==deset(1))
                    gbuf.handles.names(tracenr) = text(sxmin,offset,[' ' Mets(metnr).DAC.scale(channelnr).Name],...
                                                       'Color',kleur,'HorizontalAlignment','Left','VerticalAlignment',...
                                                       'Bottom','Fontsize',10,'Fontname','Courier');
                end
                if marker<0, lijntype = 'none'; else,lijntype = '-'; end
                gbuf.handles.trace(tracenr) = line('XData',xas,'YData',gain * yas + offset,...
                                                   'Color',kleur,'LineStyle',lijntype,'LineWidth',plt.width,...
                                                   'Marker',choose(tracenr,plt.marker),'MarkerSize',6,...
                                                   'UserData',lbuf,'ButtonDownFcn',{@NRNklik,channelnr});
                gbuf.grp(tracenr)    = Mets(metnr).DAC.scale(tracenr).Group;
                gbuf.subgrp(tracenr) = Mets(metnr).DAC.scale(tracenr).Subgroup;
                if ~isempty(plt.laserspikes) && isfield(Mets(metnr),'lasers')
                    if ~isempty(Mets(metnr).lasers{1})
                        line('XData',Mets(metnr).lasers{1}.times,...
                             'YData',Mets(metnr).lasers{1}.peaks,...
                             'Color','r','LineWidth',2,'LineStyle','none','Marker','o','MarkerSize',9);
                    end
                end
                if Formula.on && (tracenr==1), Formula.handle = gbuf.handles.trace(tracenr); end
                if ~isempty(plt.symbol)
                    index = round((plt.symbol-sxmin)/dx);
                    line('XData',sxmin + (index-1) * dx,'YData',gain * yas(index) + offset,...
                         'Marker','o','MarkerSize',8,'MarkerFaceColor','r','MarkerEdgeColor','r',...
                         'LineStyle','none','UserData',lbuf,'ButtonDownFcn',{@NRNklik,channelnr});
                end
            end
        end
        drawlines(panels.lines,panels.linecolor);
        drawlines(plt.vline,plt.vlinecol);
        hhh = split(string(Mets(metnr).nodenaam),"(");
        TextRight(handle,hhh(1)+"-"+plt.str);
        TextYAS(handle,lbuf.yas.unit);
        if plt.grid, grid on; end
        if plt.shadow
            panels.cursor.shadow(end+1) = line('XData',[-inf -inf],'YData',[symin symax],'Color','b','LineStyle','--','LineWidth',1);
        end
    end
end
set(handle,'UserData',gbuf); 

function setplotter(cmd,Mets,varargin)
global panels
if isempty(Mets) && ~strcmp(cmd,'basic'), return; end
if nargin>2
    nodenr = varargin{1};
elseif isempty(panels.plotter)
    nodenr = 1;
else
    nodenr = panels.plotter(1).metnr;
end
nodenr = min(nodenr,length(Mets));
switch cmd
    case 'basic'
        panels.plotter = [];
        panels.plotter(1).window = '9';
        panels.plotter(1).mode   = 'adc';
        panels.plotter(1).metnr  = 1;
        panels.plotter(1).struct = '';
        panels.plotter(1).subnr  = 1;
        panels.last.plotter = panels.plotter;
        return
    case 'last'
        panels.plotter = panels.last.plotter;
        return
    case 'struct'
        resname = varargin{2};
        subnr   = varargin{3};
        if isempty(Mets(nodenr).result) || ~isfield(Mets(nodenr).result,resname), return; end
        if iscell(Mets(nodenr).result.(resname))
            panels.plotter = Mets(nodenr).result.(resname){1,2}.basis.plotter;
        else
            panels.plotter = Mets(nodenr).result.(resname).basis.plotter;
        end
        for jj = 1:length(panels.plotter)
            panels.plotter(jj).metnr  = nodenr;
            panels.plotter(jj).struct = resname;
            panels.plotter(jj).subnr  = subnr;
        end
    case 'cmdline'
        if isempty(nodenr), if isempty(panels.plotter), nodenr = 1; else, nodenr = panels.plotter(1).metnr; end; end
        if nargin>3, swpnr = varargin{2}; elseif isempty(panels.plotter), swpnr = 1; else,swpnr = panels.plotter(1).subnr; end
        mouseoff = true;
        panels.plotter = [];
        CMD = getPANEL('CMDpanel');
        for jj = 4:-1:1
            ww = round(str2double(get(CMD.window(jj),'String')));
            tt = get(CMD.txt(jj),'String');
            if ~get(CMD.valid(jj),'Value') || (ww==0) || isempty(tt), continue; end
            nplot = length(panels.plotter) + 1;
            panels.plotter(nplot).window = ww;
            panels.plotter(nplot).mode   = tt;
            panels.plotter(nplot).struct = '';
            panels.plotter(nplot).metnr  = nodenr;
            panels.plotter(nplot).subnr  = swpnr;
            if strfind(tt,'mouse'), mouseoff = false; end
        end
        if mouseoff, panels.mouse = []; elseif isempty(panels.mouse), panels.mouse=1; end
    case 'fitter'
        resname = varargin{2};
        fitnr   = varargin{3};
        if isempty(Mets(nodenr).result) || ~isfield(Mets(nodenr).result,resname) || isempty(Mets(nodenr).result.(resname).fitter), return; end
        panels.plotter = Mets(nodenr).result.(resname).fitter{fitnr}.plotter;
        panels.plotter.metnr  = nodenr;
        panels.plotter.struct = resname;
        panels.plotter.subnr  = fitnr;
end
if ~isempty(Mets(nodenr).adc)
    setmaxpars(Mets(nodenr),'adc');
elseif ~isempty(Mets(nodenr).cdac)
    setmaxpars(Mets(nodenr),'cdac');
end
panels.last.plotter = panels.plotter;

function NRNshow(Mets,varargin)
global panels
if isempty(Mets) || isempty(panels.plotter) || Error, return; end
if nargin>1, marker = varargin{1}; else, marker = 1; end
if panels.NRNbusy && panels.NRNabort
    panels.NRNbusy = false;  return
elseif panels.NRNabort 
    panels.NRNabort = false; return
elseif panels.NRNbusy
    panels.NRNabort = true;  return
end
panels.NRNabort      = false;
panels.NRNbusy       = true;
panels.cursor.shadow = [];
panels.cursor.dex    = [];
panels.mouse         = [];
shifts    = [];
plotorder = [];
for plotnr = 1:length(panels.plotter)  
    metnr = max(1,min(length(Mets),panels.plotter(plotnr).metnr));
    plt = ontleed(panels.plotter(plotnr).mode,Mets(metnr));
    if Error, return; end
    if strcmp(plt.mode,'profile') && ~isempty(plt.parms)
        [~,present,ps] = ParseSpecial(plt.parms,'shift');
        if present, shifts = [shifts, rsingle(ps{1})]; end
    end
    name = panels.plotter(plotnr).mode;
    if contains(name,'spectrum') || contains(name,'spectrogram') || contains(name,'units') || contains(name,'profile')
        plotorder = [plotorder plotnr];
    else
        plotorder = [plotnr plotorder];
    end
end
panels.plotter = panels.plotter(plotorder);
for plotnr = 1:length(panels.plotter)    
    metnr = max(1,min(length(Mets),panels.plotter(plotnr).metnr));
    swpnr = max(1,min(size(Mets(metnr).adc,3),panels.plotter(plotnr).subnr));
    plt = ontleed(panels.plotter(plotnr).mode,Mets(metnr));
    if strcmp(plt.mode,'mosaic'), clearem = false; else
        clearem = strcmp(plt.clear,'always') || strcmp(plt.clear,'first');
    end
    switch plt.mode
        case 'dac'
            if isempty(Mets(metnr).dac) && isempty(Mets(metnr).cdac), continue; end
        case {'adc','avg','swp','roi','hist','phase','mosaic','profile'}
            if isempty(Mets(metnr).adc), continue; end
        case {'xy','fit'}
            if isempty(Mets(metnr).result), continue; end
            names = fieldnames(Mets(metnr).result);
            if isempty(strcmp(names,panels.plotter(plotnr).struct)), continue; end
        case {'means','sweeps','APs','APm'}
            if isempty(Mets(metnr).result), continue; end
        case {'foto','movie','spectrum','spectrogram','dynamic'}
        otherwise
            continue
    end
    handle = getplothandle(panels.plotter(plotnr).window,clearem);
    if isempty(handle.UserData) || ~isstruct(handle.UserData)
        handle.UserData=[];
        handle.UserData.window = panels.plotter(plotnr).window;
        if ~isnumeric(handle.UserData.window), handle.UserData.window = str2double(handle.UserData.window); end
        handle.UserData.lines  = [];
    end
    handle.UserData.mea       = struct('metnr',metnr,'swpnr',swpnr,'offset',0,'cursor',plt.cursor,'gain',plt.gain,'shifts',shifts);
    handle.UserData.handles   = struct('trace',[],'names',[],'nul',[],'drempel',[],'balcur',[],'keeps',[]);
    handle.UserData.type      = plt.mode;
    handle.UserData.impamp    = plt.imp;
    handle.UserData.useselect = plt.useselect;
    handle.UserData.keepon    = false;
    handle.UserData.keepset   = [];
    switch plt.mode
        case {'adc';'dac';'avg';'swp';'roi'},...
                                showtraces     (handle,plt,Mets,metnr,swpnr,marker);
        case 'phase',           showphase      (handle,plt,Mets,panels.plotter(plotnr));
        case 'xy',              showXY         (handle,plt,Mets,panels.plotter(plotnr));
        case 'fit',             showfit        (handle,plt,Mets,panels.plotter(plotnr));
        case{'sweeps','means'}, showmeans      (handle,plt,Mets,panels.plotter(plotnr));
        case {'APs','APm'},     showAPs        (handle,plt,Mets,panels.plotter(plotnr));
        case 'dynamic',         showdynamic    (handle,plt,Mets,panels.plotter(plotnr));
        case 'mosaic',          showmosaic     (handle,plt.parms);
        case 'profile',         showprofile    (handle,plt.parms);
        case {'foto','movie'},  showfoto       (handle,plt);    
        case 'spectrum',        showspectra    (handle,plt);
        case 'spectrogram',     showspectrogram(handle,plt);
        case 'hist',            hist           (double(Mets(metnr).adc(:,nsingle(plt.parms{1}))),nsingle(plt.parms{2}));
        case 'none',            TxtLeft        (handle,['Can not display:  ' plt.str],18);
        otherwise
            Error('Unknown plot command'); break;
    end
    if Error || panels.NRNabort, break; end
end
set(panels.root,'Pointer','arrow');
panels.NRNbusy  = false;
panels.NRNabort = false;
%
% ====== EP panel functions ===============================================
%
function EP = setsliders(EP)
for jj = 1:2
    EP.stim.min(jj) = max(EP.stim.min(jj),0);
    EP.stim.max(jj) = min(EP.stim.max(jj),EP.stim.full(jj));
    if EP.stim.min(jj)>=EP.stim.max(jj)
        EP.stim.min(jj) = 0;
        EP.stim.max(jj) = EP.stim.full(jj);
    end
    EP.stim.amp(jj) = max(EP.stim.min(jj),min(EP.stim.max(jj),EP.stim.amp(jj)));
    value = (EP.stim.amp(jj) - EP.stim.min(jj))/(EP.stim.max(jj) - EP.stim.min(jj));
    if jj==1
        set(EP.min1,'String',sprintf(EP.format,EP.stim.min(jj)));
        set(EP.max1,'String',sprintf(EP.format,EP.stim.max(jj)));
        set(EP.val1,'String',sprintf(EP.format,EP.stim.amp(jj)));
        set(EP.per1,'String',sprintf('%u%%',round(100 * value)));
        set(EP.slider1,'Value',value);
    else
        set(EP.min2,'String',sprintf(EP.format,EP.stim.min(jj)));
        set(EP.max2,'String',sprintf(EP.format,EP.stim.max(jj)));
        set(EP.val2,'String',sprintf(EP.format,EP.stim.amp(jj)));
        set(EP.per2,'String',sprintf('%u%%',round(100 * value)));
        set(EP.slider2,'Value',value);
    end
end

function EP_Callback(hObject,~)
global axon SWP
EP = get(get(hObject,'Parent'),'UserData');
switch hObject
    case EP.eeg
    case EP.run, TSTrun(hObject,EP.cycle);
    case {EP.zero,EP.veldsymmetry}
%         field = get(handles.veldsymmetry,'UserData');
%         if hObject==handles.veldnul, field.dV = 0; else,field.dV = str2double(get(handles.veldsymmetry,'String')); end
%         set(handles.veldsymmetry,'String',sprintf('%0.4f',field.dV),'UserData',field);
    case EP.cycle, EP.cycle = str2double(get(hObject,'String'));
%         detimer = timerfindall('Name','TST-Timer');

%         end
%         start(detimer);
    case EP.gain
        EP = GainSelect(EP);    
    case EP.dif
%         if get(hObject,'Value'), set(handles.EPCSD,'Value',0);  end;
%         Meting = ResetAverage(Meting,1);
    case EP.csd
%         if get(hObject,'Value'), set(handles.EPdiff,'Value',0); end;
%         Meting = ResetAverage(Meting,1);
    case EP.sign
        if KnobIsRed(EP.sign)
             KnobGrey(EP.sign);
             color = [0 0 1];
             txt = 'norm';
         else
             KnobRed(EP.sign);
             color = [1 0 0];
             txt = 'inv';
         end
         set([EP.slider1,EP.slider2],'BackgroundColor',color);
         set(EP.sign,'String',txt);
    otherwise
        hhh = [EP.min1 EP.max1 EP.per1 EP.val1 EP.slider1];
        if isempty(find(hhh==hObject, 1)), die = 2; else, die = 1; end
        switch hObject
            case {EP.max1,EP.max2}
                EP.stim.max(die) = max(0,min(EP.stim.full(die),str2double(get(hObject,'String'))));
            case {EP.min1,EP.min2}
                EP.stim.min(die) = max(0,min(EP.stim.full(die),str2double(get(hObject,'String'))));
            case {EP.per1,EP.per2}
                txt = get(hObject,'String'); per = findstr(txt,'%'); if ~isempty(per), txt(per) = []; end
                EP.stim.amp(die) = EP.stim.min(die) + (EP.stim.max(die) - EP.stim.min(die)) * 0.01 * max(0,min(100,str2double(txt)));
            case {EP.val1,EP.val2}
                EP.stim.amp(die) = max(EP.stim.min(die),min(EP.stim.max(die),str2double(get(hObject,'String'))));
            case {EP.slider1,EP.slider2}
                EP.stim.amp(die) = EP.stim.min(die) + (EP.stim.max(die)-EP.stim.min(die)) * get(hObject,'Value');       
        end
        EP = setsliders(EP);
end
if ~Error("box")
    set(EP.handle,'UserData',EP);
    drawnow();
end

%
% ====== Logging =====================================
%
function LoggerClear
global Log
Log = [];
Log.master   = false;
Log.on       = false;
Log.dbase    = "";
Log.modus    = "byfile";
Log.filename = "";
Log.cellname = "";
Log.channame = "";
Log.animal   = [];
Log.matlab   = [];

function DoLogmaster(parms)
global Log
[parms,present] = ParseSpecial(parms,"byfile");        if present, Log.modus = "byfile"; end
[parms,present] = ParseSpecial(parms,"bycell");        if present, Log.modus = "bycell"; end
[parms,present] = ParseSpecial(parms,"cellbyfile");    if present, Log.modus = "cellbyfile"; end
[parms,present] = ParseSpecial(parms,"filebychannel"); if present, Log.modus = "filebychannel"; end
if isempty(Log.modus), Error("Logger modes: byfile, bycell, cellbyfile, filebychannel"); return; end
Log.master = getboolean(parms,false);
if ~Log.master, Log.on = false; end

function InsertinLog(CMD,structname,result,channame)
global Log panels
if ~Log.on || panels.abort, return; end
filename = string(result.basis.file);
cellname = makecellname(filename);
idxf = find(strcmp(Log.filename,filename), 1);
if isempty(idxf), if Log.filename(1)=="", idxf = 1; else, idxf = length(Log.filename)+1; end; Log.filename(idxf,1) = filename; end
idxc = find(strcmp(Log.cellname,cellname), 1);
if isempty(idxc), if Log.cellname(1)=="", idxc = 1; else, idxc = length(Log.cellname)+1; end; Log.cellname(idxc,1) = cellname; end
idxk = find(strcmp(Log.channame,channame), 1);
if isempty(idxk), if Log.channame(1)=="", idxk = 1; else, idxk = length(Log.channame)+1; end; Log.channame(idxk,1) = channame; end
idx2 = 1;
name2 = '';
switch Log.modus
    case "byfile",        idx1 = idxf; name1 = filename;
    case "bycell",        idx1 = idxc; name1 = cellname;
    case "cellbyfile",    idx1 = idxc; name1 = cellname;
                          idx2 = idxf; name2 = filename;
    case "filebychannel", idx1 = idxf; name1 = filename;
                          idx2 - idxk; name2 = channame;
end
if CMD.Logconfirm.Value && ~isempty(Log.matlab{idx1,idx2})
    names = fieldnames(Log.matlab{idx1,idx2});
    if any(strcmp(structname,names))
        button = ["Replace data";"Always replace";"Keep original"];
        switch questdlg(sprintf("Logger Replace:\n matlab{%u,%u}.%s\n\n-- %s\n-- %s", idx1, idx2, structname, name1, name2),...
                        "Confirm",button(1),button(2),button(3),button(3))
            case button(1)
            case button(2), CMD.Logconfirm.Value= false;
            case button(3), return
        end
    end
end
Log.matlab{idx1,idx2}.(structname) = result;
KnobBlue(CMD.DBase);



function DoLogger(CMD,parms,varargin)
global Log
[parms,doload] = ParseSpecial(parms,'load');
[parms,dosave] = ParseSpecial(parms,'save');
if ~doload && ~dosave
    Log.on = getboolean(parms,false);
    if ~(Log.master && Log.on)
        if Log.on, Error("tell",'Switch Logmaster(On) if you want to Log'); end
        Log.on = false;
    end
    return
end
if ~Log.master, return; end
if doload
    if nargin>2
        oldnaam = varargin{1};
    else
        [filename,filepath] = uigetfile({'*.mat';'*.mat';'*.*'},'Select an existing database',Log.dbase);
        if filename==0, return; end
        oldnaam = fullfile(filepath,filename);
    end
    [hlp1,hlp2,hlp3] = fileparts(oldnaam);
    bunaam = fullfile(hlp1,[hlp2 '-BU' hlp3]);
    copyfile(oldnaam,bunaam,'f');
    warning off
    try
        load(oldnaam);
    catch
        Error(sprintf('can not open \n%s',oldnaam));
        warning on
        return
    end
    Log = struct('master',Log.master,'on',Log.on,'dbase',oldnaam,'modus',[],...
                 'filename',[],'cellname',[],'channame',[],'animal',[],'matlab',[]);
    Log.modus    = string(NeuronResult.modus);
    Log.filename = string(NeuronResult.filename);
    Log.cellname = string(NeuronResult.cellname);
    Log.channame = string(NeuronResult.channame);
    Log.animal   = NeuronResult.animal;
    Log.matlab   = NeuronResult.matlab;
    warning on
end
if dosave
    if isempty(Log.dbase)
        [name,path,ext] = uiputfile('*.mat','Save Logger Dbase',Log.dbase);
        if name==0, return; end
        Log.dbase  = fullfile(path,name);
    end
    NeuronResult.modus    = Log.modus;
    NeuronResult.filename = Log.filename;
    NeuronResult.cellname = Log.cellname;
    NeuronResult.channame = Log.channame;
    NeuronResult.animal   = Log.animal;
    NeuronResult.matlab   = Log.matlab;
    save(Log.dbase,'NeuronResult');
    KnobGrey(CMD.DBase);
end

function DoSnapshot(parms)
global panels graf
[parms,present] = ParseSpecial(parms,'Off');
if present, panels.snap.on = false; end
[parms,present,ps] = ParseSpecial(parms,'On');
if present
    if isempty(panels.file.name), panels.snap.on = false; return; end
    panels.snap.on = true;
    if ~isempty(ps), panels.snap.nr = nsingle(ps{1}); end
    panels.snap.dirname = '';
    [parms,panels.snap.dir,ps] = ParseSpecial(parms,'dir');
    if present && ~isempty(ps)
    	panels.snap.dirname = ssingle(ps{1});
    end
    return
end 
if ~panels.snap.on, return; end
[parms,present,ps] = ParseSpecial(parms,'window');
if present
    wins = find([graf.window]>0)';
    if ~isempty(ps), wins = intersect(wins,nsingle(ps{1})); end
    set(gcf,'Units','Pixels');
    rect = [inf inf 0 0];
    for jj=wins
        set(graf(jj).handle,'UnitsOpenMEA','pixels');
        frame = round(get(graf(jj).handle,'Position'));
        set(graf(jj).handle,'Units','normalized');
        rect(1) = min([rect(1) frame(1)]);
        rect(2) = min([rect(2) frame(2)]);
        rect(3) = max([rect(3) frame(1)+frame(3)]);
        rect(4) = max([rect(4) frame(2)+frame(4)]);
    end
    rect(1) = rect(1) - 14;
    rect(2) = rect(2) - 14;
    rect(3) = rect(3) - rect(1) + 3;
    rect(4) = rect(4) - rect(2) + 3;
    picture = getframe(gcf,rect);
    set(gcf,'Units','Normalized');
else
    picture = getframe(gcf);
end
[currentdir,name] = fileparts(panels.file.name);
if panels.snap.dir, [currentdir,~] = fileparts(currentdir); end
if isempty(panels.snap.dirname), dirname = 'snap'; else, dirname = panels.snap.dirname; end
mkdir([currentdir filesep dirname]);
if isempty(panels.segnr), sgmnt = ''; else, sgmnt = sprintf('_%u_',panels.segnr); end
if isempty(parms)
    nummer = panels.snap.nr;
    panels.snap.nr = panels.snap.nr + 1;
else
    nummer = nsingle(parms{1});
end
imwrite(picture.cdata,sprintf('%s%s%s%s_%03u.tiff',[currentdir filesep dirname],filesep,name,sgmnt,nummer),'TIFF')
DoMusic(2)
%
% ====== Macros handling  =================================================
%
function txt = Fittekst(fitter)
txt = sprintf('\n %s : %s',fitter.name,fitter.model);
if ~isempty(fitter.range), txt = [txt sprintf('\n\n fitrange:%8.4f to %8.4f',fitter.range(1),fitter.range(2))]; end
txt = [txt sprintf('\n\n GOF %6.4f  (adjusted %6.4f) iters: %u\n\n par     value       error    percent)',fitter.error,fitter.aerror,fitter.iters)];
for ii =1:length(fitter.v)
    if abs(fitter.v(ii))>0.000001, reler = abs(100*fitter.dv(ii)/fitter.v(ii)); else,reler = 0; end
    txt = [txt sprintf('\n%5s (%s) %8.2f  %7.2f  (%5.2f%%)',fitter.names{ii},fitter.n{ii},fitter.v(ii),fitter.dv(ii),reler)];
end

function rfit = Fitfunctie(xx,yy,inparms)
global panels
rfit = struct ('valid',false,...
               'xorg',xx,'yorg',yy,...
               'xfit',xx,'yfit',yy,...
               'xeva',xx,'yeva',yy,...
               'x0',0,...
               'segments',0,...
               'name','',...
               'model','',...
               'fmodel','',...
               'names','',...
               'n',[],...
               'v',[],...
               'dv',[]);
kmax = 1;
[inparms,present,parms] = ParseSpecial(inparms,'fits'); if ~present, parms = inparms; end
[parms,rfit.segments]   = ParseSpecial(parms,'segments');
[parms,dooffset]   = ParseSpecial(parms,'offset');
[parms,dofix,pfix] = ParseSpecial(parms,'fixamp');
[parms,evas,doeva] = ParseTwo(parms,'eva');
[parms,present,ps] = ParseSpecial(parms,'cormin'); if present, cormin = rsingle(ps{1}); else, cormin = 0; end
[parms,present,ps] = ParseSpecial(parms,'lower');  if present, lower = rsingle(ps{1}); else, lower = []; end
[parms,present,ps] = ParseSpecial(parms,'upper');  if present, upper = rsingle(ps{1}); else, upper = []; end
deltat = 0;
[parms,present,ps] = ParseSpecial(parms,'deltat');
if present
    deltat = rsingle(ps{1});
    if length(ps)>1, limitdelta = rsingle(ps{2}); end
else
    limitdelta = [-inf inf];
end
[fitmode,psh] = ParseCmd(parms{1});
if isempty(psh)
    fitmodepars = [];
else
    fitmodepars = rsingle(psh{1});
end
rfit.x0 = 0;
[parms,present,ps] = ParseSpecial(parms,'fitrange');
if present
    fitrange = rsingle(ps{1});
    yy = yy((xx>=fitrange(1))&(xx<=fitrange(2)));
    xx = xx((xx>=fitrange(1))&(xx<=fitrange(2)));
    if (length(fitrange)>2) && (strcmp(fitmode,'Expo')||strcmp(fitmode,'Expoxt')||strcmp(fitmode,'Alfa')||strcmp(fitmode,'Expdouble'))
        rfit.x0 = fitrange(3);
    end
else
    fitrange = [-inf inf 0];
end
if Error, return; end
if ~rfit.segments
    ynan = find(isnan(yy));
    xnan = find(isnan(xx));
    nans = [ynan(:) xnan(:)];
    if ~isempty(nans)
        xx(nans) = [];
        yy(nans) = [];
    end
    xx = xx - rfit.x0;
end
setnorm = 'on';
polynomial = false;
switch fitmode
    case 'Boltzmann'
        if rfit.segments
            splits = find(xx(1:end-1)>xx(2:end));
        else
            splits = length(xx);
        end
        [AA,idx1] = min(yy(1:splits));
        [BB,idx2] = max(yy(1:splits));
        if ~dooffset, AA = 0; end
        if idx2>idx1, die = find(yy(1:splits)>=(0.5*BB),1,'first'); else, die = find(yy(1:splits)<=(0.5*BB),1,'first'); end
        if isempty(die)
            die = splits-1;
        else
            die = max(min(die,splits-1),2);
        end
        CC = xx(die);
        if length(yy)<3, hlp = [1,1]; else, hlp = regress(yy(die-1:die+1),[ones(3,1) xx(die-1:die+1)]); end
        DD = BB/(4*hlp(2));
        setnorm = 'off';
        if rfit.segments
            AA = 2 * BB;
            themodel    = 'Boltzmann2(x,a,b,c,d)';
            startvalues = [AA BB CC DD];
            coeffname   = {'Amp1';'Amp2';'Vh';'Vc'};
        elseif dooffset
            themodel    = 'a+b/(1+exp((c-x)/d))';
            startvalues = [AA BB CC DD];
            coeffname   = {'Amp0';'Amp';'Vh';'Vc'};
        else
            themodel    = 'b/(1+exp((c-x)/d))';
            startvalues = [BB CC DD];
            coeffname   = {'Amp';'Vh';'Vc'};
        end
    case {'Poly1';'Poly2';'Poly3';'Poly4'}
        polynomial = true;
        themodel   = fitmode;
        switch fitmode
            case 'Poly1', coeffname = {'Amp1';'Amp0'};
            case 'Poly2', coeffname = {'Amp2';'Amp1';'Amp0'};
            case 'Poly3', coeffname = {'Amp3';'Amp2';'Amp1';'Amp0'};
            case 'Poly4', coeffname = {'Amp4';'Amp3';'Amp2';'Amp1';'Amp0'};
        end
        startvalues = NaN(length(coeffname),1);
    case 'Logistic'
        BB = max(yy);
        CC = mean(xx);
        DD = 1;
        coeffname = {'Amp';'EC50'};
        startvalues = [BB CC];
        switch psh{1}
            case '1', themodel = 'b*x/(x+c)';                                  
            case '2', themodel = 'b*x^2/(x^2+c^2)';                            
            case 'n', startvalues = [startvalues DD];
                      coeffname   = [coeffname;'Hill'];
                      themodel    = 'b*realpow(x,d)/(realpow(x,d)+realpow(c,d))';
        end
    case 'Expdouble'
        startvalues = [10; 1/1; 1/10; 100; 1/50];
        coeffname   = {'AmpA'; 'actA'; 'inaA'; 'AmpC'; 'actC'};
        themodel    = '-1*a*expm1(-x*b)*exp(-x*c)-d*expm1(-x*e)';
        lower = [0,  1/20, 1/50,0,  1/200];
        upper = [inf,1/0.5,1/1, inf,1/20];
    case 'Alfa'
        AA = max(yy);
        BB = 10/(xx(end)-xx(1));
        startvalues = [AA BB];
        coeffname = [];
        coeffname{1,1} = 'Amp';
        coeffname{2,1} = 'tau';
        if isempty(lower)
            lower(1,1:2) = [0, 0];
            upper(1,1:2) = [inf, inf];
        end
        themodel = 'a*x.*exp(-x@b)';
    case 'Expoxt'
        AA = yy(end);
        BB = 0.5*(yy(1)-yy(end));
        CC = 10/(xx(end)-xx(1));
        DD = -1;
        startvalues = [AA BB CC DD];
        coeffname = [];
        coeffname{1,1} = 'Amp0';
        coeffname{2,1} = 'Amp1';
        coeffname{3,1} = 'rate1';
        coeffname{4,1} = 'slope';
        if isempty(lower)
            lower(1,1:4) = [-inf, 0,   CC/1000, -inf];
            upper(1,1:4) = [ inf, inf, CC*1000, 0];
        end
        themodel = 'a+b*exp(-x@c)+0.01*d*x';
    case 'Expo'
        switch length(fitmodepars)
            case 1, nexpdwn = fitmodepars(1); npwr = 0;              nexpup = 0;                            
            case 2, nexpdwn = fitmodepars(2); npwr = fitmodepars(1); nexpup = 1;               
            case 3, nexpdwn = fitmodepars(3); npwr = fitmodepars(2); nexpup = fitmodepars(1);  
            otherwise
                Error('Expo fit needs set of 1-2-3 parameters');
                return
        end
        startvalues = [];
        coeffname = [];
        dolimit  = isempty(lower);
        mofset = [];
        CC     = 1/(xx(end)-xx(1));
        taumin = CC/1000;
        taumax = CC*1000;
        EE = CC/10;
        GG = CC/100;
        KK = CC*10;
        MM = CC*100;
        HH = 0.5;
        A0 = yy(end);
        B0 = yy(1);
        C0 = mean(yy);
        cnt = 0;
        if dooffset
            mofset       = 'a+';
            if nexpdwn==0, AA = B0; else,AA = A0; end
            startvalues  = AA;
            cnt = cnt + 1;
            coeffname{cnt,1} = 'Amp0';
        end
        if dofix
            dwnmodel = [pfix{1} '*'];
            BB = rsingle(pfix{1});
        else
            dwnmodel = 'b*';
            if nexpdwn==0
                BB = A0-B0;
            elseif nexpup==0
                BB = (B0-A0)/(nexpdwn);
            else
                if C0>=A0
                    BB = 2*max(yy)/(nexpdwn);
                else
                    BB = 2*min(yy)/(nexpdwn);
                end
            end
            DD = BB;
            FF = BB;
            startvalues = [startvalues BB];
            cnt = cnt + 1;
            coeffname{cnt,1} = 'Amp1';
            refcnt = cnt;

        end
        if nexpdwn>0
            dwnmodel    = [dwnmodel 'exp(-x@c)'];
            startvalues = [startvalues CC];
            cnt = cnt + 1;
            coeffname{cnt,1} = 'rate1';

        end
        if nexpdwn>1
            dwnmodel    = [dwnmodel '+d*exp(-x@e)'];
            startvalues = [startvalues DD EE];
            cnt = cnt + 1;
            coeffname{cnt,1} = 'Amp2';
%             if dolimit
%                 lower(1,cnt) = lower(1,refcnt);
%                 upper(1,cnt) = upper(1,refcnt);
%             end
            cnt = cnt + 1;
            coeffname{cnt,1} = 'rate2';

        end
        if nexpdwn>2
            dwnmodel    = [dwnmodel '+f*exp(-x@g)'];
            startvalues = [startvalues FF GG];
            cnt = cnt + 1;
            coeffname{cnt,1} = 'Amp3';
%             if dolimit
%                 lower(1,cnt) = lower(1,refcnt);
%                 upper(1,cnt) = upper(1,refcnt);
%             end
            cnt = cnt + 1;
            coeffname{cnt,1} = 'rate3';
%             if dolimit
%                 lower(1,cnt) = taumin;
%                 upper(1,cnt) = taumax;
%             end
        end
        if nexpup==1
            upmodel     = '(-expm1(-x@k))';
            startvalues = [startvalues KK];
            cnt = cnt + 1;
            coeffname{cnt,1} = 'rate4';
%             if dolimit
%                 lower(1,cnt) = taumin;
%                 upper(1,cnt) = taumax;
%             end
        elseif nexpup==2
            upmodel     = '(1-h*exp(-x@k)-(1-h)*exp(-x@m))';
            startvalues = [startvalues HH KK MM];
            cnt = cnt + 1;
            coeffname{cnt,1} = 'Amp4';
%             if dolimit
%                 lower(1,cnt) = 0;
%                 upper(1,cnt) = 1;
%             end
            cnt = cnt + 1;
            coeffname{cnt,1} = 'rate4';
%             if dolimt
%                 lower(1,cnt) = taumin/10;
%                 upper(1,cnt) = taumax;
%             end
            cnt = cnt + 1;
            coeffname{cnt,1} = 'rate5';
%             if dolimit
%                 lower(1,cnt) = taumin/10;
%                 upper(1,cnt) = taumax;
%             end
        end
        if npwr>1, upmodel = sprintf('realpow(%s,%u)',upmodel,npwr); end
        if nexpdwn==0
            themodel = [mofset 'b*' upmodel];
        elseif nexpup==0
            themodel = [mofset dwnmodel];
        else
            themodel = ['(' mofset dwnmodel ').*' upmodel];
        end
        if deltat~=0
            cnt = cnt+1;
            themodel = strrep(themodel,'exp','zzz');
            themodel = strrep(themodel,'x','(x-t)');
            themodel = strrep(themodel,'zzz','exp');
            startvalues = [startvalues deltat];
            coeffname{cnt,1} = 'delay';
%             lower(1,cnt) = limitdelta(1);
%             upper(1,cnt) = limitdelta(2);
        end
    otherwise
        Error(sprintf('Unknown Fitfunction: %s',fitmode));
        return
end
if ~isempty(lower) && (length(coeffname)~=length(lower))
    etxt = 'mismatch boundaries for:';
    for jj = 1:length(coeffname), etxt = sprintf('%s ,%s',etxt,coeffname{jj}); end
    Error(etxt);
    return;
end
if length(yy)<=length(startvalues)
    Error(sprintf('Cannot fit %u parameters to %u datapoints',length(startvalues),length(yy)));
    return
end
altmodel = strrep(themodel,'@','/');
themodel = strrep(themodel,'@','*');
for kkk = 1:kmax
    if polynomial
        mymodel = fittype(themodel);
    elseif isempty(lower)
        mymodel = fittype(themodel,...
                          'options',fitoptions('StartPoint',startvalues,...
                                               'Method','Nonlinear',...
                                               'Normalize',setnorm,...
                                               'MaxFunEvals',3000));
    else
        mymodel = fittype(themodel,...
                          'options',fitoptions('StartPoint',startvalues,...
                                               'Method','Nonlinear',...
                                               'MaxFunEvals',5000,...
                                               'Lower',lower,...
                                               'Upper',upper,...
                                               'Weights',[]));
    end
    rfit.xfit = xx;
    rfit.yfit = yy;
    try
        [fitout,gof,funout] = fit(xx,yy,mymodel);
    catch ME
        if ~panels.skipfit
            button1 = 'Ignore';
            button2 = 'Suppress Message';
            button3 = 'Break';
            switch questdlg(sprintf('Error while fitting: %s\n\n%s',fitmode,altmodel),...
                                    'Fit-Error',button1,button2,button3,button1)
                case button2, panels.skipfit = true;
                case button3, Error('Broken on fit error');
            end
        end
        rfit.error = 0;
        rfit.v     = NaN(1,length(startvalues));
        rfit.dv    = NaN(1,length(startvalues));
        rfit.xeva = [];
        rfit.yeva = [];
        return
    end
    rfit.res  = fitout;
    rfit.name = fitmode;
    if polynomial
        rfit.model = formula(mymodel);
    else
        rfit.model = altmodel;
    end
    rfit.n     = coeffnames(mymodel);
    rfit.range = fitrange(1:2);
    rfit.names = coeffname;
    rfit.v     = coeffvalues(fitout);
    if length(coeffname)>=length(xx)
        rfit.dv = rfit.v + NaN;
    else
        try
            hlp  = confint(fitout,0.95);
        catch ME
            text = sprintf('   MATLAB error in Fitting\n\n   Please Report to Wytse!\n\n%s\n\n%s\n\n',lasterror.message,lasterror.identifier);
            for ii = 1:length(lasterror.stack)
                msg = lasterror.stack(ii,1);
                text = [text sprintf('line: %06u    in  %s\n',msg.line,msg.name)];
            end
            if strcmp(questdlg(text,'Message','Break','Ignore','Break'),'Break')
                return;
            else
                hlp = rfit.v + NaN;
            end
        end
        rfit.dv = rfit.v - hlp(1,:);
    end
    rfit.sse     = gof.sse;
    rfit.dfe     = gof.dfe;
    rfit.rmse    = gof.rmse;
    rfit.error   = max(0,gof.rsquare);
    rfit.aerror  = max(0,gof.adjrsquare);
    rfit.iters   = funout.iterations;
    rfit.exit    = funout.exitflag;
    if doeva
        rfit.xeva = linspace(evas(1),evas(2),248)';
    elseif length(xx)<250
        rfit.xeva = linspace(xx(1),xx(end),248)';
    else
        rfit.xeva = xx;
    end
    if strcmp(fitmode,'Alfa')
        s = rfit.v;
        rfit.yres = s(1) * rfit.xeva.*exp(-rfit.xeva * s(2));
        rfit.names{2} = strrep(rfit.names{2},'rate','tau');
        relfout       = rfit.dv(2)/rfit.v(2);
        rfit.v(2)     = 1/s(2);
        rfit.dv(2)    = relfout*rfit.v(2);
    elseif strcmp(fitmode,'Expoxt')
        s = rfit.v;
        rfit.yeva = s(1) + s(2) * exp(-rfit.xeva * s(3)) + 0.01 * s(4) * rfit.xeva;
        rfit.names{3} = strrep(rfit.names{3},'rate','tau');
        relfout    = rfit.dv(3)/rfit.v(3);
        rfit.v(3)  = 1/s(3);
        rfit.dv(3) = relfout*rfit.v(3);
    elseif strcmp(fitmode,'Expdouble')
        s = rfit.v;
        rfit.yeva = -1*s(1)*expm1(-rfit.xeva*s(2)).*exp(-rfit.xeva*s(3)) - s(4)*expm1(-rfit.xeva*s(5));
        relfout    = rfit.dv(2)/rfit.v(2);
        rfit.v(2)  = 1/s(2);
        rfit.dv(2) = relfout*rfit.v(2);
        relfout    = rfit.dv(3)/rfit.v(3);
        rfit.v(3)  = 1/s(3);
        rfit.dv(3) = relfout*rfit.v(3);
        relfout    = rfit.dv(5)/rfit.v(5);
        rfit.v(5)  = 1/s(5);
        rfit.dv(5) = relfout*rfit.v(5);
    elseif strcmp(fitmode,'Expo')
        ffx = diff(xx);
        dsx = sum(ffx-ffx(1))/ffx(1);
        if dsx<0.01
            dt = xx(2)-xx(1);
            nn = round(xx(end)/dt);
            rfit.xeva = dt*(0:nn-1)';
        end
        t = -rfit.xeva;
        if deltat~=0
            t = t + rfit.v(end);
            t(t>0)=0;
        end
        y = 0*t;
        s = rfit.v;
        if dooffset, cnt = 1; amp0 = s(1); else,cnt = 0; amp0 = 0; end
        if nexpdwn==0
            cnt = cnt + 1; amp1 = s(cnt);
        elseif dofix
            cnt = cnt + 1;
            yd = rsingle(pfix{1})*exp(t*s(cnt));
        else
            yd = amp0 + 0*t;
            for jj = 1:nexpdwn
                cnt = cnt + 2;
                yd = yd + s(cnt-1)* exp(t*s(cnt));
            end
        end
        if nexpup==1
            cnt = cnt + 1;
            yu = -expm1(t*s(cnt));
        elseif nexpup==2
            cnt = cnt + 3;
            yu = 1-s(cnt-2)*exp(t*s(cnt-1))-(1-s(cnt-2))*exp(t*s(cnt));
        end
        if npwr>1
            yu = realpow(yu,npwr);
        end
        if nexpdwn==0
            y = amp0 + amp1 * yu;
        elseif nexpup==0
            y = yd;
        else
            y = yd.*yu;
        end
        for ii = 1:length(rfit.names)
            if isempty(strfind(rfit.names{ii},'rate'))
                if rfit.error<cormin
                    rfit.v(ii)  = 0;
                    rfit.dv(ii) = 0;
                end
            else
                rfit.names{ii} = strrep(rfit.names{ii},'rate','tau');
                if rfit.error<cormin
                    rfit.v(ii)  = NaN;
                    rfit.dv(ii) = NaN;
                else
                    relfout        = rfit.dv(ii)/rfit.v(ii);
                    rfit.v(ii)     = 1/s(ii);
                    rfit.dv(ii)    = relfout*rfit.v(ii);
                end
            end
        end
        rfit.yeva = y;
    elseif strcmp(fitmode,'Boltzmann')
        if rfit.segments
            rfit.xeva = [rfit.xeva; rfit.xeva];
            rfit.yeva = feval(rfit.res,rfit.xeva);
        else
            rfit.yeva = feval(rfit.res,rfit.xeva);
        end
    elseif strcmp(fitmode,'Poly1')
        rfit.yeva = feval(rfit.res,rfit.xeva);
    end
end
rfit.valid = true;

function DoFitXY(parms)
global Meting
CMD = getPANEL('CMDpanel');
[parms,winclear] = ParseClear(parms);
[parms,wait]     = ParseOne(parms,'wait',0);
[parms,metplot,pltcmd] = ParseSpecial(parms,'plot');
cmd = [];
hlp = [];
tst = {'xas';'yas';'scale'};
for jj = 1:length(parms)
    for jjj = 1:length(tst)
        if ~isempty(strfind(parms{jj},tst{jjj})), hlp = [hlp parms{jj} ',']; end
    end
end
cmd.mode = hlp(1:end-1);
[parms,data,datloc] = fetchdata(parms,Meting);
if isempty(data.xas), Error('FitXY needs xas'); return; end
if isempty(data.yas), Error('FitXY needs yas'); return; end
cmd.struct = sprintf('%s@%s',datloc.node,datloc.struct);
xx = [];
yy = [];
for jj = 1:length(data.xas)
    xhlp = data.xas{jj};
    xnan = find(isnan(xhlp));
    yhlp = data.yas{jj};
    ynan = find(isnan(yhlp));
    nans = [ynan(:) xnan(:)];
    if ~isempty(nans)
        xhlp(nans) = [];
        yhlp(nans) = [];
    end
    [xhlp,idx] = sort(xhlp);
    yhlp       = yhlp(idx);
    xx = [xx;xhlp];
    yy = [yy;yhlp];
end
rfit = Fitfunctie(xx,yy,parms);
if Error || ~rfit.valid, return; end
structname = datloc.struct;
nres       = datloc.nres;
if isfield(Meting(nres).result.(structname),'fitter')
    fitnr = length(Meting(nres).result.(structname).fitter) + 1;
else
    fitnr = 1;
end
% for jj = 1:length(rfit.names)
%     Meting(nres).result.(structname).(rfit.name).(rfit.names{jj})(fitnr,1) = rfit.v(jj);
% end
% Meting(nres).result.(structname).(rfit.name).GOF(fitnr,1) = rfit.error;
Meting(nres).result.(structname).fitter{fitnr,1}          = rfit;
Meting(nres).result.(structname).fitter{fitnr,1}.plotter  = [];
Meting(nres).result.(structname).fitter{fitnr,1}.source   = cmd;
InsertinLog(CMD,structname,Meting(nres).result.(structname),[]);
if ~isempty(winclear), WindowClear(winclear); end
NRNtimeline;
if metplot
    plotter.window = ssingle(pltcmd{1});
    plotter.struct = structname;
    plotter.mode   = ssingle(pltcmd{2});
    Meting(nres).result.(structname).fitter{fitnr,1}.plotter = plotter;
    setplotter('fitter',Meting,nres,structname,fitnr);
    NRNshow(Meting);
    DoTestwait(wait);
end
 
function savexy(mettemplate)
global spikes panels
hlp1 = (panels.zoom.tnul/1000)+spikes.spktlvl/spikes.adcrate;
hlp2 = (panels.zoom.tnul/1000)+spikes.spktmax/spikes.adcrate;
if length(hlp2)>2
    hlp3 = [hlp2(2)-hlp2(1); (hlp2(3:end)-hlp2(1:end-2))/2;  hlp2(end)-hlp2(end-1)];
else
    hlp3 = [0; 0];
end
spikes.xydata = [hlp1 spikes.spklvl hlp2 spikes.spkmax hlp3 double(spikes.class)];
spikes.xyname{1,1} ='event-trgtime';
spikes.xyname{2,1} ='event-trglvl';
spikes.xyname{3,1} ='event-maxtime';
spikes.xyname{4,1} ='event-maxamp';
spikes.xyname{5,1} ='event-interval';
spikes.xyname{6,1} ='event-class';
if mettemplate
    spikes.xydata = [spikes.xydata spikes.gain spikes.off spikes.fact spikes.err];
    spikes.xyname{7,1}  ='event-gain';
    spikes.xyname{8,1}  ='spike-offset';
    spikes.xyname{9,1}  ='spike-factor';
    spikes.xyname{10,1} ='spike-error';
end
                    
function [slope,offset] = LSQfit(xx,yy)
N = length(xx);
Sx = sum(xx);
Sy = sum(yy);
slope  = (Sx*Sy-N*sum(yy.*xx))/(Sx*Sx-N*sum(xx.*xx));
offset = (Sy - slope * Sx)/N;

function pp = DecomposeDAC(tas,yt,sdac,channel,gap,splitfreq,mnr)
global Meting
NFFT = length(yt);
wind = blackmanharris(NFFT); 
spct = fft(wind.*(yt- mean(yt)),NFFT)/NFFT;
fas  = linspace(0,1,NFFT/2)*500/(tas(2)-tas(1));
df   = fas(2)-fas(1);
pwr  = 2*abs(spct(1:round(NFFT/2)));
spnt = round(splitfreq/df);
if spnt==0
    [~,mp1] = max(pwr);
else
    [~,mp1] = max(pwr(1:spnt));
end
pp.peak1 = fas(mp1);
yf1      = cos(2 * pi() * pp.peak1 * 0.001 * tas);
yf2      = sin(2 * pi() * pp.peak1 * 0.001 * tas);
[pp.amp1,pp.offset] = LSQfit(yf1,yt);
pp.amp2             = LSQfit(yf2,yt);
if abs(pp.amp1)>abs(pp.amp2)
    pp.crossings = Crossings(yf1,[0 inf],'interpol');
else
    pp.crossings = Crossings(yf2,[0 inf],'interpol');
end
if mnr>0
    Meting(mnr).dac    (:,channel+1) = int16(round( (pp.amp1*yf1 + pp.amp2*yf2 + pp.offset)/sdac ));
    Meting(mnr).DAC.HWchn(channel+1) = channel+1;
    Meting(mnr).DAC.scale(channel+1) = Meting(mnr).DAC.scale(channel);
end
if spnt>0
    [~,mp2] = max(pwr((mp1+spnt):end));
    pp.peak2 = fas(mp2 + mp1 + spnt -1);
    yf3 = cos(2 * pi() * pp.peak2 * 0.001 * tas);
    yf4 = sin(2 * pi() * pp.peak2 * 0.001 * tas);
    pp.amp3 = LSQfit(yf3,yt);
    pp.amp4 = LSQfit(yf4,yt);
    if mnr>0
        Meting(mnr).dac    (:,channel+2) = int16(round( (pp.amp3*yf3 + pp.amp4*yf4)/sdac ));
        Meting(mnr).DAC.HWchn(channel+2) = channel+2;
        Meting(mnr).DAC.scale(channel+2) = Meting(mnr).DAC.scale(channel);
    end
end
if gap>0
    pp.alfatimes = find(diff(abs(pp.amp1)*yt)<-1000)-1;
    if isempty(pp.alfatimes), Error(sprintf('No alfa functions in measurement %u',mnr)); return; end;
    nnn = (pp.alfatimes(1)+gap):pp.alfatimes(2);
    for ii = 3:length(pp.alfatimes), nnn = [nnn (pp.alfatimes(ii-1)+gap):pp.alfatimes(ii)]; end
    nnn = nnn';
    [pp.amp1,pp.offset] = LSQfit(yf1(nnn),yt(nnn));
    pp.amp2             = LSQfit(yf2(nnn),yt(nnn));
    if pp.amp1>pp.amp2
        pp.crossings = Crossings(yf1,[0 inf],'interpol');
    else
        pp.crossings = Crossings(yf2,[0 inf],'interpol');
    end
    period = mean(diff(pp.crossings));
    nlen   = min(length(pp.crossings),length(pp.alfatimes));
    shift  = mean(pp.alfatimes(1:nlen)-pp.crossings(1:nlen));
    pp.phase = 360 *abs(shift)/period;
    if pp.alfatimes(1)<pp.crossings(1), pp.phase = 360 - pp.phase; end
    if mnr>0
        Meting(mnr).dac    (:,channel+1) = int16(round((pp.amp1*yf1 + pp.offset)/sdac ));
        Meting(mnr).DAC.HWchn(channel+1) = channel+1;
        Meting(mnr).DAC.scale(channel+1) = Meting(mnr).DAC.scale(channel);
        Meting(mnr).dac    (:,channel+2) = int16(round((yt - pp.amp1*yf1 - pp.offset)/sdac ));
        Meting(mnr).DAC.HWchn(channel+2) = channel+2;
        Meting(mnr).DAC.scale(channel+2) = Meting(mnr).DAC.scale(channel);
    end
end

function [trace] = ShiftTrace(trace,numpoints)
if numpoints>0
    trace = [repmat(trace(1),numpoints,1); trace(1:(end-numpoints))];
elseif numpoints<0
    trace = [trace(1:(end-numpoints)); repmat(trace(1),numpoints,1)];
end
%
% ====== Macro subroutines =============================================
%
function nres = Newnode(nodename)
global Meting
nres = length(Meting)+1;
Meting(nres)            = Meting(nres-1);
Meting(nres).setnr      = true;
Meting(nres).abstime    = [];
Meting(nres).reltime    = [];
Meting(nres).serienaam = nodename;
Meting(nres).nodenaam  = nodename;
Meting(nres).EXTRA.note  = '';
Meting(nres).ADC.HWchn   = [];
Meting(nres).ADC.rate    = [];
Meting(nres).ADC.scale   = [];
Meting(nres).adc  = [];
Meting(nres).DAC.HWchn = [];
Meting(nres).DAC.rate  = [];
Meting(nres).DAC.scale = [];
Meting(nres).dac  = [];
Meting(nres).cdac = [];
Meting(nres) = MeanIni(Meting(nres));
Meting(nres).SEGMENT.name  = [];
Meting(nres).SEGMENT.cmt   = [];
Meting(nres).SEGMENT.start = [];
Meting(nres).SEGMENT.eind  = [];
Meting(nres).SEGMENT.time  = [];
Meting(nres).result  = [];
Meting(nres).plotter = [];

function result = ListValid(nrs)
global cmdlist
result = false;
for die = nrs
    if (die==0)||(die>length(cmdlist)), return; end
    if isempty(cmdlist{die}), return; end
end
result = true;

function fout = Testadcrange(met,mrow,mcol,mpage)
global Meting
fout = true;
if size(Meting)<met
	Error(sprintf('Metingnr out of range %u < %u\n\n',size(Meting),met)); return;
elseif isempty(Meting(met).adc)
    Error('no adc data'); return;
else
    [row,col,page] = size(Meting(met).adc);
    if mrow>row,   Error(sprintf('Leak: adc time out of range %u < %u\n\n',row,mrow));    return; end
    if mcol>col,   Error(sprintf('Leak: adc channel out of range %u < %u\n\n',col,mcol)); return; end
    if mpage>page, Error(sprintf('Leak: adc swps out of range %u < %u\n\n',page,mpage));   return; end
end 
fout = false;

function DoMusic(nr)
persistent klik
if ~ismac
    try
        if isempty(klik)
            klik{1} = audioread('chimes.wav');
            klik{2} = audioread('ding.wav');
            klik{3} = audioread('clickerx.wav');
        end
        switch nr
            case 0, sound(klik{1},2*8192); return
            case 1, sound(klik{2},8192);   return
            case 2, sound(klik{3},2*8192); return
            case 3, load gong;
            case 4, load train;
            case 5, load chirp;
            case 6, load splat;
            case 7, load laughter;
            case 8, load handel;    
            otherwise, return;
        end
        sound(y,Fs);
    catch

    end
end

function varargout = TwoPars(parms,varargin)
switch nargin
    case 1, p1 = [];
            p2 = [];
    case 2, hlp = varargin{1};
            p1 = hlp(1);
            p2 = hlp(2);
    case 3, p1 = varargin{1};
            p2 = varargin{2};
end
switch length(parms)
    case 1, p1 = rsingle(parms{1});
            if length(p1)==1, p2 = p1; else,p2 = p1(2); p1 = p1(1);end
    case 2, p1 = rsingle(parms{1});
            p2 = rsingle(parms{2});
end
switch nargout
    case 1, varargout{1} = [p1,p2];
    case 2, varargout{1} = p1;
            varargout{2} = p2;
end

function Mets = DoZero(parms,Mets)
[parms,present,ps] = ParseSpecial(parms,'adcs'); if present, adcs = nsingle(ps{1}); else,adcs = 0; end
[parms,~,mets,swps]  = ParseList(parms);
range = TwoPars(parms,[-inf,inf]);
for ii = 1:length(mets)
    [maxpnt,maxkan,~] = size(Mets(mets(ii)).adc);
    if adcs(1)==0, adcs = 1:maxkan; end
    hlp = round(range * Mets(mets(ii)).ADC.rate / 1000);
    p1 = max(min(hlp),1); p2 = min(max(hlp),maxpnt);
    offset = int16(round(squeeze(mean(double(Mets(mets(ii)).adc(p1:p2,:,:)),1))));
    for jj = adcs
        Mets(mets(ii)).adc(:,jj,swps(ii)) = Mets(mets(ii)).adc(:,jj,swps(ii)) - offset(jj,swps(ii));
    end
end

function deset = FindNodes(strin)
global Meting
deset = [];
names = stringset(strin);
for jj1 = 1:length(names)
    for jj2 = 1:length(Meting)
        if ~isempty(strfind(Meting(jj2).nodenaam,names{jj1}))
            deset(end+1) = jj2;
        end
    end
end

function deset = MatchNodes(strin)
global Meting
deset = [];
names = stringset(strin);
for jj1 = 1:length(names)
    for jj2 = 1:length(Meting)
        if ~isempty(strcmp(Meting(jj2).nodenaam,names{jj1}))
            deset(end+1) = jj2;
        end
    end
end

function DoExport(parms)
global Meting panels graf
[parms,present,ps]   = ParseSpecial(parms,'filetype');
if present, datatype = ssingle(ps{1}); else,datatype = 'txt'; end
[parms,present,ps]   = ParseSpecial(parms,'windows');
if present
    windows = nsingle(ps{1});
else
    windows = [];
    [parms,present,ps] = ParseSpecial(parms,'skip');
    if present, skip = nsingle(ps{1}); else,skip = 0; end
    [parms,times] = ParseTijd(parms,'times',1);
end
data  = [];
list  = [];
cnt   = 0;
if ~isempty(windows)
    cnt = 0;
    for jj = 1:length(windows)
        handle = graf([graf.window]==windows(jj)).handle;
        gbuf = get(handle,'UserData');
        for jjj = 1:length(gbuf.handles.trace)
            linehandle = gbuf.handles.trace(jjj);
            lbuf = get(linehandle,'UserData');
            cnt = cnt + 1;
            if cnt==1
                data.name{cnt,1}  = 'xas';
                data.unit{cnt,1}  = lbuf.xas.unit;
                data.trace(:,cnt) = get(linehandle,'XData')';
                cnt = cnt + 1;
            end
            data.name{cnt,1}  = get(gbuf.handles.names(jjj),'String');
            data.unit{cnt,1}  = lbuf.yas.unit;
            data.trace(:,cnt) = get(linehandle,'YData');
        end
    end
    [filepath,filename] = fileparts(panels.file.name);
    data.filename = filename;
    exportname  = fullfile(filepath,[filename sprintf('_export%03u.%s',panels.ExportCnt,datatype)]);
    if strcmp(datatype,'mat')
        save(exportname,'data')
    else
        n2 = size(data.trace,2);
        [fid,message] = fopen(exportname,'wt');
        if ~isempty(message), Error(sprintf('%s\n%s',message,exportname)); return; end
        txt = data.name{1,1};
        for ii = 2:n2, txt = [txt sprintf('\t%s ',data.name{ii,1})]; end
        fprintf(fid,'%s\n',txt);
        txt = data.unit{1,1};
        for ii = 2:n2, txt = [txt sprintf('\t%s ',data.unit{ii,1})]; end
        fprintf(fid,'%s\n',txt);
        fmt = '%12.8f';
        for ii = 2:n2, fmt = [fmt '\t%12.8f']; end
        fmt = [fmt '\n'];
        fprintf(fid,fmt,data.trace'); 
        fclose(fid);
    end
    return
else
    while true
        [parms,present,ps] = ParseSpecial(parms,'source');
        if ~present
            if ~isempty(list), break; end
            Error('You need a source'); return
        end
        deset = [];
        [ps,present,idh] = ParseSpecial(ps,'find');  if present, idx = ssingle(idh{1}); deset = FindNodes(idx); end
        [ps,present,idh] = ParseSpecial(ps,'match'); if present, idx = ssingle(idh{1}); deset = MatchNodes(idx); end
        if isempty(deset), deset = 1:length(Meting); idx = 'all'; end
        [parms,~,mets] = ParseList(parms);
        deset = deset(mets(mets<=length(deset)));
        if isempty(deset), Error('No nodes selected'); end
        rate = [];
        for j0 = 1:length(ps)
            [cmd,hps] = ParseCmd(ps{j0});
            chns      = nsingle(hps{1});
            if length(hps)<2, swps = []; else,swps = nsingle(hps{2}); end
            for metnr = deset
                if metnr>length(Meting)
                    Error('you try to export non-existing Meting'); return;
                end
                if strcmp(cmd,'dac')
                    if isempty(Meting(metnr).dac) && isempty(Meting(metnr).cdac)
                        Error('node has no dac'); return; 
                    end
                    maxchns = length(Meting(metnr).DAC.HWchn);
                    if isempty(rate)
                        rate = Meting(metnr).DAC.rate;
                    elseif rate~=Meting(metnr).DAC.rate
                        Error('you cannot export two different smaple rates in the same export'); return;
                    end
                else
                    if isempty(Meting(metnr).adc), Error('data has no adc'); return; end
                    maxchns = length(Meting(metnr).ADC.HWchn);
                    if isempty(rate)
                        rate = Meting(metnr).ADC.rate;
                    elseif rate~=Meting(metnr).ADC.rate
                        Error('you cannot export two different sample rates in the same export'); return;
                    end
                end
                if chns == 0, chns = 1:maxchns; end
                if ~isempty(setdiff(chns,1:maxchns)), Error('you try to export non-existing channels'); return; end
                for j3 = chns
                    if isempty(swps)
                        cnt = cnt + 1;
                        list.idx {cnt,1} = sprintf('%s %s(%u)',idx,cmd,j3);
                        list.mets(cnt,1) = metnr;
                        list.chns(cnt,1) = j3;
                        list.swps(cnt,1) = 0;
                        list.cmd{cnt,1}  = cmd;
                    else
                        for j4 = 1: swps
                            cnt = cnt + 1;
                            list.idx {cnt,1} = sprintf('%s %s(%u-%u)',idx,cmd,j3,j4);
                            list.mets(cnt,1) = metnr;
                            list.chns(cnt,1) = j3;
                            list.swps(cnt,1) = j4;
                            list.cmd{cnt,1}  = cmd;
                        end
                    end
                end
            end
        end
    end
end
ii = 1;
p1 = 1+round(times(1)*rate/1000);
p2 = skip+1;
p3 = round(times(2)*rate/1000);
data.traces = zeros(1+p3-p1,length(list.mets));
data.traces(:,ii) = (p1:p3)'*1000/rate;
data.name{ii,1} = 'time';
data.unit{ii,1} = 'sec';
data.idx{ii,1}  = 'source';
for jj = 1:length(list.cmd)
    ii = ii +1;
    kanaal = list.chns(jj);
    metnr  = list.mets(jj);
    data.idx{ii,1} = list.idx {jj};
    if strcmp(list.cmd{jj},'dac')
        Meting(metnr) = DACexpand(Meting(metnr));
        data.name{ii,1} = Meting(metnr).DAC.scale(kanaal).Name;
        data.unit{ii,1} = Meting(metnr).DAC.scale(kanaal).Units;
        scale           = Meting(metnr).DAC.scale(kanaal).User/ Meting(metnr).DAC.ints;
        data.traces(:,ii) = squeeze(double(Meting(metnr).dac(p1:p2:p3,kanaal)))*scale; 
    else
        data.name{ii,1} = Meting(metnr).ADC.scale(kanaal).Name;
        data.unit{ii,1} = Meting(metnr).ADC.scale(kanaal).Units;
        scale           = Meting(metnr).ADC.scale(kanaal).User/Meting(metnr).ADC.ints;
        switch list.cmd{jj}
            case 'adc'
                data.traces(:,ii) = squeeze(double(Meting(metnr).adc(p1:p2:p3,kanaal,1)))*scale;
            case 'swp'
                data.traces(:,ii) = squeeze(double(Meting(metnr).adc(p1:p2:p3,kanaal,list.swps(jj))))*scale;
            case 'avg'
                data.traces(:,ii) = Meting(metnr).EXTRA.MEAN.avg(p1:p2:p3,kanaal)*scale;
                ii = ii + 1;
                data.name{ii,1} = 'sem';
                data.unit{ii,1} = Meting(metnr).ADC.scale(kanaal).Units;
                data.idx{ii,1}  = list.idx {jj};
                data.traces(:,ii) = Meting(metnr).EXTRA.MEAN.sem(p1:p2:p3,kanaal)*scale;
        end
    end
end
[filepath,filename] = fileparts(panels.file.name);
data.filename = filename;
exportname  = fullfile(filepath,[filename sprintf('_export%03u.%s',panels.ExportCnt,datatype)]);
if strcmp(datatype,'mat')
    save(exportname,'data')
else
    n2 = size(data.traces,2);
    [fid,message] = fopen(exportname,'wt');
    if ~isempty(message), Error(sprintf('%s\n%s',message,exportname)); return; end
    txt = data.name{1,1}; for ii = 2:n2, txt = [txt sprintf('\t%s ',data.name{ii,1})]; end; fprintf(fid,'%s\n',txt);
    txt = data.unit{1,1}; for ii = 2:n2, txt = [txt sprintf('\t%s ',data.unit{ii,1})]; end; fprintf(fid,'%s\n',txt);
    txt = data.idx{1,1};  for ii = 2:n2, txt = [txt sprintf('\t%s ',data.idx{ii,1})];  end; fprintf(fid,'%s\n',txt);
    fmt = '%12.8f';       for ii = 2:n2, fmt = [fmt '\t%12.8f']; end; fmt = [fmt '\n'];
    fprintf(fid,fmt,data.traces'); 
    fclose(fid);
end
panels.ExportCnt = panels.ExportCnt + 1;
DoMusic(0);

function DoLeak(parms,CMD)
global Meting cmdlist panels dt
[parms,present,ps] = ParseSpecial(parms,'shift');   if present, shift   = rsingle(ps{1}); else,shift = 0; end
[parms,present,ps] = ParseSpecial(parms,'level');   if present, tlvl    = rsingle(ps{1}); else,tlvl  = []; end
[parms,present,ps] = ParseSpecial(parms,'tbefore'); if present, tvoor   = rsingle(ps{1}); else,tvoor = []; end
[parms,present,ps] = ParseSpecial(parms,'tafter');  if present, tna     = rsingle(ps{1}); else,tna   = []; end
[parms,present,ps] = ParseSpecial(parms,'range');   if present, drange  = rsingle(ps{1}); else,drange = []; end
[parms,present,ps] = ParseSpecial(parms,'adcs');    if present, adcchan = nsingle(ps{1}); else,adcchan = 1; end
[parms,present,ps] = ParseSpecial(parms,'dacs');    if present, dacchan = nsingle(ps{1}); else,dacchan = 1; end
[parms,doshow]     = ParseSpecial(parms,'show');
[parms,present,ps] = ParseSpecial(parms,'list');
if present
    list1=nsingle(ps{1});
    if length(ps)>1
        list2=nsingle(ps{2});
    else
        list2 = list1;
    end
else
    Error('Leak needs list');
    return
end
if (list1>length(cmdlist)) || ~ListValid(list1), Error('list 1 not valid'); return; end
if (list2>length(cmdlist)) || ~ListValid(list2), Error('list 2 not valid'); return; end
list1 = cmdlist{list1};
list2 = cmdlist{list2};
dt = 1000 / Meting(list1(1,4)).ADC.rate;
command = ssingle(parms{1});
dotrig = false;
switch  command
    case {'mean';'onemean';'individual'}
    case 'trig', dotrig = true;
                 if length(tlvl)<3, Error('Leak trig level needs 3 values'); return; end
                 if isempty(tvoor), Error('Leak trg needs tbefore');         return; end
                 if isempty(tna),   Error('Leak trg needs tna');             return; end
                 command = 'individual';
    otherwise, Error(sprintf('%s\nLeak needs mean / onemean or individual',command)); return;
end
tmp = [];
listlen = size(list1,1);
for ii=1:listlen
    if isempty(Meting(list1(ii,2)).adc), tmp = [tmp ii]; end
end
if ~isempty(tmp), list1(tmp,:)=[]; end
tmp = [];
listlen = size(list2,1);
for ii=1:listlen
    if isempty(Meting(list2(ii,2)).adc), tmp = [tmp ii]; end
end
if~isempty(tmp), list2(tmp,:)=[]; end
list3  = union(list1,list2,'rows');
listlen = size(list3,1);
mets = list3(:,4);
swps = list3(:,3);
tadc = zeros(listlen,1);
tdac = zeros(listlen,1);
for ii = 1:listlen
    metnr = mets(ii);
    tadc(ii) = 1000 / Meting(metnr).ADC.rate;
    tdac(ii) = 1000 / Meting(metnr).DAC.rate;
    if (tadc(ii)~=tdac(ii)), Error('Leak not implemented yet for different sampling rates'); return; end
    Meting(mets(ii)) = DACexpand(Meting(metnr));
    adclen          = size(Meting(metnr).adc,1);
    [daclen,dcol]   = size(Meting(metnr).dac);
    if daclen~=adclen
        if daclen>adclen
            Meting(metnr).dac = Meting(metnr).dac(1:adclen,1:dcol);
            set(CMD.label1,'String',sprintf('dac %u>adc %u',daclen,adclen));
        elseif adclen>daclen
            Meting(metnr).dac(daclen+1:adclen,1:dcol) = Meting(metnr).dac(daclen,1:dcol);
            set(CMD.label1,'String',sprintf('adc %u>dac %u',adclen,daclen));
        end
    end
end
if dotrig
    drange = [];
elseif length(drange)<2
    Error('Range in Leak needs at least 2 numbers'); return;
elseif length(drange)==2
    ph1 = drange;
    ph2 = 'bb';
    drange = drange(1):drange(2);
else
    hlp1 = drange(diff([0 drange])>1);
    hlp2 = drange(diff([drange inf])>1);
    ph1 = [hlp1 hlp2];
    ph2 = [repmat('b',1,length(hlp1)) repmat('r',1,length(hlp1))];
end
tadc   = tadc(1);
prange = 1+round(drange/tadc);
mets = list1(:,4);
swps = list1(:,3);
listlen = length(mets);
if strcmp(command,'onemean')
    for ii=1:listlen
        metnr = mets(ii);
        if Testadcrange(metnr,max(prange),max(adcchan),max(swps(ii))), return; end;
        sadc = Meting(metnr).ADC.scale(adcchan).User/Meting(metnr).ADC.ints;
        if size(Meting)<metnr
            Error(sprintf('Metingnr out of range %u < %u\n\n',size(Meting),metnr)); return;
        elseif isempty(Meting(metnr).dac)
            Error('no dac data'); return;
        else
            [row,col] = size(Meting(metnr).dac);
            if max(prange)>row,  Error(sprintf('Leak: dac time out of range %u < %u\n\n',row,max(prange)));    return; end
            if max(dacchan)>col, Error(sprintf('Leak: dac channel out of range %u < %u\n\n',col,max(dacchan))); return; end
        end
        sdac = Meting(metnr).DAC.scale(dacchan).User/Meting(metnr).DAC.ints;
        if ii ==1
            yadc = sadc*double(Meting(metnr).adc(prange,adcchan,swps(ii)));
            ydac = sdac*double(Meting(metnr).dac(prange,dacchan));
        else
            yadc = yadc + sadc*double(Meting(metnr).adc(prange,adcchan,swps(ii)));
            ydac = ydac + sdac*double(Meting(metnr).dac(prange,dacchan));
        end
    end
    yadc = yadc / listlen;
    ydac = ydac / listlen;
    E = [ones(size(ydac)) ydac];
    c = E\yadc;
    gleak =  c(2);
    Eleak = -c(1)/c(2); 
else
    gleak = zeros(listlen,1);
    Eleak = zeros(listlen,1);
    for ii = 1:listlen
        metnr = mets(ii);
        swpnr = swps(11);
        sadc = Meting(metnr).ADC.scale(adcchan).User/Meting(metnr).ADC.ints;
        sdac = Meting(metnr).DAC.scale(dacchan).User/Meting(metnr).DAC.ints;
        if dotrig
            ydac = sdac*double(Meting(metnr).dac(:,dacchan));
            if tlvl(2)<0
                val = sort(find( (ydac(1:(end-1))>=tlvl(1)) & (ydac(2:end)<tlvl(1)) ));
            elseif tlvl(2)>=0
                val = sort(find( (ydac(1:(end-1))<=tlvl(1)) & (ydac(2:end)>tlvl(1)) ));
            end
            np  = val(tlvl(3));
            t1  = np*tadc;
            ph1 = [t1-tvoor(end) t1-tvoor(1) t1 t1+tna(1) t1+tna(end)];
            ph2 = 'brmbr';
            prange = [np-round(tvoor/tadc) np+round(tna/tadc) ];
        end
        yadc = sadc*double(Meting(metnr).adc(prange,adcchan,swpnr));
        ydac = sdac*double(Meting(metnr).dac(prange,dacchan));
        E = [ones(size(ydac)) ydac];
        c = E\yadc;
        gleak(ii) =  c(2);
        Eleak(ii) = -c(1)/c(2);
        if strcmp(command,'individual')
            c2 = gleak(ii)*sdac/sadc;
            c1 = gleak(ii)*Eleak(ii)/sadc;
            Meting(metnr).conductance(ii) = gleak(ii);
            Meting(metnr).Eleak(ii)       = Eleak(ii);
            trace = round(double(Meting(metnr).adc(:,adcchan,swpnr))-c2*double(ShiftTrace(Meting(metnr).dac(:,dacchan),shift))+c1);
            nmin = intmin('int16'); trace(trace<nmin) = nmin;
            nmax = intmax('int16'); trace(trace>nmax) = nmax;
            Meting(metnr).adc(:,adcchan,swpnr) = int16(trace);
            if doshow
                panels.lines     = 1000*ph1;
                panels.linecolor = ph2;
                setplotter('cmdline',Meting,metnr,swpnr);
                NRNshow(Meting);
                panels.lines     = [];
                panels.linecolor = 'k';
            end
        end
    end
end
mets = list2(:,4);
swps = list2(:,3);
if ~strcmp(command,'individual')
    gleak = mean(gleak);
    Eleak = mean(Eleak);
    for ii = 1:length(mets)
        metnr = mets(ii);
        swpnr = swps(ii);
        sadc = Meting(metnr).ADC.scale(adcchan).User/Meting(metnr).ADC.ints;
        sdac = Meting(metnr).DAC.scale(dacchan).User/Meting(metnr).DAC.ints;
        c2 = gleak*sdac/sadc;
        c1 = gleak*Eleak/sadc;
        Meting(metnr).conductance = gleak;
        Meting(metnr).Eleak       = Eleak;
        trace = round(double(Meting(metnr).adc(:,adcchan,swpnr))-c2*double(ShiftTrace(Meting(metnr).dac(:,dacchan),shift))+c1);
        nmin = intmin('int16'); trace(trace<nmin) = nmin;
        nmax = intmax('int16'); trace(trace>nmax) = nmax;
        Meting(metnr).adc(:,adcchan,swpnr) = int16(trace);            
        if doshow
            panels.lines     = 1000*ph1;
            panels.linecolor = ph2;
            setplotter('cmdline',Meting,metnr,swpnr);
            NRNshow(Meting);
            panels.lines     = [];
            panels.linecolor = 'k';
            pause(0.001);
        else
            timeline.par((timeline.par(:,1)==4) & (timeline.par(:,3)==metnr) & (timeline.idx(:,3)==swpnr),4) = gbuf.window;
            timeline.par((timeline.par(:,1)==5) & (timeline.par(:,3)==metnr),4) = gbuf.window;
            rodestippen;
        end
        if panels.abort, return; end
    end
end

function DoResample(parms)
global Meting spikes panels
[parms,~,mets,swps] = ParseList(parms);
metnr = mets(1);
sweep = swps(1);
[parms,present,ps] = ParseSpecial(parms,'channel'); if present, chns = nsingle(ps{1}); end
[parms,present,ps] = ParseSpecial(parms,'exclude');
if present
    if isempty(ps)
        exclude= [0 0];
    else
        exclude = rsingle(ps{1});
    end
else
    exclude = [];
end
spikes.spktmax = [];
spikes.spkmax  = [];
spikes.spktmin = [];
spikes.spkmin  = [];
spikes.spktlvl = [];
spikes.spklvl  = [];
if length(chns)~=1, Error('Resample 1 channel at the time'); return; end
kanaal = chns;
maxlen = size(Meting(metnr).adc,1);
adcrate = Meting(metnr).ADC.rate;
bgn = 1;
stp = 1;
lst = maxlen;
[parms,tijd] = ParseTijd(parms,'resampletime',1000);
if isempty(tijd), Error('Give resampletime'); else
    sample = max(1,min(maxlen,round(tijd*adcrate)));
end
[parms,tijd] = ParseTijd(parms,'average',1000);
if isempty(tijd)
    avlen  = 1;
    doctxt = 'Resample single datapoints';
else
    avlen  = round(tijd*adcrate*0.5);
    doctxt = sprintf(sprintf('Resample and average over %6.3f seconds',tijd));
end
switch length(sample)
    case 1, stp = sample(1);
    case 2, bgn = sample(1);
            stp = 1;
            lst = sample(2);
    case 3, bgn = sample(1);
            stp = sample(2);
            lst = sample(3);
end
unit = Meting(metnr).ADC.scale(kanaal).Units;
sadc = Meting(metnr).ADC.scale(kanaal).User/Meting(metnr).ADC.ints;
points = (bgn:stp:lst)';
points = points(points>avlen);
points = points(points<(maxlen-avlen+1));
xas = (points-1)/adcrate;
if avlen==0
    yas = sadc*double(Meting(metnr).adc(points,kanaal,sweep));
else
    yas    = zeros(length(points),1);
    start  = points-avlen;
    einde  = points+avlen;
    for jj = 1:length(points)
        yas(jj,1) = sadc*mean(double(Meting(metnr).adc(start(jj):einde(jj),kanaal,sweep)));
    end
end
if ~isempty(exclude) && ~isempty(panels.lines)
    hhh = [];
    margin = round(exclude*adcrate);
    for jj=1:length(panels.lines)/2
        p1 = margin(1)+panels.lines(2*jj-1)*adcrate/1000;
        p2 = margin(2)+panels.lines(2*jj)*adcrate/1000;
        hhh = [hhh find((points>p1)&(points<p2))'];
    end
    points(hhh) = [];
    yas(hhh)  = [];
    xas(hhh)  = [];
end
spikes.spktmax = points;
spikes.spkmax  = yas;
spikes.adcchan = kanaal;
spikes.adcrate = adcrate;
spikes.abstime = Meting(metnr).abstime;
spikes.class   = ones(length(spikes.spktmax),1,'int16');
spikes.adcdrmp = [inf inf];
Redraw;

function DoMergeEEG
global Meting panels
if isempty(panels.file.name), startname = []; else,startname = fileparts(panels.file.name); end
[filename,filepath] = uigetfile('*.mat;','Select EEG files',startname,'MultiSelect','on');
filenames = filename;
numfiles  = length(filename);
filenames = sort(filenames);
times = [];
telze = 0;
for iii = 1:numfiles
    if numfiles>1, panels.file.name = fullfile(filepath,filenames{iii}); end
    showfilename(CMD,panels.file.name);
    Meting = [];
    try
        load(panels.file.name);
    catch
        Error(sprintf('can not open \n%s',panels.file.name)); return;
    end
    if isempty(Meting) || isempty(Meting(1).SEGMENT.name), continue; end
    telze =telze + 1;
    times(telze) = Meting(1).abstime;
    Serie(telze).Meting = Meting;
end
[~,index] = sort(times);
Serie(index) = Serie(1:end);
Meting = Serie(1).Meting;
for jj = 2:telze
    last = Meting.SEGMENT.eind(end);
    duur1 = Serie(jj).Meting.abstime - Serie(jj-1).Meting.SEGMENT.time(end);
    duur2 = Serie(jj-1).Meting.SEGMENT.eind(end);
    if abs(duur2-duur1)>1, disp(sprintf('timegap %6.1f', duur1-duur2)); end
    Meting.SEGMENT.start = [Meting.SEGMENT.start; last + Serie(jj).Meting.SEGMENT.start];
    Meting.SEGMENT.eind  = [Meting.SEGMENT.eind;  last + Serie(jj).Meting.SEGMENT.eind];
    Meting.SEGMENT.name  = [Meting.SEGMENT.name; Serie(jj).Meting.SEGMENT.name];
end
Meting.SEGMENT.time = Meting.SEGMENT.time(1) + Meting.SEGMENT.start/(24*60*60);
NRNtimeline;
filename = [filename{1}(1:end-8),'EEG.mat'];
[filename,filepath] = uiputfile('*.mat','Save macro as',filename);
filename = fullfile(filepath,filename);
if ~Donotoverwrite(filename)
    Meting = DACcompress(Meting);
    Meting = MeanIni(Meting);
    Meting.adc  = [];
    Meting.dac  = [];
    Meting.cdac = [];
    save(filename,'Meting','-v6');
end

function DoMerge(parms)
global Memoryset Meting panels
[parms,present,ps] = ParseSpecial(parms,'channel');
if present, chns = nsingle(ps{1}); else,chns = 0; end
if isempty(parms)
    if     ~isempty(Meting(1).SEGMENT.name), mode = 'Segments';
    elseif ~isempty(Memoryset), mode = 'Time';
    else
        Error('Nothing to Merge');
        return
    end
else
    mode = ssingle(parms{1});
end
if strcmp(mode,'Segments')
    if isempty(Meting(1).SEGMENT.name), return; end
    writedir = makenewdir(panels.file.name);
    if Error, return; end
    seglist = length(Meting(1).SEGMENT.name);
    newlen = 1 + round((max(Meting(1).SEGMENT.eind)-min(Meting(1).SEGMENT.start))*Meting(1).ADC.rate);
    segbgn = 1 + round(Meting(1).SEGMENT.start*Meting(1).ADC.rate);
    if isempty(chns) || (chns==0)
        select = 1:size(Meting(1).adc,2);
    else
        select = chns;
    end
    hlp = zeros(newlen,length(select),'int16');
    for ii = 1:seglist
        Waitbar(CMD,'show',ii/(seglist+1),sprintf('Merging segment %u of %u',ii,seglist));
        MemoryUpdate(panels.filenr,ii);
        seglen = size(Meting(1).adc,1);
        hlp(segbgn(ii):(segbgn(ii)+seglen-1),1:length(select)) = Meting(1).adc(:,select);
        Meting(1).adc = [];
    end
    Meting(1).adc = hlp;
    clear hlp
    if ~isempty(chns)
        Meting(1).ADC.HWchn = Meting(1).ADC.HWchn(select);
        Meting(1).ADC.scale   = Meting(1).ADC.scale(select);
    end
    Meting(1) = DACexpand(Meting(1));
    if ~isempty(Meting(1).dac)
        adclen  = size(Meting(1).adc,1);
        daclen  = size(Meting(1).dac,1);
        adcrate = Meting(1).ADC.rate;
        dacrate = Meting(1).DAC.rate;
        adctim  = adclen/adcrate;
        dactim  = daclen/dacrate;
        if adctim>dactim
            adclen = round(dactim*adcrate);
            Meting(1).adc = Meting(1).adc(1:adclen,:);
        elseif adctim<dactim
            daclen = round(adctim*dacrate);
            Meting(1).dac  = Meting(1).dac(1:daclen,:);
            Meting(1).cdac = [];
            Meting = DACcompress(Meting);
        else
        end
        Meting(1).dac = [];
    end
    Meting(1).SEGMENT.name  = [];
    Meting(1).SEGMENT.time  = [];
    Meting(1).SEGMENT.start = [];
    Meting(1).SEGMENT.eind  = [];
    Meting(1).SEGMENT.cmt  = [];
    [~,newname,extstr] = fileparts(panels.file.name);
    panels.file.name = fullfile(writedir,[newname extstr]);
    Waitbar(CMD,'show',1,'write file');
    save(panels.file.name,'Meting','-v6');
    panels.segnr = [];
    panels.zoom.tnul  = 0;
    Waitbar(CMD,'hide');
    setmaxpars(Meting(1),'full');  
    NRNtimeline;
    setplotter('cmdline',Meting,1,1);
    NRNshow(Meting);
elseif strcmp(mode,'Channels')
    if length(Memoryset{1}.Meting)~=length(Memoryset{2}.Meting)
        Error('Measurements in Memoryset(1) and datst(20 should be same length');
        return
    end
    for jj = 1:length(Memoryset{1}.Meting)
        Meting = Memoryset{1}.Meting;
        [pnts1,chan1,~] = size(Memoryset{1}.Meting(jj).adc);
        [pnts2,chan2,~] = size(Memoryset{2}.Meting(jj).adc);
        npnts = min(pnts1,pnts2);
        Meting(jj).adc = [];
        Meting(jj).adc = zeros(npnts,chan1+chan2,'int16');
        Meting(jj).adc(1:npnts,1:chan1,1)                 = Memoryset{1}.Meting(jj).adc(1:npnts,1:chan1,1);
        Meting(jj).adc(1:npnts,(chan1+1):(chan1+chan2),1) = Memoryset{2}.Meting(jj).adc(1:npnts,1:chan2,1);
        Meting(jj).ADC.scale(chan1+1:chan1+chan2)         = Memoryset{2}.Meting(jj).ADC.scale  (1:chan2);
        Meting(jj).ADC.HWchn(chan1+1:chan1+chan2)         = Memoryset{2}.Meting(jj).ADC.HWchn(1:chan2);
    end
    Memoryset = [];
    setplotter('cmdline',Meting,1,1);
    NRNshow(Meting);
elseif strcmp(mode,'Traces')
    if isempty(Memoryset), return; end
    datlen = inf;
    if length(parms)>1, datlen = rsingle(parms{2}); end
    for jj = 1:length(Memoryset)
        [pnts,chans,swps] = size(Memoryset{jj}.Meting(1).adc);
        if jj==1
            maxpnt  = pnts;
            maxchan = chans;
        else
            if swps>1, Error('Merge only for swps = 1'); return; end
            if chans~= maxchan, Error('#chans in all sets the same!'); return; end
            maxpnt = min(maxpnt,pnts);
        end
    end
    maxpnt = min(maxpnt,datlen*Meting(1).ADC.rate/1000);
    Meting(1).adc = [];
    Meting(1).adc = zeros(length(Memoryset)*maxpnt,maxchan,'int16');
    panels.lines     = [];
    panels.linecolor = [];
    for jj = 1:length(Memoryset)
        Meting(1).adc((jj-1)*maxpnt+(1:maxpnt),:,1) = Memoryset{jj}.Meting(1).adc(1:maxpnt,:,1);
        if jj>1
            panels.lines     = [panels.lines (jj-1)*maxpnt*1000/Meting(1).ADC.rate];
            panels.linecolor = [panels.linecolor 'r'];
        end
    end
    Memoryset = [];
    setplotter('cmdline',Meting,1,1);
    NRNshow(Meting);
elseif strcmp(mode,'Time')
    if isempty(Memoryset), return; end
    for ii = 1:length(Memoryset), tijd(ii) = Memoryset{ii}.Meting(1).abstime; end
    tijd = tijd - min(tijd);
    [~,dset] = sort(tijd);
    adcrate = Memoryset{dset(1)}.Meting(1).ADC.rate;
    adcchn  = length(Memoryset{dset(1)}.Meting(1).ADC.HWchn);
    dacrate = Memoryset{dset(1)}.Meting(1).DAC.rate;
    dacchn  = length(Memoryset{dset(1)}.Meting(1).DAC.HWchn);
    adclen  = [];
    daclen  = [];
    metadc  = false;
    metdac  = false;
    for ii=1:length(Memoryset)
        metlen = length(Memoryset{dset(ii)}.Meting);
        if metlen>1, Error(sprintf('\nNo Metings with more than 1 node (nr %u has %u)', ii, metlen)); return;  end
        if ~isempty(Memoryset{dset(ii)}.Meting(1).adc)
            metadc   = true;
            tijd(ii) = Memoryset{dset(ii)}.Meting(1).abstime - Memoryset{dset(1)}.Meting(1).abstime;
            [adclen(ii),chn,swp] = size(Memoryset{dset(ii)}.Meting(1).adc);
            if     swp~=1,      Error('Merge data can only have 1 sweep'); return; end
            if     chn~=adcchn, Error('Merge nodes must have same #adc chans'); return; end
            if adcrate~=Memoryset{dset(ii)}.Meting(1).ADC.rate, Error('ADC.rates do not match in merge'); return; end
        end
        Memoryset{dset(ii)}.Meting(1) = DACexpand(Memoryset{dset(ii)}.Meting(1));
        if ~isempty(Memoryset{dset(ii)}.Meting(1).dac)
            metdac   = true;
            tijd(ii) = Memoryset{dset(ii)}.Meting(1).abstime - Memoryset{dset(1)}.Meting(1).abstime;
            [daclen(ii),chn] = size(Memoryset{dset(ii)}.Meting(1).dac);
            if     chn~=dacchn, Error('Merge nodes must have same #dac chans'); return; end
            if dacrate~=Memoryset{dset(ii)}.Meting(1).DAC.rate, Error('DACrates do not match in merge'); return; end
        end
    end
    if (length(adclen)==length(daclen)), daclen = min(daclen,round(adclen*dacrate/adcrate)); end
    borders.bgn = [];
    borders.end = [];
    Meting = Memoryset{dset(1)}.Meting;
    index = 0;
    adcbegin = round(tijd*24*60*60*adcrate);
    if metadc
        adcbegin = 1+round(tijd*24*60*60*adcrate);
        adceind  = adcbegin + adclen - 1;
        Meting(1).adc = zeros(max(adceind),adcchn,'int16');
        for ii=1:length(adcbegin)
            Meting(1).adc(adcbegin(ii):adceind(ii),1:adcchn,1) = Memoryset{dset(ii)}.Meting(1).adc(1:adclen(ii),1:adcchn,1);
            if ii<length(adcbegin)
                n1 = double(adceind(ii));
                n2 = double(adcbegin(ii+1)-1);
                a1 = double(Memoryset{dset(ii)}.Meting(1).adc(end,1:adcchn,1));
                a2 = double(Memoryset{dset(ii+1)}.Meting(1).adc(1,1:adcchn,1));
                if n2>n1
                    for jj=1:length(a1)
                        yhlp = int16(round(interp1q([n1;n2],[a1(jj);a2(jj)],(n1:n2)')));
                        Meting(1).adc(n1:n2,jj) = yhlp';
                    end
                    borders.bgn(end+1) = 1000*n1/adcrate;
                    borders.end(end+1) = 1000*n2/adcrate;
                else
                    borders.bgn(end+1) = 1000*n2/adcrate;
                    borders.end(end+1) = 1000*n2/adcrate;
                end
            end
        end
    end
    if metdac
        dacbegin = 1+round(tijd*24*60*60*dacrate);
        daceind  = dacbegin + daclen - 1;
        Meting(1).dac = zeros(max(daceind),dacchn,'int16');
        for ii=1:length(dacbegin)
            Meting(1).dac(dacbegin(ii):daceind(ii),1:dacchn) = Memoryset{dset(ii)}.Meting(1).dac(1:daclen(ii),1:dacchn);
            if ii<length(dacbegin)
                n1 = double(daceind(ii));
                n2 = double(dacbegin(ii+1)-1);
                a1 = double(Memoryset{dset(ii)}.Meting(1).dac(end,1:dacchn));
                a2 = double(Memoryset{dset(ii+1)}.Meting(1).dac(1,1:dacchn));
                for jj=1:length(a1)
                    yhlp = int16(round(interp1q([n1;n2],[a1(jj);a2(jj)],(n1:n2)')));
                    Meting(1).dac(n1:n2,jj) = yhlp';
                end
            end
        end
        Meting(1).cdac=[];
        Meting(1)=DACcompress(Meting(1));
    end
    writedir = makenewdir(Memoryset{1}.Meting(1).filename);
    if Error, return; end
    [~,datafile1,fileext] = fileparts(Memoryset{dset(1)  }.Meting(1).filename);
    for ii = 1:length(datafile1)
        if datafile1(ii)~=datafile2(ii)
            panels.file.name = [writedir datafile1 '_' datafile2(ii:end) fileext];
            break
        end
    end
    setmaxpars(Meting(1),'full')
    Memoryset     = [];
    panels.filenr = 0;
    panels.segnr  = 0;
    Meting(1).EXTRA.borders = borders;
    save(panels.file.name,'Meting','-v6');
    NRNtimeline;
    setplotter('cmdline',Meting,1,1);
    NRNshow(Meting);
else
    Error(sprintf('Unknown Merge command   %s', mode));
end

function [adcset,device] = Hardwire(parms)
global DAQ axon
adcset = [];
device = [];
axon.SEA.min = [];
axon.SEA.max = [];
axon.SEA.sgn = [];
axon.SEA.el1 = [];
axon.SEA.el2 = [];
axon.CAM     = [];
hwset        = DAQ(1).ADC.HWchn;
for jj = 1:length(parms)
    [cmd,ps] = ParseCmd(parms{jj});
    cage = nsingle(ps{1});
    [ps,present,psh] = ParseSpecial(ps,'camera');
    if present
        axon.CAM{cage,1} = ssingle(psh{1});
    end
    [ps,present,psh] = ParseSpecial(ps,'color');
    if present
        hlp = ssingle(psh{1});
        kl0 = hlp(1 + mod(cage-1,length(hlp)));
    else
        kl0 = 'k';
    end
    [ps,present,psh] = ParseSpecial(ps,'name');
    if present
        name = ssingle(psh{1});
    else
        name = 'chn';
    end
    [ps,present,psh] = ParseSpecial(ps,'minmax');
    for idx = 1:length(psh)
        limits = rsingle(psh{idx});
        if (limits(1)<0) || (limits(2)<0), hlp = -1; else,hlp = 1; end
        axon.SEA.min(cage,idx)= abs(limits(1));
        axon.SEA.max(cage,idx)= abs(limits(2));
        axon.SEA.sgn(cage,idx)= hlp;
    end
    [ps,present,psh] = ParseSpecial(ps,'relais');
    if present
        axon.SEA.el1(cage,1:2) = nsingle(psh{1});
        axon.SEA.el2(cage,1:2) = nsingle(psh{2});
    end
    [ps,present,psh] = ParseSpecial(ps,'adcs');
    if ~present, Error('Hardwire needs adc channels'); return; end
    [psh,present,psa] = ParseSpecial(psh,'device');
    if present
        hlp = nsingle(psa{1});
        if isempty(device)
            device = hlp;
        elseif (hlp~=device)
            Error('EEG runs (as yet) only from a single device '); return;
        end
    end
    [psh,present,psa] = ParseSpecial(psh,'names');
    if present
        channames = stringset(ssingle(psa{1}));
    else
        channames = [];
    end
    adcs = nsingle(psh{1});
    if isempty(channames)
        channames = cell(length(adcs),1);
    elseif length(adcs)~=length(channames)
        Error(sprintf('#names(%u) ~= # channnels(%u)',length(channames),length(adcs))); return
    end
    adcset = [adcset adcs];
    for idx = 1:length(adcs)
        chn = adcs(idx);
        if ~isempty(name)
            if strcmp(name,'artefact')
                dename = name;
            elseif cage>0
            	dename = sprintf('%02u-%s%s-%u',chn,name,channames{idx},cage);
            else
            	dename = sprintf('%02u-%s%s',chn,name,channames{idx});
            end
            DAQ(device).ADC.scale(chn).Name = dename;
        end
        DAQ(device).ADC.scale(chn).Color    = kl0;
        DAQ(device).ADC.scale(chn).Group    = cage;
        DAQ(device).ADC.scale(chn).Subgroup = idx;
    end
end

function DoNames(parms,daq)
global DAQ Meting axon
kiesset = 1;
[parms,present,ps] = ParseSpecial(parms,'choose');
if present && ~isempty(ps), kiesset = nsingle(ps{1}); end
grpset = [];
for jj = 1:length(parms)    
    [cmd,ps] = ParseCmd(parms{jj});
    chnset = nsingle(ps{1});
    txt    = ssingle(ps{2});
    [ps,present,pss] = ParseSpecial(ps,'color'); if present, klr = ssingle(pss{1}); else,klr = ''; end
    grp = 0;
    [ps,present,pss] = ParseSpecial(ps,'cage');  if present, grp = nsingle(pss{1}); end
    [ps,present,pss] = ParseSpecial(ps,'group'); if present, grp = nsingle(pss{1}); end
    grpset = [grpset, grp];
    [ps,present,pss] = ParseSpecial(ps,'minmax');
    if present
        if (grp==0) || (length(unique(grpset)) < length(grpset))
            Error(sprintf('Names cmd (%s) needs valid group/cage nr: %u',txt,grp));
            return;
        end
        if kiesset>length(pss), Error(sprintf('%s needs %u minmax pairs',txt,kiesset)); return; end
        limits = rsingle(pss{kiesset});
        if length(limits)~=2, Error(sprintf('%s minmax needs 2 values: %s', txt,pss{kiesset})); return; end
        vmin = limits(1);
        vmax = limits(2);
        axon.SEA.min(grp)= abs(vmin);
        axon.SEA.max(grp)= abs(vmax);
        if (vmin<0) || (vmax<0), axon.SEA.sgn(grp) = -1; else,axon.SEA.sgn(grp) = 1; end
    end
    for idx = 1:length(chnset)
        chn = chnset(idx);
        if ~isempty(klr), kl0 = klr(1 + mod(idx-1,length(klr))); end
        switch cmd
            case {'ADC';'adc'}
                if isempty(daq)
                    for kk = 1:length(Meting)
                        if ~isempty(txt), Meting(kk).ADC.scale(chn).Name = sprintf('%02u-%s-%u',chn,txt,grp); end                        
                        if ~isempty(klr), Meting(kk).ADC.scale(chn).Color = kl0; end
                        if ~isempty(grp)
                            Meting(kk).ADC.scale(chn).Group    = grp;
                            Meting(kk).ADC.scale(chn).Subgroup = idx;
                        end
                    end
                else
                    if ~isempty(txt)
                        if grp>0
                            DAQ(daq).ADC.scale(chn).Name = sprintf('%02u-%s-%u',chn,txt,grp);
                        else
                            DAQ(daq).ADC.scale(chn).Name = sprintf('%02u-%s',chn,txt);
                        end
                    end
                    if ~isempty(klr)
                        DAQ(daq).ADC.scale(chn).Color = kl0;
                    end
                    if ~isempty(grp)
                        DAQ(daq).ADC.scale(chn).Group    = grp;
                        DAQ(daq).ADC.scale(chn).Subgroup = idx;
                    end
                end
            case {'DAC';'dac'}
                if isempty(daq)
                    for kk = 1:length(Meting)
                        if ~isempty(txt), Meting(kk).DAC.scale(chn).Name = sprintf('%02u-%s-%u',chn,txt,grp); end
                        if ~isempty(klr), Meting(kk).DAC.scale(chn).Color = kl0; end
                        if ~isempty(grp)
                            Meting(kk).DAC.scale(chn).Group    = grp;
                            Meting(kk).DAC.scale(chn).Subgroup = idx;
                        end
                    end
                else
                    if ~isempty(txt)
                        if grp>0
                            DAQ(daq).DAC.scale(chn).Name = sprintf('%02u-%s-%u',chn,txt,grp);
                        else
                            DAQ(daq).DAC.scale(chn).Name = sprintf('%02u-%s',chn,txt);
                        end
                    end
                    if ~isempty(klr), DAQ(daq).DAC.scale(chn).Color = kl0; end
                    if ~isempty(grp)
                        DAQ(daq).DAC.scale(chn).Group    = grp;
                        DAQ(daq).DAC.scale(chn).Subgroup = idx;
                    end
                end
            otherwise
                Error('unknown type in Name'); return;
        end
    end
end

function DoDraw(parms)
global Meting panels SEL cmdlist
CMD = getPANEL('CMDpanel');
[parms,winclear] = ParseClear(parms);            if ~isempty(winclear), WindowClear(winclear); end
[parms,dofollow] = ParseSpecial(parms,'follow'); if dofollow && ~isempty(SEL), KnobRed(SEL.follow); end
[parms,dovalid,psv] = ParseSpecial(parms,'valids');
if dovalid
    hlp = nsingle(psv{1});
    for jj = 1:length(hlp), set(CMD.valid(jj),'Value',hlp(jj)); end
end
[parms,dosave]     = ParseSpecial(parms,'save');
[parms,noshow]     = ParseSpecial(parms,'noshow');
[parms,present,ps] = ParseSpecial(parms,'list'); 
if present
    listnr = nsingle(ps{1});
    delist = cmdlist{listnr};
else
    delist = [];
end
[parms,present,ps] = ParseSpecial(parms,'window');
if present
    [ps,present,~,psfig] = ParseSpecial(ps,'figure'); 
    if present
        tmp = panels.plotter;
        panels.plotter = panels.plotter(1);
        if isempty(delist)
            mets = panels.plotter.metnr;
            swps = panels.plotter.subnr;
        else
            mets = delist(:,2);
            swps = delist(:,3);
        end
        for jj = 1:length(mets)
            panels.plotter.window = psfig;
            panels.plotter.struct = '';
            panels.plotter.mode   = ssingle(parms{1});
            panels.plotter.metnr  = mets(jj);
            panels.plotter.subnr  = swps(jj);
            NRNshow(Meting);
        end
        panels.plotter = tmp;
        set(gcf,'Name',get(CMD.datafile,'String'));
        figure(panels.root);
        return
    end
    window = nsingle(ps{1});
else
    window = 0; 
end
wins = [];
for jj = 1:4
    if jj<=length(window)
        set(CMD.window(jj),'String',sprintf('%u',window(jj)));
    end
    if jj<=length(parms)
        set(CMD.txt(jj),'String',ssingle(parms{jj}));
    end
    win = str2double(get(CMD.window(jj),'String'));
    if (win==0) || ~isempty(intersect(wins,win)), zichtbaar = 0; else,  zichtbaar = 1; end
    set(CMD.valid(jj),'Value',zichtbaar);
    wins = [wins win];
end
if dosave && ~isempty(panels.stack)
    panels.stacker(end) = [];
    cmdstackpush;
end
if noshow
    return
elseif isempty(delist)
    if isempty(panels.plotter)
        panels.plotter(1).metnr = 1;
        panels.plotter(1).subnr = 1;
    end
    setplotter('cmdline',Meting,panels.plotter(1).metnr,panels.plotter(1).subnr);
    if Error, return; end
    Redraw;
elseif ListValid(listnr)
    for jj = 1:size(delist,1)
        panels.plotter.metnr = delist(jj,2);
        panels.plotter.subnr = delist(jj,3);
        Redraw(1);
    end
end

function DoXY(parms)
global Meting panels
[parms,present,ps] = ParseSpecial(parms,'window');  if present, window = nsingle(ps{1}); end
[parms,present,ps] = ParseSpecial(parms,'channel'); if present, chns = nsingle(ps{1}); end
[parms,present,ps] = ParseSpecial(parms,'resolution'); if present, resolution = rsingle(ps{1}); else,resolution = 1; end
[parms,tijden]     = ParseTijd(parms,'range',1);   if isempty(tijden), tijden = [-inf,inf]; end
[parms,doshow]     = ParseSpecial(parms,'show');
[parms,sets,mets,swps] = ParseList(parms);
metnr = mets(1);
kanaal = chns;
if length(kanaal)<2, Error('You need to define X and Y in XY'); return; end
maxlen = size(Meting(metnr).adc,1);
xchan  = kanaal(1);
ychan  = kanaal(2);
if isinf(tijden)
    bgn = 1;
    lst = maxlen;
else
    range = (tijden-panels.zoom.tnul)*Meting(metnr).ADC.rate/1000;
    bgn = max(1,round(range(1)));
    lst = min(maxlen,round(range(2)));
end
xname = [];
yname = [];
xx = zeros(lst-bgn+1,length(swps));
yy = zeros(lst-bgn+1,length(swps));
getplothandle(window(1),true);
for iii = 1:length(swps)
    xx(:,iii) = squeeze(double(Meting(metnr).adc(bgn:lst,xchan,swps(iii)))) * Meting(metnr).ADC.scale(xchan).User/Meting(metnr).ADC.ints;
    yy(:,iii) = squeeze(double(Meting(metnr).adc(bgn:lst,ychan,swps(iii)))) * Meting(metnr).ADC.scale(ychan).User/Meting(metnr).ADC.ints;
    [xx(:,iii),kk] = sort(xx(:,iii));
    yy(:,iii) = yy(kk,iii);
    if doshow
        line('XData',xx(:,iii),'YData',yy(:,iii),'LineStyle','none','Color','k','Marker','o','Markersize',1);
        grid on
    end
    xname{iii} = sprintf('xtrace-%u',iii);
    yname{iii} = sprintf('ytrace-%u',iii);
end
xmin = min(min(xx));
lim1 = resolution * round(xmin/resolution);
xmax = max(max(xx));
lim2 = resolution * round(xmax/resolution);
xas = (lim1:resolution:lim2)';
dx = xmax-xmin;
xmin = xmin - 0.05 * dx;
xmax = xmax + 0.05 * dx;
ymin = min(min(yy));
ymax = max(max(yy));
dy = ymax-ymin;
ymin = ymin - 0.05 * dy;
ymax = ymax + 0.05 * dy;
axis([xmin xmax ymin ymax])
yar = zeros(length(xas),length(swps));
for iii = 1:length(swps)
    for ii=2:(length(xas)-1)
        hh = (xx(:,iii)>xas(ii-1))&(xx(:,iii)<=xas(ii+1));
        yar(ii,iii)=mean(yy(hh,iii));
    end
end
yar = yar(2:end-1,:);
xas = (xas(1:end-2)+xas(3:end))/2;
if doshow
    yname = [];
    yname{1}='new x-axis';
    if length(xas)>50,ms = 1; else,ms = 5; end
    for iii = 1:length(swps)
        line('XData',xas,'YData',yar(:,iii),'LineWidth',1,'LineStyle','-','Color','r','Marker','o','Markersize',ms);
        yname{iii+1} = sprintf('ytrace-%u',ii);
    end
    grid on
end
drawnow

function answer = DoMarkmissers(parms)
global panels Meting
answer = false;
[parms,~,~,~,nodes] = ParseList(parms);
[parms,testleave]   = ParseSpecial(parms,'leaveonpresent');
[parms,present,ps]  = ParseSpecial(parms,'times');   if present, tims = rsingle(ps{1});  else, Error('Give times'); return; end
[~,present,ps]      = ParseSpecial(parms,'channel'); if present, chan = nsingle(ps{1});  else, chan=1; end
criter = [];
cnt = 0;
for jj = unique(nodes)
    maxswps = size(Meting(jj).adc,3);
    pp  = 1+round(tims * Meting(jj).ADC.rate/1000);
    adc = double(Meting(jj).adc(pp(1):pp(3),chan,:));
    pp = 1+pp-pp(1);
    for ii = 1:maxswps
        cnt = cnt + 1;
        criter(cnt,1) = abs(mean(adc(pp(2):pp(3),1,ii) ) - mean(adc(pp(1):pp(2),1,ii) ));
    end
end
missers = criter<0.25*(max(criter)+min(criter));
if testleave && ~isempty(find(missers, 1)), answer = true; end
cnt = 0;
for jj = unique(nodes)
    maxswps = size(Meting(jj).adc,3);
    Meting(jj).EXTRA.MEAN.missers = missers(cnt+(1:maxswps));
    cnt = cnt + maxswps;
end
if answer
    [~,fnaam,~] = fileparts(panels.file.name);
    fprintf('%s  has %u missers\n',fnaam,sum(missers));
end

function DoMarkspikers(parms)
global Meting
doneg = false;
[parms,present,ps] = ParseSpecial(parms,'times');   if present, tims  = rsingle(ps{1}); else, Error('Give times'); return; end
[parms,present,ps] = ParseSpecial(parms,'nodes');   if present, nodes = nsingle(ps{1}); else, nodes=1:length(Meting); end
[parms,present,ps] = ParseSpecial(parms,'channel'); if present, chan  = nsingle(ps{1}); else, chan=1; end
[parms,present,ps] = ParseSpecial(parms,'level');   if present, [ps,doneg]=ParseSpecial(ps,'neg'); slvl=rsingle(ps{1}); else,slvl = 0; end
for jj = nodes
    pp  = 1+round(tims*Meting(jj).ADC.rate/1000);
    schaal = Meting(jj).ADC.scale(chan).User/Meting(jj).ADC.ints;
    level = int16(round(slvl/schaal));
    maxswps = size(Meting(jj).adc,3);
    Meting(jj).EXTRA.MEAN.spikers = false(maxswps,1);
    for ii = 1:maxswps
        if doneg
            Meting(jj).EXTRA.MEAN.spikers(ii,1) = ~isempty(find(Meting(jj).adc(pp(1):pp(2),chan,ii)<level,1));
        else
            Meting(jj).EXTRA.MEAN.spikers(ii,1) = ~isempty(find(Meting(jj).adc(pp(1):pp(2),chan,ii)>level,1));
        end
    end
end

function DoLeakSub(parms)
global Meting cmdlist
if isempty(cmdlist), Error('no data selected'); return; end
[parms,nr] = ParseOne(parms,'list',1);
todolist   = cmdlist{nr};
[parms,art]   = ParseTwo(parms,'art',[0,0]);
[parms,zero]  = ParseTwo(parms,'zero',[0,0]);
[parms,adcnr] = ParseOne(parms,'adcs',1);
[parms,dacnr] = ParseOne(parms,'dacs',1);
[parms,mettransient,ps] = ParseSpecial(parms,'transient');
if mettransient
    [ps,smooth] = ParseOne(ps,'smooth',0);
    [ps,skip]   = ParseOne(ps,'skip',0);
    [ps,nuls]   = ParseOne(ps,'null',0);
    [ps,regs]   = ParseTwo(ps,'region');
    [parms,domean]   = ParseSpecial(parms,'mean');
    [ps,present,psh] = ParseSpecial(ps,'steps');
    steps = rsingle(psh{1});
end
[parms,metimp,ps] = ParseSpecial(parms,'imp');
if metimp, imps = rsingle(ps{1}); end
mets = todolist(:,4);
for jj = 1:length(mets)
    metnr = mets(jj);
    Meting(metnr) = DACexpand(Meting(metnr));
    scalevolt = Meting(metnr).DAC.scale(dacnr).User/Meting(metnr).DAC.ints;
    volt      = double(Meting(metnr).dac(:,dacnr));
    if jj==1
        scalecurr = Meting(metnr).ADC.scale(dacnr).User/Meting(metnr).ADC.ints;
        curravg   = double(Meting(metnr).adc(:,adcnr));  % *scalecurr;
    else
        curravg = curravg + double(Meting(metnr).adc(:,adcnr));  % *scalecurr;
    end
    if mettransient
        pp = round(steps * Meting(metnr).DAC.rate/1000);
        for ii = 1:length(steps)
            Vstep(jj,ii) = (volt(pp(ii)+5)-volt(pp(ii)-5)) * scalevolt;
        end
    end
end
curravg = curravg/length(mets);
if mettransient
    Vref = Vstep(1,1);
    Vstd = round(std(Vstep));
    pp  = round(regs*Meting(metnr).ADC.rate/1000)+[2,0];
    transient = curravg(pp(1):pp(2));
    if nuls>0
        nul = round(nuls*Meting(metnr).ADC.rate/1000);
        transient = transient - mean(transient(nul:end));
    end
    if smooth>0
        transient = conv(transient,ones(smooth,1)/smooth,'same');
    end
    if skip>0
        transient(1:skip) = 0;
    end
    tlen = length(transient);
end
if metimp
    ii = round(imps * Meting(metnr).DAC.rate/1000);
    dV = mean(volt(ii(3):ii(4))) - mean(volt(ii(1):ii(2)));
    ii = round(imps * Meting(metnr).ADC.rate/1000);
    dI = mean(curravg(ii(3):ii(4))) - mean(curravg(ii(1):ii(2)));
    gm = (dI*scalecurr)/(dV*scalevolt);
end
for jj = 1:length(mets)
    metnr = mets(jj);
    current = double(Meting(metnr).adc(:,adcnr));
    volt = double(Meting(metnr).dac(:,dacnr));
    volt = [volt(1); volt(1:end-1)];
    if mettransient
        for ii = 1:length(steps)
            p0 = 1+round(steps(ii)*Meting(metnr).DAC.rate/1000);
            if Vstep(jj,ii)<-10, tune = 1.5; else, tune = 1; end
            current(p0+[1:tlen]) = current(p0+[1:tlen]) - transient*tune*Vstep(jj,ii)/Vref;
            if art(2)>0, current(p0+[1:art(2)]) = mean(current(p0+art(1):p0)); end
        end
    end
    if metimp
		current = current - volt * dI/dV;
    end
    if ~isempty(zero)
%     current = current - mean(current(kk(1):kk(2)));
    end
    Meting(metnr).adc(:,adcnr) = int16(round(current));
end

function DoLeakFraai(parms)
global Meting cmdlist panels
[parms,zero]   = ParseTwo(parms,'zero');
[parms,off]    = ParseTwo(parms,'offset');
[parms,adcnr]  = ParseOne(parms,'adcs',1);  adcnr = Meting(1).EXTRA.(panels.amplifier).pars.adc(adcnr);
% [parms,dacnr]  = ParseOne(parms,'dacs',1);  dacnr = Meting(1).EXTRA.(panels.amplifier).pars.dac(dacnr);
[parms,smooth] = ParseOne(parms,'smooth',0);
[parms,nr]     = ParseOne(parms,'list',1);
todolist = cmdlist{nr};
for jj = 1:size(todolist,1)
    metnr = todolist(jj,4);
    if jj==1
        adc   = zeros(size(Meting(metnr).adc,1),size(todolist,1));
        dt    = Meting(metnr).ADC.rate/1000;
        scale = Meting(metnr).ADC.scale(adcnr).User/double(Meting(metnr).ADC.ints);
        if ~isempty(zero), pp = round(zero*dt); end
    end
    adc(:,jj) = double(Meting(metnr).adc(:,adcnr))*scale;
    if ~isempty(zero), adc(:,jj) = adc(:,jj) - mean(adc(pp(1):pp(2),jj)); end
end
[parms,present,ps] = ParseSpecial(parms,'submean');
if present
    curravg = mean(adc,2);
    for jj = 1:size(todolist,1)
        for ii = 1:length(ps)
            pp = round(rsingle(ps{ii}) * dt)+[1,0];
            adc(pp(1):pp(2),jj) = adc(pp(1):pp(2),jj) - curravg(pp(1):pp(2));
        end
    end
    pp = round(rsingle(ps{1}) * dt)+[1,0];
    p0 = round((pp(1)+pp(2))/2);
    offset = mean(curravg(p0:pp(2)));
end
[parms,present,ps] = ParseSpecial(parms,'result');
[name,sub] = strtok(ssingle(ps{1}),'@');
sub  = sub(2:end);
nres = find(strcmp({Meting.serienaam},name));
if isempty(nres), Error(sprintf('Did not find result node: %s',name)); return; end
Amp0 = Meting(nres).result.(sub).fexp.Amp0;
Amp1 = Meting(nres).result.(sub).fexp.Amp1;
tbgn = Meting(nres).result.(sub).tbgn;
yeva = Meting(nres).result.(sub).scratch.yeva;
[parms,present,ps] = ParseSpecial(parms,'subtrans');
if present
    f0 = rsingle(ps{1});
    f1 = rsingle(ps{2});
    if ~isempty(off), pof = round(off*dt); end
    for jj = 1:size(todolist,1)
        p1 = round(f0*dt);
        plen = round(tbgn(jj)*dt)-p1;
        p2 = round(f1*dt);
        if isnan(Amp0(jj))
            p3 = round((p1+p2)/2);
            Amp0(jj) = mean(adc(p3:p2,jj));
            Amp1(jj) = 0;
            yeva(:,jj) = Amp0(jj);
        end
        adc(p2+[0:plen],jj) = adc(p2+[0:plen],jj) - yeva(1:plen+1,jj) + adc(p1+[0:plen],jj);
        if ~isempty(off), adc(pof(1):pof(2),jj) = adc(pof(1):pof(2),jj) - offset; end
        adc(p1+[0:plen],jj) = yeva(1:plen+1,jj);
        adc(p1:p2,jj) = adc(p1:p2,jj)-Amp0(jj)-Amp1(jj);
    end
end
for jj = 1:size(todolist,1)
    metnr = todolist(jj,4);
    if smooth>0
        len = round(smooth*dt);
        adc(:,jj) = conv(adc(:,jj),ones(len,1)/len,'same');
    end
    Meting(metnr).adc(:,adcnr) = int16(round(adc(:,jj)/scale));
end

function DoLeakTrans(parms)
global Memoryset Meting cmdlist panels
[parms,present,ps] = ParseSpecial(parms,'tnul');
tnul = rsingle(ps{1});
tlen = rsingle(ps{2});
[parms,nr] = ParseOne(parms,'list',1);
todolist = cmdlist{nr};
[parms,present,ps] = ParseSpecial(parms,'node');
[name,sub] = strtok(ssingle(ps{1}),'@');
sub = sub(2:end);
nres = find(strcmp({Meting.serienaam},name));
V0  = mean(Meting(nres).result.(sub).V0);
Vm  = mean(Meting(nres).result.(sub).Vm);
Inul= mean(Meting(nres).result.(sub).Inul);
Ih0 = mean(Meting(nres).result.(sub).fexp.Amp0);
Ih1 = mean(Meting(nres).result.(sub).fexp.Amp1);
tau = mean(Meting(nres).result.(sub).fexp.tau1);
gm  = (Ih0-Inul+Ih1)/(Vm-V0);
adcs = Meting(1).EXTRA.(panels.amplifier).pars.adc(1);
dacs = Meting(1).EXTRA.(panels.amplifier).pars.dac(1);
Meting = DACexpand(Meting);
for jj = 1:size(todolist,1)
    metnr = todolist(jj,2);
    vscale  = Meting(metnr).DAC.scale(dacs).User/double(Meting(metnr).DAC.ints);
    voltage = double(Meting(metnr).dac(:,dacs)) * vscale;
    tmp = diff(voltage);
    step{jj} = find(tmp);
    amps{jj} = tmp(step{jj});
    cscale  = Meting(metnr).ADC.scale(adcs).User/double(Meting(metnr).ADC.ints);
    current = double(Meting(metnr).adc(:,adcs)) * cscale;
    current = current - voltage*gm;
    current = current - mean(current(1:1000));
    Meting(metnr).adc(:,adcs) = int16(round(current/cscale));
    if jj==1, avg = current; else,avg = avg + current; end
end
avg = avg/size(todolist,1);
dt  = 1000/Meting(todolist(1,2)).ADC.rate;
tnul = round(tnul/dt);
tlen = round(tlen/dt); 
ys  = Ih1*(exp((0:max(tlen))*dt/(-tau))-1);
transient = avg(tnul:tnul+max(tlen))-ys';
for jj = 1:size(todolist,1)
    metnr = todolist(jj,2);
    cscale  = Meting(metnr).ADC.scale(adcs).User/double(Meting(metnr).ADC.ints);
    current = double(Meting(metnr).adc(:,adcs)) * cscale;
    stp = step{jj};
    amp = amps{jj};
    for ii = 1:length(stp)
        current(stp(ii):stp(ii)+tlen(ii)) = current(stp(ii):stp(ii)+tlen(ii))-transient(1:tlen(ii)+1)*amp(ii)/amp(1);
        current(stp(ii):stp(ii)+5) = current(stp(ii)-1);
    end
    Meting(metnr).adc(:,adcs) = int16(round(current/cscale));
    if jj==1, avg = current; else, avg = avg + current; end
end
Meting = DACcompress(Meting);

function [SWPS,node] = SWPSini(fparms,xtrace,mets,swps,field)
SWPS = struct('missers',false,'spikers',false,'nospike',false,'p',[],'o',[],'std',3,'k',[],'ref',1,'nul',[],'metnr',mets,'swpnr',swps,'fld',field);
node = [];
[fparms,SWPS.missers] = ParseSpecial(fparms,'missers');
[fparms,SWPS.spikers] = ParseSpecial(fparms,'spikers');
[fparms,SWPS.nospike] = ParseSpecial(fparms,'nospike');
[fparms,~,ps] = ParseSpecial(fparms,'ext'); if isempty(ps), Error('sweeps needs ext(range(....))'); return; end
[~,zz] = ParseTwo(ps,'range');
p1 = find(xtrace>=zz(1),1,'first');
p2 = find(xtrace>=zz(2),1,'first');
if isempty(p1) || isempty(p2), Error(sprintf('sweeps time o.o.r\n%0.1f - %0.1f',zz)); return; end
SWPS.p = [p1,p2];
[fparms,present,ps] = ParseSpecial(fparms,'out');
if present
    [~,zz] = ParseTwo(ps,'range');
    p1 = find(xtrace>=zz(1),1,'first');
    p2 = find(xtrace>=zz(2),1,'first');
    if isempty(p1) || isempty(p2), Error(sprintf('out time o.o.r\n%0.1f - %0.1f',zz)); return; end
    SWPS.o = [p1,p2];
    [~,SWPS.std] = ParseOne(ps,'std',3);
end
[~,present,ps] = ParseSpecial(fparms,'kkw');
if present
    [ps,zz] = ParseTwo(ps,'range');
    p1 = find(xtrace>=zz(1),1,'first');
    p2 = find(xtrace>=zz(2),1,'first');
    if isempty(p1) || isempty(p2), Error(sprintf('kkw time o.o.r\n%0.1f - %0.1f',zz)); return; end
    SWPS.k = [p1,p2];
    [ps,SWPS.ref] = ParseOne(ps,'ref',1);
    [~,zz] = ParseTwo(ps,'zero');
    if ~isempty(zz)
        p1 = find(xtrace>=zz(1),1,'first');
        p2 = find(xtrace>=zz(2),1,'first');
        SWPS.nul = [p1,p2];
    end
end
node = struct('SWPs',    zeros(SWPS.p(2)-SWPS.p(1)+1,length(mets),1),...
              'SWPm',    [],...
              'missers', [],...
              'spikers', [],...
              'nospike', [],...
              'outlier', [],...
              'error',   [],...
              'kkwamp',  [],...
              'kkwer1',  [],...
              'kkwref',  [],...
              'kkwer2',  [],...
              'xas',     [xtrace(2)-xtrace(1),xtrace(SWPS.p(1))],...
              'yscale',  [-inf,inf],...
              'extrange',SWPS.p,...
              'outrange',SWPS.o,...
              'kkwrange',SWPS.k);

function ClearFormula(CMD)
global Formula
Formula = struct('handle',[],'on',true,'noshow',KnobIsRed(CMD.noshow),...
                 'xas',[],'yas',[],'unit','','nam',[],'col',[],'win',[],'dsp',[],'spc',[],'wait',[]);

function DoFormula(inparms)
global Memoryset Meting panels cmdlist Formula p
Error("header","Error in Formula");
CMD = getPANEL('CMDpanel');
MEA = [];
[inparms,doskip,skippar] = ParseSpecial(inparms,'skipto');
if doskip
%     KnobRed(CMD.noshow);
    [skippar,present,ps] = ParseSpecial(skippar,'tel'); if present, telnummer = nsingle(ps{1}); else, telnummer = 1; end
    [skippar,present,ps] = ParseSpecial(skippar,'swp'); if present, swpnummer = nsingle(ps{1}); else, swpnummer = 1; end
    [skippar,present,ps] = ParseSpecial(skippar,'met'); if present, metnummer = nsingle(ps{1}); else, metnummer = 1; end
    [skippar,present,ps] = ParseSpecial(skippar,'form'); if present, frmnummer = nsingle(ps{1}); else, frmnummer = 1; end
end
[inparms,doimp,pimps] = ParseSpecial(inparms,'runimp');
ClearFormula(CMD);
lastwin  = [];
newwin   = true;
[inparms,present,parms] = ParseSpecial(inparms,'run');
if ~present, Error('formula needs one run() cmd'); return; end
[parms,winclear] = ParseSpecial(parms,'clear'); if winclear, WindowClear; end
[parms,usepars]  = ParseSpecial(parms,'usepars');
if usepars, doPars([],"get"); end
[parms,grafwait] = ParseOne(parms,'wait',0);
for jj = 1:length(inparms)
    [cmd,ps] = ParseCmd(inparms{jj});
    if Error, return; end
    if strcmpi(cmd,'plot')
        lastspc = [];
        if length(ps)>1, lastwin = nsingle(ps{1}); indx = 2; else, lastwin = 9; indx = 1;  end
        lastplt = [strtrim(strrep(Unquote(ps{indx}),char(34),char(39))), '/skip(1)'];
        newwin = true;
    elseif strcmpi(cmd,'cmd')
        if length(ps)<2,     Error('formula error:\n cmd needs at least resultname and cmd!'); return; end
        if isempty(lastwin), Error('formula error:\n cmd needs valid plot to work on'); return; end
        [ps,waittime] = ParseOne(ps,'wait',0);
        index = length(Formula.nam)+1;
        field = Unquote(ssingle(ps{1}));
        Formula.nam{index,1}  = field;
        Formula.col{index,1}  = strtrim(strrep(Unquote(ps{2}),char(34),char(39)));
        Formula.wait{index,1} = waittime;
        if length(ps)>2, F.(field) = rsingle(ps{3}); end
        if newwin
            Formula.win{index,1} = lastwin;
            Formula.dsp{index,1} = lastplt;
            Formula.spc{index,1} = lastspc;
            newwin = false;
        else
            Formula.win{index,1} = [];
            Formula.dsp{index,1} = [];
            Formula.spc{index,1} = [];
        end
    else
        Error(sprintf('valid formula commands: run, plot, cmd, you gave: %s',cmd)); return
    end
end
loopset = 1;
[parms,present,psl] = ParseSpecial(parms,'defloop');
if present
    for jj = 1:length(psl)
        tmp = rsingle(psl{jj});
        if jj==1
            loopset = zeros(length(tmp),length(psl));
            loopset(:,1) = tmp;
        else
            if size(loopset,1)~=length(tmp)
                Error(sprintf('loop series must be equal (%u), not %u',size(loopset,1),length(tmp)));
                return
            else
                loopset(:,jj) = tmp;
            end
        end
    end
end
panels.NRNabort = false; 
panels.NRNbusy  = false;
Org   = [];
Org.p = p;
Org.timegain = panels.timegain;
Org.plotter = panels.plotter;
Org.skiptxt = CMD.skip.String;
Org.skipnr  = CMD.skipnr.String;
Timescale(CMD,'ms');
SkipOff(CMD,1);
[parms,nr] = ParseOne(parms,'list',1);
todolist = cmdlist{nr};
if isempty(todolist), Message('No data selected, define list?'); return; end
doswp = false;
multikanalen = [];
multitype    = "";
for ii = 1:length(Formula.dsp)
    if ~isempty(Formula.dsp{ii})
        p.loop = 0;
        plt = ontleed(Formula.dsp{ii},Meting(todolist(1,2)));
        if Error, return; end
        if strcmp(plt.mode,"swp"), doswp = true; end
        if plt.mea~=""
            if (multitype~="") && (multitype~=plt.mea)
                Error("you have to use the same meachannelset in all channels of Formula"); return
            end
            MEA = getPANEL('MEApanel');
            multitype = plt.mea;
            switch plt.mea
                case "mear", multikanalen = plt.chns;
                case "meab", multikanalen = -plt.chns;
                otherwise,   Error("dit mag niet"); return
            end
        elseif length(plt.chns)>1
            if (multitype~="") && (multitype~=string(plt.mode))
                 Error("you have to use the same mode in all channels of Formula"); return
            end
            multitype    = string(plt.mode);
            multikanalen = plt.chns;
        end
    end
end
doavg = ~doswp;
if doavg, todolist = todolist(todolist(:,3)==1,:); end
[parms,nres,structname] = INIresultbasis(CMD,parms,size(todolist,1),size(loopset,1));
if Error, return; end
Meting(nres).result.(structname).basis.disps    = Formula.dsp;
Meting(nres).result.(structname).basis.formulas = Formula.col;
MCCamps  = [];
for todonr = 1:size(todolist,1)
    nodenr = todolist(todonr,4);
    swplen = size(Meting(nodenr).adc,1)-1 * 1000/Meting(nodenr).ADC.rate;
    if doavg && (length(Meting(nodenr).reltime)>1)
        time = mean(Meting(nodenr).reltime);
    else
        time = Meting(nodenr).reltime(todolist(todonr,3));
    end
    for jj = 1:size(loopset,1)
        index = (todonr-1)*size(loopset,1)+jj;
        Meting(nres).result.(structname).basis.metswp(index,1:6) = [todolist(todonr,1), todolist(todonr,2), todolist(todonr,3), jj, todolist(todonr,4), swplen];
        Meting(nres).result.(structname).basis.times (index,1) = time; 
        Meting(nres).result.(structname).basis.Times (index,1) = Meting(nodenr).abstime + (time/(24*60*60));
    end
    if isfield(Meting(nodenr).EXTRA,'output') && ~isempty(Meting(nodenr).EXTRA.output) &&sum(strcmp({Meting(nodenr).EXTRA.output.model},'Diego'))>0
        MCCamps(:,nodenr) = Meting(nodenr).EXTRA.MCC.val;
    end
end
Org.Form = Formula;
if doimp
    DoRunIMP(pimps,nres,structname); if Error, return; end
    Formula = Org.Form;
end
parms = DoRunFRM(parms,nres,structname); if Error, return; end
Formula = Org.Form;
for ktel = 1:max(1,length(multikanalen))
    if isempty(multikanalen)
        saveindex = 1;
    else
        if winclear, WindowClear; end
        if ~isempty(MEA)
            MEA.green.Visible  = 'On';
            MEA.green.UserData = abs(multikanalen(ktel));
            MEA.vals0.String   = sprintf('%u',abs(multikanalen(ktel)));
            MEAelektrodes(MEA);
        end
        saveindex = find(abs(Meting(nres).result.(structname).basis.kanaal)==abs(multikanalen(ktel)), 1);
        if isempty(saveindex), saveindex = 1+length(Meting(nres).result.(structname).basis.kanaal); end
        Meting(nres).result.(structname).basis.kanaal(saveindex) = multikanalen(ktel);
        Meting(nres).result.(structname).basis.valid (saveindex) = true;
    end
	if usepars
        if (multitype==""), doPars([],"get"); else, doPars(sprintf("%u",abs(multikanalen(ktel))),"get"); end
	end
    SWPS = [];
    for todonr = 1:size(todolist,1)
        nodenr = todolist(todonr,4);
        swpnr  = todolist(todonr,3);
        F = struct('dt',1000/Meting(nodenr).ADC.rate,...
                   'eot',Meting(nres).result.(structname).basis.metswp(todonr,6),...
                   'temp',NaN,      'Cm',[NaN,NaN],...
                   'gm',[NaN,NaN],  'Rm',[NaN,NaN],  'Vr',[NaN,NaN],...
                   'time',Meting(nres).result.(structname).basis.times(todonr),...
                   'Time',Meting(nres).result.(structname).basis.Times(todonr));
        Meting(nres).result.(structname).basis.temp(todonr,1) = F.temp;
        if ~isempty(Meting(nodenr).EXTRA.(panels.amplifier).pars)
            F.Cm = Meting(nodenr).EXTRA.(panels.amplifier).pars.Cm; end
        if ~isempty(Meting(nodenr).EXTRA.(panels.amplifier).imps)
            F.gm = Meting(nodenr).EXTRA.(panels.amplifier).imps.gm;
            F.Rm = 1/F.gm;
            F.Vr = Meting(nodenr).EXTRA.(panels.amplifier).imps.Vr;
            Meting(nres).result.(structname).basis.Cm(todonr,1) = F.Cm;
            Meting(nres).result.(structname).basis.gm(todonr,1) = F.gm;
        end
        for loopnr = 1:size(loopset,1)
            loopidx = (todonr-1)*size(loopset,1)+loopnr;
            p.loop = loopset(loopnr,:);
            F.loop = p.loop;
            for formnr = 1:length(Formula.dsp)
                Formula.noshow = KnobIsRed(CMD.noshow);
                myformula = Formula.col{formnr};
                myfield   = Formula.nam{formnr};
                mydisplay = Formula.dsp{formnr};
                Error("line",myformula);
                if doskip && (ktel== telnummer) && (nodenr== metnummer) && (swpnr==swpnummer) && (formnr==frmnummer)
                    Waitbar(CMD,"hide");
                    KnobGrey(CMD.noshow);
                    ddd = 0;
                end
                if ~isempty(mydisplay)
                    thlp = split(string(mydisplay),"/");
                    die  = find(contains(thlp,multitype));
                    if ~isempty(die)
                        switch multitype
                            case {"mear","meab"}
                                mydisplay = strrep(mydisplay,multitype,sprintf('%s(%u)',multitype,ktel));
                            case {"adc","swp","avg"}
                                [cmd,pp]  = ParseCmd(thlp(die));
                                thlp(die) = string([sprintf('%s(%u,',cmd,multikanalen(ktel)),pp{2},')']);
                                mydisplay = join(thlp,"/");
                        end
                    end 
                    plt = ontleed(mydisplay,Meting(nodenr));
                    if Error, return; end
                    if Formula.noshow && ~strcmp(plt.mode,'xy')
                        if strcmp(plt.mode,'dac')
                            Meting(nodenr) = DACexpand(Meting(nodenr));
                            rate  = Meting(nodenr).DAC.rate;
                            scale = Meting(nodenr).DAC.scale(plt.chns(1)).User/Meting(nodenr).DAC.ints;
                            Formula.yas = double(Meting(nodenr).dac(:,plt.chns(1)))*scale;
                        else
                            rate  = Meting(nodenr).ADC.rate;
                            scale = Meting(nodenr).ADC.scale(plt.chns(1)).User/Meting(nodenr).ADC.ints;
                            if strcmp(plt.mode,'avg')
                                Formula.yas = mean(double(Meting(nodenr).adc(:,plt.chns(1),:)),3)*scale;
                            else
                                Formula.yas = double(Meting(nodenr).adc(:,plt.chns(1),swpnr))*scale;
                            end
                            Waitbar(CMD,'show',1,sprintf('kanaal: %02d, nodenr: %02u, swpnr: %02u, form: %u',plt.chns(1),nodenr,swpnr,formnr));
                        end
                        dt = 1000/rate;
                        if isinf(plt.scale.x(1)), pp1 = 1;                   else, pp1 = 1+round(plt.scale.x(1)/dt); end
                        if isinf(plt.scale.x(2)), pp2 = length(Formula.yas); else, pp2 = 1+round(plt.scale.x(2)/dt); end
                        Formula.xas = (0:(length(Formula.yas)-1))'*dt;
                        Formula.yas = FilterTrace(Formula.yas,plt.filter,rate,Formula.xas,1);
                        Formula.xas = Formula.xas(pp1:pp2);
                        Formula.yas = Formula.yas(pp1:pp2);
                    else
                        panels.plotter = [];
                        panels.plotter.window = Formula.win{formnr}(1);
                        panels.plotter.struct = '';
                        panels.plotter.mode   = mydisplay;
                        panels.plotter.metnr  = nodenr;
                        if ~isempty(Formula.spc{formnr,1}), panels.plotter.metnr = Formula.spc{formnr,1}; end
                        panels.plotter.subnr  = swpnr;
                        if length(Formula.win{formnr})>1
                            panels.plotter(2) = panels.plotter(1);
                            panels.plotter(2).window = Formula.win{formnr}(2);
                        end
                        setmaxpars(Meting(nodenr),panels.plotter(1).mode)
                        NRNshow(Meting);
                    end
                end
                if panels.abort||Error, return; end
                if Formula.noshow
                    xtrace = Formula.xas;
                    ytrace = Formula.yas;
                else
                    xtrace = get(Formula.handle,'XData')';
                    ytrace = get(Formula.handle,'YData')';
                end
                if contains(myformula,'units')
                    [~,hlp] = ParseCmd(myformula);
                    yscale  = Meting(nodenr).ADC.scale(plt.chns(1)).User/Meting(nodenr).ADC.ints;
                    result  = doUnits(hlp,xtrace(2)-xtrace(1),xtrace,ytrace,~Formula.noshow);
                    names = fieldnames(result);
                    for j4 = 1:length(names)
                        fld1 = names{j4};
                        if iscell(result.(fld1))
                            Meting(nres).result.(structname).(fld1){saveindex,1} = result.(fld1){1};
                        else
                            Meting(nres).result.(structname).(fld1)(saveindex,1) = result.(fld1);
                        end
                        F.(fld1) = result.(fld1);
                    end 
                    result = [];
                elseif contains(myformula,'fEPSP')
                    [~,hlp] = ParseCmd(myformula);
                    for iii = 1:3, hlp{iii} = eval(hlp{iii}); end
                    result = fEPSP(hlp);
                elseif contains(myformula,'fits')
                    [~,fparms] = ParseCmd(myformula);
                    [fparms,dokeep]    = ParseSpecial(fparms,'keep');
                    [~,present,ps] = ParseSpecial(fparms,'fitrange');
                    if present,	fparms{strncmp('fitrange',fparms,8)} = ['fitrange(' sprintf('%f %f %f %f %f',eval(ps{1})) ')']; end
                    fparms{end+1} = sprintf('label(trace: %u)',nodenr);
                    rfit = Fitfunctie(xtrace,ytrace,fparms);
                    if Error || ~rfit.valid, return; end
                    F.(myfield).GOF = rfit.error;
                    Meting(nres).result.(structname).(myfield).GOF(todonr,loopnr) = rfit.error;
                    for iii = 1:length(rfit.names)
                        F.(myfield).(rfit.names{iii}) = rfit.v(iii);
                        Meting(nres).result.(structname).(myfield).(rfit.names{iii})(todonr,loopnr) = rfit.v(iii);
                    end
                    if dokeep
                        Meting(nres).result.(structname).scratch.xeva                          = rfit.xeva+rfit.x0;
                        Meting(nres).result.(structname).scratch.yeva(1:length(rfit.yeva),todonr) = rfit.yeva;
                    end
                    if ~Formula.noshow
                        if ~isempty(rfit.xeva)
                            line(rfit.xeva+rfit.x0, rfit.yeva,'Color','r','LineWidth',2,'LineStyle',':')
                            TextLeft(gca,Fittekst(rfit),8);
                        end
                        drawnow;
                    end
                    result = [];
                elseif contains(myformula,'fitxy')
                    [~,fparms] = ParseCmd(myformula);
                    xtrace = eval(fparms{1});
                    ytrace = eval(fparms{2});
                    fparms = fparms(3:end);
                    fitrange ='-inf inf 0';
                    [~,present,ps] = ParseSpecial(fparms,'fitrange');
                    if present,	fparms{strncmp('fitrange',fparms,8)} = ['fitrange(' sprintf('%f %f %f %f %f',eval(ps{1})) ')']; end
                    rfit = Fitfunctie(xtrace,ytrace,fparms);
                    if Error || ~rfit.valid, return; end
                    F.(myfield).GOF = rfit.error;
                    Meting(nres).result.(structname).(myfield).GOF(todonr,loopnr) = rfit.error;
                    for iii = 1:length(rfit.names)
                        F.(myfield).(rfit.names{iii}) = rfit.v(iii);
                        Meting(nres).result.(structname).(myfield).(     rfit.names{iii})(todonr,loopnr)  = rfit.v(iii);
                        Meting(nres).result.(structname).(myfield).(['d' rfit.names{iii}])(todonr,loopnr) = rfit.dv(iii);
                    end
                    Meting(nres).fitter{fitnr,1} = rfit;
                    [~,present,ps] = ParseSpecial(fparms,'result');
                    if present
                        jj = 0;
                        for iii=1:2:length(ps)
                            jj=jj+1;
                            Meting(nres).fitter{fitnr,1}.plotter(fitnr,1).window = nsingle(ps{iii});
                            Meting(nres).fitter{fitnr,1}.plotter(fitnr,1).struct = '';
                            tmp = ssingle(ps{iii+1});
                            if strfind(tmp,'loopnr'), tmp = strrep(tmp,'loopnr',sprintf('%u',loopnr));  end
                            Meting(nres).fitter{fitnr,1}.plotter(fitnr,1).mode = tmp;
                        end
                    else
                        Meting(nres).fitter{fitnr,1}.plotter(fitnr,1).window = sourcew;
                        Meting(nres).fitter{fitnr,1}.plotter(fitnr,1).struct = '';
                        Meting(nres).fitter{fitnr,1}.plotter(fitnr,1).mode = sprintf('fit(%u)',loopnr);
                    end
                    NRNtimeline;
                    panels.plotter = Meting(nres).fitter{fitnr,1}.plotter;
                    panels.plotter.metnr = nres;
                    panels.plotter.subnr = fitnr;
                    NRNshow(Meting);
                    fitnr = fitnr + 1;
                    result = [];
                elseif contains(myformula,'loopavg')
                    fldname = ['avg_', myfield];
                    if loopidx==1
                        [~,fparms] = ParseCmd(myformula);
                        [~,tim] = ParseTwo(fparms,'range');
                        if isempty(tim), Error('loopavg needs range'); return; end
                        xp1 = find(xtrace>=tim(1),1,'first');
                        xp2 = find(xtrace<=tim(2),1,'last');
                        if isempty(xp1) || isempty(xp2), Error('loopavg time out of range'); return; end
                        Meting(nres).result.(structname).(fldname) = struct('SWPs',zeros(xp2-xp1+1,size(loopset,1)*size(todolist,1)),...
                                                                            'SWPm',...
                                                                            'spiker',[],...
                                                                            'kkwamp',[],...
                                                                            'xas',[xtrace(2)-xtrace(1),p.loop],...  % 'yunit',Formula.unit,...
                                                                            'yscale',[-inf,+inf],...
                                                                            'kkwrange',[-inf,inf],...
                                                                            'outrange',[-inf,inf]);
                    end
                    Meting(nres).result.(structname).(fldname).SWPs(:,loopidx) = ytrace(xp1:xp2);
                    Meting(nres).result.(structname).basis.times(loopidx) = Meting(nres).result.(structname).basis.times(loopidx) + p.loop/1000;
                    if loopidx==(size(loopset,1)*size(todolist,1))
                        Meting(nres).result.(structname).(fldname).scale = [-1 1]*max(abs(min(min(Meting(nres).result.(structname).means.(myfield).SWPs))),...
                                                                                      abs(max(max(Meting(nres).result.(structname).means.(myfield).SWPs))));
                    end
                    result = [];
                elseif contains(myformula,'sweeps')
                    if isempty(SWPS)
                        [~,fparms] = ParseCmd(myformula);
                        [SWPS, Meting(nres).result.(structname).(myfield)] = SWPSini(fparms,xtrace,todolist(:,4),todolist(:,3),myfield);
                        if Error, return; end
                    end
                    if isempty(SWPS.nul), swpoff = 0; else, swpoff = mean(ytrace(SWPS.nul(1):SWPS.nul(2))); end
                    Meting(nres).result.(structname).(SWPS.fld).SWPs(1:(SWPS.p(2)-SWPS.p(1)+1),todonr,saveindex) = ytrace(SWPS.p(1):SWPS.p(2))-swpoff;
                    result = [];
                elseif contains(myformula,'MCC')
                    [~,fparms] = ParseCmd(myformula);
                    if ~isempty(MCCamps)
                        cagenr = nsingle(fparms{1});
                        if length(cagenr)>1, cagenr = cagenr(ktel); end
                        result = MCCamps(cagenr,nodenr);
                    else
                        fmacro1 = sprintf('result = %s;',fparms{2});
                        eval(fmacro1);
                    end
                    F.(myfield) = result;
                else
                    try
                        fmacro1 = sprintf('result = %s;',myformula);
                        eval(fmacro1);
                        F.(myfield) = result;
                    catch
                        switch questdlg(fmacro1,'Formula crashed on:','Break','Ignore','debug','debug')
                            case 'Break', Error('Broken in Formula'); return;
                            case 'debug', eval(fmacro1);
                            otherwise
                        end
                    end
                end
                if panels.abort||Error, return; end
                if isempty(result)
                elseif isstruct(result)
                    tt = fieldnames(result);
                    for jjjj = 1:length(tt)
                        Meting(nres).result.(structname).(myfield).(tt{jjjj})(loopidx,saveindex) = result.(tt{jjjj});
                        F.(myfield).(tt{jjjj}) = result.(tt{jjjj});
                    end
                elseif (length(result)==1)
                    Meting(nres).result.(structname).(myfield)(loopidx,saveindex) = result;
                elseif contains(myformula,'samples')
                    [~,~,psh] = ParseSpecial({myformula},'samples');
                    t1 = rsingle(psh{1});
                    if length(psh)>1, t2 = rsingle(psh{2}); else,t2 = 0; end
                    for iii=1:length(t1)
                        vnaam = sprintf('sam%0.0fms',t1(iii)-t2);
                        Meting(nres).result.(structname).(myfield).(vnaam)(loopidx,saveindex) = result(iii);
                    end 
                end
                drawnow;
                if ~isempty(Formula.wait) && Formula.wait{formnr}>0
                    set(gcf,'Name',myformula);
                    DoTestwait(Formula.wait{formnr},myformula);
                end
            end
            if panels.abort||Error, return; end
        end
    end
    if ~isempty(SWPS)
        Meting(nres).result.(structname).(SWPS.fld) = MakeAverage(Meting(nres).result.(structname).(SWPS.fld),SWPS);
    end
    if panels.abort||Error, return; end
    channelname = Meting(nodenr).ADC.scale(plt.chns(1)).Name;
    InsertinLog(CMD,structname, Meting(nres).result.(structname), channelname);
    if ~isempty(Memoryset), MemoryUpdate('refresh'); end
    if winclear, WindowClear; end
    if Formula.noshow
        NRNtimeline;
    else
        if isempty(multikanalen), kanaal = 1; else, kanaal = multikanalen(ktel); end
        setplotter('struct',Meting,nres,structname,kanaal);
        NRNtimeline;
        NRNshow(Meting);
        DoTestwait(grafwait,'graphics done');
    end
end
Formula.on = false;
Formula.handle = [];
if ~isempty(multikanalen) && ~isempty(MEA), MEAelektrodes(MEA); end
switch Org.timegain
    case       1, Timescale(CMD,'ms');
    case    1000, Timescale(CMD,'sec');
    case   60000, Timescale(CMD,'min');
    case 3600000, Timescale(CMD,'hrs');
end
CMD.skip.String   = Org.skiptxt;
CMD.skipnr.String = Org.skipnr;
panels.plotter    = Org.plotter;
Formula.noshow = false;
Waitbar(CMD,'hide');

function DoExtract(parms)
global Memoryset Meting
strset1 = stringset(ssingle(parms{1}));
strset2 = stringset(ssingle(parms{2}));
if length(strset1)~=length(strset2), Error('Need same # names for in and output'); end
sumnodes = zeros(length(Memoryset),length(strset1));
for jj = 1:length(Memoryset)
    MemoryUpdate(jj,1);
    for jjj=1:length(strset1)
        hlp{1,1} = [];
        hlp{2,1} = strset1{jjj};
        delist = DoList(hlp);
        if ~isempty(delist)
            sumnodes(jj,jjj) = delist(1,2);
        end
    end
end
cnt = 1; 
for jjj = 1:length(strset1)
    nodes = sumnodes(:,jjj);
    if max(nodes)>0
        for jj=1:length(nodes)
            [~, Memoryset{jj}.Meting(nodes(jj)).filenaam] = fileparts(Memoryset{jj}.Meting(1).filename);
            Hulp(cnt)           = Memoryset{jj}.Meting(nodes(jj));
            Hulp(cnt).setnr     = (jj==1);
            Hulp(cnt).reltime   = cnt;
            Hulp(cnt).serienaam = strset2{jjj};
            Hulp(cnt).nodenaam  = sprintf('%s-%03u',strset2{jjj},jj);
            Hulp(cnt).EXTRA.note   = 'extracted from VC files';
            cnt = cnt + 1;
        end
    end
end
Meting = Hulp;
MemoryUpdate;
NRNtimeline;

function [xf,yf,zf,filenames] = AEDcollect(parms)
global Meting
hlp{1} = [];
hlp{2} = ssingle(parms{1});
nodes = DoList(hlp);
tdrmp = rsingle(parms{2});
[xcmd,xparms] = ParseCmd(ssingle(parms{3})); if ~isempty(xparms), xpar = rsingle(xparms{1}); end
[ycmd,yparms] = ParseCmd(ssingle(parms{4})); if ~isempty(yparms), ypar = rsingle(yparms{1}); end
[zcmd,zparms] = ParseCmd(ssingle(parms{5}));
if ~isempty(zparms)
    zpar1 = rsingle(zparms{1});
    if length(zparms)>1, zpar2 = rsingle(zparms{2}); end
end
xtim = 1;
filenames = [];
for ii = 1:size(nodes,1)
    nn = nodes(ii,2);
    filenames{ii} = Meting(nn).filenaam;
    [drug,ps] = ParseCmd(Meting(nn).EXTRA.comment1);
    if ~isempty(ps)
        [contxt,unit] = strtok(ssingle(ps{1}),' ');
        concentration = rsingle(contxt);
        unit = unit(2:end);
    end
    switch xcmd
        case 'time',   xf(ii,1) = mean(Meting(nn).result{1}.Times); if isempty(xpar), xtim = 1; else,xtim = xpar; end
        case 'drug',   xf(ii,1) = concentration;
        case 'fitpar', xf(ii,1) = Meting(nn).fitter{1}.v(round(xpar));
        case 'xyresult'
    end
    switch ycmd
        case 'time',   yf(ii,1) = mean(Meting(nn).result{1}.Times); if isempty(ypar), xtim = 1; else,xtim = ypar; end
        case 'drug',   yf(ii,1) = concentration;
        case 'fitpar', yf(ii,1) = Meting(nn).fitter{1}.v(round(ypar));
        case 'xyresult'
    end
    switch zcmd
        case 'time',     zf(ii,1) = mean(Meting(nn).result{1}.Times); if isempty(zpar1), xtim = 1; else,xtim = zpar1; end
        case 'drug',     zf(ii,1) = concentration;
        case 'fitpar',   zf(ii,1) = Meting(nn).fitter{1}.v(round(zpar1));
        case 'xyresult', zf(1,:)  = Meting(nn).result{1}.xy(:,round(zpar1))';
                       zf(ii+1,:) = Meting(nn).result{1}.xy(:,round(zpar2))';
    end
end
if strcmp(xcmd,'time')
    xf = (xf - xf(1)) * 24 * 60 * 60 / xtim;
    dtijd = [0; diff(xf)];
    dtijd(dtijd>tdrmp) = tdrmp+10;
    ctijd = cumsum(dtijd);
    xf = ctijd;
end

function DoShifting(parms)
global Meting
if DoDelete({'Shift-Set'}), NRNtimeline; end
tdrmp = rsingle(parms{2});
[xf,yf,zf,filenames] = AEDcollect(parms);
nres = Newnode('Shift-Set');
Meting(nres).result{1}.xas      = xf;
Meting(nres).result{1}.dispx{1} = 'time';
Meting(nres).result{1}.xy(:,1)  = xf;
Meting(nres).result{1}.xy(:,2)  = yf;
Meting(nres).result{1}.xy(:,3)  = zf;
Meting(nres).result{1}.disp1{1,1} = 'time';
Meting(nres).result{1}.disp1{2,1} = 'conc';
Meting(nres).result{1}.disp1{3,1} = ssingle(parms{5});
Meting(nres).result{1}.disp2{1} = '';
Meting(nres).result{1}.disp3{1} = '';
Meting(nres).result{1}.plotter           = [];
Meting(nres).result{1}.plotter(1,1).window = 21;
Meting(nres).result{1}.plotter(1,1).mode   = 'xy(0,[2 3])';
Meting(nres).result{1}.plotter(2,1).window = 4;
Meting(nres).result{1}.plotter(2,1).mode   = 'xy(1,2)/noline';
i1 = 1;
x1(i1) = 0;
z1(i1) = 0;
i2 = 0;
for ii = 1:length(xf)
    if yf(ii)==0
        x1(i1) = x1(i1) + xf(ii);
        z1(i1) = z1(i1) + zf(ii);
        i2 = i2 + 1;
        if (ii<length(xf)) && ((xf(ii+1)-xf(ii))>tdrmp)
            x1(i1) = x1(i1)/i2;
            z1(i1) = z1(i1)/i2;
            i1 = i1 + 1;
            i2 = 0;
            x1(i1) = 0;
            z1(i1) = 0;
        end
    else
        if i2>0
            x1(i1) = x1(i1)/i2;
            z1(i1) = z1(i1)/i2;
            i1 = i1 + 1;
            i2 = 0;
            if ii<length(xf)
                x1(i1) = 0;
                z1(i1) = 0;
            end
        end
    end
end
if i2>0
    x1(i1) = x1(i1)/i2;
    z1(i1) = z1(i1)/i2;
end
xi = xf(yf~=0);
zi = zf(yf~=0);
yi = interp1q(x1',z1',xi);
dy = yi-zi;
dy = [0; dy];
xc = yf(yf~=0);
xc = [0; xc];
%
[sxmin,sxmax] = scalexy([-inf inf],[0.05 0.05],min(xf),max(xf));
[symin,symax] = scalexy([-inf inf],[0.05 0.05],min(zf),max(zf));
handle = getplothandle(21,true);
set(handle,'XLim',[sxmin sxmax],'YLim',[symin symax],'XGrid','on','YGrid','on');
line('XData',xf(yf==0),'YData',zf(yf==0),'MarkerFaceColor','b','MarkerEdgeColor','b','Marker','o','MarkerSize',8,'LineStyle','none')
line('XData',xf(yf~=0),'YData',zf(yf~=0),'MarkerFaceColor','r','MarkerEdgeColor','r','Marker','o','MarkerSize',8,'LineStyle','none')               
line('XData',x1,       'YData',z1,'Color','b','MarkerEdgeColor','b','MarkerFaceColor','w','Marker','o','MarkerSize',6,'LineStyle',':')
line('XData',xi,       'YData',yi,'MarkerEdgeColor','r','MarkerFaceColor','w','Marker','o','MarkerSize',6,'LineStyle','none');
for ii=1:length(xi), line('XData',[xi(ii) xi(ii)],'YData',[yi(ii) zi(ii)],'Color','r','LineStyle',':'); end
Meting(nres).result{2}.xas               = xc;
Meting(nres).result{2}.dispx{1}          = 'conc';
Meting(nres).result{2}.xy(:,1)           = xc;
Meting(nres).result{2}.xy(:,2)           = dy;
Meting(nres).result{2}.disp1{1,1}        = 'conc';
Meting(nres).result{2}.disp1{2,1}        = 'shift';
Meting(nres).result{2}.disp2{1}          = '';
Meting(nres).result{2}.disp3{1}          = '';
Meting(nres).result{2}.plotter           = [];
Meting(nres).result{2}.plotter(1,1).window = 4;
Meting(nres).result{2}.plotter(1,1).mode   = 'xy(0,2,1,1,2)/noline';
[sxmin,sxmax] = scalexy([-inf inf],[0.05 0.05],min(xc),max(xc));
[symin,symax] = scalexy([-inf inf],[0.05 0.05],min(dy),max(dy));
handle = getplothandle(4,true);
set(handle,'XLim',[sxmin sxmax],'YLim',[symin symax],'XGrid','on','YGrid','on');
line('XData',xc,'YData',dy,'MarkerEdgeColor','r','MarkerFaceColor','w','Marker','o','MarkerSize',8,...
     'LineWidth',2,'LineStyle','none');
parms{end+1} = 'label(Shifting)';
fitter = Fitfunctie(xc,dy,parms(6:end));
if Error || ~fitter.valid, return; end
fitter.plotter(1,1).window   = 5;
fitter.plotter(1,1).mode     = 'fit(1)';
Meting(nres).fitter{1} = fitter;
[sxmin,sxmax] = scalexy([-inf inf],[0.05 0.05],min(fitter.fx),max(fitter.fx));
[symin,symax] = scalexy([-inf inf],[0.05 0.05],min(fitter.fy),max(fitter.fy));
handle = getplothandle(5,true);
set(handle,'XLim',[sxmin sxmax],'YLim',[symin symax],'XGrid','on','YGrid','on');
plot(fitter.res,'r-',fitter.fx,fitter.fy,'bo');
grid on
axis([sxmin sxmax symin symax]);
TextLeft(handle,Fittekst(fitter),8);
NRNtimeline;

function DoBinding(parms)
global Meting
if DoDelete({'Bind-Set'}), NRNtimeline; end
[xf,yf,zf,filenames] = AEDcollect(parms);
nres = Newnode('Bind-Set');
xf = xf';
yf = yf';
zf = zf'; 
col = size(zf,2);
concentration = -1;
cols = 1;
zfh  = [];
zfh(:,cols) = zf(:,cols);
yfh  = []; 
yfh(:,cols) = concentration;
for ii =2:col
    if concentration ~= yf(ii-1)
        if ii>2, zfh(:,cols) = zfh(:,cols)/colcount; end
        concentration = yf(ii-1);
        cols          = cols +1;
        colcount      = 1;
        zfh(:,cols)   = zf(:,ii);
        yfh(cols)     = concentration;
    else
        zfh(:,cols)   = zfh(:,cols) + zf(:,ii);
        colcount      = colcount + 1;
    end
end
if colcount>1, zfh(:,cols) = zfh(:,cols)/colcount; end
sxmin = 0;
sxmax = 1.1 * max(zf(:,1));
symin = 1.1 * min(min(zf(:,2:end)));
symax = 0;
handle = getplothandle(4,true);
set(handle,'XLim',[sxmin sxmax],'YLim',[symin symax],'XGrid','on','YGrid','on');
txt1 = 'xy(1,[';
txt2 = 'xy(1,[';
for ii = 1 + find(yf==0)
    line('XData',zf(:,1),'YData',zf(:,ii),'Color','b','LineStyle','-','Linewidth',2,...
         'MarkerEdgeColor','b','MarkerFaceColor','w','Marker','o','MarkerSize',8);
    txt1 = [txt1 sprintf('%u,',ii)];
end
for ii = 1 + find(yf>0)
    line('XData',zf(:,1),'YData',zf(:,ii),'Color','r','LineStyle','-','Linewidth',2,...
         'MarkerEdgeColor','r','MarkerFaceColor','w','Marker','o','MarkerSize',8);
    txt2 = [txt2 sprintf('%u,',ii)];
end
Meting(nres).result{1}.xas      = zf(:,1);
Meting(nres).result{1}.dispx{1} = 'time';
Meting(nres).result{1}.xy       = zf;
Meting(nres).result{1}.disp1{1} = 'time';
for ii = 1:length(yf), Meting(nres).result{1}.disp1{ii+1} = sprintf('[%0.1f]',yf(ii)); end
Meting(nres).result{1}.disp2{1} = '';
Meting(nres).result{1}.disp3{1} = '';
Meting(nres).result{1}.plotter           = [];
Meting(nres).result{1}.plotter(1,1).window = 4;
Meting(nres).result{1}.plotter(1,1).mode   = [txt1 '])/color(''r'')/grid/' sprintf('sety(%0.0f,0)',symin)];
Meting(nres).result{1}.plotter(2,1).window = 5;
Meting(nres).result{1}.plotter(2,1).mode   = [txt2 '])/color(''b'')/grid/' sprintf('sety(%0.0f,0)',symin)];
handle = getplothandle(5,true);
set(handle,'XLim',[sxmin sxmax],'YLim',[symin symax],'XGrid','on','YGrid','on');
txt1 = 'xy(1,[';
for die = find(yfh>0)
    line('XData',zfh(:,1),'YData',zfh(:,die),'Color','r','LineStyle','-','Linewidth',2,...
         'MarkerEdgeColor','r','MarkerFaceColor','w','Marker','o','MarkerSize',8);
    txt1 = [txt1 sprintf('%u,',die)];
end
Meting(nres).result{2}.xas      = zfh(:,1);
Meting(nres).result{2}.dispx{1} = 'time';
Meting(nres).result{2}.xy       = zfh;
Meting(nres).result{2}.disp1{1} = 'time';
for ii = 2:length(yfh), Meting(nres).result{2}.disp1{ii} = sprintf('[%0.1f]',yfh(ii)); end
Meting(nres).result{2}.disp2{1} = '';
Meting(nres).result{2}.disp3{1} = '';
Meting(nres).result{2}.plotter           = [];
Meting(nres).result{2}.plotter(1).window = 1;
Meting(nres).result{2}.plotter(1).mode   = [txt1 '])/color(''r'')/grid/' sprintf('sety(%0.0f,0)',symin)];
Meting(nres).fitter = [];
controles = find(yfh==0);
waardes   = find(yfh>0);
parms{end+1} = 'label(Binding)';
parms = parms(6:end);
[parms,metrange,psrange] = ParseSpecial(parms,'limit');
cnt = 1;
for die = waardes
    concentraties{cnt,1} = sprintf('conc %4.2f uM',yfh(die));
    zfc = 0 * zfh(:,1);
    aantal = 0;
    controlevoor = controles(controles<die);
    if ~isempty(controlevoor), zfc = zfc + zfh(:,controlevoor(end)); aantal = aantal + 1; end
    controlena   = controles(controles>die);
    if ~isempty(controlena),   zfc = zfc + zfh(:,controlena(1));     aantal = aantal + 1; end
    zfh(:,die) = (zfc/aantal) - zfh(:,die);
    fparms = parms;
    if metrange && (length(psrange)>=die)
        fparms{end+1} = sprintf('fitrange(%s)',psrange{die});
    end
    fitter = Fitfunctie(zfh(:,1),zfh(:,die),fparms);
    if Error || ~fitter.valid, return; end
    handle = getplothandle(cnt,true);
    set(handle,'XLim',[sxmin sxmax],'YLim',[symin symax],'XGrid','on','YGrid','on');
    plot(fitter.res,'r-',fitter.fxorg,fitter.fyorg,'bo');
    line(fitter.fxorg,  fitter.fyorg,'Color','r','Marker','o','MarkerSize',8,'LineWidth',2,'LineStyle','none');
    line(fitter.fx,      fitter.fy,    'Color','b','Marker','o','MarkerSize',8,'LineWidth',2,'LineStyle','none');
    grid on
    axis([sxmin sxmax symin symax]);
    if ~isempty(fitter.range)
        for iii = 1:length(fitter.range)
            line('XData',[fitter.range(iii) fitter.range(iii)],'YData',[symin symax],'Color','m','LineStyle',':','LineWidth',2);
        end
    end
    TextLeft(handle,Fittekst(fitter),8);
    tce(cnt)  = fitter.dv(3)/fitter.v(3);
    tcv(cnt)  = 1000/fitter.v(3);
    tcdv(cnt) = tce(cnt) *  tcv(cnt);
    ccc(cnt)  = yfh(die);
    fitter.plotter(1).window = cnt;
    fitter.plotter(1).mode   = sprintf('fit(%u)/grid/sety(%0.0f,0)',cnt,symin);
    Meting(nres).fitter{cnt} = fitter;
    cnt = cnt + 1;
end
if Error, return; end
sxmin = -10;
sxmax = 1.2*max(ccc);
symin = 0;
symax = 1.2*max(tcv);
handle = getplothandle(12,true);
set(handle,'XLim',[sxmin sxmax],'YLim',[symin symax],'XGrid','on','YGrid','on');
errorbar(ccc,tcv,tcdv,'o');
axis([sxmin sxmax symin symax]);
hold on
grid on
if length(ccc)>1
    if length(ccc)>2
        [b,sb] = lscov([ ones(length(ccc),1) ccc'],tcv',1./tcdv');
        stats.se(1) = sb(1);
        stats.se(2) = sb(2);
    else
        b(2)        = (tcv(2)-tcv(1))/(ccc(2)-ccc(1));
        b(1)        = tcv(1) - b(2) * ccc(1);
        stats.se(1) = 0;
        stats.se(2) = 0;
    end
    micro = 1000000;
    milli = 1000;
    plot([0 ccc], b(2) * [0 ccc] + b(1),'--r','Linewidth',2);
    txt = ' par      val       error';
    txt = [txt sprintf('\n slope  = %6.1f (%6.1f)*10^-^6 mM^-^1s^-^1',micro*b(2),micro*stats.se(2))];
    txt = [txt sprintf('\n offset = %6.1f (%6.1f)*10^-^3 s^-^1',milli*b(1),milli*stats.se(1))];
    text(sxmin+0.01*(sxmax-sxmin),symax - 0.01*(symax-symin),txt,...
         'HorizontalAlignment','left','VerticalAlignment','Top','Fontsize',10,'Fontname','Courier');
end
NRNtimeline;

function [macros,inclds] = DoInsertfile(macros)
global panels
inclds = [];
index = find(strncmp('InsertCmds',macros,length('InsertCmds')));
if isempty(index), return; end
[~,~,ps] = ParseSpecial(macros(index),'InsertCmds');
for jj = 1:length(ps)
    ps{jj} = ssingle(ps{jj});
end
[ps,present,psh] = ParseSpecial(ps,'select');
if present
    [selection,OK] = listdlg('PromptString', 'Select the instruction file',...
                             'Selectionmode','Single',...
                             'InitialValue',1,...
                             'OKString','Select',...
                             'uh',32,...
                             'fus',12,...
                             'ffs',12,...
                             'ListString',psh);
    if OK
        ps{1} = psh{selection};
    else
        macros = [];
        return
    end
end
[filepath,filename,fileext] = fileparts(ssingle(ps{1}));
if isempty(fileext),  fileext = '.txt'; end
if isempty(filepath), filepath = fileparts(panels.file.script); end
newname = fullfile(filepath,[filename fileext]);
[fid,message] = fopen(newname,'r');
if ~isempty(message), Error(sprintf('%s\n%s',message,newname)); return; end
data = textscan(fid,'%s','delimiter','\n','whitespace','');
fclose(fid);
data = data{1};
insert = [];
skipon = false;
if iscell(data)
    alltxt = data{1};
    for jj = 2:length(data)
        if alltxt(end)==','
            alltxt = [alltxt data{jj}];
        else
            alltxt = [alltxt ',' data{jj}];
        end
    end
    data = ParseSimple(alltxt);
    [data,~,inclds] = ParseSpecial(data,'Parameters');
    for jj =1:size(data)
        str = data{jj};
        if str(1)=='!'
            insert = [insert, str, ','];
        else
            if strcmp(str,'$$'), skipon = ~skipon; continue; end
            if isempty(str), continue; end
            if ~skipon
                txt = strtrim(strtok(str,'!'));
                [~,present1,ps] = ParseSpecial({txt},'CellLoad');
                if present1
                    [name,psh] =ParseCmd(ps{1});
                    dir = ssingle(psh{1});
                    for jjj = 2:length(psh)
                        hlp = sprintf('DataLoad(%s%s%s%s%s0000.mat,cell),',dir,filesep,name,dir,psh{jjj});
                        insert = [insert hlp];
                    end
                end
                [~,present2,ps] = ParseSpecial({txt},'DataLoad');
                if present2
                    if isempty(inclds)
                        if (txt(end)~=','), txt(end+1) = ','; end
                    else
                        txt = sprintf('DataLoad(%s',ps{1});
                        for jjj = 2:length(ps)
                            txt = sprintf('%s,%s',txt,ps{jjj});
                        end
                        txt = sprintf('%s),',txt);
                    end
                    insert = [insert txt];
                end
            end
            if strcmp(str,'exit'), break; end
        end
    end
    insert = ParseSimple(insert);
else
    insert = data;
end
hlp1 = macros(1:index-1);
hlp2 = macros(index+1:end);
macros = [hlp1; insert; hlp2;];

function kleur = colorname(die)
color = {'blue'; 'red'; 'magenta'; 'cyan'; 'green';};
kleur = color{1+mod(die-1,4)};

function kleur = colorchar(die)
color = 'brgmc';
kleur = color(1+mod(die-1,4));

% function serie = correctborders(serie)
% global spikes
% if ~isempty(spikes.borders.bgn)
%     for jj = 1:length(spikes.borders.bgn)
%         a1 = spikes.borders.bgn(jj);
%         a2 = spikes.borders.end(jj);
%         if (a2<=serie(1)) || (a1>=serie(end))
%             
%         else
%             n1 = find((a1>serie(1:end-1)) &(a1<=serie(2:end)));
%             n2 = find((a2>serie(1:end-1)) &(a2<=serie(2:end)));
%             if rem(n1,2)
%                 if rem(n2,2)
%                     serie = [serie(1:n1) a1 a2 serie(n2+1:end)];
%                 else
%                     serie = [serie(1:n1) a1 serie(n2+1:end)];
%                 end
%             else
%                 if rem(n2,2)
%                     serie = [serie(1:n1) a2 serie(n2+1:end)];
%                 else
%                     serie = [serie(1:n1) serie(n2+1:end)];
%                 end
%             end
%         end
%         die = find(diff(serie)==0);
%         if ~isempty(die), serie(die:die+1) = []; end
%     end
% end

function [parms,data,datloc] = fetchdata(parms,Mets,varargin)
data = struct('xas', [],'xtxt',[],'xlen',[],'xres',[],...
              'yas', [],'ysem',[],'ytxt',[],'yres',[],...
              'zas', [],'zsem',[],'ztxt',[],'zres',[],...
              'time',[],          'ttxt',[],'tres',[],...
              'sets',[],...
              'mets',[],...
              'swps',[],...
              'class',[],...
              'rate',false);
if nargin>2
    datloc = varargin{1};
else
    datloc = struct('nres',  [],...
                    'node',  "",...
                    'struct',"",...
                    'flds',  "",...
                    'kanidx',1);
end
[parms,present,ps] = ParseSpecial(parms,'node');   if present, datloc.node   = ssingle(ps{1}); end
[parms,present,ps] = ParseSpecial(parms,'struct'); if present, datloc.struct = ssingle(ps{1}); end
[parms,present,ps] = ParseSpecial(parms,'root');
if present
    hlp = split(string(ssingle(ps{1})),"@"); if length(hlp)==1, datloc.struct= hlp; else, datloc.node= hlp(1); datloc.struct= hlp(2); end
end
if ~isempty(datloc.node)
    datloc.nres = find(startsWith(string({Mets.nodenaam}),datloc.node));
    if isempty(datloc.nres), Error(sprintf('cannot find %s',datloc.node)); return; end
end
for command = ["yas","zas","xas"]
    [parms,present,ps] = ParseSpecial(parms,command);
    if ~present, continue; end
    for jj = 1:length(ps)
        [hlp,timeranges] = ParseCmd(ps{jj},'[]');
        [hlp,index]      = ParseCmd(hlp,'()');
        hlp = split(string(hlp),"@"); if length(hlp)==2, datloc.node = hlp(1);   hlp = hlp(2); end
        hlp = split(hlp,":");         if length(hlp)==2, datloc.struct = hlp(1); hlp = hlp(2); end
        datloc.flds = split(hlp,".");
        basnode = Mets(datloc.nres).result.(datloc.struct).basis;
        if datloc.flds(1)=="time"
            datar = basnode.times;
            datatxt = "time(sec)"; 
            % hier timeranges...
        else
            startnode = Mets(datloc.nres).result;
            if ~isfield(startnode,datloc.struct), Error(sprintf('node %s does not exist',datloc.struct)); return; end
            startnode = startnode.(datloc.struct);
            if length(datloc.flds)>0
                if isfield(startnode,datloc.flds(1))
                    startnode = startnode.(datloc.flds(1));
                    datatxt   = sprintf("%s@%s:%s",datloc.node,datloc.struct,datloc.flds(1));
                else
                    Error(sprintf('field %s does not exist',datloc.flds(1))); return;
                end
            end
            if length(datloc.flds)>1
                if isfield(startnode,datloc.flds(2))
                    startnode = startnode.(datloc.flds(2));
                    datatxt   = sprintf("%s@%s:%s.%s",datloc.node,datloc.struct,datloc.flds(1:2));
                else
                    Error(sprintf('subfield %s.%s does not exist',datloc.flds(1:2))); return;
                end
            end
            if length(datloc.flds)>2
                if isfield(startnode,datloc.flds(3))
                    startnode = startnode.(datloc.flds(3));
                    datatxt   = sprintf("%s@%s:%s.%s.%s",datloc.node,datloc.struct,datloc.flds(1:3));
                else
                    Error(sprintf('subfield %s.%s.%s does not exist',datloc.flds(1:3))); return;
                end
            end
            if iscell(startnode)
                datar = startnode{1,datloc.kanidx};
            else
                datar = startnode(:,datloc.kanidx);
            end
        end
        for kk = 1:max(1,length(timeranges))
            if ~isempty(timeranges)
                if kk==1, datat = basnode.times; end
                tt = rsingle(timeranges{kk});
                if tt(1)>=datat(end), Error(sprintf('%s outside datarange',tt{1})); return; end
                select = (datat>=tt(1)) & (datat<=tt(2));
                select = (datat>=tt(1)) & (datat<=tt(2));
                data.time{end+1,1} = datat(select);
                data.ttxt{end+1,1} = sprintf('timerange[%0.2f-%0.2f]',tt(1),tt(2));
                data.tres(end+1,1) = nres;
                seldata = datar(select);
                seltext = sprintf('%s[%0.2f-%0.2f]',datatxt,tt(1),tt(2));
            else
                seldata = datar;
                seltext = datatxt;
            end
            switch command
                case "xas", data.xas{end+1,1} = seldata;
                            data.xtxt{end+1,1}= seltext;
                            data.xlen(end+1,1)= basnode.metswp(1,6);
                            data.xres(end+1,1)= datloc.nres;
                case "yas", data.yas{end+1,1} = seldata;
                            data.ytxt{end+1,1}= seltext;
                            data.yres(end+1,1)= datloc.nres;
                            if ~isempty(timeranges)
                                data.sets{end+1,1} = basnode.metswp(select,1);
                                data.mets{end+1,1} = basnode.metswp(select,2);
                                data.swps{end+1,1} = basnode.metswp(select,3);
                            else
                                data.sets{end+1,1} = basnode.metswp(:,1);
                                data.mets{end+1,1} = basnode.metswp(:,2);
                                data.swps{end+1,1} = basnode.metswp(:,3);
                            end
                case "zas", data.zas{end+1,1} = seldata;
                            data.ztxt{end+1,1}= seltext;
                            data.zres(end+1,1)= datloc.nres;
            end
        end
    end
end
      
%         if isempty(fld3) && isempty(fld2)
%             datar = startnode.(fld1);
% 
%         elseif isempty(fld3)
%             die = find(strcmp(fieldnames(startnode.(fld1)),fld2), 1);
%             if isempty(die), Error(sprintf('Cannot find struct\n  %s.%s',fld1,fld2)); return; end
%             datar = startnode.(fld1).(fld2);
%             datatxt = sprintf('%s@%s:%s.%s',node,structname,fld1,fld2);
%         else
%             datar = startnode.(fld1).(fld2).(fld3);
%             datatxt = sprintf('%s@%s:%s.%s.%s',node,structname,fld1,fld2,fld3);
%         end
%         die = find(strcmp(fieldnames(startnode),fld1), 1);
%         if isempty(die), Error(sprintf('Cannot find struct\n  %s\nin %u  %s',fld1,nres,structname)); return; end
%         [cmd,subs] = ParseCmd(cmd);
%         if isempty(subs), todonr = datloc.todonr; else, todonr = nsingle(subs{1}); end
%         if isempty(datloc.todonr), datloc.todonr = todonr; end
%         txt = ssingle(ssingle(cmd));
%         sep = strfind(txt,':');
%         if isempty(sep)
%             node = datloc.node;
%             structname = datloc.struct;
%         else
%             structname = ssingle(txt(1:sep-1));
%             txt        = ssingle(txt(sep+1:end));
%             sep = strfind(structname,'@');
%             if isempty(sep)
%                 if isempty(node), node = datloc.node; end
%                 structname = txt1;
%             else
%                 node       = ssingle(structname(1:sep-1));
%                 structname = ssingle(structname(sep+1:end));
%             end
%         end
%         if isempty(datloc.node)
%             datloc.node = node;
%             datloc.nres = find(strncmp({Mets.nodenaam},node,length(node)));
%             if isempty(datloc.nres), Error(sprintf('%s is not present',datloc.node)); return; end
%         end
%         if isempty(datloc.struct)
%             datloc.struct = structname;
%         end
%         names = fieldnames(Mets(datloc.nres).result);
%         if ~strcmp(names,structname)
%             Error(sprintf('%s is not in %s',datloc.struct,datloc.node)); return;
%         end
%         if isempty(txt)
%             fld1 = datloc.fld1;
%             fld2 = datloc.fld2;
%             fld3 = datloc.fld3;
%         else
%             sep = strfind(txt,'.');
%             fld3 = '';
%             if isempty(sep)
%                 fld1 = txt;
%                 fld2 = '';
%             else
%                 fld1 = ssingle(txt(1:sep-1));
%                 fld2 = ssingle(txt(sep+1:end));
%             end
%         end
%         if isempty(datloc.fld1)
%             datloc.fld1 = fld1; 
%             datloc.fld2 = fld2;
%             datloc.fld3 = fld3;
%         end
%         if isempty(node), Error(sprintf('Cannot find node for\n  %s',ps{jj})); return; end
%         nres = find(strncmp({Mets.nodenaam},node,length(node)));
%         if isempty(nres), Error(sprintf('Cannot find node\n  %s',node)); return; end
%         if (hh==1) && (jj==1) && strcmp(fld1,'rate'), data.rate = true; end
%         startnode = Mets(nres).result.(structname);

function DoTrace(parms)
global Meting
color = 'brmkcgyw';
parms{end+1,1} = 'xas(time)';
[parms,data] = fetchdata(parms,Meting);
if Error, return; end
[parms,barsize,nbins] = ParseBins(parms);
[parms,present,ps] = ParseSpecial(parms,'window');  if present, wins = nsingle(ps{1}); else,wins = 9; end
[parms,range]      = ParseTijd(parms,'range',1);
if isempty(range) || isinf(range)
    range = [0 data.xlen(1)]/1000;
    set(CMD.adctime,'Value', range(2)*1000);
end
[parms,scale] = ParseScale(parms);
if Error, return; end
handle = getplothandle(wins(1),true);
tijdas = data.xas{1};
[sxmin,sxmax] = scalexy(scale.x,scale.dx,tijdas(1),tijdas(end));
numtrace = length(data.yas);
if ~isempty(barsize)
    xx = (range(1):barsize:range(2))';
    yy = data.yas{1};
    result = zeros(length(xx)-1,1);
    rates  = zeros(length(xx)-1,1);
    jjj = 1;
    iii = 1;
    som = 0;
    cnt = 0;
    while (jjj<=length(tijdas))
        if tijdas(jjj)>xx(iii+1)
            rates(iii) = cnt/barsize;
            if cnt>0, result(iii) = som/cnt; end
            if iii == length(result), break; end
            iii = iii+1;
            som = 0;
            cnt = 0;
        end
        if tijdas(jjj)<=xx(iii+1)
            cnt = cnt + 1;
            som = som + yy(jjj);
            jjj = jjj + 1;
        end
    end
    rates(iii) = cnt/barsize;
    if cnt>0, result(iii) = som/cnt; end   
    xx = (xx(1:end-1)+xx(2:end))/2;
    if data.rate, result = rates; end
    [symin,symax]=scalexy(scale.y,scale.dy,0,1.1*max(result)); 
    bar(xx,result,1,color(1));
    axis([sxmin,sxmax,symin,symax]);
    text(sxmin,symax,data.ytxt{1},'HorizontalAlignment','Left','VerticalAlignment','Top',...
                          'Fontsize',12,'Fontname','Courier');
else
    smooth = 1;
	if numtrace==2
        if isempty(smooth)
            [haxes,hline1,hline2] = plotyy(tijdas,data.yas{1},tijdas,data.yas{2});
        else
            half = floor(smooth/2);
            smooth = 2 * half + 1;
            maxlen = length(tijdas);
            h1 = data.yas{1};
            h2 = data.yas{2};
            s1 = h1;
            s2 = h2;
            for jj = 1:half
                s1(jj) = mean(h1(1:(2*jj-1)));
                s2(jj) = mean(h2(1:(2*jj-1)));
            end
            som1 = smooth * s1(half);
            som2 = smooth * s2(half);
            for jj = (half+1):(maxlen-half-1)
                som1 = som1 - h1(jj-half)+h1(jj+half+1);
                som2 = som2 - h2(jj-half)+h2(jj+half+1);
                s1(jj) = som1/smooth;
                s2(jj) = som2/smooth;
            end
            for jj = (maxlen-half):maxlen
                s1(jj) = mean(h1((2*jj-maxlen):maxlen));
                s2(jj) = mean(h2((2*jj-maxlen):maxlen));
            end
            [haxes,hline1,hline2] = plotyy(tijdas,s1,tijdas,s2);
        end
        set(haxes(1),'XLim',[sxmin sxmax]);
        set(haxes(2),'XLim',[sxmin sxmax],'xtick',[],'YColor',color(2));
        set(hline1,'Color',color(1));
        set(hline2,'Color',color(2));
        grid on
        hlp = get(gca,'YLim');
        text(sxmin,hlp(2),data.ytxt{1},'Color',color(1),'HorizontalAlignment','Left',...
                          'VerticalAlignment','Top','Fontsize',12,'Fontname','Courier');
        text(sxmax,hlp(2),data.ytxt{2},'Color',color(2),'HorizontalAlignment','Right',...
                          'VerticalAlignment','Top','Fontsize',12,'Fontname','Courier');
    else
        legd = [];
        for jj=1:numtrace
            if isempty(smooth)
                vals = data.yas{jj};
            else
                vals = conv(data.yas{jj},fltr,'same');
            end
            line(tijdas,vals,'LineStyle','-','Color',color(jj),'LineWidth',1);
            legd = [legd txtcolor(color(jj)) sprintf('%s\n',data.ytxt{jj})];
        end
        set(handle,'XLim',[sxmin,sxmax]);
        hlp = get(gca,'YLim');
        text(sxmin,hlp(2),legd,'HorizontalAlignment','Left','VerticalAlignment','Top',...
                              'Fontsize',12,'Fontname','Courier');
	end
end

function DoHist(parms)
global Meting
[parms,present,ps] = ParseSpecial(parms,'source');
if ~present, return; end
[ps,data] = fetchdata(ps,Meting);
if Error, return; end
drawhist(parms,data)

function drawhist(parms,data)
[parms,scale] = ParseScale(parms);
if Error, return; end
[parms,present, ps] = ParseSpecial(parms,'window'); if present, winnr = nsingle(ps{1}); else, winnr = 9; end
[parms,present, ps] = ParseSpecial(parms,'range');  if present, fitrange = rsingle(ps{1}); else, fitrange = []; end
[parms,donrmfit,ps] = ParseSpecial(parms,'nrmfit'); if donrmfit && ~isempty(ps), nc = ssingle(ps{1}); else, nc = 'r'; end
[parms,dogamfit,ps] = ParseSpecial(parms,'gamfit'); if dogamfit && ~isempty(ps), gc = ssingle(ps{1}); else, gc = 'b'; end
[parms,doexpfit,ps] = ParseSpecial(parms,'expfit'); if doexpfit && ~isempty(ps), ec = ssingle(ps{1}); else, ec = 'm'; end
[parms,binsize,nbins] = ParseBins(parms);
handle = getplothandle(winnr(1),true);
values = data.yas{1};
values(isnan(values)) = [];
if isempty(nbins) && isempty(binsize)
    nbins = 10;
elseif isempty(nbins)
    nbins = max(1,round((max(values)-min(values))/binsize));
end
[nout,xout] = hist(values,nbins);
bar(xout,nout,1,'c');
if ~isempty(fitrange)
    select = (values>=fitrange(1)) & (values<=fitrange(2));
    values = values(select);
    xout   = xout(select);
    nout   = nout(select);
end
mtxt = sprintf('\n %s (n=%u)\n  mean %0.3f sec (%0.3f Hz), median %0.3f',...
               data.ytxt{1},length(values),mean(values), 1/mean(values), median(values));
[sxmin,sxmax] = scalexy(scale.x,scale.dx,min(xout),max(xout));
[symin,symax] = scalexy(scale.y,scale.dy,0, 1.1 * max(nout));
axis([sxmin sxmax symin symax]);
xxx = sxmin:(sxmax-sxmin)/200:sxmax;
if donrmfit
    [mu,sigma,muci,sigmaci] = normfit(values);
    yy = normpdf(xout,mu,sigma);
    schaal = sum(nout.*yy)/sum(yy.*yy);
    line(xxx,schaal*normpdf(xxx,mu,sigma),'LineStyle','-','Color',nc,'LineWidth',2);
    htxt = ['\color{red}' sprintf('\n\n Normal distribution\n     mu: %0.2f (%0.2f - %0.2f)',mu,muci(1),muci(2)) ...
                          sprintf('\n  sigma: %0.2f (%0.2f - %0.2f) sem: %0.3f',sigma,sigmaci(1),sigmaci(2),std(values)/realsqrt(length(values)))];
else
    htxt = [];
end
if doexpfit
    [mua,mub] = expfit(values);
    yy = exp(-xout/mua);
    schaal = sum(nout.*yy)/sum(yy.*yy);
    line(xxx,schaal *exp(-xxx/mua),'LineStyle','-','Color',ec,'LineWidth',2);
    etxt = ['\color{magenta}' sprintf('\n\n Exponential distribution\n    mu: %6.3f (%0.2f - %0.2f) sec',mua,mub(1),mub(2))];
else
    etxt = [];
end
if dogamfit
    [phat, pci] = gamfit(values);
    yy = gampdf(xout,phat(1),phat(2));
    schaal = sum(nout.*yy)/sum(yy.*yy);
    line(xxx,schaal*gampdf(xxx,phat(1),phat(2)),'LineStyle','-','Color',gc,'LineWidth',2);
    gtxt = ['\color{blue}' sprintf('\n\n Gamma distribution\n    phi: %0.2f (%0.2f - %0.2f)',phat(1),pci(1,1),pci(2,1)) ...
                           sprintf('\n phisig: %0.2f (%0.2f - %0.2f)',phat(2),pci(1,2),pci(2,2))];
else
    gtxt = [];
end
if ~isempty(fitrange)
    ylims = get(gca,'YLim');
    xxx = [fitrange(1) *[1,1],NaN,fitrange(2) *[1,1]];
    yyy = [ylims,NaN,ylims];
    line(xxx,yyy,'LineStyle',':','Color','b','LineWidth',2);
end
text(sxmin,symax,[mtxt htxt gtxt etxt],'HorizontalAlignment','Left','VerticalAlignment','Top','Fontsize',10,'Fontname','Courier');

function showreturnmap(parms,handle,intervals,idx,silou,thold)
[parms,scale]         = ParseScale(parms); if Error, return; end
[parms,binsize,nbins] = ParseBins(parms);
[parms,present,ps]    = ParseSpecial(parms,'limit');    if present, limits  = rsingle(ps{1}); else,limits  = [0 inf]; end
[parms,present,ps]    = ParseSpecial(parms,'fitlimit'); if present, flimit  = rsingle(ps{1}); else,flimit  = [0 inf]; end
set(handle,'XScale','linear','Xgrid','on','YScale','linear','Ygrid','on');
% handle.XScale = 'log';
% handle.YScale = 'log';
% intervals = [intervals(1:end-1),intervals(2:end)];
% numcluster = length(unique(idx));
% centers = zeros(numcluster,8);
% if silou>criterion
%     htxt = sprintf(' %u clusters(>%3.2f) silhouette %4.3f',numcluster,criterion,silou);
%     for jj = 1:numcluster
%         centers(jj,1) = round(realpow(10,mean(log10(intervals(idx==jj,1)))));
%         centers(jj,2) = round(realpow(10,mean(log10(intervals(idx==jj,2)))));
%         centers(jj,3) = sum(idx==jj);
%         centers(jj,4) = 1000./mean(intervals(idx==jj,1));
%         centers(jj,5) = round(realsqrt(centers(jj,1)^2 + centers(jj,2)^2));
%         centers(jj,6) = abs(centers(jj,1)-centers(jj,2))/(centers(jj,1)+centers(jj,2));
%     end
%     inside = find(centers(:,6)<mean(centers(:,6)));
%     [~,hlp] = sort(centers(inside,5));
%     order = inside(hlp);
%     midden = length(order);
%     rest = 1:numcluster;
%     rest(order) = [];
%     order = [order;rest'];
%     
%     demark = 'rbmgyckrbmgyck';
%     almark = 'brgmkkybrgmkky';
%     for jjj = 1:numcluster
%         jj = order(jjj);
%         if sum(idx==jj)>0
%             line(intervals(idx==jj,1),intervals(idx==jj,2),'LineStyle','none','Marker','o','Markersize',05,'Color',demark(jjj),'LineWidth',1);
%             line(centers(jj,1),centers(jj,2),              'LineStyle','none','Marker','o','Markersize',18,'Color',almark(jjj),'LineWidth',2);
%             if jjj<=midden
%                 htxt = sprintf('%s\n clr: %u,%6.2f Hz(n=%u)',htxt,jjj,centers(jj,4),centers(jj,3));
%             end
%         end
%     end
%     for jjj = 1:numcluster
%         jj = order(jjj);
%         text(centers(jj,1),centers(jj,2),sprintf('   cls %u',jjj),'Fontsize',14,'FontWeight','bold','Color','k');
%     end
% else
%     line(intervals(:,1),intervals(:,2),'LineStyle','none','Marker','o','Markersize',5,'Color','k','LineWidth',0.5);
%     nspk = length(intervals(:,1));
%     freq = 1000./mean(intervals(:,1));
%     htxt = sprintf('No clusters((<%3.2f)) silhouette %4.3f\n mean freq %6.2f Hz(n=%u)',criterion,silou,freq,nspk);
% end
% handle.XLim(1) = 0.9*thold;
% handle.YLim(1) = 0.9*thold;
% text(handle.XLim(1),handle.YLim(2),htxt,'Fontsize',10,'Fontname','Courier','Color','k',...
%                                         'HorizontalAlignment','Left','VerticalAlignment','Top');
% return
numgraph = min(length(wins)-1,best);
for igraph = 1:numgraph
    die = order(igraph);
    fscale = 1;
    hlp = intervals(idx==die);
%     fitlimit = flimit * fscale;
    binsize  = binsize * fscale;
    handle = getplothandle(wins(igraph+1),true);
%     if isempty(nbins), nbins = fscale * (max(intervals)-min(intervals))/binsize; end
    his = histogram(hlp,25);
    handle.XLim(1) = 0;
    handle.YLim(1) = 0;
    handle.YLim(2) = 1.2*handle.YLim(2);
    hold on
    spkhlp = sort(hlp);   
    [mua,mub] = expfit(spkhlp);
    xx = (his.BinEdges(1:end-1)+ his.BinEdges(2:end))/2;
    yy = his.BinCounts;
    yf = exp(-xx/mua);
    AA = sum(yy.*yf)/sum(yf.*yf);
    x1 = min(his.BinEdges);
    x2 = max(his.BinEdges);
    xxx = x1:((x2-x1)/100):x2;
    line(xxx,AA*exp(-xxx/mua),'LineStyle','-','Color','r','LineWidth',2);
    
    [mu,ci] = gamfit(spkhlp);
    yy2 = gampdf(xx,mu(1),mu(2));
    aa2 = sum(yy.*yy2)/sum(yy2.*yy2);
    yyy = gampdf(xxx,mu(1),mu(2));
    line(xxx,yyy*aa2,'LineStyle','-','Color','m','LineWidth',2)
    
    htxt = [sprintf('Intervals(n=%u)\nmedian: %0.3f s (%4.2f Hz)\nmean: %0.3f s (%0.2f Hz)',...
                     length(intervals),median(intervals),1/median(intervals),mean(intervals),1/mean(intervals))...
                    '\color{red}'     sprintf('\n\nExp Fit:\nu: %6.3f s (%0.2f-%0.2f)',mua,mub(1),mub(2))...
                    '\color{magenta}' sprintf('\n\nGamma Fit:\nu1: %0.2f s (%0.2f-%0.2f)',mu(1),ci(1,1),ci(2,1)) ...
                                      sprintf('\nu2: %0.2f s (%0.2f-%0.2f)',mu(2),ci(1,2),ci(2,2))];
%     if limits(1)>0
%         drempel = limits(1);
%         intervals = intervals(intervals>drempel);
%         pf_truncgamma = @(x,mu1,mu2) gampdf(x,mu1,mu2)./(1-gamcdf(drempel,mu1,mu2));
%         [gamres,gamci] = mle(intervals,'pdf',pf_truncgamma,'start',[mu(1) mu(2)],'lower',[0 0]);
%         yy3 = gampdf(xout,gamres(1),gamres(2));
%         sel = find(xout>drempel);
%         aa3 = sum(nout(sel).*yy3(sel))/sum(yy3(sel).*yy3(sel));
%         line(xout,yy3*aa3,'LineStyle','-','Color','g','LineWidth',2)
%         line([drempel drempel],[symin symax],'Color','g','LineStyle',':');
%         htxt = [htxt '\color{green}' sprintf('\n drempel>%4.2f (%u)\n Gamma fit:\n mu-1: %6.2f (%6.2f - %6.2f) sc',drempel,length(intervals),gamres(1),gamci(1,1),gamci(2,1)) ...
%                                      sprintf('\n mu-2: %6.2f (%6.2f - %6.2f) sec',gamres(2),gamci(1,2),gamci(2,2))];
%     end
    text(handle.XLim(2),handle.YLim(2),htxt,'HorizontalAlignment','Right','VerticalAlignment','Top','Fontsize',10,'Fontname','Courier');
end

function DoReturn(parms)
global Meting
[~,data] = fetchdata(parms,Meting);
if Error, return; end
returnmap(parms,data.yas{1});

function DoAmpHist(parms)
global Meting panels spikes
[parms,scale] = ParseScale(parms);
if Error, return; end
[parms,present,ps] = ParseSpecial(parms,'window');  if present, window = nsingle(ps{1});  else,Error('hist needs window'); return; end
[parms,present,ps] = ParseSpecial(parms,'binning'); if present, binning = rsingle(ps{1}); else,Error('hist needs binning'); return; end
[parms,present,ps] = ParseSpecial(parms,'reduce');  if present, reduce  = rsingle(ps{1}); else,Error('reduce is needed'); return; end
[parms,present,ps] = ParseSpecial(parms,'margin');  if present, margin  = rsingle(ps{1}); else,margin = []; end
[parms,present,ps] = ParseSpecial(parms,'limit');   if present, limits  = rsingle(ps{1}); else,limits = [-inf inf]; end
[parms,tijden] = ParseTijd(parms,'range',1);        if isempty(tijden), tijden = [-inf,inf]; end
[parms,~,mets,swps] = ParseList(parms);
metnr = mets(1);
swpnr = swps(1);
if isempty(metnr), Error('hist needs mets'); end
[~,present,ps] = ParseSpecial(parms,'adcs'); 
if present
    kanaal = nsingle(ps{1});
    schaling = Meting(metnr).ADC.scale(kanaal).User/Meting(metnr).ADC.ints;
    unit     = Meting(metnr).ADC.scale(kanaal).Units;
    if isinf(tijden)
        values = double(Meting(metnr).adc(1:reduce:end,kanaal,swpnr)) * schaling;
        mmm1   = mean(double(Meting(metnr).adc(1:end,kanaal,swpnr)))  * schaling;
        mmm2   = std(double(Meting(metnr).adc(1:end,kanaal,swpnr)))  * schaling;
    else
        dlen   = (length(Meting(1).adc)-1)*1000/spikes.adcrate;
        bgn    = 1+round((max(tijden(1),panels.zoom.tnul     ) - panels.zoom.tnul)*spikes.adcrate/1000);
        lst    = 1+round((min(tijden(2),panels.zoom.tnul+dlen) - panels.zoom.tnul)*spikes.adcrate/1000);
        values = double(Meting(metnr).adc(bgn:reduce:lst,kanaal,swpnr)) * schaling;
    end
else
    return
end
[nout,xout] = hist(values,round((max(values)-min(values) )/binning));
warning off
[h0,p1] = lillietest(values);
if h0, liltest = 'Accept'; else,liltest = 'Reject'; end
warning on
[mu,sigma,muci,sigmaci] = normfit(values);
mum = median(values);
mur = 0.5 * iqr(values);
yy1 = normpdf(xout,mu,sigma);
yy1 = yy1 *sum(nout)/sum(yy1);
[sxmin,sxmax] = scalexy(scale.x,scale.dx,min(xout),max(xout));
getplothandle(window(1),true);
if strcmp(scale.logy,'log')
    bar(xout,log10(nout),1,'b','EdgeColor','w');
    [symin,symax] = scalexy(scale.y,scale.dy,2,max(log10(2*nout)));
    axis([sxmin sxmax symin symax]);
    line(xout,log10(yy1),'LineStyle','-','Color','r','LineWidth',2);
else
    bar(xout,nout,1,'b','EdgeColor','w');  % 'FaceColor','b','EdgeColor','w','LineStyle','-','LineWidth',2
    [symin,symax] = scalexy(scale.y,scale.dy,0,1.1 * max(nout));
    axis([sxmin sxmax symin symax]);
    line(xout,yy1,'LineStyle','-','Color','r','LineWidth',2);
end
txt = [sprintf('\nPeak amplitude distribution analysis (n=%u, reduced by %u\n\n%s normality (lillietest): p = %0.4f ) ',length(values),reduce,liltest,p1) ...
       '\color{blue}' sprintf('\n\nmedian & interquartile range: %0.2f (%0.2f : %0.2f) %s ',mum,mum-mur,mum+mur,unit) ...
        '\color{red}' sprintf('\n\nnormal fit mu: %0.2f (%0.2f : %0.2f) %s ',mu,muci(1),muci(2),unit) ...
                      sprintf('\nsigma: %0.2f (%0.2f : %0.2f) %s ',sigma,sigmaci(1),sigmaci(2),unit)];
dofit = false;
if ~isempty(margin)
    dd1 = mum-mur*margin;
    dd2 = mum+mur*margin;
    dofit = true;
elseif ~isinf(limits)
    dd1 = limits(1);
    dd2 = limits(2);
    dofit = true;
end
if dofit
    pf_truncnorm = @(x,mua,sigmaa) normpdf(x,mua,sigmaa)./(normcdf(dd2,mua,sigmaa)-normcdf(dd1,mua,sigmaa));
    values2 = values((values>dd1)&(values<dd2));
    [normres,normci] = mle(values2,'pdf',pf_truncnorm,'start',[mu sigma],'lower',[-inf 0]);
    yy2 = normpdf(xout,normres(1),normres(2));
    die = find((xout>dd1)&(xout<dd2));
    yy2 = yy2 * sum(nout(die))/sum(yy2(die));
    dgain = max(yy2);
    hlp = abs(double(nout)-yy2)./(yy2+double(nout));
    fraction = 0.99;
    hh1 = find(hlp<fraction);
    if hh1(1)==1, dhh1 = xout(1); else,dhh1 = xout(hh1(1)-1); end
    if hh1(end)<length(xout), dhh2 = xout(hh1(end)+1); else, dhh2 = xout(end); end
    if strcmp(scale.logy,'log')
        line(xout,log10(yy2),'LineStyle','-','Color','m','LineWidth',2)
        tmp = nout(xout<dd1)-yy2(xout<dd1);
        tmp(tmp<100) = 100;
        line(xout(xout<dd1),log10(tmp),  'LineStyle','-','Color','g','LineWidth',2)
        tmp = nout(xout>dd2)-yy2(xout>dd2);
        tmp(tmp<100) = 100;
        line(xout(xout>dd2),log10(tmp),  'LineStyle','-','Color','g','LineWidth',2)
        line(xout,log10(dgain * hlp),                               'LineStyle',':','Color','k','LineWidth',2)
        line([sxmin sxmax],log10(dgain*fraction)*[1 1],             'LineStyle','-','Color','k','LineWidth',1)
        ytext = log10(dgain*0.98);
    else
        line(xout,yy2,'LineStyle','-','Color','m','LineWidth',2)
        line(xout(xout<dd1),(nout(xout<dd1)-yy2(xout<dd1)),  'LineStyle','-','Color','g','LineWidth',2)
        line(xout(xout>dd2),(nout(xout>dd2)-yy2(xout>dd2)),  'LineStyle','-','Color','g','LineWidth',2)
        line(xout,dgain * hlp,                               'LineStyle',':','Color','k','LineWidth',2)
        line([sxmin sxmax],dgain*fraction*[1 1],             'LineStyle','-','Color','k','LineWidth',1)
        ytext = dgain*0.98;
    end
    line([dd1  dd1  NaN dd2  dd2], [symin symax NaN symin symax],'LineStyle','--','Color','m');    
    line([dhh1 dhh1 NaN dhh2 dhh2],[symin symax NaN symin symax],'LineStyle','--','Color','g');
    text(sxmin,ytext,sprintf(' %0.1f%% outside',100*fraction),'HorizontalAlignment','Left','Fontsize',9,'Fontname','Courier');
    
    txt = [txt '\color{magenta}' sprintf('\n\nfit distribution on %0.1f * iqr: (%0.2f : %0.2f) %s ',margin,dd1,dd2,unit) ...
                                 sprintf('\nfractional fit mu: %0.2f (%0.2f : %0.2f) %s ',normres(1),normci(1,1),normci(2,1),unit) ...
                                 sprintf('\nsigma: %0.2f (%0.2f : %0.2f) %s ',normres(2),normci(1,2),normci(2,2),unit) ...
               '\color{green}'   sprintf('\n\nboundaries for %0.1f %% exclusion (%0.2f : %0.2f) %s ',100*fraction,dhh1,dhh2,unit)];
end
text(sxmax,symax,txt,'HorizontalAlignment','Right','VerticalAlignment','Top','Fontsize',9,'Fontname','Courier');
drawnow

function showlegend(txt)
xx = get(gca,'XLim');
yy = get(gca,'Ylim');
text(xx(1),yy(2),txt,'HorizontalAlignment','Left','VerticalAlignment','Top','Fontsize',10,'Fontname','Courier');

function org = dispnames(node)
org = fieldnames(node);
for jj = 1:length(org)
    if iscell(node.(org{jj}))
        org{jj} = ['{} ',org{jj}];
    elseif isstruct(node.(org{jj}))
        org{jj} = ['>> ',org{jj}];
    elseif isnumeric(node.(org{jj}))
        org{jj} = ['[] ',org{jj}];
    elseif islogical(node.(org{jj}))
        org{jj} = ['00 ',org{jj}];
    else
        org{jj} = ['   ',org{jj}];
    end
end

function [p1,p2] = findlabels(STAT)
global Log
[n1,n2] = size(Log.matlab);
for p1 = 1:n1
    for p2 = 1:n2
        for main = fieldnames(Log.matlab{p1,p2})'
            if strcmp(main{1},STAT.main.String)
                if strcmp(Log.matlab{p1,p2}.(main{1}).basis.label{1},STAT.label1.String) &&...
                   strcmp(Log.matlab{p1,p2}.(main{1}).basis.label{2},STAT.label2.String)
                    STAT.extra.String = sprintf('first: [%u,%u]',p1,p2);
                    return
                end
            end
        end
    end
end

function result = STATcollect(STAT)
global Log
result = struct('vals',[],'grps',[],'dier',[],'stdp',[],'stim',[],'lbl1',[],'lbl2',[]);
main = STAT.main.String;
sub  = STAT.sub.String;
strings1 = STAT.label1.UserData.string; slen1 = length(strings1);
strings2 = STAT.label2.UserData.string; slen2 = length(strings2);
select1  = STAT.label1.UserData.select;
select2  = STAT.label2.UserData.select;
cnt  = 0;
for j1 = 1:size(Log.matlab,1)
    for j2 = 1:size(Log.matlab,2)
        if isfield(Log.matlab{j1,j2},main) && isfield(Log.matlab{j1,j2}.(main),sub)
            idx1 = find(strcmp(Log.matlab{j1,j2}.(main).basis.label{1},strings1));
            idx2 = find(strcmp(Log.matlab{j1,j2}.(main).basis.label{2},strings2));
            if any(select1==idx1) && any(select2==idx2)
                val = Log.matlab{j1,j2}.(main).(sub);
                if ~isnan(val(1))
                    cnt = cnt + 1;
                    if length(val)>1, result.vals{cnt,1} = val; else, result.vals(cnt,1) = val; end
                    result.grps(cnt,1) = slen2*(idx1-1)+idx2;
                    result.dier(cnt,1) = Log.animal(j1,1);
                    result.stdp(cnt,1) = Log.subset(j1,1);
                    result.stim(cnt,1) = Log.matlab{j1,1}.(main).testamp;
                    result.lbl1{cnt,1} = strings1{idx1};
                    result.lbl2{cnt,1} = strings2{idx2};
                end
            end
        end
    end
end
names = fieldnames(result);
for jj = 1:2
    if jj==1, [~,idx] = sort(result.lbl2); else, [~,idx] = sort(result.lbl1); end
    for jjj = 1:length(names), result.(names{jjj}) = result.(names{jjj})(idx); end
end

function STATtree(STAT,handle,node)
names = fieldnames(node);
if (handle.UserData.select>length(names)) || ~strcmp(names{handle.UserData.select},handle.String)
    if ~handle.UserData.protect
        handle.UserData.select = min(handle.UserData.select,length(names));
        handle.UserData.string = names;
        handle.UserData.disp   = dispnames(node);
    end
    handle.String = names{handle.UserData.select};
    handle.Visible = 'on';
end
datnode = node.(handle.String);
if isstruct(datnode)
    handle.UserData.child.Visible = 'on';
    STATtree(STAT,handle.UserData.child,datnode);
elseif iscell(datnode)
    vis.subidx = true;
    STAT.subidx.String   = [];
    STAT.subidx.UserData = [];
    for jj = 1:length(lognode)
        if ~isempty(lognode{jj})
            STAT.subidx.String  {end+1,1} = sprintf(' %u',jj);
            STAT.subidx.UserData(end+1,1) = jj;
        end
    end
    STAT.subidx.Value = min(STAT.subidx.Value, size(STAT.subidx.String,1));
    if strcmp(sub,'fitter')
        vis.par1   = true;
        vis.subfit = true;
        lognode = lognode{str2double(STAT.subidx.String{STAT.subidx.Value})};
        STAT.subfit.String = lognode.model;
        fitpar = STATtext(STAT.par1,lognode);
        if strcmp(fitpar,'v')
            vis.paridx = true;
            STAT.paridx.String = lognode.names;
            index = intersect(STAT.paridx.Value ,1:size(STAT.paridx.String,1));
            if isempty(index), STAT.paridx.Value = 1; else, STAT.paridx.Value = index; end
            datnode = lognode.v(index);
        else
            datnode = lognode.(fitpar);
        end
    else
        cellindex = str2double(STAT.subidx.String{STAT.subidx.Value});
        datnode = lognode{cellindex};
        if isstruct(datnode)
            vis.par1 = true;
            par = STATtext(STAT.par1,lognode);
            handle = STAT.par1;
            datnode = lognode.(par);
        end
    end
elseif isnumeric(datnode) || islogical(datnode)    % geen struct of cell, dan een array....
    [n1,n2] = size(datnode);
    STAT.data.UserData = [];
    mynode = handle.UserData.child;
    while ~isempty(mynode)
        mynode.Visible = 'off';
        mynode = mynode.UserData.child;
    end
    if isempty(datnode)
        STAT.data.String = 'empty';
    elseif ischar(datnode)
        STAT.data.String = sprintf('%s',datnode); 
    elseif iscell(datnode)
        STAT.data.String = sprintf('%s',datnode{1});
    elseif length(datnode)==1
        if isnumeric(datnode)
            STAT.data.String = sprintf('%0.4f   ',datnode);
            STAT.data.UserData = STATcollect(STAT);
        elseif islogical(datnode)
            STAT.data.String = sprintf('%u   ',datnode);
        end
    elseif (size(datnode,2)==2) && (size(datnode,1)>1)
        STAT.data.String = sprintf('curves %u  * %u',size(datnode));
        STAT.data.UserData = STATcollect(STAT);
    elseif isnumeric(datnode) || islogical(datnode)
        [n1,n2] = size(datnode);
        if isstruct(handle.UserData.parent)
            strings = fieldnames(handle.UserData.parent);
            select  = handle.UserData.select;
        else
            select{1} = 'none';
        end
        if n2>1
            STAT.data.String = sprintf('sweeps %u x %u',n1,n2);
        else
            STAT.data.String = sprintf('array %u x %u',n1,length(select));
        end
        hlp = [];
        for jj = 1:length(select)
            if isstruct(handle.UserData.parent)
                name = strings{select(jj)};
                value = handle.UserData.parent.(name)(1,1);
            else
                name = sprintf('%9s{%02u} ',handle.String,cellindex);
                value = 3.14;
            end
            if islogical(value)
                hlp = sprintf('%s%7s',hlp,name);
            else
                hlp = sprintf('%s %12s ',hlp,name);
            end
        end
        mytxt{1,1} = hlp;
        for j1 = 1:n1
            hlp = [];
            for jj = 1:length(select)
                if isstruct(handle.UserData.parent)
                    value = handle.UserData.parent.(strings{select(jj)})(j1,1);
                else
                    value = handle.UserData.parent{cellindex}(j1,1);
                end
                if islogical(value)
                    hlp = sprintf('%s   %1u   ',hlp,value);
                else
                    hlp = sprintf('%s %12.5f ',hlp,value);
                end
            end
            mytxt{j1+1,1} = hlp;
        end
        mytxt{end+1,1} = '';
        STAT.data.UserData = mytxt;
    end
end

function STATxy(STAT,dat)
dostim = false;
switch STAT.sub.String
    case 'ImNspk',xlimit = [0,500];
    case 'Samax', xlimit = [0,1010]; dostim = true; stim = [];
    case 'Skkw',  xlimit = [0,1010]; dostim = true; stim = [];
    otherwise,    xlimit = [-65,-30];
end
WindowClear;
handle = getplothandle(9,true);
nrs = unique(dat.grps)';
kleur = 'rbgmrbgm';
soort = '----::::';
lgd = [];
xas = (xlimit(1):(diff(xlimit)/500):xlimit(2))';
for iii = 1:length(nrs)
    grp = nrs(iii);
    if KnobIsRed(STAT.select)
        idx = find((dat.grps==grp) & (dat.stdp==1));
    else
        idx = find(dat.grps==grp);
    end
    hlp  = [];
    cnt  = 1;
    for jj = 1:length(idx)
        xind = dat.vals{idx(jj)}(:,1);
        yind = dat.vals{idx(jj)}(:,2);
        valid = ~isnan(xind) & ~isnan(yind);
        if isempty(valid) || sum(valid)<2, continue; end
        hlp(:,cnt) = interp1(xind(valid),yind(valid),xas,'linear');
        if dostim, stim(cnt,1) = dat.stim(idx(jj)); end
        cnt = cnt + 1;
    end
    [n1,n2] = size(hlp);
    for jj =1:n2
        last = find(~isnan(hlp(:,jj)),1,'last');
        if last<n1, hlp(last:end,jj) = hlp(last,jj); end
    end
    len = size(hlp,2);
    if STAT.outlier.Value
        yerror = zeros(len,1);
        ymid   = mean(hlp,2,'omitnan');
        for jj = 1:len, yerror(jj) = nansum((hlp(:,jj)-ymid).^2); end
        valid  = ~isoutlier(yerror);
        hlp = hlp(:,valid);
        if dostim, stim = stim(valid); end
        len = size(hlp,2);
    end
    yas{iii}  = mean(hlp,2,'omitnan');
    ystd{iii} = std(hlp,0,2,'omitnan');
    ysem{iii} = ystd{iii}/realsqrt(len);
    if dostim
        stmean(iii) = mean(stim);
        stsem(iii)  = std(stim,0)/realsqrt(len);
    end
    lgd{1,2*iii-1} = '';
    lgd{1,2*iii}   = sprintf('%s-%s (%u)',dat.lbl1{idx(1)},dat.lbl2{idx(1)},len);  
end
if length(nrs)==1
    plot(xas,hlp);
    y1 = yas{1}+ystd{1};
    y2 = yas{1}-ystd{1};
    patch([xas;xas(end:-1:1)],[y1;y2(end:-1:1)],[0.8 0.8 0.8],'Edgecolor' ,'none');
    line('XData',xas,'YData',yas{1},'Color',kleur(nrs(iii)),'LineStyle','-','LineWidth',2);
    h=legend('Location','northwest');
    h.FontSize = 12;
    h.String = lgd;
else
    for iii = 1:length(nrs)
        y1 = yas{iii}+ysem{iii};
        y2 = yas{iii}-ysem{iii};
        xhlp = xas(~isnan(y2));
        yhlp1 = y1(~isnan(y2));
        yhlp2 = y2(~isnan(y2));
        patch([xhlp;xhlp(end:-1:1)],[yhlp1;yhlp2(end:-1:1)],[0.7 0.7 0.7],'Edgecolor' ,'none');
        line('XData',xas,'YData',yas{iii},'Color',kleur(nrs(iii)),'LineStyle',soort(nrs(iii)),'LineWidth',2);
    end
    h =legend('Location','northwest');
    h.FontSize = 12;
    h.String = lgd;
end
if STAT.yfix.Value
    handle.YLim = [str2double(STAT.ymin.String), str2double(STAT.ymax.String)];
else
    STAT.ymin.String = sprintf('%0.1f',handle.YLim(1));
    STAT.ymax.String = sprintf('%0.1f',handle.YLim(2));
end
if dostim
    dy = diff(handle.YLim);
    for ii = 1:length(nrs)
        dy = 0.975*dy;
        ybar = handle.YLim(1) + dy;
        line('XData',stmean(ii)-stsem(ii)*[-1,1],'YData',ybar*[1,1],'Color',kleur(nrs(ii)),'LineStyle',soort(nrs(ii)),'LineWidth',1.5);
        line('XData',stmean(ii),'YData',ybar,'Color',kleur(nrs(ii)),'Marker','o','LineWidth',5);
    end
end
correctorder(handle);

function STATval(STAT,dat)
if STAT.outlier.Value
    invalid = false(size(dat.vals,1),1);
    lbl1 = unique(dat.lbl1);
    lbl2 = unique(dat.lbl2);
    for j1 = 1:length(lbl1)
        for j2 = 1:length(lbl2)
            select = strcmp(dat.lbl1,lbl1{j1}) & strcmp(dat.lbl2,lbl2{j2});
            invalid(select) = isoutlier(dat.vals(select));
        end
    end
    names = fieldnames(dat);
    for jj = 1:length(names), dat.(names{jj}) = dat.(names{jj})(~invalid); end
    if isempty(dat), return; end
end
lbl1 = unique(dat.lbl1);
lbl2 = unique(dat.lbl2);
nl1  = length(lbl1);
nl2  = length(lbl2);
if (nl1>1) && (nl2>1)
    modus = 1;
    grps = {dat.lbl1,dat.lbl2}';
elseif nl1>1
    modus = 2;
    grps = {dat.lbl1};
    varname = {'type'};
elseif nl2>1
    modus = 3;
    grps = {dat.lbl2};
    varname = {'age'};
else
    winnr = str2double(STAT.box.String);
    if winnr==0, return; end
    WindowClear;
    set([STAT.panel1,STAT.panel2],'String','');
    ltxt = [lbl1{1},' - ',lbl2{1},' - ',STAT.sub.String];
    handle = getplothandle(9,true);
    Norg = length(dat.vals);
    [myavg,mystd,mysem,N] = mymean(dat.vals);
    etxt = sprintf(' (n=%u of %u) ',N,Norg);
    warning off
    [~,ksp] = kstest((dat.vals-myavg)/mystd);
    if length(dat.vals)>3, [~,ltp] = lillietest(dat.vals); else, ltp = NaN; end
    warning on
    h1 = histogram(dat.vals);
    h1.NumBins = max(h1.NumBins,10);
    if KnobIsRed(STAT.select) && (sum(dat.stdp)>0)
        hold on
        h2 = histogram(dat.vals(dat.stdp==1));
        binwidth = min(h1.BinWidth,h2.BinWidth);
        h1.BinWidth = binwidth;
        h2.BinWidth = binwidth;
        [h,p] = ttest2(dat.vals(dat.stdp==0),dat.vals(dat.stdp==1));
        if ~isnan(h), etxt = ['\color{blue}', sprintf(' rest (n=%u) versus select(n=%u): p=%5.3f',Norg-N,length(dat.vals(dat.stdp==1)),p)]; end
    end
    handle.YLim(2) = 1.2 * handle.YLim(2);
    [mu,sigma,muci,sigmaci] = normfit(dat.vals);
    hlp = 0.5*(h1.BinEdges(1:end-1)+h1.BinEdges(2:end));
    yhlp = normpdf(hlp,mu,sigma);
    xhlp = h1.Values;
    schaal = sum(xhlp.*yhlp)/sum(yhlp.*yhlp);
    xxx = handle.XLim(1):(diff(handle.XLim)/200):handle.XLim(2);
    line(xxx,schaal*normpdf(xxx,mu,sigma),'LineStyle','-','Color','r','LineWidth',2);
    htxt = [sprintf(' %s ',ltxt), etxt,...
            '\color{black}', sprintf('\n mean-sem %0.3f(%0.3f), med: %0.3f, lillie/KS %0.2f/%0.2f',myavg,mysem,median(dat.vals),ltp,ksp),...
            '\color{red}',   sprintf('\n fit mu: %0.2f (%0.2f - %0.2f)',mu,muci(1),muci(2)), ...
                             sprintf(' sigma: %0.2f (%0.2f - %0.2f)',sigma,sigmaci(1),sigmaci(2))];
    text(handle.XLim(1),handle.YLim(2),htxt,'HorizontalAlignment','Left','VerticalAlignment','Top','Fontsize',14,'Fontname','Courier');
    return
end
WindowClear(9);
if KnobIsRed(STAT.select)
    valid = dat.stdp==1;
    names = fieldnames(dat);
    for jj = 1:length(names)
        dat.(names{jj}) = dat.(names{jj})(valid);
    end
    switch modus
        case 1, grps = {dat.lbl1,dat.lbl2}';
        case 2, grps = {dat.lbl1};
        case 3, grps = {dat.lbl2};
    end
end
grp = unique(dat.grps)';
for jj = 1:length(grp)
    [dat.grpavg(jj),~,dat.grpsem(jj),dat.grpN(jj)] = mymean(dat.vals(dat.grps==grp(jj)));
    dat.grpD(jj) = length(unique(dat.dier(dat.grps==grp(jj))));
end
boxwindow = round(str2double(STAT.box.String));
if boxwindow>0
    if modus==1
        handle =  getplothandle(9,true);
        boxplot(handle,dat.vals,grps,'notch','on','whisker',1,'symbol','ro','FactorGap',[10,0]);
        handle.Position([2,4]) = [0.05 0.85];
    else
        handle =  getplothandle(boxwindow,true);
        boxplot(handle,dat.vals,grps,'notch','on','whisker',1,'symbol','ro');
    end
    if STAT.yfix.Value
        handle.YLim = [str2double(STAT.ymin.String), str2double(STAT.ymax.String)];
    else
        STAT.ymin.String = sprintf('%0.1f',handle.YLim(1));
        STAT.ymax.String = sprintf('%0.1f',handle.YLim(2));
    end
end
if modus==1
    [p,tbl,stats,terms] = anovan(dat.vals,{dat.lbl2,dat.lbl1},'nested',[0,0;1,0],'varnames',{'age','type'});
    hhh = gcf;
    STAT.panel1.ListboxTop = 1;
    tmp = string(hhh.Children(3).String);
    tmp(end) = [];
    tmp(end) = ' ';
    delete(hhh);
    STAT.panel1.Visible = 'on';
    [p,tbl,stats,terms] = anovan(dat.vals,grps,'nested',[0,0;1,0],'varnames',{'type','age'});
    hhh = gcf;
    hlp = string(hhh.Children(3).String);
    delete(hhh);
    for jj = 3:size(hlp,1), tmp(end+1) = hlp(jj); end
    STAT.panel1.Max   = size(tmp,1);
    STAT.panel1.Min   = 1;
    STAT.panel1.Value = 2;
    STAT.panel1.String = tmp;
else
    [p,tbl,stats,terms] = anovan(dat.vals,grps,'varnames',varname);
    hhh = gcf;
    STAT.panel1.ListboxTop = 1;
    STAT.panel1.Max    = hhh.Children(3).Max;
    STAT.panel1.Min    = hhh.Children(3).Min;
    STAT.panel1.String = string(hhh.Children(3).String);
    delete(hhh);
    STAT.panel1.Visible = 'on';
    if round(str2double(STAT.cmp.String))>0
        figure(2);
        [c,m,h,nms] = multcompare(stats);
        pos = h.Parent.ScreenSize;
        h.Position = round([pos(3),1.47*pos(4),pos(3),pos(4)]/3);
        h.Tag = 'multicompare';
    end
end
tmp = [];
format = '%14s';
tmp{1,1} = sprintf('%3s','');
for jj = 1:nl2
    txt = sprintf('%10s',lbl2{jj});
    tmp{1} = [tmp{1}, sprintf(format,txt)];
end
for j1 = 1:nl1
    tmp{2*j1,1}   = sprintf('%6s',lbl1{j1});
    tmp{2*j1+1,1} = sprintf('%3s','');
    for j2 = 1:nl2 
        idx = j2+(j1-1)*nl2;
        txt1 = [strip(sprintf('%6.2f%s%-6.2f',dat.grpavg(idx),char(177),dat.grpsem(idx))) ];
        txt2 = [strip(sprintf('(%u/%u)',dat.grpN(idx),dat.grpD(idx))) ];
        tmp{2*j1,1}   = [tmp{2*j1,1},   sprintf(format,txt1)];
        tmp{2*j1+1,1} = [tmp{2*j1+1,1}, sprintf(format,txt2)];
    end
end
STAT.panel2.String = tmp;

function STAT_Callback(hObject,~)
global Log panels
STAT = getPANEL('STATpanel');
switch hObject
    case STAT.close,             delete(STAT.handle); return;
    case STAT.data,              if ~isempty(STAT.data.UserData), textpanel(STAT.data.UserData,'selected data'); end; return
    case {STAT.subidx,           STAT.paridx}
    case {STAT.ymin,STAT.ymax},  STAT.yfix.Value = true;
    case STAT.select,            ToggleRed_Callback(hObject);
    case {STAT.label1, STAT.label2, STAT.main, STAT.sub, STAT.par1, STAT.par2}
        [~,hlp] = ParseSelect(string(hObject.UserData.disp), hObject.UserData.select,"Select the elements");
        if isempty(hlp), return; else
            hObject.UserData.select = hlp;
            hObject.String = hObject.UserData.string{min(hlp)};
            if length(hObject.UserData.select)==1
                hObject.BackgroundColor = panels.color.wit;
            elseif length(hObject.UserData.string)==length(hObject.UserData.select)
                hObject.BackgroundColor = panels.color.green;
            else
                hObject.BackgroundColor = panels.color.blue;
            end
        end
end
[p1,p2] = findlabels(STAT);
STATtree(STAT, STAT.main, Log.matlab{p1,p2})
if isempty(STAT.data.UserData), return; end
dat = STAT.data.UserData;
set([STAT.panel1,STAT.panel2],'String','');
if iscell(dat.vals)
    STATxy(STAT,dat)
else
    STATval(STAT,dat)
end


function mains = DoStatistics
global Log
if isempty(Log.matlab), return; end
STAT = getPANEL('STATpanel'); if ~isempty(STAT), delete(STAT.handle); end
STAT = Openpanel('STATpanel',@STAT_Callback);
[~,STAT.dbase.String] = fileparts(Log.dbase);
KnobGrey(STAT.select);
%
% verzamel alle labels die er in de Log file zitten en zet in de selectie
%
for jj = 1:2
    if jj==1, name = "label1"; else, name = "label2"; end
    hlp = [];
    mains = [];
    for j1 = 1:size(Log.matlab,1)
        for j2 = 1:size(Log.matlab,2)
            names = fieldnames(Log.matlab{j1,j2});
            mains = unique([mains; names]);
            for j0 = 1:length(names)
                if ~strcmp(hlp,Log.matlab{j1,j2}.(names{j0}).basis.label{jj})
                    hlp{end+1,1} = Log.matlab{j1,j2}.(names{j0}).basis.label{jj};
                end
            end
        end
    end
    STAT.(name).UserData.string  = sort(hlp);
    STAT.(name).UserData.disp    = STAT.(name).UserData.string;
    STAT.(name).UserData.select  = 1;
    STAT.(name).UserData.protect = true;
    STAT.(name).String           = STAT.(name).UserData.string{STAT.(name).UserData.select};
    STAT.(name).Visible          = 'on';
end

function doTamar(parms)
global Log
STAT = getPANEL('STATpanel'); if ~isempty(STAT), delete(STAT.handle); end
WindowClear;
CMD        = getPANEL('CMDpanel');
Waitbar(CMD,'show',1,'open dbase');
tmp        = Log.master;
Log.master = true;
dbasenaam  = ssingle(parms{1});
DoLogger(CMD,{'load'},dbasenaam);
Log.master = tmp;
Waitbar(CMD,'show',1,'convert and add');
Tamar;
Waitbar(CMD,'show',1,'open statistics');
mains = DoStatistics;
STAT = getPANEL('STATpanel');
findlabels(STAT);
%
idx = strcmp(mains,'percell');
if sum(idx)>0, mains = [mains(idx); mains(~idx)]; end
STAT.main.UserData.string  = mains;
STAT.main.UserData.disp    = mains;
STAT.main.UserData.select  = 1;
STAT.main.UserData.protect = true;
STAT.main.String           = mains{STAT.main.UserData.select};
STAT.main.Visible          = 'on';
%
subs = fieldnames(Log.matlab{1}.percell);
STAT.sub.UserData.string  = subs;
STAT.sub.UserData.disp    = subs;
STAT.sub.UserData.select  = 2;
STAT.sub.UserData.protect = true;
STAT.sub.String           = subs{STAT.sub.UserData.select};
STAT.sub.Visible          = 'on';
%
set([STAT.par1, STAT.par2, STAT.paridx, STAT.subidx, STAT.subfit],'Visible','off');
Waitbar(CMD,'hide'); 
%
% =========================================================================
%
function DoStat(parms)
global Meting
color = 'brmcgkyw';
dobox = [];
docmp = [];
dokrs = [];
doreg = [];
[parms,scale]      = ParseScale(parms);
[parms,present,ps] = ParseSpecial(parms,'box'); if present, dobox = nsingle(ps{1}); end
[parms,present,ps] = ParseSpecial(parms,'cmp'); if present, docmp = nsingle(ps{1}); end
[parms,present,ps] = ParseSpecial(parms,'krs'); if present, dokrs = nsingle(ps{1}); end
[parms,present,ps] = ParseSpecial(parms,'reg'); if present, doreg = nsingle(ps{1}); end
[~,present,ps] = ParseSpecial(parms,'source');  if ~present, Error('Stats needs source'); return; end
[~,data] = fetchdata(ps,Meting); if Error, return; end
yyy  = [];
stat = [];
for ii = 1:length(data.yas)
    tmp = data.yas{ii};
    tmp = tmp(~isnan(tmp));
    par.name = data.ytxt{ii};
    [par.mean, par.std, par.sem, par.num] = mymean(tmp);
    warning off
    [par.ksh,par.ksp] = kstest((tmp-par.mean)/par.std);
    [par.lth,par.ltp] = lillietest(tmp);
    warning on
    par.median = median(tmp);
    par.iqr    = iqr(tmp);
    par.mode   = mode(tmp);
    stat{ii,1} = par;
    yyy {ii,1} = tmp;
end
yval = [];
ygrp = [];
for ii = 1:size(yyy,1)
    yval = [yval; yyy{ii}];
    ygrp = [ygrp, ii * ones(1,length(yyy{ii}))];
    par = stat{ii,1};
    lbls{ii,1} = par.name;
    sl{ii,1} = sprintf(' %s n=%u',par.name,par.num);
    if par.ksh, tt = 'rejected'; else, tt = 'accepted'; end
    sl{ii} = sprintf('%s\n   normal distribution %s pks= %0.3f plt= %0.3f',sl{ii},tt,par.ksp,par.ltp);
    if par.ksh
        sl{ii} = sprintf('%s\n   median-iqr: %0.2f +- %0.2f',sl{ii},par.median,par.iqr); 
    else
        sl{ii} = sprintf('%s\n   mean-sem: %0.2f +- %0.2f',sl{ii},par.mean,par.sem);
    end
end
if ~isempty(dobox)
    handle = getplothandle(dobox,true);
    % special code to resolve a MATLAB Boxplot bug on scaling
    try
        uu  = get(gca,'Units');
        pp  = get(gca,'ActivePositionProperty');
        pos = get(gca,'Position');
        set(handle,'Units','pixels','ActivePositionProperty','outerposition');
        boxplot(handle,yval,ygrp,'notch','on','whisker',1,'labels',lbls,'symbol','ro');
        set(handle,'Units',uu,'ActivePositionProperty',pp,'Position',pos);
        ylims = get(gca,'YLim');
        [ylims(1),ylims(2)] = scalexy(scale.y,scale.dy,0,1.1 * ylims(2));
        set(gca,'YLim',ylims);
        showlegend(sl)
    catch
    end
end
if ~isempty(docmp)
    handle = getplothandle(docmp,true);
    xxmin = inf;
    xxmax = -inf;
    for ii = 1:size(yyy,1)
        [f1,xf1]  = ecdf(yyy{ii});
        [xx{ii},yy{ii}] = stairs(xf1,f1);
        xxmin = min([xxmin, xx{ii}(1)]);
        xxmax = max([xxmax, xx{ii}(end)]);
    end
    dx = 0.2 * (xxmax-xxmin);
    xxx = linspace(xxmin-dx,xxmax+dx,100);
    sl = [];
    for ii = 1:size(yyy,1)
        plot(xx{ii},yy{ii},color(ii));
        hold on
        plot(xxx,normcdf(xxx,stat{ii}.mean,stat{ii}.std),[color(ii),':']);
        hold on
        sl = [sl '\color' sprintf('{%s}\n %s n=%u, norm: p = %4.3f\n\n',colorname(ii),stat{ii}.name,stat{ii}.num,stat{ii}.ksp)];
    end
    hold off
    axis([xxmin-dx xxmax+dx 0 1.1]);
    if size(yyy,1)>1
        [h,p0,ci] = ttest2 (yyy{1},yyy{2});
        [p3,h]    = ranksum(yyy{1},yyy{2});
        [h,p4,k]  = kstest2(yyy{1},yyy{2});
        sl = [sl '\color{black}' sprintf('Compare %u against %u:',1,2),...
                                 sprintf('\n t-Test:             p=%0.5f',p0),...
                                 sprintf('\n Wilcoxon Rank sum:  p=%0.5f',p3),...
                                 sprintf('\n Kolmogorov-Smirnov: p=%0.5f',p4)];
        showlegend(sl)
    end
end
if ~isempty(dokrs)
    handle = getplothandle(dokrs,true);
	[p5,tbl,stat5] = kruskalwallis(yval,ygrp);
end
% if ~isempty(doanova)
%     horg = gcf;
%     handle = getplothandle(doano,true);
%     y1 = yyy{1};
%     y2 = yyy{2};
%     y3 = yyy{3};
%     [p,stat] = anova_rm({[y1' y1'] [y2' y2'] [y3' y3']});
%     minl = min([length(y1),length(y2),length(y3)]);
%     ttt = [y1(1:minl)', y2(1:minl)', y3(1:minl)'];
% 	  [p,tbl,statpar] = anova1(ttt);
%     figure(4);
%     [c,m,h,gnames] = multcompare(statpar);
%     figure(horg)
% end
if ~isempty(doreg)
    handle = getplothandle(doreg,true);
    hlp = data.xas{1}(:);
    yas = data.yas{1}(:);
    outs = [];
    n = length(hlp);
    xas = [ones(size(hlp)) hlp(:)];
    [B,BINT,R,RINT,STATS1] = regress(yas,xas);
    STATS2 = STATS1;
    txt2 = [];
%     if dooutlier
%         outs = find((RINT(:,1).*RINT(:,2))>=0);
%         if ~isempty(outs)
%             yas(outs) = [];
%             xas(outs,:) = [];
%             [B,BINT,R,RINT,STATS2] = regress(yas,xas);
%         end
%         txt1 = sprintf(', (excluded:%u)',length(outs));
%         txt2 = sprintf('(%0.3f)',STATS1(1));
%     end
    line(xas(:,2),yas,'Marker','o','MarkerSize',8,'LineStyle','none','Color','b','LineWidth',1);
    xlims = get(handle,'Xlim'); xlims(2) = 1.1*xlims(2);
    ylims = get(handle,'Ylim'); ylims(2) = 1.1*ylims(2);
    set (handle,'XLim',xlims,'YLim',ylims)
    xlim = [min(xas(:,2)) max(xas(:,2))];
    line(xlims, B(2)*xlims + B(1),'Marker','none','MarkerSize',12,'LineStyle','-','Color','r','LineWidth',2);
%     if (BINT(2,1) * BINT(2,2))<=0
%         txt = 'regression n.s';
%     else
%         txt = 'sign regression:';
%     end
    sl =[sprintf('%s  vs  %s',data.ytxt{1},data.xtxt{1}),...
         sprintf('\n\n Regression\n     Slope: %4.3f, (%4.3f -- %4.3f)',B(2),BINT(2,1),BINT(2,2)),...
         sprintf('\n Intercept: %4.3f, (%4.3f -- %4.3f)',   B(1),BINT(1,1),BINT(1,2)),...
         sprintf('\n R^2(n=%u): %0.2f%s,  p=%0.3f (F-test)', length(hlp),STATS2(1),txt2,STATS2(3))];
    showlegend(sl)
end

% function DoSpikescan(cmd,parms)
% [parms,present,ps] = ParseSpecial(parms,'window');  if present, window = nsingle(ps{1}); end
% [parms,present,ps] = ParseSpecial(parms,'channel'); if present, chns = nsingle(ps{1}); end
% [parms,scale] = ParseScale(parms); 
% if Error, return; end
% [parms,sets,mets,swps]  = ParseList(parms);
% metnr = mets(1);
% kanaal = chns;
% tadc = Meting(metnr).ADC.rate/1000;
% if strcmp(cmd,'ScanPeaks')
%     nlen = round(rsingle(parms{1})*tadc);
% elseif strcmp(cmd,'ScanThreshold')
%     nlen = 0;
% else
%     return
% end
% spikes.adcchan = kanaal;
% spikes.abstime = Meting(metnr).abstime;
% spikes.adcrate = Meting(metnr).ADC.rate;
% spikes.adcunit = Meting(metnr).ADC.scale(kanaal).Units; 
% sadc           = Meting(metnr).ADC.scale(kanaal).User/Meting(metnr).ADC.ints;
% r1             = max(tijden(1),panels.zoom.tnul);
% r2             = min(tijden(2),panels.zoom.tnul+(length(Meting(metnr).adc)-1)/tadc);
% bgn            = 1+round((r1 - panels.zoom.tnul)*tadc);
% lst            = 1+round((r2 - panels.zoom.tnul)*tadc);
% Waitbar(CMD,'show',0,'Scan std man max');
% Restant        = Meting(metnr).adc(bgn:lst,kanaal);
% spikes.vstd    = sadc * double(std(single(Restant)));
% maxs           = sadc * double(max(Restant));
% mins           = sadc * double(min(Restant));
% xas = [];
% yas = [];
% if nlen==0
%     ttt = 'threshold';
%     levels = (2*spikes.vstd) : (0.5*spikes.vstd) : (maxs-mins);    
%     for jjj = 1:length(spikes.nlvl)
%         level   = int16(round(levels(jjj)/sadc));
%         k1      = (Restant(1:end-1)>level);
%         k2      = (Restant(1:end-1)<=level) & (Restant(2:end)>level);
%         Restant = Restant(k1|k2);
%         spikes.nspk = [spikes.nspk length(find( k2 ))];
%     end
% else
%     ttt = 'peak-peak';
%     kk1 = zeros(length(Restant)-nlen,1,'int16');
%     kk2 = zeros(length(Restant)-nlen,1,'int16');
%     for jjj = 1:length(Restant)-nlen
%         kk1 = max(Restant(jjj:jjj+nlen));
%         kk2 = min(Restant(jjj:jjj+nlen));
%     end
%     kkk(jjj) = uint16(int32(kk1)-int32(kk2));
%     kkk = zeros(length(Restant)-nlen+1,nlen,'int16');
%     for jjj = 1:nlen
%         Waitbar(CMD,'show',jjj/nlen,sprintf('generate %u',nlen-jjj));
%         kkk(:,jjj) = Restant(jjj:end+jjj-nlen);
%     end
%     kkk     = uint16(round(single( max(kkk,[],2))-single(min(kkk,[],2))));
%     levels  = uint16(round((0.5*spikes.vstd:(0.25*spikes.vstd):(maxs-mins))/sadc));
%     for jjj = 1:length(levels)
%         kkk(kkk<levels(jjj))=0;
%         numspk = length(find((kkk(1:end-1)<=0) & (kkk(2:end)>0)))-1;
%         if numspk<2, break; end
%         yas = [yas numspk];
%         xas = [xas 0.5+(jjj-1)*0.25];
%         Waitbar(CMD,'show',jjj/length(levels),sprintf('find %u spikes %u',numspk));
%     end
%     Waitbar(CMD,'hide');
% end
% if isempty(yas), return; end
% spikes.nlvl = xas*spikes.vstd;
% spikes.nspk = yas;
% spikes.nlvl(length(spikes.nspk)+1:end) = [];
% getplothandle(window(1),true);
% hh   = semilogy(xas,spikes.nspk,'ro');
% if isinf(scale.x(2)), sxmax =max(xas); else,sxmax = scale.x(2); end
% hlp = get(gca,'YLim'); symin = hlp(1); symax = hlp(2);
% axis([0 sxmax symin symax]);
% set(hh,'MarkerEdgeColor','b','MarkerFaceColor','c','Marker','o','MarkerSize',8);
% grid on
% hold on
% hlp     = nsingle(parms{2});
% [mm,p1] = max(yas);
% p2      = find(xas>hlp(1),1,'first')-1;
% yy = log10(spikes.nspk);
% p  = polyfit(xas(p1:p2),yy(p1:p2),2);
% yf = polyval(p,xas);
% h2 = plot(xas(p1:p2),10.^yf(p1:p2),'ro');
% set(h2,'MarkerSize',12);
% h3 = plot(xas,10.^yf,'r');
% spikes.fstd = xas(p2);
% text(sxmax,symax,sprintf('\n scan with %s algorithm \nsd = %8.2f \ndetection level= %0.2f * sd ',ttt,spikes.vstd,spikes.fstd),...
%      'HorizontalAlignment','Right','VerticalAlignment','Top','Fontsize',14,'Fontname','Courier');

function result = gettrgdrempel(source,channel,metnr,swpnr,bgn,lst,drmp,holdoff)
global Meting
if drmp(2)>drmp(1)
    if strcmp(source,'dac')
        result = bgn - 1 + find((Meting(metnr).dac(bgn:lst-1,channel)<=drmp(1)) & (Meting(metnr).dac(bgn+1:lst,channel)>drmp(1)));
    elseif strcmp(source,'adc')
        result = bgn - 1 + find((Meting(metnr).adc(bgn:lst-1,channel,swpnr)<=drmp(1)) & (Meting(metnr).adc(bgn+1:lst,channel,swpnr)>drmp(1)));
    end
else
    if strcmp(source,'dac')
        result = bgn - 1 + find((Meting(metnr).dac(bgn:lst-1,channel)>=drmp(1)) & (Meting(metnr).dac(bgn+1:lst,channel)<drmp(1)));
    elseif strcmp(source,'adc')
        result = bgn - 1 + find((Meting(metnr).adc(bgn:lst-1,channel,swpnr)>=drmp(1)) & (Meting(metnr).adc(bgn+1:lst,channel,swpnr)<drmp(1)));
    end
end
maxtrg = length(result);
if (maxtrg>1) && (holdoff>0)
    cnt = 1;
    for jj = 2:maxtrg
        if result(jj) >= (result(cnt)+holdoff)
            cnt = cnt + 1;
            result(cnt) = result(jj);
        end
    end
    if maxtrg>cnt, result((cnt+1):end) = []; end
end

% function DotrigClear(parms)
% global Meting spikes
% [parms,present,ps] = ParseSpecial(parms,'channel'); if present, kanaal = nsingle(ps{1}); end
% [parms,sets,mets,swps] = ParseList(parms);
% metnr = mets(1);
% for jj = 1:length(spikes.trg.trg1)
%     p1 = spikes.trg.trg1(jj);
%     a1 = Meting(metnr).adc(p1,kanaal,1);
%     p2 = spikes.trg.trg2(jj);
%     a2 = Meting(metnr).adc(p2,kanaal,1);
%     hlp = int16(round(double(a1) + double((p1:p2)-p1)*double(a2-a1)/double(p2-p1)));
%     Meting(metnr).adc(p1:p2,kanaal,1) = hlp;
% end

function showseizure(xas,channel,toff,nxmin,nxmax,gain,offset)
global panels seizure
if channel~=seizure.chn, return; end
select = find((seizure.peaks>nxmin)&(seizure.peaks<nxmax));
xas = seizure.peaks(select)*1000/(seizure.rate*panels.timegain);
line('XData',xas,'YData',seizure.amps(select) + offset,'Color','b',...
     'Markersize',14,'Marker','o','Linestyle','none','LineWidth',2);
xas =[seizure.bgn(select)'; seizure.end(select)'; NaN(1,length(select))]*1000/(seizure.rate*panels.timegain);
line('XData',xas(:),'YData',0*xas(:)+seizure.drempel + offset,'Color','b',...
     'Markersize',8,'Marker','s','Linestyle','--','LineWidth',2);

function Detect(parms,metingnr,swpnr)
global Meting panels spikes
[adclen,~,~] = size(Meting(metingnr).adc);
[parms,metreload]  = ParseSpecial(parms,'reload');
[parms,dosave]     = ParseSpecial(parms,'save');
[parms,holdoff]    = ParseTijd(parms,'holdoff',1);  if isempty(holdoff),holdoff = 0; end
[parms,margin]     = ParseTijd(parms,'margin',1);   if isempty(margin), margin = [0 0]; end
[parms,tijden]     = ParseTijd(parms,'range',1);    if isempty(tijden), tijden = [-inf,inf]; end
[parms,present,ps] = ParseSpecial(parms,'channel'); if present, kanaalnr = nsingle(ps{1}); else, kanaalnr = 1; end
[parms,present,ps] = ParseSpecial(parms,'modus');   if present, modus = ssingle(ps{1}); else, modus = 'all'; end
[parms,present,ps] = ParseSpecial(parms,'count');   if present, count = nsingle(ps{1}); else, count = 1; end
method = ssingle(parms{1});
spikes.method  = method;
if strcmp(method,'dactrg') || strcmp(method,'adctrg')
    [~,metdrem] = ParseSpecial(parms,'threshold');
    spikes.trg.lvl(1:2) = [0 inf];
    if metdrem
        hlp = rsingle(ps{1});
        if length(hlp)==1, if hlp>0, hlp = [hlp inf]; else,hlp = [hlp -inf]; end; end
        spikes.trg.lvl = hlp;
        if length(ps)>1
            hlp = rsingle(ps{2});
            if length(hlp)==1
                if hlp>=0, hlp = [hlp inf]; else,hlp = [hlp -inf]; end
            end
            spikes.trg.lvl(3:4) = hlp(1:2);
        end
    end
    spikes.trg.channel = 1;
    if ~isempty(kanaalnr), spikes.trg.channel = kanaalnr(1); end
    if strcmp(method,'dactrg')
        Meting(metingnr)  = DACexpand(Meting(metingnr));
        maxtrg = size(Meting(metingnr).dac,1);
        spikes.trg.unit   = Meting(metingnr).DAC.scale(spikes.trg.channel).Units;
        spikes.trg.rate   = Meting(metingnr).DAC.rate;
        strg              = Meting(metingnr).DAC.scale(spikes.trg.channel).User/Meting(metingnr).DAC.ints;
        spikes.trg.source = 'dac';
    else
        maxtrg = size(Meting(metingnr).adc,1);
        spikes.trg.unit   = Meting(metingnr).ADC.scale(spikes.trg.channel).Units;
        spikes.trg.rate   = Meting(metingnr).ADC.rate;
        strg              = Meting(metingnr).ADC.scale(spikes.trg.channel).User/Meting(metingnr).ADC.ints;
        spikes.trg.source = 'adc';
    end
    spikes.trg.range = panels.zoom.tnul + [0 maxtrg-1]*1000/spikes.trg.rate;
    trgdrempel = int16(min(double(intmax('int16')),max(double(intmin('int16')),round(spikes.trg.lvl/strg))));
    range   = 1+round((tijden-panels.zoom.tnul)*spikes.trg.rate/1000);
    bgn     = max(1,     range(1));
    lst     = min(maxtrg,range(2));
    spikes.sxminmax = panels.zoom.tnul + ([bgn lst] - 1) * 1000 / spikes.trg.rate;
    holdoff = round(holdoff * spikes.trg.rate/1000);
    margin  = round(margin  * spikes.trg.rate/1000);
    spikes.trg.trg1 = gettrgdrempel(spikes.trg.source,spikes.trg.channel,metingnr,swpnr,bgn,lst,trgdrempel(1:2),holdoff);
    if isempty(spikes.trg.trg1), Error('No trigs detected, check your parameters'); return; end
    if length(spikes.trg.lvl)<3
        spikes.trg.trg1 = spikes.trg.trg1 + margin(1);
        spikes.trg.trg2 = spikes.trg.trg1 + margin(2);
    else
        spikes.trg.trg2  = gettrgdrempel(spikes.trg.source,spikes.trg.channel,metingnr,swpnr,bgn,lst,trgdrempel(3:4),0);
        hlp1 = [spikes.trg.trg1; lst];
        hlp2 = spikes.trg.trg1;
        for jj = 1:length(hlp2)
            die = find((spikes.trg.trg2>=hlp1(jj))&((spikes.trg.trg2<hlp1(jj+1))));    
            if isempty(die) || (abs(count)>length(die))
                hlp2(jj) = NaN;
                spikes.trg.freq(jj,1) = 0;
            elseif count<0
                hlp2(jj) = spikes.trg.trg2(die(end+count+1));
                spikes.trg.freq(jj,1) = (length(die)+count)*spikes.trg.rate/(hlp2(jj)-hlp1(jj));
            elseif count>0
                hlp2(jj) = spikes.trg.trg2(die(count));
                spikes.trg.freq(jj,1) = (length(die)+count)*spikes.trg.rate/(hlp2(jj)-hlp1(jj));
            end
        end
        spikes.trg.trg1 = spikes.trg.trg1 + margin(1);
        spikes.trg.trg2 = hlp2            + margin(2);
    end
    return
end
[parms,burst]  = ParseTijd(parms,'burst',1);
[parms,sync]   = ParseTijd(parms,'sync',1);
[parms,search] = ParseTijd(parms,'search',1);  if isempty(search), search = 0; end
[parms,metdrem,psm] = ParseSpecial(parms,'threshold');
spikes.abstime = Meting(metingnr).abstime;
spikes.adcrate = Meting(metingnr).ADC.rate;
spikes.adcchan = kanaalnr;
spikes.adcunit = Meting(metingnr).ADC.scale(kanaalnr).Units;
sadc           = Meting(metingnr).ADC.scale(kanaalnr).User/Meting(metingnr).ADC.ints;
r1             = max(tijden(1),panels.zoom.tnul);
r2             = min(tijden(2),panels.zoom.tnul+(adclen-1)*1000/spikes.adcrate);
bgn            = 1+round((r1 - panels.zoom.tnul) * spikes.adcrate/1000);
lst            = 1+round((r2 - panels.zoom.tnul) * spikes.adcrate/1000);
spikes.sxminmax = panels.zoom.tnul + ([bgn lst] - 1) * 1000 / spikes.adcrate;
spikes.adcdrmp = [0 inf];
if metdrem
    if strfind(psm{1},'auto')
        spikes.adcdrmp(1) = spikes.fstd * spikes.vstd;
    elseif strfind(psm{1},'sd')
        spikes.vstd       = sadc * std(single(Meting(metingnr).adc(bgn:lst,kanaalnr,swpnr)));
        spikes.adcdrmp(1) = rsingle(strrep(psm{1},'sd',sprintf('%0.8f',spikes.vstd)));
    else
        hlp = rsingle(psm{1});
        if length(hlp)==1
            if hlp>0
                hlp = [hlp inf];
            else
                hlp = [hlp -inf];
            end
        end
        spikes.adcdrmp = hlp;
        if length(psm)>1
            hlp = rsingle(psm{2});
            if length(hlp)==1, if hlp>=0, hlp = [hlp inf]; else,hlp = [hlp -inf]; end; end
            spikes.adcdrmp(3:4) = hlp;
        end
    end
end
adcdrempel = int16(round((min(single(intmax('int16')),max (single(intmin('int16')),single(spikes.adcdrmp/sadc)) ))));
nlen  = round(search  * spikes.adcrate/1000);
if (nlen<4)||(nlen>999), Error(sprintf('Search range (%u) must be >2 & <1000 pnts',nlen)); return; end
nhold = round(holdoff * spikes.adcrate/1000);
kkk = zeros(lst-bgn+1-nlen,nlen,'int16');
for jjj = 1:nlen
    kkk(:,jjj) = Meting(metingnr).adc((bgn+jjj-1):(lst+jjj-1-nlen),kanaalnr,swpnr);
end
kkk = max(kkk,[],2)-min(kkk,[],2); 
kkk(kkk<adcdrempel(1))=0;
pbgn = find((kkk(1:end-1)<=0) & (kkk(2:end)>0));
if kkk(1)>0, pbgn = [1; pbgn]; end
plst = find((kkk(1:end-1)>0) & (kkk(2:end)==0));
if kkk(end)>0, plst = [plst; length(kkk)]; end
spikes.spktmax = zeros(length(pbgn),1);    
spikes.spkmax  = zeros(length(pbgn),1);
spikes.spktmin = zeros(length(pbgn),1);    
spikes.spkmin  = zeros(length(pbgn),1);
for jj=1:length(pbgn)
    bmax = max(kkk(pbgn(jj):plst(jj)));
    tmax = pbgn(jj)-1+find(kkk(pbgn(jj):plst(jj))==bmax);
    thlp = zeros(length(tmax),5);
    for j1 = 1:length(tmax)
        start = bgn-1+tmax(j1);
        [thlp(j1,2),tim1] = max(Meting(metingnr).adc(start:(start+nlen),kanaalnr,swpnr));
         thlp(j1,4)       = start-1+tim1;
        [thlp(j1,3),tim2] = min(Meting(metingnr).adc(start:(start+nlen),kanaalnr,swpnr));
         thlp(j1,5)       = start-1+tim2;
         thlp(j1,1)       = abs(tim2-tim1);
    end
    [~,index]        = sort(thlp(:,1));
    spikes.spkmax(jj)  = thlp(index(1),2);
    spikes.spktmax(jj) = thlp(index(1),4);
    spikes.spkmin(jj)  = thlp(index(1),3);
    spikes.spktmin(jj) = thlp(index(1),5);
end
% select on second threshold
if adcdrempel(2)<intmax('int16')
    exclude = find((spikes.spkmax - spikes.spkmin)>adcdrempel(2));
    if ~isempty(exclude)
        fprintf('detect: remove %u based on second threshold\n',length(exclude));
        spikes.spkmax(exclude)  = [];
        spikes.spktmax(exclude) = [];
        spikes.spkmin(exclude)  = [];
        spikes.spktmin(exclude) = [];
    end
end
% select for best direction
exclude  = [];
if strcmp(modus,'best')
    poscount = length(find((spikes.spktmin-spikes.spktmax)>0));
    negcount = length(find((spikes.spktmin-spikes.spktmax)<0));
    fraction = poscount/(poscount+negcount);
    if (fraction>0.2)&&(fraction<0.8), modus = 'all';
    elseif poscount>negcount,          modus = 'up';
    elseif negcount>poscount,          modus = 'down'; end
end
if strcmp(modus,'up'),       exclude = find((spikes.spktmin-spikes.spktmax)<0);
elseif strcmp(modus,'down'), exclude = find((spikes.spktmin-spikes.spktmax)>0);
end
if ~isempty(exclude)
    fprintf('detect: remove %u based on direction\n',length(exclude));
    spikes.spkmax(exclude)  = [];
    spikes.spktmax(exclude) = [];
    spikes.spkmin(exclude)  = [];
    spikes.spktmin(exclude) = [];
end
% select for minimal interval duration, keep largest
if nhold>0
    hlp = [[diff(round((spikes.spktmax+spikes.spktmin)/2)); inf] spikes.spkmax-spikes.spkmin];
    exclude = [];
    jj = 1;
    while jj<size(hlp,1)
        if hlp(jj,1)>nhold
            jj = jj + 1;
        else
           if hlp(jj,2)<hlp(jj+1,2)
               exclude = [exclude jj];
               jj = jj + 1;
           else
               if (hlp(jj,1)+hlp(jj+1,1))>nhold
                   exclude = [exclude jj+1];
                   jj = jj + 1;
               else
                   if hlp(jj,2)>hlp(jj+2,2)
                       exclude = [exclude jj+1 jj+2];
                       jj = jj + 2;
                   else
                       exclude = [exclude jj jj+1];
                       jj = jj + 2;
                   end
               end
           end
        end
    end
    if ~isempty(exclude)
        if ~isempty(exclude)
            fprintf('detect: remove %u based on holdoff\n',length(exclude));
            spikes.spkmax(exclude)  = [];
            spikes.spktmax(exclude) = [];
            spikes.spkmin(exclude)  = [];
            spikes.spktmin(exclude) = [];
        end
    end
end
spikes.spkmax  = spikes.spkmax*sadc;
spikes.spkmin  = spikes.spkmin*sadc;
spikes.spktlvl = spikes.spktmax;
spikes.spklvl  = spikes.spkmax;
spk1 = bgn-1+Crossings(Meting(metingnr).adc(bgn:lst,kanaalnr),adcdrempel(1:2),'interpol');
if strcmp(spikes.method,'spkdrm')
    nhold = round(holdoff * spikes.adcrate / 1000);
    spikes.spktmax = zeros(length(spk1),1);
    spikes.spktlvl = zeros(length(spk1),1);
    spikes.spkmax  = zeros(length(spk1),1);
    dspk = diff(spk1);
    cnt1 = 0;
    cnt2 = 0;
    while cnt1<length(spk1)
        cnt1 = cnt1 + 1;
        cnt2 = cnt2 + 1;
        bgn2 = spk1(cnt1);
        last = bgn2+nhold;
        cnt3 = 1;
        while (cnt1<length(spk1)) && (dspk(cnt1)<nhold)
            cnt1 = cnt1 + 1;
            cnt3 = cnt3 + 1;
            bgn2(cnt3) = spk1(cnt1);
            last = spk1(cnt1)+nhold;
        end
        if last>adclen, last = adclen; end
        if spikes.adcdrmp(2)>spikes.adcdrmp(1)
            [alim,tlim] = max(Meting(metingnr).adc(floor(bgn2(1)):ceil(last),kanaalnr,swpnr));
        else
            [alim,tlim] = min(Meting(metingnr).adc(floor(bgn2(1)):ceil(last),kanaalnr,swpnr));
        end
        tlim = floor(bgn2(1))-1+tlim;
        spikes.spktmax(cnt2) = tlim;
        spikes.spkmax (cnt2) = alim;
        if cnt3==1
            spikes.spktlvl(cnt2) = bgn2(1);
        else
            spikes.spktlvl(cnt2) = bgn2(find(bgn2<=tlim,1,'last'));
        end
    end
    spikes.spktmax = spikes.spktmax(1:cnt2);
    spikes.spkmax  = spikes.spkmax (1:cnt2);
    spikes.spktlvl = spikes.spktlvl(1:cnt2);
    if ~isinf(adcdrempel(2))
        if spikes.adcdrmp(2)>spikes.adcdrmp(1)
            select = find(spikes.spkmax<=adcdrempel(2));
        else
            select = find(spikes.spkmax>=adcdrempel(2));
        end
        spikes.spktmax = spikes.spktmax(select);
        spikes.spkmax  = spikes.spkmax (select);
        spikes.spktlvl = spikes.spktlvl(select);
    end
    spikes.spktmin = spikes.spktmax;
    spikes.spkmax  = spikes.spkmax*sadc;
    spikes.spklvl  = 0 * spikes.spkmax + spikes.adcdrmp(1);
    spikes.spkmin  = 0 * spikes.spkmax;
elseif strcmp(spikes.method,'event')
    if metreload,  CMDoffline(CMD,CMD.Reload,true); end
    nlen  = round(search  * spikes.adcrate / 1000);
    nhold = round(holdoff * spikes.adcrate / 1000);
    spikes.spkmax  = zeros(length(spk1),1);
    spikes.spktmax = zeros(length(spk1),1);
    spikes.spklvl  = zeros(length(spk1),1);
    spikes.spktlvl = zeros(length(spk1),1);
    diespikes      = find((spk1>nlen) & (spk1<(adclen-nlen)))';
    midden         = nlen+1;
    einde          = 2*nlen+1;
    numspikes = 0;
    for jj = diespikes
        gebied = Meting(metingnr).adc(floor(spk1(jj))+(-nlen:nlen),kanaalnr,swpnr);
        if spikes.adcdrmp(2)<spikes.adcdrmp(1)
            [amp,peak] = min(gebied(midden:einde));
            if amp<adcdrempel(2), continue; end
        else
            [amp,peak] = max(gebied(midden:einde));
            if amp>adcdrempel(2), continue; end
        end
        if peak == midden, continue; end
        spkloc = floor(spk1(jj))+peak-1;
        if (numspikes>0) && (spkloc<(spikes.spktmax(numspikes)+nhold)), continue; end
        if isempty(sync)   
            tim0  = spk1(jj);
            value = adcdrempel(1);
        else
            drempel = round(amp*sync);
            lst     = (midden + peak -1);
            if spikes.adcdrmp(2)<spikes.adcdrmp(1)
                hlp = find(gebied(1:lst)>drempel);
            else
                hlp = find(gebied(1:lst)<drempel);
            end
            if isempty(hlp), continue; end
            drmp1 = hlp(end);
            fraction = double(drempel-gebied(drmp1))/double(gebied(drmp1+1)-gebied(drmp1));
            tim0  = floor(spk1(jj)) - nlen + hlp(end) - 1 + fraction;
            value = drempel;
        end
        numspikes = numspikes + 1;
        spikes.spkmax (numspikes) = amp;
        spikes.spktmax(numspikes) = spkloc;
        spikes.spklvl (numspikes) = value;
        spikes.spktlvl(numspikes) = tim0;
    end
    spikes.spktlvl = spikes.spktlvl(1:numspikes);
    spikes.spktmax = spikes.spktmax(1:numspikes);
    spikes.spktmin = 0 * spikes.spktmax;
    spikes.spklvl  = spikes.spklvl(1:numspikes) * sadc;
    spikes.spkmax  = spikes.spkmax(1:numspikes) * sadc;
    spikes.spkmin  = 0 * spikes.spkmax;
else
    Error(['Method: ' spikes.method  ' unknown in Detect']);
    spikes.method = 'none';
    return;    
end
% proces bursts and masks
spikes.mask  = ones(length(spikes.spktmax),1,'int16');
spikes.class = ones(length(spikes.spktmax),1,'int16');
spikes.maskname{1,1} = 'Include/Exclude';
if ~isempty(burst)
    p3  = burst * spikes.adcrate / 1000;
    hlp = [inf; diff(spikes.spktmax)];
    spikes.class(hlp<=p3) = 3;
    spikes.class((hlp(1:(end-1))>p3)&(hlp(2:end)<=p3)) = 2;
    spikes.mask(:,2) = spikes.class==1;
    spikes.mask(:,3) = spikes.class==2;
    spikes.mask(:,4) = spikes.class==3;
    spikes.maskname{2,1} = 'single spikes';
    spikes.maskname{3,1} = 'bursts';
    spikes.maskname{4,1} = 'spikes in bursts';
    state1 = sprintf('singles: %u',length(find(spikes.class==1)));
    state2 = sprintf('bursts:  %u',length(find(spikes.class==2)));
end
if dosave, savexy(false); end

function DoDetect(parms)
global Meting cmdlist spikes
if isempty(cmdlist) 
    Detect(parms,1,1);
else
    [parms,present,ps] = ParseSpecial(parms,'list');
    if present
        list = nsingle(ps{1});
        mets = cmdlist{list}(:,2);
        swps = cmdlist{list}(:,3);
        [parms,dorapp] = ParseSpecial(parms,'rapptrg');
        if dorapp
            [parms,present,ps] = ParseSpecial(parms,'channel');  if present, kanaalnr = nsingle(ps{1}); end
        end   
        for kkk = 1:length(mets)
            if dorapp
                Meting(mets(kkk)) = DACexpand(Meting(mets(kkk)));
                spikes.trg.trg1 = find((Meting(mets(kkk)).dac(1:end-1,kanaalnr(1))<=8000) & (Meting(mets(kkk)).dac(2:end,kanaalnr(1))>8000));
                spikes.trg.trg2 = Meting(mets(kkk)).dac(spikes.trg.trg1,kanaalnr(2));
                spikes.laser{mets(kkk),1} = spikes.trg.trg1;
                spikes.laser{mets(kkk),2} = spikes.trg.trg2;
            else
                Detect(parms,mets(kkk),swps(kkk));
                spikes.detects{mets(kkk),swps(kkk)} = spikes.spktmax;
            end
        end
    end
end

function result = doUnits(parms,dt,xas,yas,doshow)
global panels
result = struct('dt',dt,'times',[],'irate',[],'frate',[],'nspks',0,'mrate',NaN,'level',[],'thold',[],...
                'critr',0.65,'cmax',4','silou',NaN,'class',[],'order',[]);
result.times{1} = [];
result.irate{1} = [];
result.frate{1} = [];
result.class{1} = [];
result.order{1} = [];
if doshow
    hhh = gca; hline = hhh.Children(string(get(hhh.Children,'Tag'))=="trace");
    if isequal(hline.Color,[0 0 1]), kleur = [1,0,0]; else, kleur = [1 0 0]; end
end
[~,dodetect,ps] = ParseSpecial(parms,'detect');
if dodetect
    [~,spkpar] = spikeparms(ps);
    idx = abs(yas)<(mean(yas)+spkpar.auto*std(yas));
    [avg,dev] = mymean(yas(idx));
    avgp = 1000*mean( yas( yas>( avg+spkpar.auto*dev)).^2);
    avgm = 1000*mean( yas( yas<(-avg-spkpar.auto*dev)).^2);
    if isempty(spkpar.height)
        level = avg+spkpar.auto * dev;
        if avgp<abs(avgm)
            spkpar.invert = true;
            level = -level;
        end
    else
        level = spkpar.height;
    end
    if spkpar.abs, yas = abs(yas); elseif spkpar.invert, yas = -yas; end
    thold = spkpar.thold;
    idxs = peakfinder(yas,abs(level),abs(spkpar.depth*level),round(thold/dt));
else
    [parms,present1,ps1] = ParseSpecial(parms,'localmax'); if present1, ps = ps1; tek = 1;  end
    [parms,present2,ps2] = ParseSpecial(parms,'localmin'); if present2, ps = ps2; tek = -1; end
    if present1 || present2
        level = rsingle(ps{1});
        thold = rsingle(ps{2}); minsep = max(1,round(thold/(dt*panels.timegain)));
        if doshow
            line('XData',xas([1,end]),'YData',tek*level*[1,1],'LineStyle','--','LineWidth',1,'Color',kleur);
        end
        idxs = logical(size(yas));
        p1 = 1;
        p2 = 0;
        N = ceil(length(yas)/100000);
        ystep = round(length(yas)/ceil(length(yas)/100000));
        while p2<length(yas)
            p2 = min(length(yas),p2+ystep);
            if present1
                idxs(p1:p2) = islocalmax(yas(p1:p2),'MinSeparation',minsep,'MinProminence',level);
            else
                idxs(p1:p2) = islocalmin(yas(p1:p2),'MinSeparation',minsep,'MinProminence',level);
            end
            p1 = p2+1;
        end
        if doshow
            line('XData',xas(idxs),'YData',yas(idxs),'Color',kleur,'LineStyle','none','LineWidth',1,'Marker','o','MarkerSize',6);
        end
        idxs = find(idxs);
    else
        Error("units needs detect, localmax or localmin as method"); return
    end
end
result.times{1} = idxs;
result.nspks = length(idxs);
result.level = level;
result.thold = thold;
if result.nspks >1
    adcrate = 1000/dt;
    [parms,dofilt,ps] = ParseSpecial(parms,'rate');
    if dofilt, [~,filter2] = ParseFilter(ps); end
    result.mrate = (result.nspks-1)*adcrate/(idxs(end)-idxs(1));
    if result.nspks >2
        result.irate{1} = 2 * adcrate./(idxs(3:end)-idxs(1:end-2));
        rate = zeros(length(yas),1);
        hlp = [1,idxs,length(yas)];
        for jjj = 1:length(hlp)-1
            rate(hlp(jjj):hlp(jjj+1)) = adcrate/(hlp(jjj+1)-hlp(jjj));
        end
        if ~isempty(filter2)
            rate = FilterTrace(rate,filter2,adcrate);
        end
        result.frate{1} = rate;
    end
end
[~,docluster,ps] = ParseSpecial(parms,'cluster');
if docluster && (result.nspks>20)
    [ps,present,psh] = ParseSpecial(ps,'max');       if present, result.cmax  = nsingle(psh{1}); end
    [~, present,psh] = ParseSpecial(ps,'criterion'); if present, result.critr = rsingle(psh{1}); end
    intervals = diff(dt*double(idxs))';
    intervals = [intervals(1:end-1),intervals(2:end)];
    hlp = log10(intervals);
    silvalue = zeros(1,result.cmax);
    for jj = 1:result.cmax
        warning off
        class = kmeans(hlp,jj,'replicates',4);
        warning on
        silvalue(jj) = mean(silhouette(hlp,class));
    end
    [~,best] = max(silvalue);
    class    = kmeans(hlp,best,'replicates',4);
    centers = zeros(best,6);
    result.silou = mean(silhouette(hlp,class));
    if result.silou>result.critr
        for jj = 1:best
            centers(jj,1) = round(realpow(10,mean(log10(intervals(class==jj,1)))));
            centers(jj,2) = round(realpow(10,mean(log10(intervals(class==jj,2)))));
            centers(jj,3) = sum(class==jj);
            centers(jj,4) = 1000./mean(intervals(class==jj,1));
            centers(jj,5) = round(realsqrt(centers(jj,1)^2 + centers(jj,2)^2));
            centers(jj,6) = abs(centers(jj,1)-centers(jj,2))/(centers(jj,1)+centers(jj,2));
        end
        inside = find(centers(:,6)<mean(centers(:,6)));
        [~,hlp] = sort(centers(inside,5));
        order = inside(hlp);
        rest = 1:best;
        rest(order) = [];
        result.order{1} = [order;-rest'];
    else
        result.order{1} = 1;
        class = 1+0*class;
    end
    result.class{1} = class;
end

function DoSeizure(parms)
global Meting seizure
[parms,sets,mets,swps] = ParseList(parms);
setnr = sets(1);
metnr = mets(1);
swpnr = swps(1);
seizure = struct('rate',1,'chn',1,'gain',1,'minheight',0,'depth',0.5,'hold',0,'peaks',[],'amps',[],'bgn',[],'end',[]);
[parms,present,ps] = ParseSpecial(parms,'adcs'); if present, seizure.chn = nsingle(ps{1}); end
[parms,present,ps] = ParseSpecial(parms,'peaks');
if present
    [ps,present,psh] = ParseSpecial(ps,'height');  if present, seizure.minheight = rsingle(psh{1}); end
    [ps,present,psh] = ParseSpecial(ps,'depth');   if present, seizure.depth     = rsingle(psh{1}); end
    [ps,present,psh] = ParseSpecial(ps,'drempel'); if present, seizure.drempel   = rsingle(psh{1}); end
    [ps,present,psh] = ParseSpecial(ps,'holdoff');
    if present
        [psh,present] = ParseSpecial(psh,'sec'); if present, tgain = 1; else,tgain = 0.001; end
        seizure.hold = rsingle(psh{1})*tgain;
    end
end
[parms,present,pstarget] = ParseSpecial(parms,'target');
if present 
    [pstarget,present,ps] = ParseSpecial(pstarget,'root');
    if present
        names = ssingle(ps{1});
        [fld1,fld2] = strtok(names,'@');
        fld2 = fld2(2:end);
    else
        Error('target needs root'); return
    end
else
    Error('Seizure need target'); return
end
tmp = {};
tmp{1} = sprintf('target(root(%s@%s%s),%s)',fld1,fld2,',delnode',pstarget{1});
[~,nres,structname] = INIresultbasis(tmp,1);
if Error, return; end
seizure.rate = Meting(metnr).ADC.rate;
seizure.gain = Meting(metnr).ADC.scale(seizure.chn).User/Meting(metnr).ADC.ints;
[seizure.peaks,seizure.amps] = peakfinder(seizure.gain * double(Meting(metnr).adc(:,seizure.chn,swpnr)),...
                                          seizure.minheight,seizure.depth,round(seizure.hold * seizure.rate));
drempel = int16(round(seizure.drempel/seizure.gain));
seizure.bgn = seizure.peaks;
seizure.end = seizure.peaks;
for jj = 1:length(seizure.peaks)
    if jj==1, prv = 1;                                             else,prv = seizure.peaks(jj-1); end
    if jj==length(seizure.peaks), nxt = size(Meting(metnr).adc,1); else,nxt = seizure.peaks(jj+1); end
    dis = seizure.peaks(jj);
    hlp = find(Meting(metnr).adc(prv:dis,seizure.chn,swpnr)<drempel,1,'last');
    if isempty(hlp)
        [~,hlp] = min(Meting(metnr).adc(prv:dis,seizure.chn,swpnr));
    end
    seizure.bgn(jj) = prv - 1 + hlp;
    hlp = find(Meting(metnr).adc(dis:nxt,seizure.chn,swpnr)<drempel,1,'first');
    if isempty(hlp)
        [~,hlp] = min(Meting(metnr).adc(dis:nxt,seizure.chn,swpnr));
    end
    seizure.end(jj) = dis - 1 + hlp;
end
slen = size(seizure.peaks,1);
Meting(nres).result.(structname).basis.metswp(1,1:6)  = [setnr, metnr, swpnr, 1, metnr, size(Meting(metnr).adc,1)*1000/Meting(metnr).ADC.rate];
Meting(nres).result.(structname).basis.times = Meting(metnr).reltime;
Meting(nres).result.(structname).basis.Times = Meting(metnr).abstime + (Meting(metnr).reltime/(24*60*60));
hlp = seizure.bgn/seizure.rate;
Meting(nres).result.(structname).aanvaltime(1:slen,1) = hlp;
Meting(nres).result.(structname).rate      (1:slen,1) = [NaN; 2./(hlp(3:end)-hlp(1:end-2)); NaN];
Meting(nres).result.(structname).interval  (1:slen,1) = [diff(hlp); NaN];
Meting(nres).result.(structname).end       (1:slen,1) = seizure.end/seizure.rate;
Meting(nres).result.(structname).duur      (1:slen,1) = (seizure.end-seizure.bgn)/seizure.rate;
Meting(nres).result.(structname).t2next    (1:slen,1) = ([seizure.bgn(2:slen); NaN]-seizure.end)/seizure.rate;
Meting(nres).result.(structname).tpeak     (1:slen,1) = seizure.peaks/seizure.rate;
Redraw;

function DoConcatenate (parms)
global Meting panels cache
if isempty(Meting), Error('No Meting'); return; end
if isempty(Meting(1).SEGMENT.start), Error('No segments to select'); return; end
cache = [];
cache.status = false;
KnobGrey(CMD.cache);
set(CMD.cachelevel,'String','0');
WindowClear;
[parms,present,ps] = ParseSpecial(parms,'adcs');
if present, chn = nsingle(ps{1}); else,chn = 1; end
panels.filenr = 1;
panels.segnr  = 0;
Meting(1).adc = [];
dt = 1000/Meting.ADC.rate;
segs = Meting(1).SEGMENT.eind - Meting(1).SEGMENT.start;
lens = 1+round(1000*segs/dt);
hadc = zeros(sum(lens),length(chn),'int16');
start = 1;
txt = sprintf(' %u ',chn);
d1 = 0;
d2 = 0;
for segnr = 1:length(lens)
    Waitbar(CMD,'show',segnr/length(lens),sprintf('Load, select (%s), merge segment %u  (%u Mb)',txt,length(lens)-segnr,round(d1*d2/(1024*512))));
    MemoryUpdate('nobar',panels.filenr,segnr);
    [d1,d2] =size(Meting(1).adc);
    hadc(start:start+d1-1,1:length(chn)) = Meting(1).adc(:,chn);
    start = start + d1;
end
Waitbar(CMD,'hide');
panels.segnr = 1;
Meting(1).ADC.HWchn = chn;
Meting(1).ADC.HWloc = chn;
Meting(1).ADC.HWdev = 1;
Meting(1).ADC.scale = Meting(1).ADC.scale(chn);
Meting(1).adc = hadc;
Meting(1).SEGMENT.name  = [];
Meting(1).SEGMENT.time  = [];
Meting(1).SEGMENT.start = [];
Meting(1).SEGMENT.eind  = [];
setmaxpars(Meting(1),'full')
NRNtimeline;

function  DoStimulation(parms)
global Memoryset Meting events panels
metnr = 1;
[parms,present] = ParseSpecial(parms,'artefact');
if present
    names = {Meting(metnr).ADC.scale.Name};
    artchan = [];
    for jj = 1:length(names)
        if ~isempty(strfind(names{jj},'art')), artchan = [artchan, jj]; end
    end
    if isempty(artchan), Error('Data has no artefact channel'); return; end
end
[parms,present,ps] = ParseSpecial(parms,'level');
if present
    grens = rsingle(ps{1});
    if length(ps)>1, stimscale = rsingle(ps{2}); else,stimscale = 20; end
else
    Error('You need to specify level'); return
end
[parms,present,ps] = ParseSpecial(parms,'findstim');
if present
    [ps,present,psh] = ParseSpecial(ps,'files');
    if present
        if isempty(psh)
            files = 1:length(Memoryset);
        else
            files = intersect(nsingle(psh{1}),1:length(Memoryset));
            if isempty(files)
                Error('None of the selected datafiles in the dbase'); return
            end
        end
    else
        Error('You need to specify files'); return;
    end
    [~,present,psh] = ParseSpecial(ps,'calduur');
    if present
        hlp  = rsingle(psh{1});
        tduur = hlp(1);
        trand = hlp(2);
    else
        Error('You need to specify calduur'); return
    end
    events.stim.filenr =[];
    events.stim.tbgn =[];
    events.stim.tlst =[];
    events.stim.amps =[];
    for kk = 1:length(files)
        MemoryUpdate(files(kk),1);
        [~,nchan] = size(Meting.adc);
        dt = 1000/Meting(1).ADC.rate;
        pduur = round(tduur/dt);
        prand = round(trand/dt);
        NRNtimeline;
        drempel = int16(round(0.5 * grens * Meting(1).ADC.ints/Meting(1).ADC.scale(artchan(1)).User));
        segtimes = Meting(1).SEGMENT.eind - Meting(1).SEGMENT.start;
        tracelen = 1+round(1000*segtimes/dt);
        trace    = zeros(sum(tracelen),1,'int16');
        pbgn = 1;
        d1 = 0;
        d2 = 0;
        for segnr = 1:length(tracelen)
            Waitbar(CMD,'show',segnr/length(tracelen),sprintf('Load and merge artefact, file(%u), channel(%u), segment: %u (%u Mb)',...
                                                        files(kk),artchan(1),segnr,round(d1*d2/(1024*512))));
            MemoryUpdate('nobar',files(kk),segnr);
            [d1,d2,d3] = size(Meting(1).adc);
            trace(pbgn:pbgn+d1-1,1) = Meting(1).adc(:,artchan(1));
            pbgn = pbgn + d1;
        end
        pnts = find((trace(1:end-1)>drempel) & (trace(2:end)<=drempel));
        if length(pnts)>1
            limit1 = 300;
            pinter = [diff(pnts); 2*limit1];
            dbgn = find((pinter(1:end-1)>limit1)&(pinter(2:end)<=limit1));
            dlst = find((pinter(1:end-1)<=limit1)&(pinter(2:end)>limit1));
            if length(dlst)~=length(dbgn), Error('length problem in find amp'); return; end
            ical = pnts(dbgn);
            itet = pnts(dbgn+1);
            etet = pnts(dlst+1);
            atet = zeros(length(itet),1);
            for jj = 1:length(dbgn)
                Waitbar(CMD,'show',jj/length(dbgn),sprintf('calbrate (%u)',jj));
                pbgn = ical(jj);
                p1 = pbgn + prand - pduur ;
                p2 = pbgn - prand;
                anul = mean(double(trace(p1:p2)));
                p1 = pbgn + prand;
                p2 = pbgn - prand + pduur;
                p3 = pbgn + prand + pduur;
                p4 = pbgn - prand + 2*pduur;
                atet(jj) = abs(stimscale * (mean(double(trace(p3:p4)))-anul)/(mean(double(trace(p1:p2)))-anul));
            end
            nbgn = length(events.stim.tbgn) + 1;
            nlst = length(events.stim.tbgn) + length(itet);
            events.stim.filenr(nbgn:nlst,1) = files(kk);
            events.stim.tbgn (nbgn:nlst,1) = dt * itet;
            events.stim.tlst (nbgn:nlst,1) = dt * etet;
            org = events.rats.index(kk,:);
            if nbgn==1
                hhh = unique(org); hhh = hhh(~isnan(hhh));
                events.stim.amps = zeros(nlst-nbgn+1,length(hhh));
            end
            for jj = nbgn:nlst
                filenr = events.stim.filenr(jj);
                tbgn   = events.stim.tbgn(jj);
                tlst   = events.stim.tlst(jj);
                segments = find(events.sgmt.filenr == filenr);
                segnr    = find((events.sgmt.start(segments)<=tbgn) & (events.sgmt.eind(segments)>tbgn));
                Waitbar(CMD,'show',jj/(nlst-nbgn+1),sprintf('Find Rat Stimulation (%u)',jj));
                MemoryUpdate('nobar',filenr,segnr);
                pbgn = round((tbgn-panels.zoom.tnul)/dt);
                plst = min(round((tlst-panels.zoom.tnul)/dt),size(Meting.adc,1));
                pnts = pbgn + find((Meting(1).adc(pbgn:plst-1,artchan)>drempel) & (Meting(1).adc(pbgn+1:plst,artchan)<=drempel));
                anul = round(mean(abs(double(Meting(1).adc(pnts(1)+[-10:1:10]-20,1:nchan-2)))))';
                amps = round(mean(abs(double(Meting(1).adc(pnts(1)+[-2:1:2],1:nchan-2)))))'- anul;
                stimsel = unique(org(amps>(0.5*max(amps))));
                if ~isempty(stimsel)
                    events.stim.amps(jj,stimsel) = deal(atet(jj-nbgn+1));
                end
            end
        end
    end
    Waitbar(CMD,'hide');
end
[~,present,ps]  = ParseSpecial(parms,'removeart');
if present
    alen = rsingle(ps{1});
    if length(alen)==1, alen = [0 alen]; end
    corchan = 1:length(Meting(metnr).ADC.HWchn)-length(artchan);
    trace = Meting(metnr).adc(:,artchan(1));
    drempel = int16(round(0.5 * grens * Meting(1).ADC.ints/Meting(1).ADC.scale(artchan(1)).User));
    pnts = find((trace(1:end-1)>drempel) & (trace(2:end)<=drempel));
    if length(pnts)>1
        range = alen(2)-alen(1);
        inter = diff(pnts);
%       bgns  =(inter<(1.5*inter(2)))|(inter>(1.5*inter(1)));
        times = pnts((inter<(1.5*inter(2)))|(inter>(1.5*inter(1))))+alen(1);
        delta = double(Meting(metnr).adc(times+range,corchan)) - double(Meting(metnr).adc(times,corchan));
        for jj = 1:range
            Meting(metnr).adc(times+jj,corchan) = int16(round(double(Meting(metnr).adc(times,corchan)) + delta * jj/range));
        end
    end
end

function DoTemplate(parms)
global Meting panels events spikes
[parms,doclear]  = ParseSpecial(parms,'clear');
[parms,doshow]   = ParseSpecial(parms,'show');
[parms,dosave]   = ParseSpecial(parms,'save');
[parms,doweight] = ParseSpecial(parms,'weight');
tadc  = Meting(1).ADC.rate /1000;
sadc  = Meting(1).ADC.scale(spikes.adcchan).User/Meting(1).ADC.ints;
if isempty(events.evt.first)||isempty(events.evt.last), Error('No spikes detected for template'); return; end
tlen  = round((events.evt.last(1)-events.evt.first(1)) * tadc);
slen  = length(spikes.spktlvl);
grens = rsingle(parms{1});
nulrange = []; spikes.tmpnul = [];
fitrange = []; spikes.tmprng = [];
if length(parms)>1, spikes.tmpnul = rsingle(parms{2}) * tadc; nulrange = spikes.tmpnul(1):spikes.tmpnul(2); end
if length(parms)>2, spikes.tmprng = rsingle(parms{3}) * tadc; fitrange = spikes.tmprng(1):spikes.tmprng(2); end
if doclear
    spikes.mask(:,1) = true(length(spikes.mask),1);
elseif length(events.evt.first)~=length(spikes.mask(:,1))
    Error('Events length different from mask'); return;
end
spikes.gain = zeros(slen,1);
spikes.off  = zeros(slen,1);
spikes.fact = zeros(slen,1);
spikes.err  = zeros(slen,1);
for jj = 1:2
    cnt   = 0;
    for ii=1:length(spikes.spktlvl)
        if spikes.mask(ii,1)
            bgn    = round((events.evt.first(ii) - panels.zoom.tnul) * tadc);
            ytrace = sadc * double(Meting(1).adc(bgn:(bgn+tlen),spikes.adcchan,1));
            if cnt==0, ymean = ytrace; else,ymean = ymean + ytrace; end
            cnt = cnt + 1;
        end
    end
    ymean = ymean / cnt;
    if ~isempty(nulrange)
        ymean = ymean - mean(ymean(nulrange));
    end
    if abs(max(ymean))>abs(min(ymean)), extamp = max(ymean); else,extamp = min(ymean); end
    if doweight
        if isempty(fitrange), yweight = ymean; else,yweight = ymean(fitrange); end
        yweight = yweight.*yweight;
        yweight = yweight/mean(yweight); 
    else
        if isempty(fitrange)
            yweight = 1 + 0 * ymean; 
        else
            yweight = 1 + 0 * ymean(fitrange);
        end
    end
    if isempty(fitrange)
        syy = sum(yweight.*ymean.*ymean);
    else
        syy = sum(yweight.*ymean(fitrange).*ymean(fitrange));
    end
    for ii=1:cnt
        bgn    = round((events.evt.first(ii) - panels.zoom.tnul) * tadc);
        ytrace = sadc * double(Meting(1).adc(bgn:(bgn+tlen),spikes.adcchan,1));
        if ~isempty(nulrange)
            spikes.off(ii) = mean(ytrace(nulrange));
            ytrace = ytrace - spikes.off(ii);
        end
        if isempty(fitrange)
            spikes.gain(ii) = sum(yweight.*ytrace.*ymean)/syy;
            spikes.err(ii)  = realsqrt(mean((ytrace-ymean*spikes.gain(ii)).^2));
        else
            spikes.gain(ii) = sum(yweight.*ytrace(fitrange).*ymean(fitrange))/syy;
            spikes.err(ii)  = realsqrt(mean((ytrace(fitrange)-ymean(fitrange)*spikes.gain(ii)).^2));
        end
        spikes.fact(ii) = spikes.gain(ii)*extamp;
    end
    spikes.template = ymean;
    if length(grens)==1
        spikes.mask(spikes.err>=grens,1) = false;
    else
        spikes.mask((spikes.err>=grens(1))|(spikes.gain<=grens(2)),1) = false;
    end
end
if dosave, savexy(true); end
if doshow
    for ii=1:length(spikes.spktlvl)
        if spikes.mask(ii,1)
            set(DB.nr,'String',sprintf('%u',ii));
            EventShow;
        end
        if panels.abort, return; end
    end
end

function DoClean50Hz(parms)
global Meting panels events spikes p
[parms,present,ps] = ParseSpecial(parms,'channel'); if present, kanaal = nsingle(ps{1}); end
tadc    = Meting(1).ADC.rate /1000;
sadc    = Meting(1).ADC.scale(kanaal).User/Meting(1).ADC.ints;
eventnr = str2double(get(DB.nr,'String'));
bgn     = round((events.evt.first(eventnr) - panels.zoom.tnul) * tadc);
lst     = round((events.evt.last(eventnr)  - panels.zoom.tnul) * tadc);
start   = round((rsingle(parms{1})*panels.timegain - panels.zoom.tnul) * tadc);
if (start<bgn) || (start>lst)
    Error('startpoint outside correction range');
    return;
end
srange  = round(rsingle(parms{2}) * tadc);
crange  = round(rsingle(parms{3}) * tadc);
step    = round(20 * tadc);
points  = [];
current = start;
while current>bgn
    [~,pnt] = max(Meting(1).adc(current-srange:current+srange,kanaal));
    points = [current-srange+pnt-1; points];
    if length(points)>3, step = round(mean(diff(points))); end
    current = points(1)-step;
end
current = points(end)+step;
while current<lst
    [~,pnt] = max(Meting(1).adc(current-srange:current+srange,kanaal));
    points = [points; current-srange+pnt-1];
    if length(points)>3, step = round(mean(diff(points))); end
    current = points(end)+step;
end
spikes.spktmax = points;
spikes.spkmax  = double(Meting(1).adc(spikes.spktmax,kanaal))*sadc;
spikes.spktmin = points;
spikes.spkmin  = 0*spikes.spkmax;
spikes.spktlvl = points;
spikes.spklvl  = 0*spikes.spkmax;
spikes.class   = ones(length(spikes.spktmax),1,'int16');
spikes.mask    = spikes.class;
spikes.adcchan = kanaal;
for ii = -crange:1:crange
    Meting(1).adc(spikes.spktmax+ii,kanaal) = 0;
end
Redraw;

function findallfiles(dirname,lvl,maxlvl)
global filelist
if lvl>maxlvl, return; end
if contains(dirname,'ignore'), return; end
dd = dir(dirname);
for ii=1:length(dd)
    if dd(ii).isdir
        if ~strcmp(dd(ii).name,'.')&& ~strcmp(dd(ii).name,'..')
            findallfiles([dirname filesep dd(ii).name],lvl+1,maxlvl)
        end
    else
        hlp = dd(ii).name;
        filelist{end+1,1} = [dirname filesep dd(ii).name];
        if strcmp(hlp(end-2:end),'mat')
            
        end
    end
end
% 
% function findallmatfiles(dirname,lvl,maxlvl)
% global filelist
% filelist = [];
% findallfiles(dirname,lvl,maxlvl);
% hh = [];
% for jj = 1:length(filelist)
%     name = filelist{jj};
%     if ~strcmp(name(end-2:end),'mat') || contains(name,'foto.mat') || contains(name,'result.mat')
%        hh = [hh jj];
%     end
% end
% filelist(hh) = [];

function DoSubtraces(parms)
global Meting
[parms,~,mets,~] = ParseList(parms);
metnrs = mets(1);
[parms,present,ps] = ParseSpecial(parms,'adcs');
if present
    adcs = nsingle(ps{1});
    plotter.window = 9;
    plotter.mode   = 'adc';
else
    Error('You need to specify adcs'); return
end 
[parms,present,ps] = ParseSpecial(parms,'dacs');
if present
    dacs = nsingle(ps{1});
    plotter(1).window = 11;
    plotter(1).mode   = 'adc';
    plotter(2).window = 13;
    plotter(2).mode   = 'dac';
else
    dacs = [];
end 
[parms,tijden] = ParseTijd(parms,'range',1);
if isempty(parms), name = ''; else,name = ssingle(parms{1}); end
for j1 = 1:length(metnrs)
    metnr = metnrs(j1);
    if isempty(tijden)
        pbgn = 1;
        pend = size(Meting(metnr).adc);
    else
        pbgn = round(tijden(1) * Meting(metnr).ADC.rate/1000);
        pend = round(tijden(2) * Meting(metnr).ADC.rate/1000);
    end
    for j2 = 1:length(pbgn)
        Meting(end+1)         = Meting(metnr);
        Meting(end).setnr     = (j2==1);
        Meting(end).adc       = Meting(metnr).adc(pbgn(j2):pend(j2),adcs,:);
        Meting(end).ADC.scale = Meting(metnr).ADC.scale(adcs);
        Meting(end).ADC.HWchn = 1:length(adcs);
        Meting(end).ADC.HWloc = 1:length(adcs);
        Meting(end).ADC.HWdev = ones(1,length(adcs));
        if isempty(dacs)
            Meting(end).dac       = [];
            Meting(end).cdac      = [];
            Meting(end).DAC.scale = [];
            Meting(end).DAC.HWchn = [];
            Meting(end).DAC.HWloc = [];
            Meting(end).DAC.HWdev = [];
        else
            Meting(end).dac                       = Meting(metnr).adc(pbgn(j2):pend(j2),dacs,:);
            for jj=1:length(dacs)
                Meting(end).DAC.scale(jj).User  = Meting(metnr).ADC.scale(dacs(jj)).User;
                Meting(end).DAC.scale(jj).Units = Meting(metnr).ADC.scale(dacs(jj)).Units;
                Meting(end).DAC.scale(jj).Name  = Meting(metnr).ADC.scale(dacs(jj)).Name;
                Meting(end).DAC.scale(jj).Color = Meting(metnr).ADC.scale(dacs(jj)).Color ;
            end
            Meting(end).DAC.HWchn = 1:length(dacs);
            Meting(end).DAC.HWloc = 1:length(dacs);
            Meting(end).DAC.HWdev = ones(1,length(dacs));
        end
        Meting(end).reltime    = Meting(metnr).reltime - Meting(metnr).reltime(1) + max(Meting(end-1).reltime) + 1;
        if ~isempty(name)
            Meting(end).serienaam = name;
            Meting(end).nodenaam  = name;
        end
        Meting(end).EXTRA.note = 'extracted from other';
        Meting(end).plotter = plotter;
    end
end
NRNtimeline;

function DoFindDAC(parms)
global Meting cmdlist p
stimstart = [];
stimend   = [];
noevent   = true;
while true
    [parms,present,ps] = ParseSpecial(parms,'event');
    if ~present, break; else
        noevent = false;
        [ps,present,psh] = ParseSpecial(ps,'list');
        if present
            listnr = nsingle(psh{1});
            nodes  = unique(cmdlist{listnr}(:,2)');
        else
            nodes = 1:length(Meting);
        end
        [ps,present,psh] = ParseSpecial(ps,'node');
        if present
            hlp = nsingle(psh{1});
            if hlp>0
                nodenr = nodes(hlp);
            else
                nodenr = nodes(end + 1 + hlp);
            end
        else
            nodenr = 1;
        end
        if nodenr>length(Meting)
            Error(sprintf('Meting %u does not exist',nodenr));
            return
        elseif isempty(Meting(nodenr).cdac) && isempty(Meting(nodenr).dac)
            Error(sprintf('Meting(%u) needs dac or cdac',nodenr));
            return
        elseif isempty(Meting(nodenr).dac)
            Meting(nodenr) = DACexpand(Meting(nodenr));
        end
        [ps,dacnrs] = ParseDACs(ps,Meting(nodenr));
        if isempty(dacnrs), continue; end
        [ps,present1,psh1] = ParseSpecial(ps,'transient');
        [ps,present2,psh2] = ParseSpecial(ps,'bipolar');
        [~,present3]      = ParseSpecial(ps,'puls');
        for jj = 1:length(dacnrs)
            schaal = 1000/Meting(nodenr).DAC.rate;
            signal = Meting(nodenr).dac(:,dacnrs(jj));
            if present1
                times = find(diff(signal))';
                times = [0 times size(Meting(nodenr).dac,1)]*schaal;
                steps = rsingle(psh1{1});
                if abs(steps)>length(times)
                    Error(sprintf('FindDAC: trace has only %u steps',length(times)));
                    return
                end
                for ii = 1:length(steps)
                    if steps(ii)>0
                        stimstart = [stimstart times(steps(ii))];
                    else
                        stimstart = [stimstart times(length(times)+1+steps(ii))];
                    end
                end
                stimend = stimstart;
            end
            if present2
                timesp = find((signal(1:end-1)<=0) & (signal(2:end)>0))';
                timesp = (timesp-1)*schaal;
                timesn = find((signal(1:end-1)>=0) & (signal(2:end)<0))';
                timesn = (timesn-1)*schaal;
                if isempty(timesp) || isempty(timesn)
                    
                elseif timesp(1)>timesn(1)
                    stimstart = [stimstart timesn];
                    stimend   = [stimend timesp];
                else
                    stimstart = [stimstart timesp];
                    stimend   = [stimend timesn];
                end
                if ~isempty(psh2)
                    index = nsingle(psh2{1});
                    stimstart = stimstart(index);
                    stimend   = stimend(index);
                end
            end
            if present3
                stimstart = [stimstart (find((signal(1:end-1)<=0) & (signal(2:end)>0))'-1) *schaal];
                stimend   = [stimend   (find((signal(1:end-1)>0)  & (signal(2:end)<=0))'-1)*schaal];
            end
        end
    end
end
if noevent, Error('FindDAC needs event'); return; end
if isempty(dacnrs), Error('FindDAC needs valid DAC channel'); return; end
[parms,present] = ParseSpecial(parms,'nodouble');
if present
    stimstart = unique(stimstart);
    stimend   = unique(stimend);
end
stimstart = sort(stimstart);
stimend   = sort(stimend);
[parms,present,ps] = ParseSpecial(parms,'limit');
if present
    limit = rsingle(ps{1});
else
    limit = [0 (size(Meting(nodenr).dac,1)-1)*schaal];
end
[parms,present,ps] = ParseSpecial(parms,'starts');
if present
    eval([ps{1} '=[' sprintf('%0.8f ',stimend) '];']);
end
[parms,present,ps] = ParseSpecial(parms,'begins');
if present
    eval([ps{1} '=[' sprintf('%0.8f ',stimstart) '];']);
end
[parms,present,ps] = ParseSpecial(parms,'ends');
if present
    eval([ps{1} '=[' sprintf('%0.8f ',[stimstart(2:end) limit(2)]) '];']);
end
[~,present,ps] = ParseSpecial(parms,'intervals');
if present
    eval([ps{1} '=[' sprintf('%0.8f ',[stimstart(2:end) limit(2)]-stimend) '];']);
end
%
% ====== Varia ===============================================
%
function doredraw = DoDelete(parms)
global Meting cmdlist
doredraw = false;
if isempty(Meting), return; end
[parms,present,ps] = ParseSpecial(parms,'list');
if present, list=nsingle(ps{1}); else,list = []; end
if isempty(list)
    findnames = stringset(ssingle(parms{1}));
    serienames = {Meting.serienaam}';
	todelete = [];
    for j2 = 1:length(findnames)
        for j1 = 1:length(serienames)
            if ~isempty(strfind(serienames{j1},findnames{j2}))
                todelete = [todelete j1];
                doredraw = true;
            end
        end
    end
    if ~isempty(todelete), Meting(todelete) = []; end
else
    for jj = list
        if ListValid(jj)
            Meting(cmdlist{jj}(:,2)) = [];
            doredraw = true;
        end
    end
end

function DoCollaps
global Meting
nm  = length(Meting);
nds = zeros(nm,1);
swp = zeros(nm,1);
cnt1 = 0;
cnt2 = 0;
for ii=1:nm
    if nds(ii)==0
        cnt1 = cnt1+1;
        txt = Meting(ii).serienaam;
        for jj=ii:nm
            if strcmp(Meting(jj).serienaam,txt), nds(jj) = cnt1; end
        end
    end
    if swp(ii)==0
        cnt2 = cnt2+1;
        txt = Meting(ii).nodenaam;
        for jj=ii:nm
            if strcmp(Meting(jj).nodenaam,txt), swp(jj) = cnt2; end
        end
    end
end
for ii=1:cnt1
    for jj=1:cnt2
        pp = find((nds==ii)&(swp==jj))';
        die = pp(1);
        Meting(die).setnr = (jj==1);
        for kk = 2:length(pp)
            daar = pp(kk);
            Meting(die).adc(:,:,kk) = Meting(daar).adc(:,:,1);
            Meting(die).reltime   = [Meting(die).reltime Meting(daar).reltime];            
            Meting(daar).setnr    = -1;
            Meting(die).EXTRA.MEAN.aver = length(pp); 
        end               
    end
end
Meting([Meting.setnr] == -1)=[];
NRNtimeline;

function DoTrans(parms)
global Meting
modus = [];
modus.trend     = true;
modus.window    = true;
modus.fase      = [];
modus.transfer  = [];
modus.coherence = [];
modus.color{1}  = 'b';
modus.color{2}  = 'r';
[parms,sets,mets,swps] = ParseList(parms);
metnr = mets(1);
[parms,spectlen]   = ParseTijd(parms,'segment',1);
[parms,present,ps] = ParseSpecial(parms,'window');    if present, window = nsingle(ps{1}); else, window = 9; end
[parms,present,ps] = ParseSpecial(parms,'phase');     if present, modus.fase = nsingle(ps{1}); end
[parms,present,ps] = ParseSpecial(parms,'transfer');  if present, modus.transfer = nsingle(ps{1}); end
cmd = 'invalid';
[parms,present,ps] = ParseSpecial(parms,'input');
if present
    [cmd,psh] = ParseCmd(ps{1});
    chn = nsingle(psh{1});
    if length(ps)>1, gain = rsingle(ps{2}); else, gain = 1; end
end
switch cmd
    case 'dacs', trace1 = gain * double(Meting(metnr).dac(:,chn)) * Meting(metnr).DAC.scale(chn).User / Meting(metnr).DAC.ints; rate1 = Meting(metnr).DAC.rate;
    case 'adcs', trace1 = gain * double(Meting(metnr).adc(:,chn)) * Meting(metnr).ADC.scale(chn).User / Meting(metnr).ADC.ints; rate1 = Meting(metnr).ADC.rate;
    otherwise, Error('no valid input'); return
end
cmd = 'invalid';
[parms,present,ps] = ParseSpecial(parms,'output');
if present
    [cmd,psh] = ParseCmd(ps{1});
    chn = nsingle(psh{1});
    if length(ps)>1, gain = rsingle(ps{2}); else,gain = 1; end
end
switch cmd
    case 'dacs', trace2 = gain * double(Meting(metnr).dac(:,chn)) * Meting(metnr).DAC.scale(chn).User / Meting(metnr).DAC.ints; rate2 = Meting(metnr).DAC.rate;
    case 'adcs', trace2 = gain * double(Meting(metnr).adc(:,chn)) * Meting(metnr).ADC.scale(chn).User / Meting(metnr).ADC.ints; rate2 = Meting(metnr).ADC.rate;
    otherwise, Error('no valid output'); return
end
if rate1~=rate2, Error('sample rate of input and output need to be the same'); return; end
spectrum = makespectra(trace2,trace1,spectlen,rate1,modus);
if ~Error
    handle = getplothandle(window(1),true);
    drawspectra(parms,handle,spectrum,modus)
end

function DoChirp(parms)
global Meting
[parms,winclear]   = ParseClear(parms);
[parms,sets,mets,swps]  = ParseList(parms);
[parms,present,ps] = ParseSpecial(parms,'dacref');
if present, dacref = nsingle(ps{1}); else, Error('Chirp needs dacref'); return; end
[parms,present,ps] = ParseSpecial(parms,'avg');
if present
    pavg = round(0.5*(rsingle(ps{1})-1)); pavg = ones(pavg,1)/pavg;
else
    pavg = [];
end
[parms,present,ps] = ParseSpecial(parms,'Current');
if present
    [curcmd,psh] = ParseCmd(ps{1});
    curchn = nsingle(psh{1});
else, Error('Chirp needs Current'); return; end
[parms,present,ps] = ParseSpecial(parms,'Voltage');
if present
    [volcmd,psh] = ParseCmd(ps{1});
    volchn = nsingle(psh{1});
else, Error('Chirp needs Voltage'); return; end
if ~isempty(winclear), WindowClear(winclear); end
deset = unique(sets);
demet = unique(mets);
[~,nres,structname] = INIresultbasis(parms,1);
if Error, return; end
basis = Meting(nres).result.(structname).basis;
Meting(nres).result = rmfield(Meting(nres).result,structname);
for iii = 1:length(deset)
    structname = sprintf('chirp%02u',iii);
    Meting(nres).result.(structname).basis = basis;
    cumfrq = [];
    cumcur = [];
    cumvol = [];
    cumres = [];
    refs   = [];
    time   = zeros(1,length(mets));
    for ii = 1:length(demet)
        index = length(demet)*(iii-1)+ii;
        metnr = nodes(index);
        swpnr = swps(index);
        time(1,index) = Meting(metnr).reltime(swpnr);
        switch curcmd
            case 'adcs', current = double(Meting(metnr).adc(:,curchn)) * Meting(metnr).ADC.scale(curchn).User / Meting(metnr).ADC.ints;
            case 'dacs', current = double(Meting(metnr).dac(:,curchn)) * Meting(metnr).DAC.scale(curchn).User / Meting(metnr).DAC.ints;
            otherwise, Error('Currents needs adcs or dacs'); return;
        end
        switch volcmd
            case 'adcs', voltage = double(Meting(metnr).adc(:,volchn)) * Meting(metnr).ADC.scale(volchn).User / Meting(metnr).ADC.ints;
            case 'dacs', voltage = double(Meting(metnr).dac(:,volchn)) * Meting(metnr).DAC.scale(volchn).User / Meting(metnr).DAC.ints;
            otherwise, Error('Voltage needs adcs or dacs'); return;
        end
        if ~isempty(pavg)
            current = convn(current,pavg,'same');
            voltage = convn(voltage,pavg,'same');
        end
        Meting(metnr) = DACexpand(Meting(metnr)); 
        dactrace = double(Meting(metnr).dac(:,dacref));
        refval = dactrace(1);
        d2 = 1+find((dactrace(1:end-1)<=refval) & (dactrace(2:end)> refval));
        d3 = find((dactrace(1:end-1)> refval) & (dactrace(2:end)<=refval));
        d4 = 1+find((dactrace(1:end-1)>=refval) & (dactrace(2:end)< refval));
        d1 = [d2(1)-d4(1)+d3(1); find((dactrace(1:end-1)< refval) & (dactrace(2:end)>=refval))];
        dlen = min([length(d1),length(d2),length(d3),length(d4)]);
        refs(1:2:2*dlen,1) = round(0.5 * (d1(1:dlen)+d2(1:dlen)));
        refs(2:2:2*dlen,1) = round(0.5 * (d3(1:dlen)+d4(1:dlen)));
        dlen = length(refs)-1;
        camp = zeros(dlen,1);
        vamp = zeros(dlen,1);
        cur = camp;
        vol = camp;
        for jj = 1:2:dlen
            camp(jj,1) = max(current(refs(jj):refs(jj+1)));
            vamp(jj,1) = max(voltage(refs(jj):refs(jj+1)));
        end
        for jj = 2:2:dlen
            camp(jj,1) = min(current(refs(jj):refs(jj+1)));
            vamp(jj,1) = min(voltage(refs(jj):refs(jj+1)));
        end
        frq = 0.5 * Meting(metnr).DAC.rate./diff(double(refs));
        cur(2:dlen-1) = abs(0.5 * (camp(1:dlen-2)+camp(3:dlen))-camp(2:dlen-1));
        vol(2:dlen-1) = abs(0.5 * (vamp(1:dlen-2)+vamp(3:dlen))-vamp(2:dlen-1));
        cur(1)    = abs(camp(2)-camp(1));
        vol(1)    = abs(vamp(2)-vamp(1));
        frq(1)    = 0.5 * (frq(1)+frq(2));
        cur(dlen) = abs(camp(dlen)-camp(dlen-1));
        vol(dlen) = abs(vamp(dlen)-vamp(dlen-1));
        frq(dlen) = 0.5 * (frq(dlen)+frq(dlen-1));
        if isequal(cumfrq,frq)
            [nrow,nkol] = size(cumfrq);
            cumfrq(:,nkol+1) = frq;
            cumcur(:,nkol+1) = cur;
            cumvol(:,nkol+1) = vol;
            cumres(:,nkol+1) = 1000 * vol./cur;
            resmet = metnr;
            resswp = swpnr;
        else
            cumfrq = [cumfrq; frq];
            cumcur = [cumcur; cur];
            cumvol = [cumvol; vol];
            cumres = [cumres; 1000 * vol./cur];
            resmet = metnr;
            resswp = swpnr;
        end
        reslen = size(Meting(metnr).adc,1)*1000/Meting(metnr).ADC.rate;
    end
    if size(cumfrq,2)>1
        cumfrq = mean(cumfrq,2);
        cumcur = mean(cumcur,2);
        cumvol = mean(cumvol,2);
        cumres = mean(cumres,2);
    end
    deset = (0:length(cumfrq)-1)';
    Meting(nres).result.(structname).basis.metswp = [0*deset, resmet+0*deset, resswp+0*deset, deset, resmet+0*deset, reslen+0*deset];
    Meting(nres).result.(structname).basis.times  = mean(time)+0*deset;
    Meting(nres).result.(structname).basis.Times  = Meting(metnr).abstime + (mean(time)/(24*60*60))+0*deset;
    Meting(nres).result.(structname).basis.cap(1,1:2) = [Meting(metnr).EXTRA.AXON1.pars.Cm,0];
    Meting(nres).result.(structname).frq(:,1) = cumfrq(:,1);
    Meting(nres).result.(structname).Im (:,1) = cumcur';
    Meting(nres).result.(structname).Vm (:,1) = cumvol';
    Meting(nres).result.(structname).Rm (:,1) = cumres';
    NRNtimeline;
    setplotter('struct',Meting,nres,structname,1);
    NRNshow(Meting);
    InsertinLog(CMD,structname,Meting(nres).result.(structname),[]);
end

function DoElles(parms)
global Memoryset Meting panels
[parms,present,keepnames] = ParseSpecial(parms,'keep');
ccio = find(strcmp(keepnames,'CCIO'), 1);
if ~isempty(ccio)
    deset = 1:length(keepnames);
    keepnames = keepnames([ccio,deset(deset~=ccio)]);
end
HLP = [];
idx1 = 0;
for j1 = 1:length(keepnames)
    keep = keepnames{j1};
    Mets = [];
    idx2 = 0;
    first = true;
    for j2 = 1:length(Memoryset)
        [naam,pars] = ParseCmd(Memoryset{j2}.Meting(1).serienaam);
        if ~strcmp(naam,keep), continue; end
        if strcmp(keep,'CCIO')
            idx1 = idx1 + 1;
            HLP{idx1,1}.Meting = Memoryset{j2}.Meting;
        else
            for j3 = 1:length(Memoryset{j2}.Meting)
                idx2 = idx2 + 1;
                if isempty(Mets)
                    Mets = Memoryset{j2}.Meting(j3);
                else
                    Mets(idx2,1) = Memoryset{j2}.Meting(j3);
                end
                Mets(idx2).setnr = first;
                if first
                    first = false;
                    start = Mets(idx2).abstime;
                end
                Mets(idx2).reltime = Mets(idx2).reltime + round((Mets(idx2).abstime-start)*24*60*60);
            end
        end
    end
    if ~isempty(Mets)
        idx1 = idx1 + 1;
        HLP{idx1,1}.Meting = Mets;
    end
end
if isempty(HLP)
    Error('No data')
else
    Memoryset = HLP;
    Meting = Memoryset{1}.Meting;
    panels.filenr = 1;
    panels.segnr = 0;
    NRNtimeline;
end

function DoReorg(parms)
global Meting
[parms,doavg] = ParseSpecial(parms,'avg');
setnrs = cumsum([Meting.setnr]);
[parms,present,ps] = ParseSpecial(parms,'stimdac'); 
if present, stimdac = nsingle(ps{1}); else,Error('Reorganize needs stimdac'); return; end
curchannel = [];
[parms,present,ps] = ParseSpecial(parms,'current'); 
if present
    [ps,present,psh] = ParseSpecial(ps,'adcs'); 
    if present, curchannel = nsingle(psh{1}); end
    [ps,present,psh] = ParseSpecial(ps,'dacs'); 
    if present, curchannel = nsingle(psh{1}); end
end
if isempty(curchannel), Error('Reorganize needs current'); return; end
volchannel = [];
[parms,present,ps] = ParseSpecial(parms,'voltage'); 
if present
    [ps,present,psh] = ParseSpecial(ps,'adcs'); 
    if present, volchannel = nsingle(psh{1}); end
    [ps,usedac,psh] = ParseSpecial(ps,'dacs'); 
    if usedac, volchannel = nsingle(psh{1}); end
end
if isempty(volchannel), Error('Reorganize needs voltage'); return; end
for metnr = 1:length(Meting)
    Meting(metnr) = DACexpand(Meting(metnr));
    Meting(metnr).cdac = [];
end
newnames = {Meting([Meting.setnr]).serienaam}';
hhh = unique(setnrs);
Tmp = [];
for kkk = 1:length(hhh)
    kk = hhh(kkk);
    deset    = find(setnrs==kk);
    firstset = deset(1);
    [adcpnts,maxchans,maxswps] = size(Meting(firstset).adc);
    swps = 1:maxswps;
    doavg = doavg && (maxswps>1);
    node  = length(Tmp) + 1;
    if isempty(Tmp)
        Tmp       = Meting(firstset);
        abstime   = Meting(firstset).abstime + 1/(24*60*60);
    else
        Tmp(node)       = Meting(firstset);
    end
    Tmp(node).setnr   = true;
    Tmp(node).reltime = (kkk-1)*length(hhh) + hhh;
    Tmp(node).abstime = abstime;
    Tmp(node).serienaam  = newnames{kkk};
    Tmp(node).nodenaam   = Meting(firstset).nodenaam;
    Tmp(node).EXTRA.note = Meting(firstset).EXTRA.note;
    Tmp(node) = MeanIni(Tmp(node));
    Tmp(node).EXTRA.MEAN.aver = 1;
    if length(swps)>1
        Tmp(node).EXTRA.MEAN.cnt  = length(swps);
    else
        Tmp(node).EXTRA.MEAN.cnt  = 0;
    end
    Tmp(node).adc  = [];
    Tmp(node).dac  = [];
    Tmp(node).cdac = [];        
    Tmp(node).ADC.scale(2:end) = [];
    Tmp(node).DAC.scale(2:end) = [];
    Tmp(node).plotter = [];
    Tmp(node).plotter(1,1).window = 11;
    Tmp(node).plotter(1,1).mode   = 'adc/shadow';
    Tmp(node).plotter(2,1).window = 13;
    Tmp(node).plotter(2,1).mode   = 'dac/shadow';
    Tmp(node).ADC.HWchn = 1:length(deset);
    Tmp(node).ADC.HWloc = Tmp(node).ADC.HWchn;
    Tmp(node).ADC.HWdev = ones(1,length(deset));
    Tmp(node).DAC.HWchn = 1:length(deset);
    Tmp(node).DAC.HWloc = Tmp(node).DAC.HWchn;
    Tmp(node).DAC.HWdev = ones(1,length(deset));
    for jj = 1:length(deset)
        metnr = deset(jj);
        Meting(metnr).dac        = Meting(metnr).dac(1:adcpnts,:);
        Tmp(node).ADC.scale(jj)  = Meting(metnr).ADC.scale(curchannel);
        Tmp(node).adc(:,jj,swps) = Meting(metnr).adc(:,curchannel,swps);
        Tmp(node).DAC.scale(jj)  = Meting(metnr).DAC.scale(1);
        if usedac
            Tmp(node).DAC.scale(jj).User  = Meting(metnr).DAC.scale(volchannel).User;
            Tmp(node).DAC.scale(jj).Units = Meting(metnr).DAC.scale(volchannel).Units;
            Tmp(node).dac(:,jj)           = Meting(metnr).dac(:,volchannel);
        else
            Tmp(node).DAC.scale(jj).User  = Meting(metnr).ADC.scale(volchannel).User;
            Tmp(node).DAC.scale(jj).Units = Meting(metnr).ADC.scale(volchannel).Units;
            Tmp(node).dac(:,jj)           = round(mean(double(Meting(metnr).adc(:,volchannel,swps)),3));
        end
        if Tmp(node).DAC.scale(jj).User>200
            Tmp(node).plotter(2,1).mode = sprintf('dac(0,%u)/shadow',round(Tmp(node).DAC.scale(jj).User/200));
        end
    end
    if ~isempty(stimdac) && (stimdac<=size(Meting(firstset).dac,2))
        Tmp(node).dac(:,end+1) = round(double(Meting(firstset).dac(:,stimdac)));
        Tmp(node).DAC.scale(end+1) = Meting(firstset).DAC.scale(stimdac);
        Tmp(node).DAC.HWchn(end+1) = jj;
        Tmp(node).DAC.HWloc(end+1) = jj;
        Tmp(node).DAC.HWdev(end+1) = Tmp(node).DAC.HWdev(1);
    end
    Tmp(node).adc = int16(Tmp(node).adc);
    Tmp(node).dac = int16(Tmp(node).dac);
    if doavg && (maxswps>1)
        Tmp(node).adc = int16(round(mean(double(Tmp(node).adc),3)));
        Tmp(node).EXTRA.MEAN.cnt  = 0;
        Tmp(node).EXTRA.MEAN.aver = 0;
        Tmp(node).reltime = mean(Tmp(node).reltime);
    end   
end
Meting = Tmp;
NRNtimeline;

function DoStim2Swp(parms)
global Meting
[parms,present,ps] = ParseSpecial(parms,'name');   if present, name   = ssingle(ps{1}); end
[parms,present,ps] = ParseSpecial(parms,'stims');  if present, stims  = rsingle(ps{1}); end
[parms,present,ps] = ParseSpecial(parms,'mode');   if present, mode   = ssingle(ps{1}); end
[parms,present,ps] = ParseSpecial(parms,'source'); if present, source = nsingle(ps{1}); end
[parms,metzero,ps] = ParseSpecial(parms,'zero');   if present, nuls   = rsingle(ps{1}); end
[parms,times]    = ParseTijd(parms,'select',1);
if strcmp(mode,'permet')
    refnr   = source(1);
    newnr   = length(Meting)+1;
    adcrate = Meting(refnr).ADC.rate;
    dacrate = Meting(refnr).DAC.rate;
    tim     = Meting(newnr-1).reltime(end);
    dt      = Meting(newnr-1).reltime(1) - Meting(newnr-2).reltime(end);
    hlp    = round(times * adcrate / 1000);
    r1     = hlp(1);
    r2     = hlp(2)-1;
    hlp = round(times * dacrate / 1000);
    s1 = hlp(1);
    s2 = hlp(2);
    if metzero
        hlp = round(nuls * adcrate / 1000);
        z1 = r1+hlp(1);
        z2 = r1+hlp(2);
    end
    for jj = source
        Meting(newnr) = Meting(refnr);
        Meting(newnr).serienaam = sprintf('%s-%02u',name,jj);
        Meting(newnr).nodenaam  = sprintf('%s-%02u',name,jj);
        Meting(newnr).setnr     = true;
        Meting(newnr).reltime   = tim + dt * [1:length(stims)];
        tim = Meting(newnr).reltime(end);
        [adclen,numchan,numswp] = size(Meting(newnr).adc);
        hlp = round(times * adcrate / 1000);
        Meting(newnr).adc = zeros(r2-r1+1,numchan,length(stims),'int16');
        for pstim = 1:length(stims)
            stim = round(stims(pstim) * adcrate / 1000);
            if metzero
                offset = int16(round(mean(Meting(jj).adc(stim+r1+(z1:z2),:,1))));
                Meting(newnr).adc(:,:,pstim) = Meting(jj).adc(stim+(r1:r2),:,1) - offset;
            else
                Meting(newnr).adc(:,:,pstim) = Meting(jj).adc(stim+(r1:r2),:,1);
            end
            if pstim==1
                stim = round(stims(pstim) * dacrate / 1000);
                Meting(newnr)      = DACexpand(Meting(newnr));
                Meting(newnr).cdac = [];
                Meting(newnr).dac  = Meting(newnr).dac(stim+(s1:s2),1);
                Meting(newnr)      = DACcompress(Meting(newnr));
            end
        end
        newnr = newnr + 1;
        refnr = refnr + 1;
    end
elseif strcmp(mode,'allmets')
    refnr   = source(1);
    newnr   = length(Meting) + 1;
    adcrate = Meting(refnr).ADC.rate;
    dacrate = Meting(refnr).DAC.rate;
    tim     = Meting(newnr-1).reltime(end);
    dt      = Meting(newnr-1).reltime(1) - Meting(newnr-2).reltime(end);
    hlp = round([stims(1) times] * adcrate / 1000);
    stim = hlp(1);
    r1   = hlp(2);
    r2   = hlp(3)-1;
    if metzero
        hlp = round(nuls * adcrate / 1000);
        z1 = hlp(1);
        z2 = hlp(2);
    end
    Meting(newnr) = Meting(refnr);
    Meting(newnr).serienaam = sprintf('%s',name);
    Meting(newnr).nodenaam  = sprintf('%s',name);
    Meting(newnr).reltime   = tim + dt * [1:length(source)];
    [adclen,numchan,swp]    = size(Meting(refnr).adc);
    Meting(newnr).adc = zeros(r2-r1+1,numchan,length(source),'int16');
    for jj = source
        if metzero
            offset = int16(round(mean(Meting(jj).adc(stim+r1+(z1:z2),:,1))));
            Meting(newnr).adc(:,:,jj) = Meting(jj).adc(stim+(r1:r2),:,1) - offset;
        else
            Meting(newnr).adc(:,:,jj) = Meting(jj).adc(stim+(r1:r2),:,1);
        end
    end
    hlp = round([stims(1) times] * dacrate / 1000);
    stim = hlp(1);
    s1 = hlp(2);
    s2 = hlp(3);
    Meting(newnr)      = DACexpand(Meting(newnr));
    Meting(newnr).cdac = [];
    Meting(newnr).dac  = Meting(newnr).dac(stim+(s1:s2),:);
    Meting(newnr)      = DACcompress(Meting(newnr));
end
NRNtimeline;

function DoBalance1(parms,handles)
global Meting panels
panels.balans = [];
panels.balans.xpnt = 10;
panels.balans.ref1 = [];
panels.balans.ref2 = [];
panels.balans.range1 = [];
panels.balans.range2 = [];
panels.balans.Ei = -86;
panels.balans.Ee = 0;
panels.balans.Er = [];
panels.balans.gr = 0;
panels.balans.gi = 0;
panels.balans.ge = 0;
parms                  = ParseCondition(parms);
[parms,dosnap]         = ParseBoolean(parms,'snapshot',   'No');
[parms,present,ps]     = ParseSpecial(parms,'resolution'); if present, resolutie = rsingle(ps{1})/2; else, resolutie = 0; end
[parms,present,ps]     = ParseSpecial(parms,'filter');     if present, filter    = rsingle(ps{1})/2; else, filter = 0;    end
[parms,sets,mets,swps] = ParseList(parms);
[parms,present,ps] = ParseSpecial(parms,'ref');
if ~present, Error('Balance needs a ref command'); return; else
    refmode = 'normal';
    [ps,present] = ParseSpecial(ps,'zero');
    if present, refmode = 'zero'; else
        [ps,present] = ParseSpecial(ps,'linear');
        if present, refmode = 'linear'; end
    end
    panels.balans.ref1 = rsingle(ps{1});
    panels.balans.ref2 = rsingle(ps{2});
end
[parms,present,ps] = ParseSpecial(parms,'range');
if ~present, Error('Balance needs a ref() command'); return; else
    [ps,present,psh] = ParseSpecial(ps,'start'); if present, rstart = rsingle(psh{1}); else, rstart = 0;  end
    [ps,present,psh] = ParseSpecial(ps,'limit'); if present, hlimit = rsingle(psh{1}); else, hlimit = []; end
    panels.balans.range1 = rsingle(ps{1});
    panels.balans.range2 = rsingle(ps{2});
    if ~isempty(hlimit)
        for jj = 1:length(panels.balans.range1)
            panels.balans.range2(jj) = min(panels.balans.range2(jj),panels.balans.range1(jj)+hlimit);
        end
    end
end
if (length(panels.balans.ref1)>1) && (length(panels.balans.ref1)~=length(panels.balans.range1))
    Error('Ref ranges must be 1 or equal to #ranges'); return
end
[parms,present,ps] = ParseSpecial(parms,'artefact');
if ~present, artpos = []; else
    artpos = rsingle(ps{1});
    if ~isempty(artpos)
        artlen   = rsingle(ps{2});
        artmodus = ssingle(ps{3});
    end
end
[parms,present,ps] = ParseSpecial(parms,'Erevs');
if ~present || (length(ps)<2), Error('Balance needs  two Erevs'); return; else
   [ps,present,psh] = ParseSpecial(ps,'who');
    if present
        sensmet = rsingle(psh{1});
        senstim = rsingle(psh{2});
    else
        sensmet = 1;
        senstim = 1;
    end
    Sens.Einh = rsingle(ps{1});
    Sens.Eexc = rsingle(ps{2});
end
dosensitivity = (length(Sens.Einh)>1) || (length(Sens.Eexc)>1);
if dosensitivity
    Sens.Ratio           = zeros(length(Sens.Einh),length(Sens.Eexc),3);
    panels.balans.ref1   = panels.balans.ref1(senstim);
    panels.balans.ref2   = panels.balans.ref2(senstim);
    panels.balans.range1 = panels.balans.range1(senstim);
    panels.balans.range2 = panels.balans.range2(senstim);
    Meting               = Meting(sensmet);
    list                 = 1;
end
if ~isempty(parms), naamext = ssingle(parms{1}); else,naamext = ''; end
panels.balans.stats = [];
panels.balans.Er    = [];
panels.balans.yr    = {};
panels.balans.gr    = [];
teller = 0;
for ii = 1:size(list,2)
    mnr = list(ii);
   [~,maxadcs,maxswps] = size(Meting(mnr).adc);
    adcrate                = Meting(mnr).ADC.rate/1000;
    node                   = length(Meting) + 1;
    Meting(node)           = Meting(mnr);
    Meting(node).nodenaam  = [Meting(mnr).nodenaam naamext];
    Meting(node).serienaam = [Meting(mnr).serienaam naamext];
    Meting(node).EXTRA.note = 'Balans-Calculation';
    Meting(node).ADC.HWchn = 1:(12+maxadcs);
    Meting(node).ADC.HWloc = 1:(12+maxadcs);
    Meting(node).ADC.HWdev = ones(1,12+maxadcs);
    Meting(node).adc = zeros(size(Meting(node).adc,1),12+maxadcs);
    Meting(node).EXTRA.MEAN.avg = [];
    Meting(node).EXTRA.MEAN.sem = [];
    Meting(node).ADC.scale(2:end) = [];
    for kk1 = 1:6,  Meting(node).ADC.scale(kk1) = Meting(mnr).ADC.scale(2); end
    for kk1 = 7:12, Meting(node).ADC.scale(kk1) = Meting(mnr).ADC.scale(1); end
    Meting(node).reltime = Meting(node-1).reltime(end)+ 1 + (1:maxswps);
    if ~isempty(artpos)
        for kk1 = 1:length(artpos)
            apos  = round(artpos(kk1) * adcrate) + 1;
            aend  = round((artpos(kk1) + artlen) * adcrate);
            for swp = 1:maxswps
                for kk2 = 1:maxadcs
                    switch artmodus
                        case 'straight', Meting(mnr).adc(apos:aend,kk2,swp) = Meting(mnr).adc(apos,kk2,swp); 
                        case 'zero',     Meting(mnr).adc(apos:aend,kk2,swp) = 0;
                    end
                end
            end
        end
    end
    pref1 = round(adcrate * panels.balans.ref1)+1;
    pref2 = round(adcrate * panels.balans.ref2);
    pran1 = round(adcrate * panels.balans.range1)+1;
    pran2 = round(adcrate * panels.balans.range2);
    pfres = round(adcrate * resolutie);
    pstrt = round(adcrate * rstart); 
    panels.balans.res = pfres;
    if ii==1
        noemer = 0;
        for jj=1:length(pran1)
             noemer =noemer + size(list,2) * maxswps * length(pran1(jj):(2*pfres+1):pran2(jj)) * length(Sens.Einh) * length(Sens.Eexc);
        end
    end
    for swp = 1:maxswps
        for kk1 = 1:length(Sens.Einh)
            panels.balans.Ei = Sens.Einh(kk1);
            for kk2 = 1:length(Sens.Eexc)
                panels.balans.Ee = Sens.Eexc(kk2);
                
                for kk0 = 1:length(panels.balans.ref1)
                    if (kk1==1) && (kk2==1)
                        rpnt = pref1(kk0):pref2(kk0);
                        yar = mean(double(Meting(mnr).adc(rpnt,:,swp    )),1)' * Meting(mnr).ADC.scale(1).User/Meting(mnr).ADC.ints;
                        xar = mean(double(Meting(mnr).dac(rpnt,1:maxadcs)),1)' * Meting(mnr).DAC.scale(1).User/Meting(mnr).DAC.ints;        
                        [bbb,~,~,ival,stats] = regress(yar,[ones(length(xar),1) xar]);
                        rselect = 1:length(xar);
                        outlier = find( (ival(:,1).*ival(:,2))>0);
                        if ~isempty(outlier)
                            rselect(outlier) = [];
                            [bbb,~,~,~,stats] = regress(yar(rselect),[ones(length(xar(rselect)),1) xar(rselect)]);
                        end
                        panels.balans.stats(swp,kk0) = stats(1);
                        panels.balans.yr{swp,kk0} = yar;
                        panels.balans.gr(swp,kk0) = bbb(2);
                        panels.balans.Er(swp,kk0) = -bbb(1)/bbb(2);
                        if kk0==1
                            Meting(node).adc(:,1,swp) = panels.balans.Er(swp,1);
                            Meting(node).adc(:,2,swp) = panels.balans.Er(swp,1);
                            Meting(node).adc(:,7,swp) = panels.balans.gr(swp,1);
                        end
                    end
                    switch refmode
                        case 'zero',   gr = 0;
                                       y0 = panels.balans.yr{swp,kk0};
                        case 'normal', gr = panels.balans.gr(swp,kk0);
                                       y0 = 0 * panels.balans.yr{swp,kk0};
                        otherwise, Error('Reference mode defined'); return;
                    end
                    for kk3 = (pran1(kk0)+pfres):(2*pfres+1):(pran2(kk0)-pfres)
                        teller = teller + 1;
                        if dosensitivity
                            if kk3==(pran1(kk0)+pfres)
                                Waitbar(CMD,'show',teller/noemer,sprintf('Sensitivity Ei:%03.1f Ee:%03.1f',panels.balans.Ei,panels.balans.Ee));
                            end
                        else
                            if mod(teller,10)==1
                                Waitbar(CMD,'show',teller/noemer,sprintf('Balance node: %1u swp: %1u ref: %2u  time:%6u',ii,swp,kk0,kk3));
                            end
                        end
                        pnts = (kk3-pfres):(kk3+pfres);
                        yar = mean(double(Meting(mnr).adc(pnts,:,swp    )),1)' * Meting(mnr).ADC.scale(1).User/Meting(mnr).ADC.ints;
                        yar = yar - y0;
                        xar = mean(double(Meting(mnr).dac(pnts,1:maxadcs)),1)' * Meting(mnr).DAC.scale(1).User/Meting(mnr).DAC.ints;
                        select = rselect;
                        [bbb,~,~,ival] = regress(yar(select),[ones(length(xar(select)),1) xar(select)]);
                        outlier = find( (ival(:,1).*ival(:,2))>0);
                        if ~isempty(outlier)
                            select(outlier) = [];
                            [bbb,~,~,~] = regress(yar(select),[ones(length(xar(select)),1) xar(select)]);
                        end
                        gi = (bbb(1) + gr * (panels.balans.Er(swp,kk0)-panels.balans.Ee) + bbb(2)*panels.balans.Ee)/(panels.balans.Ee-panels.balans.Ei);
                        ge = bbb(2)-gr-gi;
                        Meting(node).adc(pnts,1,swp) = (gi*panels.balans.Ei+ge*panels.balans.Ee+ panels.balans.gr(swp,kk0)*panels.balans.Er(swp,kk0))/(gi+ge+panels.balans.gr(swp,kk0));
                        Meting(node).adc(pnts,2,swp) = panels.balans.Er(swp,kk0);
                        Meting(node).adc(pnts,7,swp) = panels.balans.gr(swp,kk0);
                        Meting(node).adc(pnts,8,swp) = gi;
                        Meting(node).adc(pnts,9,swp) = ge;
                        if panels.abort, Meting(node) = []; return; end
                    end
                end
                if filter>0
                    flen  = 1+2*round(filter * adcrate);
                    Meting(node).adc(:,1,swp) = convn(Meting(node).adc(:,1,swp),ones(flen,1)/flen,'same');
                    Meting(node).adc(:,2,swp) = convn(Meting(node).adc(:,2,swp),ones(flen,1)/flen,'same');
                    Meting(node).adc(:,7,swp) = convn(Meting(node).adc(:,7,swp),ones(flen,1)/flen,'same');
                    Meting(node).adc(:,8,swp) = convn(Meting(node).adc(:,8,swp),ones(flen,1)/flen,'same');
                    Meting(node).adc(:,9,swp) = convn(Meting(node).adc(:,9,swp),ones(flen,1)/flen,'same');
                end
                if dosensitivity
                    Sens.Result(kk1,kk2,1) = max (Meting(node).adc(pnts,8,swp));
                    Sens.Result(kk1,kk2,2) = max (Meting(node).adc(pnts,9,swp));
                    Sens.Result(kk1,kk2,3) = (Sens.Result(kk1,kk2,1)+Sens.Result(kk1,kk2,2))/panels.balans.gr(swp,kk0);
                    Sens.Result(kk1,kk2,4) = 100 * Sens.Result(kk1,kk2,1)/(Sens.Result(kk1,kk2,1)+Sens.Result(kk1,kk2,2));
                    Sens.Result(kk1,kk2,5) = 100 * mean(Meting(node).adc(pnts,7,swp))/(mean(Meting(node).adc(pnts,8,swp)) + mean(Meting(node).adc(pnts,9,swp)));
                end
            end
        end
        Meting(node).adc(:,11,swp) = 100 * (Meting(node).adc(:,7,swp) + Meting(node).adc(:,9,swp))./(Meting(node).adc(:,7,swp) + Meting(node).adc(:,8,swp))-100;
        Meting(node).adc(:,12,swp) = 100 * (Meting(node).adc(:,8,swp) + Meting(node).adc(:,9,swp))./ Meting(node).adc(:,7,swp);
        for kk0 = 1:length(pran1)
            phlp = pstrt + pran1(kk0);
            cumgi  = cumsum(Meting(node).adc(phlp:pran2(kk0),8,swp));
            cumge  = cumsum(Meting(node).adc(phlp:pran2(kk0),9,swp));
            warning off;
            ratio = cumgi./(cumge+cumgi);
            warning on;
            ratio((cumge+cumgi)==0) = 0;
            Meting(node).adc(phlp:pran2(kk0),10,swp) = max(0,min(100,100*ratio));
        end
        Vnul = Meting(node).adc(:,2,swp).*Meting(node).adc(:,7,swp);
        Meting(node).adc(:,3,swp)       = (Vnul+Meting(node).adc(:,8,swp)*panels.balans.Ei+Meting(node).adc(:,9,swp)*panels.balans.Ee)...
                                             ./(Meting(node).adc(:,7,swp)+Meting(node).adc(:,8,swp)+Meting(node).adc(:,9,swp));
        Meting(node).adc(:,5,swp)       = (Vnul+Meting(node).adc(:,8,swp)*panels.balans.Ei)./(Meting(node).adc(:,7,swp)+Meting(node).adc(:,8,swp));
        Meting(node).adc(:,6,swp)       = (Vnul+Meting(node).adc(:,9,swp)*panels.balans.Ee)./(Meting(node).adc(:,7,swp)+Meting(node).adc(:,9,swp));
        Meting(node).adc(:,[3 5 6],swp) = Meting(node).adc(:,[3 5 6],swp) - panels.balans.Er(swp,1);
        Meting(node).adc(:,4,swp)       = Meting(node).adc(:,5,swp) + Meting(node).adc(:,6,swp);
    end
    Vschaal = 100;
    Meting(node).adc(:,1:6,:) = round(Meting(node).adc(:,1:6,:) * Meting(node).ADC.ints/Vschaal);
    gnorm = 1.05 *max(max(max(Meting(node).adc(:,7:9,:))));
    Meting(node).adc(:,7:9,:) = round(Meting(node).adc(:,7:9,:) * Meting(node).ADC.ints/gnorm);
    Mschaal = 100;
    Meting(node).adc(:,10:12,:) = round(Meting(node).adc(:,10:12,:) * Meting(node).ADC.ints/Mschaal);
    warning off;
    Meting(node).adc = int16(Meting(node).adc);
    warning on;
    if maxswps>1
        Meting(node).adc(:,12+(1:maxadcs),1:maxswps) = Meting(mnr).adc(:,1:maxadcs,1:maxswps);
    else
        Meting(node).adc(:,12+(1:maxadcs)) = Meting(mnr).adc(:,1:maxadcs);
    end
    for kk1 = 12+(1:maxadcs)
        Meting(node).ADC.scale(kk1) = Meting(mnr).ADC.scale(1);
    end
    [Meting(node).ADC.scale(1:6).User]  = deal(Vschaal);
    [Meting(node).ADC.scale(1:6).Units] = deal('mV');
    Meting(node).ADC.scale(1).Name = 'Vmr';
    Meting(node).ADC.scale(2).Name = '    Erev';
    Meting(node).ADC.scale(3).Name = '          EIPSP-Vr';
    Meting(node).ADC.scale(4).Name = 'lin add';
    Meting(node).ADC.scale(5).Name = '          IPSP-Vr';
    Meting(node).ADC.scale(6).Name = 'EPSP-Vr';
    Meting(node).ADC.scale(1).Color = 'k';
    Meting(node).ADC.scale(2).Color = 'k';
    Meting(node).ADC.scale(3).Color = 'k';
    Meting(node).ADC.scale(4).Color = 'g';
    Meting(node).ADC.scale(5).Color = 'r';
    Meting(node).ADC.scale(6).Color = 'b';
   [Meting(node).ADC.scale(7:9).User]  = deal(gnorm);
   [Meting(node).ADC.scale(7:9).Units] = deal('nS');
    Meting(node).ADC.scale(7).Name = '      gr';
    Meting(node).ADC.scale(8).Name = '   gi';
    Meting(node).ADC.scale(9).Name = 'ge';
    Meting(node).ADC.scale(7).Color = 'm';
    Meting(node).ADC.scale(8).Color = 'r';
    Meting(node).ADC.scale(9).Color = 'b';
   [Meting(node).ADC.scale(10:12).User]  = deal(Mschaal);
   [Meting(node).ADC.scale(10:12).Units] = deal('%');
    Meting(node).ADC.scale(10).Name = 'cum(I)/cum(E)+cum(I)';
    Meting(node).ADC.scale(11).Name = '             (gr+ge)/(gr+gi)-1';
    Meting(node).ADC.scale(12).Name = '                               (ge+gi)/gr';
    Meting(node).ADC.scale(10).Color = 'm';
    Meting(node).ADC.scale(11).Color = 'r';
    Meting(node).ADC.scale(12).Color = 'b';
    Meting(node).plotter(1,1).window = 14;
    Meting(node).plotter(2,1).window = 15;
    Meting(node).plotter(3,1).window = 16;
    Meting(node).plotter(1,1).mode = 'adc(1:6)/ballines/shadow';
    Meting(node).plotter(2,1).mode = 'adc(7:9)/ballines/shadow';
    Meting(node).plotter(3,1).mode = ['adc([10])/shadow'];
    Meting(node).plotter(4,1).window = 10;
    Meting(node).plotter(4,1).mode   = sprintf('adc(13:%u)/shadow',13+maxadcs);
    Meting(node).plotter(5,1).window = 12;
    Meting(node).plotter(5,1).mode   = 'dac/shadow';   
    Waitbar(CMD,'hide');
    NRNtimeline;
    WindowClear;
    panels.plotter = Meting(node).plotter;
    panels.plotter.metnr = node;
    panels.plotter.subnr = 1;
    NRNshow(Meting);
    if dosnap, DoSnapshot([]); end
    drawnow();
end
% if dosensitivity
%     Meting(node).result{1}.naam  = 'balance';
%     Meting(node).result{1}.xy    = Sens.Result;
%     Meting(node).result{1}.xas   = Sens.Eexc;
%     Meting(node).result{1}.yas   = Sens.Einh;
%     Meting(node).result{1}.dispx = 'Reversal for Exc';
%     Meting(node).result{1}.dispy = 'Reversal for Inh';
%     for kk1 = 1:length(Sens.Eexc), Meting(node).result{1}.disp1{kk1} = sprintf('Ee %3.2f',Sens.Eexc(kk1)); end
%     for kk1 = 1:length(Sens.Einh), Meting(node).result{1}.disp2{kk1} = sprintf('Ei %3.2f',Sens.Einh(kk1)); end
%     Meting(node).result{1}.disp3 = {'gimax'; 'gemax';'(gimax+gemax)/gr';'gimax/(gimax+gemax)';'cum(gi)/(cum(gi)+cum(ge))'};
%     Meting(node).result{1}.plotter(1).window = 1;
%     Meting(node).result{1}.plotter(1).mode   = 'xyz(3,64)';
%     Meting(node).result{1}.plotter(2).window = 2;
%     Meting(node).result{1}.plotter(2).mode   = 'xyz(4,64)';
%     Meting(node).result{1}.plotter(3).window = 3;
%     Meting(node).result{1}.plotter(3).mode   = 'xyz(5,64)';
%     Meting(node).result{1}.plotter(4).window = 4;
%     Meting(node).result{1}.plotter(4).mode   = 'xyz(1,64)';
%     Meting(node).result{1}.plotter(5).window = 5;
%     Meting(node).result{1}.plotter(5).mode   = 'xyz(2,64)';
% end

function DoBalance2(parms)
global Meting panels p
parms                     = ParseCondition(parms);
% [parms,sets,mets,swps]    = ParseList(parms);
[parms,panels.balans.set] = ParseTwo(parms,"set");
if isempty(panels.balans.set), Error('Balance needs set'); return; end
[parms,panels.balans.zero] = ParseTwo(parms,'zero');
if isempty(panels.balans.zero), Error('Balance needs zero'); return; end
[parms,panels.balans.region] = ParseTwo(parms,'region');
if isempty(panels.balans.region), Error('Balance needs region'); return; end
[parms,present,ps] = ParseSpecial(parms,'artefact');
if ~present, artpos = []; else
    artpos = rsingle(ps{1});
    if ~isempty(artpos)
        artlen   = rsingle(ps{2});
        artmodus = ssingle(ps{3});
    end
end
[parms,present,ps] = ParseSpecial(parms,'Erevs');
if ~present || (length(ps)<2), Error('Balance needs  two Erevs'); return; else
   [ps,present,psh] = ParseSpecial(ps,'who');
    if present
        sensmet = rsingle(psh{1});
        senstim = rsingle(psh{2});
    else
        sensmet = 1;
        senstim = 1;
    end
    Sens.Einh = rsingle(ps{1});
    Sens.Eexc = rsingle(ps{2});
end
% dosensitivity = (length(Sens.Einh)>1) || (length(Sens.Eexc)>1);
% if dosensitivity
%     Sens.Ratio           = zeros(length(Sens.Einh),length(Sens.Eexc),3);
%     panels.balans.ref1   = panels.balans.ref1(senstim);
%     panels.balans.ref2   = panels.balans.ref2(senstim);
%     panels.balans.range1 = panels.balans.range1(senstim);
%     panels.balans.range2 = panels.balans.range2(senstim);
%     Meting               = Meting(sensmet);
%     list                 = 1;
% end
if ~isempty(parms), naamext = ssingle(parms{1}); else,naamext = ''; end
panels.balans.stats = [];
panels.balans.Er    = [];
panels.balans.yr    = {};
panels.balans.gr    = [];
teller = 0;
for ii = 1:size(list,2)
    mnr = list(ii);
   [~,maxadcs,maxswps] = size(Meting(mnr).adc);
    adcrate                = Meting(mnr).ADC.rate/1000;
    node                   = length(Meting) + 1;
    Meting(node)           = Meting(mnr);
    Meting(node).nodenaam  = [Meting(mnr).nodenaam naamext];
    Meting(node).serienaam = [Meting(mnr).serienaam naamext];
    Meting(node).EXTRA.note = 'Balans-Calculation';
    Meting(node).ADC.HWchn = 1:(12+maxadcs);
    Meting(node).ADC.HWloc = 1:(12+maxadcs);
    Meting(node).ADC.HWdev = ones(1,12+maxadcs);
    Meting(node).adc = zeros(size(Meting(node).adc,1),12+maxadcs);
    Meting(node).EXTRA.MEAN.avg = [];
    Meting(node).EXTRA.MEAN.sem = [];
    Meting(node).ADC.scale(2:end) = [];
    for kk1 = 1:6,  Meting(node).ADC.scale(kk1) = Meting(mnr).ADC.scale(2); end
    for kk1 = 7:12, Meting(node).ADC.scale(kk1) = Meting(mnr).ADC.scale(1); end
    Meting(node).reltime = Meting(node-1).reltime(end)+ 1 + (1:maxswps);
    if ~isempty(artpos)
        for kk1 = 1:length(artpos)
            apos  = round(artpos(kk1) * adcrate) + 1;
            aend  = round((artpos(kk1) + artlen) * adcrate);
            for swp = 1:maxswps
                for kk2 = 1:maxadcs
                    switch artmodus
                        case 'straight', Meting(mnr).adc(apos:aend,kk2,swp) = Meting(mnr).adc(apos,kk2,swp); 
                        case 'zero',     Meting(mnr).adc(apos:aend,kk2,swp) = 0;
                    end
                end
            end
        end
    end
    pref1 = round(adcrate * panels.balans.ref1)+1;
    pref2 = round(adcrate * panels.balans.ref2);
    pran1 = round(adcrate * panels.balans.range1)+1;
    pran2 = round(adcrate * panels.balans.range2);
    pfres = round(adcrate * resolutie);
    pstrt = round(adcrate * rstart); 
    panels.balans.res = pfres;
    if ii==1
        noemer = 0;
        for jj=1:length(pran1)
             noemer =noemer + size(list,2) * maxswps * length(pran1(jj):(2*pfres+1):pran2(jj)) * length(Sens.Einh) * length(Sens.Eexc);
        end
    end
    for swp = 1:maxswps
        for kk1 = 1:length(Sens.Einh)
            panels.balans.Ei = Sens.Einh(kk1);
            for kk2 = 1:length(Sens.Eexc)
                panels.balans.Ee = Sens.Eexc(kk2);
                
                for kk0 = 1:length(panels.balans.ref1)
                    if (kk1==1) && (kk2==1)
                        rpnt = pref1(kk0):pref2(kk0);
                        yar = mean(double(Meting(mnr).adc(rpnt,:,swp    )),1)' * Meting(mnr).ADC.scale(1).User/Meting(mnr).ADC.ints;
                        xar = mean(double(Meting(mnr).dac(rpnt,1:maxadcs)),1)' * Meting(mnr).DAC.scale(1).User/Meting(mnr).DAC.ints;        
                        [bbb,~,~,ival,stats] = regress(yar,[ones(length(xar),1) xar]);
                        rselect = 1:length(xar);
                        outlier = find( (ival(:,1).*ival(:,2))>0);
                        if ~isempty(outlier)
                            rselect(outlier) = [];
                            [bbb,~,~,~,stats] = regress(yar(rselect),[ones(length(xar(rselect)),1) xar(rselect)]);
                        end
                        panels.balans.stats(swp,kk0) = stats(1);
                        panels.balans.yr{swp,kk0} = yar;
                        panels.balans.gr(swp,kk0) = bbb(2);
                        panels.balans.Er(swp,kk0) = -bbb(1)/bbb(2);
                        if kk0==1
                            Meting(node).adc(:,1,swp) = panels.balans.Er(swp,1);
                            Meting(node).adc(:,2,swp) = panels.balans.Er(swp,1);
                            Meting(node).adc(:,7,swp) = panels.balans.gr(swp,1);
                        end
                    end
                    switch refmode
                        case 'zero',   gr = 0;
                                       y0 = panels.balans.yr{swp,kk0};
                        case 'normal', gr = panels.balans.gr(swp,kk0);
                                       y0 = 0 * panels.balans.yr{swp,kk0};
                        otherwise, Error('Reference mode defined'); return;
                    end
                    for kk3 = (pran1(kk0)+pfres):(2*pfres+1):(pran2(kk0)-pfres)
                        teller = teller + 1;
                        if dosensitivity
                            if kk3==(pran1(kk0)+pfres)
                                Waitbar(CMD,'show',teller/noemer,sprintf('Sensitivity Ei:%03.1f Ee:%03.1f',panels.balans.Ei,panels.balans.Ee));
                            end
                        else
                            if mod(teller,10)==1
                                Waitbar(CMD,'show',teller/noemer,sprintf('Balance node: %1u swp: %1u ref: %2u  time:%6u',ii,swp,kk0,kk3));
                            end
                        end
                        pnts = (kk3-pfres):(kk3+pfres);
                        yar = mean(double(Meting(mnr).adc(pnts,:,swp     )),1)' * Meting(mnr).ADC.scale(1).User/Meting(mnr).ADC.ints;
                        yar = yar - y0;
                        xar = mean(double(Meting(mnr).dac(pnts,1:maxadcs)),1)'  * Meting(mnr).DAC.scale(1).User/Meting(mnr).DAC.ints;
                        select = rselect;
                        [bbb,~,~,ival] = regress(yar(select),[ones(length(xar(select)),1) xar(select)]);
                        outlier = find( (ival(:,1).*ival(:,2))>0);
                        if ~isempty(outlier)
                            select(outlier) = [];
                            [bbb,~,~,~] = regress(yar(select),[ones(length(xar(select)),1) xar(select)]);
                        end
                        gi = (bbb(1) + gr * (panels.balans.Er(swp,kk0)-panels.balans.Ee) + bbb(2)*panels.balans.Ee)/(panels.balans.Ee-panels.balans.Ei);
                        ge = bbb(2)-gr-gi;
                        Meting(node).adc(pnts,1,swp) = (gi*panels.balans.Ei+ge*panels.balans.Ee+ panels.balans.gr(swp,kk0)*panels.balans.Er(swp,kk0))/(gi+ge+panels.balans.gr(swp,kk0));
                        Meting(node).adc(pnts,2,swp) = panels.balans.Er(swp,kk0);
                        Meting(node).adc(pnts,7,swp) = panels.balans.gr(swp,kk0);
                        Meting(node).adc(pnts,8,swp) = gi;
                        Meting(node).adc(pnts,9,swp) = ge;
                        if panels.abort, Meting(node) = []; return; end
                    end
                end
                if filter>0
                    flen  = 1+2*round(filter * adcrate);
                    Meting(node).adc(:,1,swp) = convn(Meting(node).adc(:,1,swp),ones(flen,1)/flen,'same');
                    Meting(node).adc(:,2,swp) = convn(Meting(node).adc(:,2,swp),ones(flen,1)/flen,'same');
                    Meting(node).adc(:,7,swp) = convn(Meting(node).adc(:,7,swp),ones(flen,1)/flen,'same');
                    Meting(node).adc(:,8,swp) = convn(Meting(node).adc(:,8,swp),ones(flen,1)/flen,'same');
                    Meting(node).adc(:,9,swp) = convn(Meting(node).adc(:,9,swp),ones(flen,1)/flen,'same');
                end
                if dosensitivity
                    Sens.Result(kk1,kk2,1) = max (Meting(node).adc(pnts,8,swp));
                    Sens.Result(kk1,kk2,2) = max (Meting(node).adc(pnts,9,swp));
                    Sens.Result(kk1,kk2,3) = (Sens.Result(kk1,kk2,1)+Sens.Result(kk1,kk2,2))/panels.balans.gr(swp,kk0);
                    Sens.Result(kk1,kk2,4) = 100 * Sens.Result(kk1,kk2,1)/(Sens.Result(kk1,kk2,1)+Sens.Result(kk1,kk2,2));
                    Sens.Result(kk1,kk2,5) = 100 * mean(Meting(node).adc(pnts,7,swp))/(mean(Meting(node).adc(pnts,8,swp)) + mean(Meting(node).adc(pnts,9,swp)));
                end
            end
        end
        Meting(node).adc(:,11,swp) = 100 * (Meting(node).adc(:,7,swp) + Meting(node).adc(:,9,swp))./(Meting(node).adc(:,7,swp) + Meting(node).adc(:,8,swp))-100;
        Meting(node).adc(:,12,swp) = 100 * (Meting(node).adc(:,8,swp) + Meting(node).adc(:,9,swp))./ Meting(node).adc(:,7,swp);
        for kk0 = 1:length(pran1)
            phlp = pstrt + pran1(kk0);
            cumgi  = cumsum(Meting(node).adc(phlp:pran2(kk0),8,swp));
            cumge  = cumsum(Meting(node).adc(phlp:pran2(kk0),9,swp));
            warning off;
            ratio = cumgi./(cumge+cumgi);
            warning on;
            ratio((cumge+cumgi)==0) = 0;
            Meting(node).adc(phlp:pran2(kk0),10,swp) = max(0,min(100,100*ratio));
        end
        Vnul = Meting(node).adc(:,2,swp).*Meting(node).adc(:,7,swp);
        Meting(node).adc(:,3,swp)       = (Vnul+Meting(node).adc(:,8,swp)*panels.balans.Ei+Meting(node).adc(:,9,swp)*panels.balans.Ee)...
                                             ./(Meting(node).adc(:,7,swp)+Meting(node).adc(:,8,swp)+Meting(node).adc(:,9,swp));
        Meting(node).adc(:,5,swp)       = (Vnul+Meting(node).adc(:,8,swp)*panels.balans.Ei)./(Meting(node).adc(:,7,swp)+Meting(node).adc(:,8,swp));
        Meting(node).adc(:,6,swp)       = (Vnul+Meting(node).adc(:,9,swp)*panels.balans.Ee)./(Meting(node).adc(:,7,swp)+Meting(node).adc(:,9,swp));
        Meting(node).adc(:,[3 5 6],swp) = Meting(node).adc(:,[3 5 6],swp) - panels.balans.Er(swp,1);
        Meting(node).adc(:,4,swp)       = Meting(node).adc(:,5,swp) + Meting(node).adc(:,6,swp);
    end
    Vschaal = 100;
    Meting(node).adc(:,1:6,:) = round(Meting(node).adc(:,1:6,:) * Meting(node).ADC.ints/Vschaal);
    gnorm = 1.05 *max(max(max(Meting(node).adc(:,7:9,:))));
    Meting(node).adc(:,7:9,:) = round(Meting(node).adc(:,7:9,:) * Meting(node).ADC.ints/gnorm);
    Mschaal = 100;
    Meting(node).adc(:,10:12,:) = round(Meting(node).adc(:,10:12,:) * Meting(node).ADC.ints/Mschaal);
    warning off;
    Meting(node).adc = int16(Meting(node).adc);
    warning on;
    if maxswps>1
        Meting(node).adc(:,12+(1:maxadcs),1:maxswps) = Meting(mnr).adc(:,1:maxadcs,1:maxswps);
    else
        Meting(node).adc(:,12+(1:maxadcs)) = Meting(mnr).adc(:,1:maxadcs);
    end
    for kk1 = 12+(1:maxadcs)
        Meting(node).ADC.scale(kk1) = Meting(mnr).ADC.scale(1);
    end

    [Meting(node).ADC.scale(1:6).User]  = deal(Vschaal);
    [Meting(node).ADC.scale(1:6).Units] = deal('mV');
    Meting(node).ADC.scale(1).Name = 'Vmr';
    Meting(node).ADC.scale(2).Name = '    Erev';
    Meting(node).ADC.scale(3).Name = '          EIPSP-Vr';
    Meting(node).ADC.scale(4).Name = 'lin add';
    Meting(node).ADC.scale(5).Name = '          IPSP-Vr';
    Meting(node).ADC.scale(6).Name = 'EPSP-Vr';
    Meting(node).ADC.scale(1).Color = 'k';
    Meting(node).ADC.scale(2).Color = 'k';
    Meting(node).ADC.scale(3).Color = 'k';
    Meting(node).ADC.scale(4).Color = 'g';
    Meting(node).ADC.scale(5).Color = 'r';
    Meting(node).ADC.scale(6).Color = 'b';
   [Meting(node).ADC.scale(7:9).User]  = deal(gnorm);
   [Meting(node).ADC.scale(7:9).Units] = deal('nS');
    Meting(node).ADC.scale(7).Name = '      gr';
    Meting(node).ADC.scale(8).Name = '   gi';
    Meting(node).ADC.scale(9).Name = 'ge';
    Meting(node).ADC.scale(7).Color = 'm';
    Meting(node).ADC.scale(8).Color = 'r';
    Meting(node).ADC.scale(9).Color = 'b';
   [Meting(node).ADC.scale(10:12).User]  = deal(Mschaal);
   [Meting(node).ADC.scale(10:12).Units] = deal('%');
    Meting(node).ADC.scale(10).Name = 'cum(I)/cum(E)+cum(I)';
    Meting(node).ADC.scale(11).Name = '             (gr+ge)/(gr+gi)-1';
    Meting(node).ADC.scale(12).Name = '                               (ge+gi)/gr';
    Meting(node).ADC.scale(10).Color = 'm';
    Meting(node).ADC.scale(11).Color = 'r';
    Meting(node).ADC.scale(12).Color = 'b';
    Meting(node).plotter(1,1).window = 14;
    Meting(node).plotter(2,1).window = 15;
    Meting(node).plotter(3,1).window = 16;
    Meting(node).plotter(1,1).mode = 'adc(1:6)/ballines/shadow';
    Meting(node).plotter(2,1).mode = 'adc(7:9)/ballines/shadow';
    Meting(node).plotter(3,1).mode = ['adc([10])/shadow'];
    Meting(node).plotter(4,1).window = 10;
    Meting(node).plotter(4,1).mode   = sprintf('adc(13:%u)/shadow',13+maxadcs);
    Meting(node).plotter(5,1).window = 12;
    Meting(node).plotter(5,1).mode   = 'dac/shadow';   
    Waitbar(CMD,'hide');
    NRNtimeline;
    WindowClear;
    panels.plotter = Meting(node).plotter;
    for jj = 1: length(panels.plotter)
        panels.plotter(jj).metnr = node;
        panels.plotter(jj).subnr = 1;
    end
    NRNshow(Meting);
end

function DoPCA(parms)
global Meting
[parms,present,ps] = ParseSpecial(parms,'window');
if present, window = nsingle(ps{1}); else,window = [1,5,2,3]; end
[parms,present,ps] = ParseSpecial(parms,'example');
if present, example = nsingle(ps{1}); else,example = []; end
[parms,present,ps] = ParseSpecial(parms,'root');
if present
    [nodename,resname] = strtok(ssingle(ps{1}),'@');
    resname = resname(2:end);
    nres = find(strcmp({Meting.nodenaam},nodename));
	if ~isfield(Meting(nres).result,resname)
        Error(sprintf('%s does not exist',resname)); return
	end
else
    Error('pca needs root'); return
end
donumbers = false;
param = [];
use   = [];
[parms,present,ps] = ParseSpecial(parms,'factors');
if present
    for jj = 1:length(ps)
        [cmd,pars] = ParseCmd(ssingle(ps{jj}));
        [name1,name2] = strtok(cmd,'.');
        if strcmp(name1,'mets')
            factor = Meting(nres).result.(resname).basis.metswp(:,2);
            donumbers = true;
        elseif isempty(name2)
            if isfield(Meting(nres).result.(resname),name1)
                factor = round(Meting(nres).result.(resname).(name1));
            else
                Error(sprintf('%s does not exist',name1)); return
            end
        else
            factor = round(Meting(nres).result.(resname).(name1).(name2(2:end)));
        end
        param(:,jj) = factor;
        unifac = unique(factor);
        sel = nsingle(pars{1});
        if sel==0
            sel = 1:length(unifac);
        end
        if jj==1
            use = ismember(factor,unifac(sel));
        else
            use = use & ismember(factor,unifac(sel));
        end
    end
end
[parms,present,ps] = ParseSpecial(parms,'source');
if present
    dt = 1;
    strset = stringset(ssingle(ps{1}));
    for ii = 1:length(strset)
        [name1,name2] = strtok(ssingle(strset{ii}),'.');
        if ~isfield(Meting(nres).result.(resname),name1), continue; end
        if isempty(name2)
            source = Meting(nres).result.(resname).(name1);
        else
            name2 = name2(2:end);
            source = Meting(nres).result.(resname).(name1).(name2);
            if strcmp(name2,'SWPs')
                dt = Meting(nres).result.(resname).(name1).xas(1);
            end
        end
%         source = source(:,valid);
%         params = param(valid,:);
%         use = use(valid);
        [timelen,numswp] = size(source);
        if ~isempty(use)
            source = source(:,use);
            params = param(use,:);
        end
        if length(strset)>1
            params(:,3) = deal(ii);
        end
        if ii==1
            data.source = source;
            data.param  = params;
        else
            data.source = [data.source, source];
            data.param  = [data.param;  params];
        end
    end
end
[timelen,numswp] = size(data.source);
vecnum = size(data.source,2);
[parms,present,ps] = ParseSpecial(parms,'vectors');
if present
    vecuse = max(1,min(vecnum,nsingle(ps{1})));
else
    vecuse = vecnum;
end
[parms,zero] = ParseTwo(parms,'zero');
p1 = 1+round(zero(1)/dt);
p2 = 1+round(zero(2)/dt);
aver = mean(data.source,1);
hlp = data.source;
for jj = 1:vecnum, hlp(:,jj) = hlp(:,jj) - aver(jj); end
[data.coeff,data.pc,data.var,data.stat] = princomp(hlp);
aver = mean(data.pc(p1:p2,:));
for jj=1:vecnum
    data.norm(jj,1) = sum(data.pc(:,jj).* data.pc(:,jj));
    data.pc(:,jj) = data.pc(:,jj) - aver(jj);
end
data.norm   = sqrt(data.norm/data.norm(1));
data.cumvar = 100*data.var/sum(data.var);
data.result = zeros(size(data.source));
for jj = 1:vecnum
    for ii = 1:vecuse
        data.result(:,jj) = data.result(:,jj) + data.pc(:,ii)*data.coeff(jj,ii);
    end
    data.error(jj,1) = sum((data.result(:,jj)-data.source(:,jj)).^2)/(10*timelen);
end
xas = dt * (0:(timelen-1));
colors = 'rbgcmk';
getplothandle(window(1),true);
for jj = 1:vecnum
    kleur = choose(jj+1,[]);
    line('XData',xas,'YData',data.source(:,jj),...
         'Color',kleur,'LineStyle','-','LineWidth',1.5,'Marker','none');
    line('XData',xas,'YData',data.result(:,jj),...
         'Color',kleur,'LineStyle',':','LineWidth',1.5,'Marker','none');
end
line('XData',xas([1,end]),'YData',[0,0],'Tag','zero',...
     'Color','k','LineStyle','--','LineWidth',1,'Marker','none');
 
getplothandle(window(2),true);
handle = semilogy(data.cumvar); grid on
set(handle,'Color','r','LineWidth',2,'Marker','o','Markersize',12);
hold on
handle = semilogy(data.error/1000);
set(handle,'Color','b','LineWidth',2,'Marker','s','Markersize',12);
handle1 = getplothandle(window(3),true);
for jj = 1:vecuse
    kleur = choose(jj+1,[]);
    line('XData',xas,'YData',data.pc(:,jj),'UserData',data.pc(:,jj),'Tag',sprintf('comp%0u',jj),...
         'Color',kleur,'LineStyle','-','LineWidth',1.5,'Marker','none');
end
line('XData',xas([1,end]),'YData',[0,0],'UserData',example,'Tag','zero',...
     'Color','k','LineStyle','--','LineWidth',1,'Marker','none');
 
handle2 = getplothandle(window(4),true);
for jj = 1:vecuse
    kleur = choose(jj+1,[]);
    if donumbers
        xin = 1:numswp;
    elseif length(unique(data.param(:,1)))==1
        xin = data.param(:,2);
    else
        xin = data.param(:,1);
    end
    [xx,yy] = monotone(xin,data.coeff(:,jj));
    line('XData',xx,'YData',yy,'UserData',yy,'Tag',sprintf('comp%0u',jj),...
         'Color',kleur,'LineStyle','-','LineWidth',2,'Marker','o','Markersize',12);
end
line('XData',xx([1,end]),'YData',[0,0],'Tag','zero',...
     'Color','k','LineStyle','--','LineWidth',1.5,'Marker','none');
Rotatepca([],[handle1;handle2])

function Rotatepca(src,grafhandles)
if isempty(src)
    pos = get(grafhandles(1),'Position');
    pos(2)=pos(2)-0.04;
    pos(4) = 0.04;
    hp = uipanel('Position',pos,'Tag','rotatepca','UserData',grafhandles);
    uicontrol('Style','slider','Parent',hp,'Units','normalized','Position',[0.15,0.15,0.80,0.7],'Tag','pcaslider',...
              'Min',0,'Max',180,'Value',0,'Sliderstep',[1/180,10/180],...
              'ForegroundColor',[1 1 1],'BackgroundColor',[0.75 0 0],'Callback',{@Rotatepca});
    uicontrol('Parent',hp,'Units','normalized','Callback',{@Rotatepca},...
              'FontSize',20,...
              'HorizontalAlignment','center',...
              'Position',[0.96,0.15,0.04,0.7],...
              'String','X',...
              'TooltipString','close rotate panel',...
              'Tag','pcaclose');
    uicontrol('Parent',hp,'Style','edit','Units','normalized','Callback',{@Rotatepca},...
              'ForegroundColor',[1 0 0],...
              'FontSize',20,...
              'HorizontalAlignment','center',...
              'Position',[0.01,0.15,0.14,0.7],...
              'String','0',...
              'TooltipString','rotation angle',...
              'Tag','pcaangle');
else
    parent = get(src,'Parent');
    hhh = get(parent,'Children');
    switch get(src,'Tag')
        case 'pcaclose',  delete(parent); return;
        case 'pcaangle',  set(hhh(strcmp(get(hhh,'Tag'),'pcaslider')),'Value',str2double(get(src,'String')));
        case 'pcaslider', set(hhh(strcmp(get(hhh,'Tag'),'pcaangle')), 'String',sprintf('%0.1f', get(src,'Value')));
    end
    fie = pi * get(hhh(strcmp(get(hhh,'Tag'),'pcaslider')),'Value')/180;
    rots = [cos(fie) -sin(fie);sin(fie) cos(fie)];
    grfs = get(parent,'UserData');
    lines = get(grfs(1),'Children');
    hcomp1 = lines(strcmp(get(lines,'Tag'),'comp1'));
    hcomp2 = lines(strcmp(get(lines,'Tag'),'comp2'));
    hnul   = lines(strcmp(get(lines,'Tag'),'zero'));
    c1 = get(hcomp1,'UserData');
    c2 = get(hcomp2,'UserData');
    cc = [c1,c2]*rots;
    set(hcomp1,'YData',cc(:,1));
    set(hcomp2,'YData',cc(:,2));
    hfact = get(grfs(2),'Children');
    hfact1 = hfact(strcmp(get(hfact,'Tag'),'comp1'));
    hfact2 = hfact(strcmp(get(hfact,'Tag'),'comp2'));
    a1 = get(hfact1,'UserData');
    a2 = get(hfact2,'UserData');
    aa = [a1,a2]*rots;
    set(hfact1,'YData',aa(:,1));
    set(hfact2,'YData',aa(:,2));
    example = get(hnul,'UserData');
    if ~isempty(example) && (example<=size(aa,1))
        set(hnul,'Xdata',get(hcomp1,'Xdata'),'Ydata',aa(example,1)*cc(:,1)+aa(example,2)*cc(:,2));
    end
end

function [xx,yy] = monotone(xin,yin)
splits = [find(diff(xin(:))<0); length(yin)]; 
xx = xin(1:splits(1));
yy = yin(1:splits(1));
for jj = 2:length(splits)
    bgn = splits(jj-1)+1;
    lst = splits(jj);
    xx = [xx; NaN; xin(bgn:lst)];
    yy = [yy; NaN; yin(bgn:lst)];
end

function value = LV(spiketrain)
if length(spiketrain)<3
    value = NaN;
else
    dtrain = diff(spiketrain);
    for jj = 1:length(dtrain)
        dmin = dtrain(1:end-1)-dtrain(2:end);
        dmax = dtrain(1:end-1)+dtrain(2:end);
        value = 3*sum((dmin./dmax).^2)/length(dtrain);
    end
end

function [freq,xt] = makefreq(times)
xt   = times;
freq = NaN;
if length(times)==1
    return
elseif length(times)==2
    interval = [times(2)-times(1); times(2)-times(1);];
    xt  = [0.5*(xt(2)+xt(1)); 0.5*(xt(2)+xt(1));];
else
    interval = [times(2)-times(1);...
                (times(3:end)-times(1:(end-2)))*0.5;...
                 times(end)-times(end-1);];
end
freq = (1000./interval);

function DoSpikes(parms)
global panels spikebasis
parms = ParseFigure(parms);
window = 23;
legtxt = [];
[parms,present,ps] = ParseSpecial(parms,'window');
if present
    [ps,present] = ParseSpecial(ps,'file');
    if present, [~,hlp,~] = fileparts(panels.file.name); else,hlp = []; end
    window = nsingle(ps{1});
    if length(ps)>1, legtxt = [hlp '   ' ssingle(ps{2})]; end
end
[parms,doadapt,ps] = ParseSpecial(parms,'adapt');
if doadapt, adaptwin = nsingle(ps{1}); end
[parms,dosort,ps]  = ParseSpecial(parms,'sort');
if dosort, sortoffset = nsingle(ps{1}); else,sortoffset = -1; end
[parms,dobasis] = ParseSpecial(parms,'basis');
[parms,donext]  = ParseSpecial(parms,'next');
numtrace = length(result.times);
handle = getplothandle(window,true);
if window<0, title(legtxt); end
if isfield(result,'xas')
    patch ([result.xas; result.xas(end:-1:1)],[result.mean+result.sem; result.mean(end:-1:1)-result.sem(end:-1:1)],[0.8 0.8 0.8],'EdgeColor','none'); 
    line('XData',result.xas,'YData',result.mean,'Color','r','LineWidth',2,'LineStyle','-','Marker','none');
    amp = max(result.mean+result.sem);
    damp = 3*amp/numtrace;
else
    amp = 0;
    damp = 0.1;
end
total   = [];
special = [];
volgende = [];
before  = [];
after   = [];
sfreq   = [];
xfreq   = [];
if dosort
    hlp = zeros(numtrace,1);
    for jj = 1:numtrace
        die = find(result.times{jj}>0,1,'first');
        hlp(jj) = result.times{jj}(die+sortoffset);
    end
    [~,idx] = sort(hlp);
else
    idx = 1:numtrace;
end
for jjj = 1:numtrace
    jj = idx(jjj);
    total = [total diff(result.times{jj})'];
    if doadapt
        [fhlp,xhlp] = makefreq(result.times{jj});
        sfreq = [sfreq; fhlp];
        xfreq = [xfreq; xhlp];
    end
    die = find(result.times{jj}>0,1,'first');
    if die>1
        special(end+1)  = result.times{jj}(die)-result.times{jj}(die-1);
        if donext, volgende(end+1) = result.times{jj}(die+1)-result.times{jj}(die); end
        before(end+1)   = result.times{jj}(die);
        after(end+1)    = result.times{jj}(die-1);
    end
    amp = amp + damp;
    line('XData',result.times{jj},...
         'YData',amp + 0*result.times{jj},...
         'Color','b','LineWidth',1,'LineStyle','none','Marker','o','MarkerSize',8);
end
set(handle,'XLim',result.tt(1:2),'YLim',[0,amp+0.1]);
line('XData',[0 0],'YData',[0 amp+0.1],'Color','r','LineWidth',2,'LineStyle','--','Marker','none');
if dobasis || isempty(special)
    result.meanint = mean(total);
    result.meansem = std(total)/realsqrt(length(total));
    result.median  = median(total);
    [H,P] = lillietest(total);
    result.lillie  = [H,P];
    if dobasis
        spikebasis = result;
        spikebasis.total = total;
    end
else
    if donext
        special = volgende;
    end
    result.meanint = mean(special);
    result.meansem = std(special)/realsqrt(length(special));
    result.median  = median(special);
    warning off
    [H,P] = lillietest(special);
    warning on
    result.lillie  = [H,P];
end
if doadapt
    handle = getplothandle(adaptwin,true);
    [xfreq,idx] =sort(xfreq);
    sfreq = sfreq(idx);
    plot(xfreq,sfreq,'or');
    set(handle,'YLIM',[0,1.1*max(sfreq)],'XLim',[min(result.xas),max(result.xas)]);
    if adaptwin<0, title('adaptation'); end
end
[parms,present,ps] = ParseSpecial(parms,'hist');
if present
    win = nsingle(ps{1});
    if length(ps)>1, resolutie = rsingle(ps{2}); else,resolutie = 0:10:250; end
    handle = getplothandle(win,true);
    if isempty(special)
        hist(total,resolutie);
        numspk = length(total);
    else
        hist(special,resolutie);
        numspk = length(special);
    end
    xlims = [min(resolutie) max(resolutie)];
    ylims = 1.2*get(handle,'YLim');
    set(handle,'XLim',xlims,'YLim',ylims);
    if win<0, title('interval distribution'); end
	text(xlims(1),ylims(2), sprintf('mean: %6.2f(%0.1f Hz)\nsem:  %6.2f(n=%u)\nLT(%u):%0.4f\n\nmed:  %6.2f\n\nLV:   %0.3f',...
        result.meanint,1000/result.meanint,result.meansem,numspk,round(result.lillie(1)),result.lillie(2),result.median,result.LV),...
        'Color','b','HorizontalAlignment','Left', 'VerticalAlignment','Top','Fontsize',14,'Fontname','Courier');
    if ~isempty(special)
        [H1,P1] = ttest2 (special,spikebasis.total);
        [P2,H2] = ranksum(special,spikebasis.total);
        text(xlims(2),ylims(2), sprintf('compare to basis\n\nT-test(%u): %0.4f\nMWU(%u): %0.4f',H1,P1,H2,P2),...
            'Color','b','HorizontalAlignment','Right','VerticalAlignment','Top','Fontsize',14,'Fontname','Courier');
    end
end
[~,present,ps] = ParseSpecial(parms,'histaround');
if present
    win = nsingle(ps{1});
    if length(ps)>1, resolutie = rsingle(ps{2}); else,resolutie = 0:10:250; end
    handle = getplothandle(win,true);
    hist([after before],resolutie);
    set(handle,'XLim',[min(resolutie) max(resolutie)]);
    line('XData',[0 0],'YData',get(handle,'YLim'),'Color','r','LineWidth',2,'LineStyle','--','Marker','none');
    if win<0, title('before and after first laser puls'); end
end
figure(panels.root);

function [parms,nres,resnaam,nodename] = INIresultbasis(CMD,parms,numtraces,varargin)
global Meting panels p
if nargin>3, numloop = varargin{1}; else, numloop = 1; end
nodename = [];
resnaam  = [];
nres     = [];
[parms,present,ps] = ParseSpecial(parms,'target'); if ~present, Error('target ?'); return; end
[ps,present,psh]   = ParseSpecial(ps,'root');      if ~present, Error('root ?'); return; end
[psh,delnode]      = ParseSpecial(psh,'delnode');
[psh,delstruct]    = ParseSpecial(psh,'delstruct');
[tmp1,tmp2] = strtok(ssingle(psh{1}),'@');
if isempty(tmp2), Error('target needs a root xxx@xxx'); return; end
nodename = ssingle(tmp1);
resnaam  = ssingle(tmp2(2:end));
nres = find(strncmp({Meting.nodenaam},nodename,length(nodename)));
if length(nres)>1, Error('target exists already'); return; end
if delnode && ~isempty(nres)
    Meting(nres) = [];
    nres = [];
end
if delstruct && ~isempty(nres) && isfield(Meting(nres).result,resnaam)
	Meting(nres).result = rmfield(Meting(nres).result,resnaam);
end
if isempty(nres)
    nres = Newnode(nodename);
    Meting(nres).nodenaam = nodename;
    Meting(nres).setnr    = true;
    Meting(nres).abstime  = Meting(nres-1).abstime;
    Meting(nres).reltime  = NaN;
end
[~,fnaam] = fileparts(panels.file.name);
if ~isfield(Meting(nres).result,resnaam)
    Meting(nres).result.(resnaam).basis = struct('file',fnaam,'label',[],'disps',[],'formulas',[],'plotter',[],...
                                                 'parameters',p,'rechts',[],'kanaal',[],'valid',[],'metswp',NaN(numtraces*numloop,6),...
                                                 'times',NaN(numtraces*numloop,1),'Times',NaN(numtraces*numloop,1));
end
[~,present,psh] = ParseSpecial(ps,'plot');
if present
	Meting(nres).result.(resnaam).basis.plotter = [];
	jjj = 0;
	for jj=1:2:length(psh)
        jjj = jjj+1;
        Meting(nres).result.(resnaam).basis.plotter(1,jjj).window = ssingle(psh{jj});
        Meting(nres).result.(resnaam).basis.plotter(1,jjj).mode   = ssingle(psh{jj+1});
        Meting(nres).result.(resnaam).basis.plotter(1,jjj).struct = sprintf('%s@%s',nodename,resnaam);
	end  
end
Meting(nres).result.(resnaam).basis.label{1,1} = CMD.label1.UserData;
Meting(nres).result.(resnaam).basis.label{2,1} = CMD.label2.UserData;
CMD.label1.String = Meting(nres).result.(resnaam).basis.label{1};
CMD.label2.String = Meting(nres).result.(resnaam).basis.label{2};
[~,present,psh] = ParseSpecial(ps,'rechts'); if present, Meting(nres).result.(resnaam).basis.rechts = psh; end

function [parms] = DoRunFRM(parms,nres,resnaam)
global Meting Formula panels p
mets  = Meting(nres).result.(resnaam).basis.metswp(:,2);
swps  = Meting(nres).result.(resnaam).basis.metswp(:,3);
nodes = Meting(nres).result.(resnaam).basis.metswp(:,5);
numtraces = length(nodes);
dorun = true;
while dorun
    [parms,dorun,ps] = ParseSpecial(parms,'runform');
    if dorun
        [ps,formwait]  = ParseOne(ps,'wait',0);
        [ps,docmd,psh] = ParseSpecial(ps,'cmd');
        if docmd
            [ps,present,psp] = ParseSpecial(ps,'plot');
            if present
                Org.plot = panels.plotter;
                panels.plotter = struct('window',nsingle(psp{1}),'mode',ssingle(psp{2}),'struct',[],'metnr',[],'swpnr',[]);
            else
                Error('runform cmd needs plot'); return
            end
        else
            [ps,present,psh] = ParseSpecial(ps,'form');
            if ~present
                Error('runform needs cmd or form'); return
            end
        end
        subnaam   = ssingle(psh{1});
        formel{1} = ssingle(psh{2});
        Meting(nres).result.(resnaam).(subnaam) = NaN(numtraces,1);
        for idx = 1:numtraces
            if docmd
                Formula.on = true;
                panels.plotter.metnr = nodes(idx);
                panels.plotter.subnr = swps(idx);
                NRNshow(Meting);
                eval(['res = ', formel{1}, ';']);
                if formwait>0, pause(formwait); else, pause(0.010); end
            else
                Org.p    = p;
                Org.axon = panels.axon;
                setpanelaxonandp(Meting(nodes(idx)));
                res = rsingle(formel{1}); 
                panels.axon = Org.axon;
                if length(res)>1, res = res(idx); end
            end
            Meting(nres).result.(resnaam).(subnaam)(idx,1) = res;
            if panels.abort, Error('form aborted'); return; end
        end
        if docmd
            panels.plotter = Org.plot;
            WindowClear;
        end
    end
end

function DoRunIMP(parms,nres,resnaam)
global panels timeline Formula Meting
[parms,formwait] = ParseOne(parms,'wait',0);
[parms,wins]     = ParseTwo(parms,'window',[11,13]);
voltplot         = struct('window',wins(1),'mode','','struct',[],'metnr',[],'swpnr',[]);
curplot          = struct('window',wins(2),'mode','','struct',[],'metnr',[],'swpnr',[]);
[parms,present,psh] = ParseSpecial(parms,'voltage'); if present, voltplot.mode = ssingle(psh{1}); else, Error('imp needs voltage'); return; end
[parms,present,psh] = ParseSpecial(parms,'current'); if present, curplot.mode = ssingle(psh{1}); else, Error('imp needs current'); return; end
imp = [];
[parms,present,psh] = ParseSpecial(parms,'times'); if present, imp.times = rsingle(psh{1}); else, Error('imp needs times'); return; end  
if Error, return; end
swps  = Meting(nres).result.(resnaam).basis.metswp(:,3);
nodes = Meting(nres).result.(resnaam).basis.metswp(:,5);
numtraces = length(nodes);
Meting(nres).result.(resnaam).imp.Ihold = NaN(numtraces,1);
Meting(nres).result.(resnaam).imp.Vhold = NaN(numtraces,1);
Meting(nres).result.(resnaam).imp.Vimp  = NaN(numtraces,1);
Meting(nres).result.(resnaam).imp.Rimp  = NaN(numtraces,1);
Meting(nres).result.(resnaam).imp.Cm    = NaN(numtraces,1);
Meting(nres).result.(resnaam).imp.Rm    = NaN(numtraces,1);
Meting(nres).result.(resnaam).imp.Vm    = NaN(numtraces,1);
panels.NRNabort = false;
panels.NRNbusy  = false;
tmpshow         = Formula.noshow;
for idx = 1:numtraces
    nodenr = nodes(idx);
    swpnr  = swps(idx);
    if idx==1
        Formula.on     = true;
        Formula.handle = [];
        Formula.noshow = false;
        panels.plotter = [];
        panels.plotter = voltplot;
        panels.plotter.struct = [];
        panels.plotter.metnr  = nodenr;
        panels.plotter.subnr  = swpnr;
        NRNshow(Meting);
        if Error, return; end
        volthandle = Formula.handle;
        ymax = get(get(volthandle,'Parent'),'YLim');
        for jj = 1:2:length(imp.times)
            patch([imp.times(jj); imp.times(jj); imp.times(jj+1); imp.times(jj+1); imp.times(jj)]/panels.timegain,...
                  [ymax(2);       ymax(1);       ymax(1);         ymax(2);         ymax(2)],[0.9 0.97 0.97],'EdgeColor','k','LineStyle',':');
        end
        correctorder(get(volthandle,'Parent'));
        xdata     = get(volthandle,'XData')';
        plt       = ontleed(voltplot.mode,Meting(nodenr));
        if Error, return; end
        voltisadc = strcmp(plt.mode,'adc');
        voltchan  = plt.chns(1);
        if voltisadc
            optie = 'adc';
            voltas = (0:size(Meting(nodenr).adc,1)-1)' * 1000/Meting(nodenr).ADC.rate;
        else
            optie = 'dac';
            Meting(nodenr) = DACexpand(Meting(nodenr));
            voltas = (0:size(Meting(nodenr).dac,1)-1)' * 1000/Meting(nodenr).DAC.rate;
        end
        vp1 = find(voltas>=xdata(1),  1,'first');
        vp2 = find(voltas>=xdata(end),1,'first');
        voltas = voltas(vp1:vp2);
        Formula.on = true;
        Formula.handle = [];
        Formula.noshow = false;
        
        panels.plotter = curplot;
        panels.plotter.struct = [];
        panels.plotter.metnr  = nodenr;
        panels.plotter.subnr  = swpnr;
        
        NRNshow(Meting);
        
        if Error, return; end
        curhandle = Formula.handle;
        ymax = get(get(curhandle,'Parent'),'YLim');
        for jj = 1:2:length(imp.times)
            patch([imp.times(jj); imp.times(jj); imp.times(jj+1); imp.times(jj+1); imp.times(jj)]/panels.timegain,...
                  [ymax(2);       ymax(1);       ymax(1);         ymax(2);         ymax(2)],[0.9 0.97 0.97],'EdgeColor','k','LineStyle',':');
        end
        correctorder(get(curhandle,'Parent'));
        
        xdata = get(curhandle,'XData')';
        plt = ontleed(curplot.mode,Meting(nodenr));
        if Error, return; end
        curisadc = strcmp(plt.mode,'adc');
        curchan  = plt.chns(1);
        if strcmp(plt.mode,'adc')
            curtas = (0:size(Meting(nodenr).adc,1)-1)' * 1000/Meting(nodenr).ADC.rate;
        else
            Meting(nodenr) = DACexpand(Meting(nodenr));
            curtas = (0:size(Meting(nodenr).dac,1)-1)' * 1000/Meting(nodenr).DAC.rate;
        end
        cp1 = find(curtas>=xdata(1),  1,'first');
        cp2 = find(curtas>=xdata(end),1,'first');
        curtas = curtas(cp1:cp2);
    end
    if voltisadc
        volts = squeeze(double(Meting(nodenr).adc(vp1:vp2,voltchan,swpnr)))* Meting(nodenr).ADC.scale(voltchan).User/Meting(nodenr).ADC.ints;
    else
        Meting(nodenr) = DACexpand(Meting(nodenr));
        volts = squeeze(double(Meting(nodenr).dac(vp1:vp2,voltchan)))* Meting(nodenr).DAC.scale(voltchan).User/Meting(nodenr).DAC.ints;
    end
    if curisadc
        current = squeeze(double(Meting(nodenr).adc(cp1:cp2,curchan,swpnr)))* Meting(nodenr).ADC.scale(curchan).User/Meting(nodenr).ADC.ints;
    else
        Meting(nodenr) = DACexpand(Meting(nodenr));
        current = squeeze(double(Meting(nodenr).dac(cp1:cp2,curchan)))* Meting(nodenr).DAC.scale(curchan).User/Meting(nodenr).DAC.ints;
    end
    set(volthandle,'XData',voltas,'YData',volts);
    set(curhandle,'XData',curtas,'YData',current);
    V = [];
    C = [];
    for jj = 1:2:length(imp.times)
        V(end+1,1) = mean(volts  ((voltas>=imp.times(jj)) & (voltas<imp.times(jj+1))));
        C(end+1,1) = mean(current((curtas>=imp.times(jj)) & (curtas<imp.times(jj+1))));
    end    
    bbb = regress(C,[ones(size(V,1),1) V]);
    Meting(nres).result.(resnaam).imp.Vhold(idx,1) = V(1,1);
    Meting(nres).result.(resnaam).imp.Ihold(idx,1) = C(1,1);
    if abs(bbb(2))<0.1
        Rm = NaN;
        Vrest = NaN;
    else
        Rm = 1000/bbb(2);
        Vrest = -bbb(1)/bbb(2);
    end
    Meting(nres).result.(resnaam).imp.Rimp(idx,1) = Rm;
    Meting(nres).result.(resnaam).imp.Vimp(idx,1) = Vrest;
    if isempty(Meting(nodenr).EXTRA.(panels.amplifier).pars)
        Meting(nres).result.(resnaam).imp.Cm(idx,1) = NaN;
        Meting(nres).result.(resnaam).imp.Rm(idx,1) = NaN;
        Meting(nres).result.(resnaam).imp.Vm(idx,1) = NaN;
    else
        Meting(nres).result.(resnaam).imp.Cm(idx,1) = abs(Meting(nodenr).EXTRA.(panels.amplifier).pars.Cm);
        Meting(nres).result.(resnaam).imp.Rm(idx,1) =   1/Meting(nodenr).EXTRA.(panels.amplifier).imps.gm;
        Meting(nres).result.(resnaam).imp.Vm(idx,1) =     Meting(nodenr).EXTRA.(panels.amplifier).imps.Vr;
    end
    timeline.par((timeline.par(:,1)==4) & (timeline.par(:,3)==nodenr) & (timeline.idx(:,3)==swpnr),4) = wins(1);
    timeline.par((timeline.par(:,1)==2) & (timeline.par(:,3)==nodenr),4) = wins(1);
    timeline.par((timeline.par(:,1)==5) & (timeline.par(:,3)==nodenr),4) = wins(2);
    rodestippen;
    drawnow;
    if panels.abort, return; end
    if formwait>0, pause(formwait); else,pause(0.001); end
end
Formula.noshow = tmpshow;
WindowClear(wins);

function DoDynamic(parms)
global Meting dynamax
CMD = getPANEL('CMDpanel');
[parms,sets,mets,swps,nodes] = ParseList(parms);
[parms,resolution] = ParseOne(parms,'resolution',1);
[parms,nres,structname] = INIresultbasis(CMD,parms,length(nodes));
[parms,doselect,seltxt] = ParseSpecial(parms,'select');
[parms,dodac,ps]   = ParseSpecial(parms,'dacs'); if dodac, vchan = nsingle(ps{1}); else, vchan = 1; end
[parms,doGHK]      = ParseSpecial(parms,'GHK');
[~,doPrinz]    = ParseSpecial(parms,'Prinz');
if doselect, ccmax = -inf+0*zeros(length(seltxt),1); end
for jj = 1:length(nodes)
    Waitbar(CMD,'show',jj/length(nodes),'generate currents');
    nodenr = nodes(jj);
    if dodac
        dt = 1000/Meting(nodenr).DAC.rate;
        Meting(nodenr) = DACexpand(Meting(nodenr));
        Vm = double(Meting(nodenr).dac(:,vchan))*Meting(nodenr).DAC.scale(vchan).User/double(Meting(nodenr).DAC.ints);
    else
        dt = 1000/Meting(nodenr).ADC.rate;
        Vm = double(Meting(nodenr).adc(:,vchan,swps(jj)))*Meting(nodenr).ADC.scale(vchan).User/double(Meting(nodenr).ADC.ints);
    end
    if doPrinz
        cc = dynamicP(Vm(1:resolution:end),resolution*dt,doGHK);
    else
        cc = dynamicH(Vm(1:resolution:end),resolution*dt,doGHK);
    end
    time = mean(Meting(nodenr).reltime);
    Meting(nres).result.(structname).basis.metswp(jj,1:6) = [1, mets(jj), swps(jj), sets(jj), nodes(jj), length(Vm)];
    Meting(nres).result.(structname).basis.times (jj,1)   = time; 
    Meting(nres).result.(structname).basis.Times (jj,1)   = Meting(nodenr).abstime + (time/(24*60*60));
    if doselect
        for jjj =1:length(seltxt)
            select = seltxt{jjj};
            ccmax(jjj) = max(ccmax(jjj),max(cc.(select)));
            if jj==1
                Meting(nres).result.(structname).dynamic.varia    = cc.varia;
                Meting(nres).result.(structname).dynamic.(select) = cc.(select);
            else
                Meting(nres).result.(structname).dynamic.(select)(:,jj) = cc.(select);
            end
        end
    else
        if jj==1
            names = fieldnames(cc);
            Meting(nres).result.(structname).dynamic = cc;
            ccmax = ones(length(names)-1,1); 
        else
            for jjj = 2:length(names)
                Meting(nres).result.(structname).dynamic.(names{jjj})(:,jj) = cc.(names{jjj});
            end
        end
    end
    Meting(nres).result.(structname).dynamic.varia.node(jj) = nodenr;
end
if doGHK
    Meting(nres).result.(structname).dynamic.varia.norm = dynamax./ccmax;
else
    dynamax = ccmax;
    Meting(nres).result.(structname).dynamic.varia.norm = 1+0*ccmax;
end
Waitbar(CMD,'hide')
NRNtimeline;
if ~isempty(Meting(nres).result.(structname).basis.plotter)
    setplotter('struct',Meting,nres,structname,1);
    NRNshow(Meting);
end

function [cluster,sensitivity] = clusterspikes(spikes,venster,adcdt,dosensitivity)
sensitivity = [];
[n1,n2] = size(spikes);
merged = [];
isis = [];
for j1 = 1:n1
    for j2 = 1:n2
        merged = [merged; spikes{j1,j2}];
        isis = [isis; diff(spikes{j1,j2})];
    end
end
merged = sort(merged);
borders = [0; find(diff(merged)>round(venster/adcdt)); length(merged)];
data = NaN(length(borders)-1,1);
cluster = struct('set',[],'txt','','par',[],'distribution',isis,...
                 'tim',data,'rel',data,'acc',data,'sem',data,'cnt',data,'van',data,'tot',data);
if isempty(merged), return; end
for jj = 1:length(borders)-1
    p1 = borders(jj)+1;
    p2 = borders(jj+1);
    cluster.cnt(jj,1) = p2-p1+1;
    cluster.tim(jj,1) = mean(merged(p1:p2));
    cluster.rel(jj,1) = cluster.cnt(jj,1)/(n1*n2);
    cluster.acc(jj,1) = std(merged(p1:p2));
    cluster.sem(jj,1) = cluster.acc(jj,1)/realsqrt(cluster.cnt(jj));
    cluster.van(jj,1) = merged(p1);
    cluster.tot(jj,1) = merged(p2);
end
if dosensitivity
    sensitivity.intervals = unique(sort(diff(merged)));
    sensitivity.clusters  = NaN(length(sensitivity.intervals),1);
    sensitivity.singles   = NaN(length(sensitivity.intervals),1);
    for jj = 1:length(sensitivity.intervals)-1
        if sensitivity.intervals(jj)<1, continue; end
        borders = [0; find(diff(merged)>sensitivity.intervals(jj)); length(merged)];
        distrb  = sort(diff(borders));
        sensitivity.clusters(jj) = length(borders);
        singles = find(distrb>1,1,'first');
        if ~isempty(singles), sensitivity.singles(jj) = singles; end
    end
end

function DoSpikeAnalyser(parms)
global panels Memoryset Meting p
CMD = getPANEL('CMDpanel');
[parms,sets,mets,swps,nodes] = ParseList(parms);
numnodes = length(nodes);
selnodes = unique(nodes);
nodearr  = zeros(numnodes,1);
[parms,nres,resnaam] = INIresultbasis(CMD,parms,length(nodes));
Meting(nres).result.(resnaam).basis.metswp = [sets',mets',swps',1+0*nodes',nodes',0*nodes'];
Meting(nres).result.(resnaam).basis.times  = [Meting(selnodes).reltime];
Meting(nres).result.(resnaam).basis.Times  = [Meting(selnodes).abstime];
[parms,venster]    = ParseOne(parms,'ClusterVenster',5);
[parms,present,ps] = ParseSpecial(parms,'Spikes');
if present
    [ps,adcs] = ParseOne(ps,'adcs',1);
    [ps,present,psh] = ParseSpecial(ps,'exclude'); if present, texc = rsingle(psh{1}); else, texc = [-2,4]; end
    [ps,spkpar] = spikeparms(ps);
    [~,range]  = ParseTwo(ps,'range',[-inf,inf]);
else
    Error('analyser needs spikes'); return;
end
veld = [];
[~,present,ps] = ParseSpecial(parms,'Conditions');
if present
    condition = [];
	conparms  = [];
    for jj = 1:length(ps)
        [cmd,pss] = ParseCmd(ps{jj});
        if strcmp(cmd,'Veld')
            veld = zeros(length(selnodes),1);
            [pss,present,psh] = ParseSpecial(pss,'dacs');   if present, dacs = nsingle(psh{1}); else, Error('Veld needs 2 dacs'); return; end
            [pss,present,psh] = ParseSpecial(pss,'stepnr'); if present, stps = nsingle(psh{1}); else, Error('Veld needs stepnr'); return; end
            [pss,present,psh] = ParseSpecial(pss,'round');  if present, rnds = nsingle(psh{1}); else, rnds = 0; end
            [pss,fieldstep]   = ParseTwo(pss,'fieldstep',[100,400]);
            Meting(nres).result.(resnaam).Veld = nodearr;
        else
            condition{end+1,1} = cmd;
            conparms {end+1,1} = pss{1};
            Meting(nres).result.(resnaam).(cmd) = nodearr;
        end
    end
else
    Error('analyser needs Conditions'); return
end
Meting(nres).result.(resnaam).FLDamp = nodearr;
Meting(nres).result.(resnaam).FLDoff = nodearr;
Meting(nres).result.(resnaam).Vstp  = nodearr;
Meting(nres).result.(resnaam).Vnul  = nodearr;
Meting(nres).result.(resnaam).Ih    = nodearr;
Meting(nres).result.(resnaam).Rm    = nodearr;
Meting(nres).result.(resnaam).Vr    = nodearr;
Meting(nres).result.(resnaam).Vavg = nodearr;
Meting(nres).result.(resnaam).Vstd = nodearr;
Meting(nres).result.(resnaam).Iavg = nodearr;
Meting(nres).result.(resnaam).Istd = nodearr;
Meting(nres).result.(resnaam).nspk = nodearr;
Meting(nres).result.(resnaam).mfrq = nodearr;
dac0 = 1;
adc0 = 1;
Org.p    = p;
Org.axon = panels.axon;
parval   = [];
laststate = [];
metnr = selnodes(1);
dacdt = 1000/Meting(metnr).DAC.rate;
adcdt = 1000/Meting(metnr).ADC.rate;
Meting(nres).result.(resnaam).spkstats.dt       = adcdt;
Meting(nres).result.(resnaam).spkstats.tracelen = size(Meting(metnr).adc,1);
Meting(nres).result.(resnaam).spkstats.venster  = venster;
for jj = 1:length(selnodes)
    metnr = selnodes(jj);
    p           = Org.p;
    panels.axon = Org.axon;
    setpanelaxonandp(Meting(metnr));
    Waitbar(CMD,'show',jj/length(selnodes),sprintf('find spikes %u',jj));
    Meting(metnr) = DACexpand(Meting(metnr));
    dacscale = Meting(metnr).DAC.scale(dac0).User/double(Meting(metnr).DAC.ints);
    adcscale = Meting(metnr).ADC.scale(adc0).User/double(Meting(metnr).ADC.ints);
    pstp  = round(fieldstep/adcdt);
    if ~isempty(veld)
        vldscale = Meting(metnr).DAC.scale(dacs(1)).User/double(Meting(metnr).DAC.ints);
        V1 = Meting(metnr).cdac{dacs(1)}(min(size(Meting(metnr).cdac{dacs(1)},1),stps),2);
        V2 = Meting(metnr).cdac{dacs(2)}(min(size(Meting(metnr).cdac{dacs(2)},1),stps),2);
        veld(jj,1) = round(1000*(V1-V2)*vldscale,rnds);
        Meting(nres).result.(resnaam).Veld  (nodes==metnr) = veld(jj,1);
        Meting(nres).result.(resnaam).FLDamp(nodes==metnr) = 1000*vldscale*(V1-V2);
        Meting(nres).result.(resnaam).FLDoff(nodes==metnr) = 1000*vldscale*(V1+V2);
    end
    pspk = round(texc/adcdt);
    p3 = max(1,1+round(range(1)/dacdt));
    p4 = min(size(Meting(metnr).dac,1),round(range(2)/dacdt));
    Meting(nres).result.(resnaam).Vr  (nodes==metnr) = Meting(metnr).EXTRA.(panels.amplifier).imps.Vr;
    Meting(nres).result.(resnaam).Rm  (nodes==metnr) = Meting(metnr).EXTRA.(panels.amplifier).imps.gm;
    Meting(nres).result.(resnaam).Iavg(nodes==metnr) = dacscale * mean(double(Meting(metnr).dac(p3:p4,dac0)));
    Meting(nres).result.(resnaam).Istd(nodes==metnr) = dacscale * std(double(Meting(metnr).dac(p3:p4,dac0)));
    Meting(nres).result.(resnaam).Ih  (nodes==metnr) = dacscale * double(Meting(metnr).cdac{dac0}(1,2));
    for ii = 1:length(condition)
        parval(jj,ii) = rsingle(conparms{ii});
    	Meting(nres).result.(resnaam).(condition{ii})(nodes==metnr) = deal(parval(jj,ii));
    end
    if isempty(laststate)
        state = 1;
    elseif ~isequal(laststate,parval(jj,1:2))
        state = state + 1;
    end
    laststate = parval(jj,1:2);
    parval(jj,length(condition)+1) = state;
    denode = find(nodes==metnr);
    for swpnr = 1:size(Meting(metnr).adc,3)
        yas = adcscale * double(Meting(metnr).adc(:,adcs,swpnr));
        Vnul = mean(yas(1:pstp(1)));
        V100 = mean(yas(pstp(2)+(-100:0)));
        Meting(nres).result.(resnaam).Vnul(denode(swpnr)) = Vnul;
        Meting(nres).result.(resnaam).Vstp(denode(swpnr)) = V100-Vnul;
        Voff = 0;
        pp = 1+round(range/adcdt);
        if spkpar.mean
            Vmean = mean(yas(pp(1):pp(2)));
            Voff  = Vmean;
        elseif spkpar.median
            Vmedian = median(yas(pp(1):pp(2)));
            Voff    = Vmedian;
        end
        idxs = pp(1)-1+peakfinder(yas(pp(1):pp(2))-Voff,spkpar.height,spkpar.height*spkpar.depth,round(spkpar.thold/adcdt));
        allspikes{jj,swpnr} = idxs;
        numspikes = length(idxs);
        Meting(nres).result.(resnaam).nspk(denode(swpnr)) = numspikes;
        if numspikes>1
            Meting(nres).result.(resnaam).mfrq(denode(swpnr)) = 1000*(numspikes-1)/(adcdt*(idxs(end)-idxs(1)));
        end
        hlp = pspk(1):pspk(2); for ii =1:numspikes, yas(idxs(ii)+hlp) = NaN; end
        Meting(nres).result.(resnaam).Vavg(denode(swpnr)) = nanmean(yas(pp(1):pp(2)));
        Meting(nres).result.(resnaam).Vstd(denode(swpnr)) = nanstd(yas(pp(1):pp(2)));
    end
end
Meting(nres).result.(resnaam).spkstats.idxs = allspikes;
p           = Org.p;
panels.axon = Org.axon;
select = [];
params = [];
nclus  = 0;
allfields = unique(veld);
nofields = (length(allfields)==1)  && (allfields(1)==0);
if nofields
    goal = parval(:,1); goalset = unique(goal);
    if length(goalset)>1
        for j1 = 1:length(goalset)
            nodes = find(goal==goalset(j1));
            nclus = nclus + 1;
            for j2 = 1:length(nodes)
                select{nclus,j2} = nodes(j2);
                params{nclus,j2} = parval(nodes(j2),1:2);
            end
        end
    end
    nois = parval(:,2); noisset = unique(nois);
    if length(noisset)>1
        for j1 = 1:length(noisset)
            nodes = find(nois==noisset(j1));
            nclus = nclus + 1;
            for j2 = 1:length(nodes)
                select{nclus,j2} = nodes(j2);
                params{nclus,j2} = parval(nodes(j2),1:2);
            end
        end
    end
else
    allstates = unique(parval(:,end))';
    allfields = [0; allfields(allfields~=0)];
    for j1 = 1:length(allstates)
        nullen = find((parval(:,end)==allstates(j1))&(veld==0));
        nclus = nclus + 1;
        for j2 = 1:length(allfields)
            nodes = find((parval(:,end)==allstates(j1))&(veld==allfields(j2)));
            select{nclus,j2} = nodes;
            if ~isempty(nodes)
                params{nclus,j2} = [veld(nodes(1)), parval(nodes(1),:)];
            end
        end
        if length(nullen)>1
            for j2 = 1:length(nullen)-1
                p1 = nullen(j2);
                p2 = nullen(j2+1);
                tussen = p1+1:p2-1;
                nclus = nclus + 1;
                select{nclus,1} = [p1, p2];
                params{nclus,1} = [veld(p1), parval(p1,:)];
                for j3 = 1:length(tussen)
                    select{nclus,j3+1} = tussen(j3);
                    params{nclus,j3+1} = [veld(tussen(j3)), parval(tussen(j3),:)];
                end
            end
        end
    end
end
for j1 = 1:size(select,1)
    for j2 = 1:size(select,2)
        if isempty(select{j1,j2}), continue; end
        [cluster,sensitivity] = clusterspikes(allspikes(select{j1,j2},:), venster, adcdt, (j1==1) && (j2==1));
        cluster.set = select{j1,j2};
        cluster.par = params{j1,j2};
        if nofields
            cluster.txt = sprintf('goal(%0.1f),noise(%0.1f)',params{j1,j2}(1:2));
        else
            cluster.txt = sprintf('veld(%0.0f),goal(%0.1f),noise(%0.1f)',params{j1,j2}(1:3));
        end
        if ~isempty(sensitivity), Meting(nres).result.(resnaam).spkstats.sensitivity = sensitivity; end
        Meting(nres).result.(resnaam).spkstats.cluster(j1,j2) = cluster;
    end
end
Waitbar(CMD,'hide');
if ~isempty(Memoryset), MemoryUpdate('refresh'); end
NRNtimeline;

function [parms,spkpar] = spikeparms(parms)
spkpar = struct('auto',3,'height',[],'depth',1,'abs',false,'invert',false,'thold',0,'mean',false,'median',false,'std',0,'modus','plus'); 
[parms,present]  = ParseSpecial(parms,'minus');
if present, spkpar.modus = 'minus'; else
    [parms,present] = ParseSpecial(parms,'both'); if present, spkpar.modus = 'both'; end
end
[parms,spkpar.abs]    = ParseSpecial(parms,'abs');
[parms,spkpar.invert] = ParseSpecial(parms,'invert');
[parms,spkpar.median] = ParseSpecial(parms,'median');
[parms,spkpar.mean]   = ParseSpecial(parms,'mean');
[parms,spkpar.thold]  = ParseOne(parms,'holdoff',spkpar.thold);
[parms,spkpar.depth]  = ParseOne(parms,'depth',  spkpar.depth);
[parms,dohoog,ps] = ParseSpecial(parms,'height');
if dohoog
    spkpar.height = rsingle(ps{1});
    if spkpar.height<0
        spkpar.invert = true;
    elseif spkpar.invert
        spkpar.height = -abs(spkpar.height);
    end
else
    spkpar.height = [];
    [parms,spkpar.auto] = ParseOne(parms,'auto',3);
end

function DoFiring(parms)
global Memoryset Meting panels Formula
CMD = getPANEL('CMDpanel');
panels.NRNabort = false;
panels.NRNbusy  = false;
WindowClear;
[parms,winclear] = ParseClear(parms);
[parms,sets,mets,swps,nodes] = ParseList(parms);
numtraces = length(nodes);
[parms,nres,resnaam,nodename] = INIresultbasis(CMD,parms,numtraces);
if Error, return; end
for idx = 1:length(nodes)
    swpnr  = swps(idx);
    nodenr = nodes(idx);
    swplen = (size(Meting(nodenr).adc,1)-1)*1000/Meting(nodenr).ADC.rate;
    time = Meting(nodenr).reltime(swpnr);
    Meting(nres).result.(resnaam).basis.metswp(idx,1:6) = [sets(idx),mets(idx),swpnr,idx,nodenr,swplen];
    Meting(nres).result.(resnaam).basis.times (idx,1) = time;
    Meting(nres).result.(resnaam).basis.Times (idx,1) = Meting(nodenr).abstime+(time/(24*60*60));
end
ClearFormula(CMD);
Formula.noshow = false;
[parms,doimp,ps] = ParseSpecial(parms,'runimp'); if doimp, DoRunIMP(ps,nres,resnaam); end;  if Error, return; end
parms            = DoRunFRM(parms,nres,resnaam);      if Error, return; end
[parms,present,ps] = ParseSpecial(parms,'spikes');
if present
    plothlp1 = struct('window',9,'mode','adc(1)','struct',[],'metnr',[],'swpnr',[]);
    [ps,present,psh] = ParseSpecial(ps,'plot');
    if present
        plothlp1.window = nsingle(psh{1});
        plothlp1.mode   = ssingle(psh{2});
    end
    [ps,tracewait] = ParseOne(ps,'wait',0);
    [ps,spkpar] = spikeparms(ps);
    [ps,tahp] = ParseOne(ps,'ahp',20);
    [ps,present,psh] = ParseSpecial(ps,'region');
    if present
        tregion = rsingle(psh{1});
        if length(psh)>1
            tdetect = tregion + rsingle(psh{2});
        else
            tdetect = tregion;
        end
    end
else
    Error('Firing needs spike parameters');
    return
end
[parms,metspks,ps] = ParseSpecial(parms,'spikepars');
if metspks
    [ps,spkwait]     = ParseOne(ps,'wait',0);
    [ps,spkshow]     = ParseSpecial(ps,'show');
    [ps,spksave,psh] = ParseSpecial(ps,'save');
    if spksave
        spksave1 = rsingle(psh{1});
        spksave2 = rsingle(psh{2});
    end
    plothlp2 = plothlp1;
	[ps,present,psh] = ParseSpecial(ps,'window');
    if present
        plothlp2.window = nsingle(psh{1});
    else
        plothlp2.window = 11;
        plothlp1.window = 13;
    end
    [ps,present,psh] = ParseSpecial(ps,'around'); 
    if present, taround = rsingle(psh{1}); else, taround = [4,15]; end
end
har = NaN(numtraces,1);
haz = zeros(numtraces,1);
if ~doimp, Meting(nres).result.(resnaam).Rm = haz + (1000/Meting(nodes(1)).EXTRA.(panels.amplifier).imps.gm); end
Meting(nres).result.(resnaam).nspks = haz;
Meting(nres).result.(resnaam).LV    = har;
Meting(nres).result.(resnaam).freq  = struct('mean',haz,'first',har,'second',har,'last',har);
Meting(nres).result.(resnaam).Vm    = struct('rest',har,'hold',har,'mean',har,'median',har,'thres',har, 'hyper',har,'dahp',har,'dthr',har);
if doimp
    Meting(nres).result.(resnaam).Vm = rmfield(Meting(nres).result.(resnaam).Vm,'rest');
else
    Meting(nres).result.(resnaam).Vm.rest = Meting(nodes(1)).EXTRA.(panels.amplifier).imps.Vr;
end
if isfield(Meting(nres).result.(resnaam),'Vhold')
    Meting(nres).result.(resnaam).Vm.hold = Meting(nres).result.(resnaam).Vhold;
    Meting(nres).result.(resnaam) = rmfield(Meting(nres).result.(resnaam),'Vhold');
end                                         
                                         
[parms,metfit,ps] = ParseSpecial(parms,'adaptation');
if metfit
    [ps,fitwait]     = ParseOne(ps,'wait',0);
    [ps,fitwindow]   = ParseOne(ps,'window',1);
    [ps,fitscale]    = ParseScale(ps);
    if Error, return; end
    [ps,fitsecond]   = ParseSpecial(ps,'second');
    [ps,present,psh] = ParseSpecial(ps,'exclude'); if present, exclude = nsingle(psh{1}); else, exclude = [];   end
    [ps,islinear]    = ParseSpecial(ps,'linear');
    if islinear
        Meting(nres).result.(resnaam).Poly1 = [];
    else
        Meting(nres).result.(resnaam).Expoxt = struct('goff',haz,'Amp0',har,'Amp1',har,'tau1',har,'slope',har);
    end
end
for idx = 1:numtraces
    if Error, return; end
    nodenr = nodes(idx);
    swpnr =  swps(idx);
    if panels.abort, continue; end
    time = Meting(nodenr).reltime(swps(idx));
    Meting(nres).result.(resnaam).basis.metswp(idx,1:6)= [sets(idx), mets(idx), swpnr, idx, nodenr, size(Meting(nodenr).adc,1)*1000/Meting(nodenr).ADC.rate];
    Meting(nres).result.(resnaam).basis.times (idx,1)  = time;
    Meting(nres).result.(resnaam).basis.Times (idx,1)  = Meting(nodenr).abstime + (time/(24*60*60));
    panels.plotter = plothlp1;
    panels.plotter.metnr = nodenr;
    panels.plotter.subnr = swpnr;
    NRNshow(Meting);
    if Error, return; end
    has1 = get(Formula.handle,'Parent');
    xas  = get(Formula.handle,'XData')';
    yas  = get(Formula.handle,'YData')';
    Formula.xas = xas;
    Formula.yas = yas;
    ylims = get(has1,'Ylim');
    dtx = xas(2)-xas(1);
    pahp = round(tahp/dtx);
    p1 = 1+round((tdetect(1)-xas(1))/dtx);
    p2 = 1+round((tdetect(2)-xas(1))/dtx);
    Vmean   = mean  (yas(p1:p2));
    Vmedian = median(yas(p1:p2));
    if spkpar.mean, Voff = Vmean; elseif spkpar.median, Voff = Vmedian; else, Voff = 0; end
    [ppeak,apeak] = peakfinder(yas(p1:p2)-Voff, spkpar.height, spkpar.depth,round(spkpar.thold/dtx));
    ppeak = ppeak+p1-1; 
    if ~isempty(apeak), apeak = apeak + Voff; end
    drempel = Voff+spkpar.height;
    nspks = length(ppeak);
    pbott = zeros(nspks,1);
    abott = zeros(nspks,1);
    for jj=1:(nspks-1)
        [abott(jj),index] = min(yas(ppeak(jj):min([ppeak(jj)+pahp, ppeak(jj+1)])));
         pbott(jj)        = ppeak(jj)-1+index;
    end
    if nspks>0
        [abott(nspks),index] = min( yas(ppeak(nspks):min([ppeak(nspks)+pahp, p2]) ));
        pbott(nspks)         = ppeak(nspks)-1+index;
    end
    Meting(nres).result.(resnaam).nspks    (idx) = nspks;
    Meting(nres).result.(resnaam).Vm.mean  (idx) = Vmean;
    Meting(nres).result.(resnaam).Vm.median(idx) = Vmedian;
    line('XData',[tdetect(1)*[1 1] NaN tdetect(2)*[1 1]],'YData',[ylims NaN ylims],'Color','b','LineWidth',1,'LineStyle',':');
    line('XData',xas([1,end]),'YData',drempel*[1 1],'Color','b','LineWidth',2,'LineStyle',':');
    line('XData',xas([1,end]),'YData',Vmean*[1 1],  'Color','r','LineWidth',1,'LineStyle','--');
    line('XData',xas([1,end]),'YData',Vmedian*[1 1],'Color','b','LineWidth',1,'LineStyle','--');
    if nspks>0
        [freq,xfreq] = makefreq(p2t(ppeak)-tregion(1));
        if nspks>1
            Meting(nres).result.(resnaam).LV(idx) = LV(ppeak);
            Meting(nres).result.(resnaam).freq.mean(idx) = 1000*(length(ppeak)-1)/(p2t(ppeak(end))-p2t(ppeak(1)));
            Meting(nres).result.(resnaam).freq.first(idx) = freq(1);
            if nspks>2,  Meting(nres).result.(resnaam).freq.second(idx) = freq(2); end
            Meting(nres).result.(resnaam).freq.last(idx)  = freq(end);
        end
        line('XData',p2t(ppeak),'YData',apeak,'MarkerEdgeColor','b','MarkerFaceColor','c','Marker','o','MarkerSize',8,'LineStyle','none','LineWidth',2);
        line('XData',p2t(pbott),'YData',abott,'MarkerEdgeColor','r','MarkerFaceColor','w','Marker','o','MarkerSize',6,'LineStyle','none','LineWidth',2);
        drawnow();
    end
    if metspks
        first = true;
        har = NaN(nspks,1);
        spr = struct('time',har, 'amp',har, 'peak',har, 't2peak',har, 'hyper',har, 't2hyper',har, 'dahp',har, 'thresh',har, 't2thresh',har, 'dthr',har,...
                     'halfwidth',har, 'threshwidth',har, 'slprise',har, 'slpfall',har, 'srf',har, 'ifrq',zeros(nspks,1));
        for jj = 1:nspks 
            if panels.abort, return; end
            if spksave
                if jj==1
                    np1 = round(spksave1/(xas(2)-xas(1)));
                    np2 = round(spksave2/(xas(2)-xas(1)));
                    Meting(nres).result.(resnaam).APs{idx,1}.xas  = dtx*(ppeak-p1);
                    Meting(nres).result.(resnaam).APs{idx,1}.tas  = dtx*(0:(np2-np1))';
                    Meting(nres).result.(resnaam).APs{idx,1}.yavg = zeros(np2-np1+1,1);
                    Meting(nres).result.(resnaam).APs{idx,1}.ystd = zeros(np2-np1+1,1);
                    Meting(nres).result.(resnaam).APs{idx,1}.yas  = NaN(np2-np1+1,nspks);
                    Meting(nres).result.(resnaam).basis.APscale   =[0,dtx*(np2-np1),0,dtx*(ppeak(end)-p1),-inf,inf];
                end
                Meting(nres).result.(resnaam).APs{idx,1}.yas(:,jj) = yas((ppeak(jj)+np1):(ppeak(jj)+np2));
                if jj==nspks
                    Meting(nres).result.(resnaam).APs{idx,1}.yavg = mean(Meting(nres).result.(resnaam).APs{idx,1}.yas,2);
                    Meting(nres).result.(resnaam).APs{idx,1}.ystd = std(Meting(nres).result.(resnaam).APs{idx,1}.yas,0,2);
                end
            end
            spr.time(jj)   = p2t(ppeak(jj))-tregion(1);
            spr.peak(jj)   = apeak(jj);
            spr.t2peak(jj) = p2t(ppeak(jj));
            spr.hyper(jj)  = abott(jj);
            spr.t2hyper(jj)= p2t(pbott(jj));
            spr.ifrq(jj)   = freq(jj);
            ylims(2) = max(ylims(2),mean(apeak)+20);
            ylims(1) = -ylims(2);
            set(has1,'YLim',ylims);
            if jj==1
                panels.plotter = plothlp2;
                panels.plotter.metnr = nodenr;
                panels.plotter.subnr = swps(idx);
                NRNshow(Meting);
                has2 = get(Formula.handle,'Parent');
                tbegin = max(tregion(1), spr.t2peak(1)-taround(1));
            else
                set(panels.root,'CurrentAxes',has2);
                set(has2,'YLim',ylims);
                tbegin = spr.t2peak(jj)-min(taround(1),0.25*(spr.t2peak(jj)-spr.t2hyper(jj-1)));
            end
            set(has2,'XLim',[tbegin spr.t2peak(jj)+taround(2)]);
            if Error, return; end
            FF = Twolines(tbegin,spr.t2peak(jj),spkshow);
            spr.t2thresh(jj) = FF.x1;
            spr.thresh(jj)   = FF.y1;
            spr.amp(jj)      = spr.peak(jj)-spr.thresh(jj);
            pdrem            = t2p(spr.t2thresh(jj));
            d50              = 0.5*(spr.thresh(jj) + spr.peak(jj));
            p1 = pdrem-1+find(yas(pdrem:ppeak(jj))<=d50,1,'last');
            if isempty(p1)
                p1 = pdrem;
                t1 = p2t(p1);
            elseif yas(p1+1)==yas(p1)
                t1 = p2t(p1);
            else
                t1 = p2t(p1) + dtx * (d50-yas(p1))/(yas(p1+1)-yas(p1));
            end
            p2  = ppeak(jj)-1+find(yas(ppeak(jj):pbott(jj))<=d50,1,'first');
            if isempty(p2)
                [~, p2] = min(yas(ppeak(jj):pbott(jj)));
                p2 = p2 + ppeak(jj)-1;
            elseif yas(p2+1)==yas(p2)
                t2 = p2t(p2);
            else
                t2 = p2t(p2) + dtx * (d50-yas(p2))/(yas(p2+1)-yas(p2));
            end
            spr.halfwidth(jj) = t2 - t1;
            p3 = ppeak(jj)-1+find(yas(ppeak(jj):pbott(jj))<=spr.thresh(jj),1,'first');
            if isempty(p3)
                continue;
            else
                spr.threshwidth(jj) = p2t(p3) - spr.t2thresh(jj);
                spr.srf(jj)         = sum(yas(pdrem:p3)) * dtx;
            end
            index = p1-2:p1+2;
            xt  = p2t(index)-p2t(p1);
            yt  = yas(index)-yas(p1);
            spr.slprise(jj) = regress(yt,xt);
            x1 = p2t(p1) + xt(1);
            y1 = yas(p1) - spr.slprise(jj) * 2 * dtx;
            x2 = p2t(p1) + xt(5);
            y2 = yas(p1) + spr.slprise(jj) * 2 * dtx;
            index = p2-2:p2+2;
            xt  = p2t(index)-p2t(p2);
            yt  = yas(index)-yas(p2);
            spr.slpfall(jj) = regress(yt,xt);
            x3 = p2t(p2) + xt(1);
            y3 = yas(p2) - spr.slpfall(jj) * 2 * dtx;
            x4 = p2t(p2) + xt(5);
            y4 = yas(p2) + spr.slpfall(jj) * 2 * dtx;
            if first
                first = false;
                spf1 = line([t1-0.5                    t2+0.5], d50*[1 1],            'LineWidth',1,'LineStyle','--','Color','g');
                spf2 = line([spr.t2thresh(jj)-0.5 p2t(p3)+0.5], spr.thresh(jj)*[1 1], 'LineWidth',1,'LineStyle','--','Color','g');
                spf3 = line([t1 t2],  d50*[1 1], 'LineWidth',2,'LineStyle','none','Marker','o','MarkerSize',10,'Color','g');
                spf4 = line(spr.t2peak(jj), spr.peak(jj),  'LineWidth',2,'LineStyle','none','Marker','o','MarkerSize',10,'MarkerEdgeColor','b','MarkerFaceColor','c');
                spf5 = line(spr.t2hyper(jj),spr.hyper(jj), 'LineWidth',2,'LineStyle','none','Marker','o','MarkerSize',10,'MarkerEdgeColor','r','MarkerFaceColor','y');
                if has2~=has1
                    set(panels.root,'CurrentAxes',has1);
                    spf6 = line(spr.t2thresh(jj),spr.thresh(jj),'Color','b','LineWidth',2,'LineStyle','none','Marker','o','MarkerSize',9);
                    set(panels.root,'CurrentAxes',has2);
                end
                if spkshow
                    spf7 = line([x1 x2],[y1 y2], 'LineWidth',1.5,'LineStyle','--','Color','b');
                    spf8 = line([x3 x4],[y3 y4], 'LineWidth',1.5,'LineStyle','--','Color','b');
                end
                if spksave
                    spf9 = line([[1 1]*spr.t2peak(jj)+spksave1, NaN ,[1 1]*spr.t2peak(jj)+spksave2],[ylims NaN ylims], 'LineWidth',1,'LineStyle','--','Color','b');
                end
            else
                set(spf1,'XData',[t1-0.5                  t2+0.5],  'YData',d50*[1 1]);
                set(spf2,'XData',[spr.t2thresh(jj)-0.5 p2t(p3)+0.5],'YData',spr.thresh(jj)+[1 1]);
                set(spf3,'XData',[t1 t2],        'YData',d50*[1 1]);
                set(spf4,'XData',spr.t2peak(jj), 'YData',spr.peak(jj));
                set(spf5,'XData',spr.t2hyper(jj),'YData',spr.hyper(jj));
                if has2~=has1
                    set(spf6,'XData',spr.t2thresh,'YData',spr.thresh);
                end
                if spkshow
                    set(spf7,'XData',[x1 x2],'YData',[y1 y2]);
                    set(spf8,'XData',[x3 x4],'YData',[y3 y4]);
                end
                if spksave
                    set(spf9,'XData',[[1 1]*spr.t2peak(jj)+spksave1, NaN ,[1 1]*spr.t2peak(jj)+spksave2]);
                end
                if spkwait>0, pause(spkwait); end
            end
            drawnow;
        end
        if nspks>2
            Meting(nres).result.(resnaam).Vm.thres(idx) = nanmean(spr.thresh(3:end));
            Meting(nres).result.(resnaam).Vm.hyper(idx) = nanmean(spr.hyper(3:end));
            spr.dahp = spr.hyper - Vmedian;
            Meting(nres).result.(resnaam).Vm.dahp (idx) = nanmean(spr.dahp(3:end));
            spr.dthr = spr.thresh - Vmedian;
            Meting(nres).result.(resnaam).Vm.dthr (idx) = nanmean(spr.dthr(3:end));
        end
        if ~isempty(spr.t2peak)
            spr.t2peak   = spr.t2peak  - spr.t2thresh;
            spr.t2hyper  = spr.t2hyper - spr.t2thresh;
            spr.t2thresh = spr.t2thresh - tregion(1);
        end
        names = fieldnames(spr);
        for iii = 1:length(names)
            Meting(nres).result.(resnaam).spk.(names{iii}){idx,1} = spr.(names{iii});
        end
        Meting(nres).result.(resnaam).avg.t2peak(idx)      = nanmean(spr.t2peak);
        Meting(nres).result.(resnaam).avg.t2ahp(idx)       = nanmean(spr.t2hyper);
        Meting(nres).result.(resnaam).avg.halfwidth(idx)   = nanmean(spr.halfwidth);
        Meting(nres).result.(resnaam).avg.threshwidth(idx) = nanmean(spr.threshwidth);
        Meting(nres).result.(resnaam).avg.slprise(idx)     = nanmean(spr.slprise);
        Meting(nres).result.(resnaam).avg.slpfall(idx)     = nanmean(spr.slpfall);
        Meting(nres).result.(resnaam).avg.srf(idx)         = nanmean(spr.srf);
    end
    if metfit && (nspks>(4+length(exclude)))
        if ~isempty(exclude)
            freq (exclude) = [];
            xfreq(exclude) = [];
        end
        if fitsecond, xfreq = xfreq/1000; end
        if isinf(fitscale.x)
            fitscale.x = [0 1.05*max(xfreq)];
        end
        if isinf(fitscale.y)
            fitscale.x = [0 1.25*max(freq)];
        end
        hhhandle = getplothandle(fitwindow,true);
        axis([fitscale.x fitscale.y]);
        line('XData',xfreq,'YData',freq,'MarkerEdgeColor','b','MarkerFaceColor','c','Marker','o','MarkerSize',6,'LineStyle','none','LineWidth',2);
        if islinear
            rfit      = Fitfunctie(xfreq,freq,{'Poly1';'nologger'});
            rfit.yeva = rfit.v(1).*rfit.xeva + rfit.v(2);
        else
            rfit = Fitfunctie(xfreq,freq,{'Expoxt';'nologger'});
        end
        if Error ||~rfit.valid, return; end
        Meting(nres).result.(resnaam).(rfit.name).('goff')(idx,1) = rfit.error;
        for jjjj = 1:length(rfit.names)
            Meting(nres).result.(resnaam).(rfit.name).(rfit.names{jjjj})(idx,1) = rfit.v(jjjj);
        end
        Meting(nres).result.(resnaam).fitter{idx,1} = rfit;
        Meting(nres).result.(resnaam).fitter{idx,1}.source.window  = fitwindow;
        Meting(nres).result.(resnaam).fitter{idx,1}.source.struct  = sprintf('%s@%s',nodename,resnaam);
        Meting(nres).result.(resnaam).fitter{idx,1}.source.mode    = sprintf('xy(xas(time),yas(freq))/scale(x(%f,%f),y(%f,%f))/legend',fitscale.x(1:2),fitscale.y(1:2));
        Meting(nres).result.(resnaam).fitter{idx,1}.plotter.window = fitwindow;
        Meting(nres).result.(resnaam).fitter{idx,1}.plotter.struct = sprintf('%s@%s',nodename,resnaam);
        Meting(nres).result.(resnaam).fitter{idx,1}.plotter.mode   = sprintf('fit(%u)/scale(x(%f,%f),y(%f,%f))/legend',idx,fitscale.x(1:2),fitscale.y(1:2));
        TextLeft(hhhandle,Fittekst(Meting(nres).result.(resnaam).fitter{idx,1}));
        line('XData',rfit.xeva,'YData',rfit.yeva,'Color','r','LineStyle',':','LineWidth',2);
        NRNtimeline;
        drawnow;
        if fitwait>0, pause(fitwait); end
    end
    if tracewait>0, pause(tracewait); end
end
if spksave && (nspks>1)
    aslim = [inf,-inf,inf,-inf];
    for jj = 1:length(Meting(nres).result.(resnaam).APs)
        if ~isempty(Meting(nres).result.(resnaam).APs{jj})
            aslim(1) = min(aslim(1),min(Meting(nres).result.(resnaam).APs{jj}.xas(:)));
            aslim(2) = max(aslim(2),max(Meting(nres).result.(resnaam).APs{jj}.xas(:)));
            aslim(3) = min(aslim(3),min(Meting(nres).result.(resnaam).APs{jj}.yas(:)));
            aslim(4) = max(aslim(4),max(Meting(nres).result.(resnaam).APs{jj}.yas(:)));
        end
    end
    if aslim(3)<0, aslim(3) = 1.1 *aslim(3); else, aslim(3) = 0.9 *aslim(3); end
    if aslim(4)<0, aslim(4) = 0.9 *aslim(4); else, aslim(4) = 1.1 *aslim(4); end
    Meting(nres).result.(resnaam).basis.APscale(3:6) = aslim;
end
if ~isempty(Memoryset), MemoryUpdate('refresh'); end
InsertinLog(CMD,resnaam,Meting(nres).result.(resnaam),[]);
if ~isempty(winclear), WindowClear(winclear); end
NRNtimeline;
if ~isempty(Meting(nres).result.(resnaam).basis.plotter)
    setplotter('struct',Meting,nres,resnaam,1);
    NRNshow(Meting);
end

function DoPSTH(parms)
global Meting spikes 
[parms,present,ps] = ParseSpecial(parms,'window'); if present, window=nsingle(ps{1}); else,window = 9; end
adcrate   = spikes.adcrate;
hlp       = rsingle(parms{1});
binwidth  = rsingle(parms{2});
before    = hlp(1);
after     = hlp(2);
pntbefore = round(before * adcrate);
pntafter  = round(after  * adcrate);
numtrigs  = length(spikes.trg.trg1);
if length(parms)>2, tgraph = ssingle(parms{3}); else,tgraph = 'counts'; end
getplothandle(window(1),true);
cumar = [];
yyy = zeros(pntafter-pntbefore+1,numtrigs);
for iii = 1:numtrigs
    np = round(spikes.trg.trg1(iii));
    if isempty(spikes.spktlvl)
        spiketrace{iii} = [];
    else
        spiketrace{iii} = (spikes.spktlvl((spikes.spktlvl>=(np+pntbefore))&(spikes.spktlvl<=(np+pntafter)))-np)/adcrate;
    end
    cumar = [cumar; spiketrace{iii}];
    yyy(:,iii) = double(Meting(1).adc(np+pntbefore:np+pntafter,spikes.adcchan));
end
tijdas1 = 0.5*binwidth+binwidth*(0:round(after/binwidth));
tijdas2 = 0.5*binwidth+binwidth*(0:round(-before/binwidth));
tijdas = [-tijdas2(end:-1:1) tijdas1];
[ncounts] = hist(cumar,tijdas);
hold on
if strcmp(tgraph,'Hz'), ncounts = ncounts/(binwidth*numtrigs); end
bar(tijdas,ncounts,1);
maxyas = max(ncounts);
if strcmp(tgraph,'Hz'), txt = '  yaxis firing rate in Hz'; else,txt = '  yaxis spikecount/bin'; end
text(-before,maxyas,txt,'Fontsize',8,'Fontname','Courier','HorizontalAlignment','left');
maxyas = 1.05 * maxyas;
if maxyas==0, maxyas = 1; end
ymax = maxyas+maxyas*(numtrigs+1)/numtrigs;
line('XData',[0 0],'YData',[0 0.999*ymax],'Color','r','LineWidth',2,'LineStyle',':');
axis([before after 0 ymax]);
ym  = mean(yyy,2);
ymh = max(yyy')'; tm1 = 2*max(ymh);
yml = min(yyy')'; tm2 = 2*min(yml);
tas = before+ ((1:length(ym))-1)/adcrate;
ymh = convn(ymh,ones(5,1)/5,'same');
line('XData',tas,'YData',(3*ymh)*maxyas/(tm1-tm2),'Color','r','LineWidth',1,'LineStyle','-');
hhh =sort(cumar(cumar>=0));
line('XData',[before after],'YData',[maxyas maxyas],'Color','k','LineWidth',2,'LineStyle','-');
line('XData',hhh,'YData',0.98*maxyas+0*hhh,'LineStyle','none','MarkerFaceColor','w','MarkerEdgeColor','r','Marker','o','Markersize',8)
for iii = 1:numtrigs
    if numtrigs<30
        line('XData',[before after],'YData',maxyas+(maxyas*iii/numtrigs)*[1 1],'Color','k','LineWidth',1,'LineStyle',':')
    end
    line('XData',spiketrace{iii},'YData',maxyas+(maxyas*iii/numtrigs)+0*spiketrace{iii},...
         'LineStyle','none','MarkerFaceColor','w','MarkerEdgeColor','b','Marker','o','Markersize',8)
end

function DoVanAnaarB(cmd,parms)
global Memoryset Meting panels spikes events
CMD = getPANEL('CMDpanel');
[parms,present,ps] = ParseSpecial(parms,'class'); if present, class = ssingle(ps{1}); else,class = []; end
[parms,tnul] = ParseTijd(parms,'tnul',1); if isempty(tnul), tnul = 0; end
[parms,margin] = ParseTijd(parms,'margin',1); if isempty(margin), margin = [0 0]; end
[parms,doinvert] = ParseSpecial(parms,'invert');
[parms,dosave] = ParseSpecial(parms,'save');
newname = '';
notitie = '';
[parms,present,ps] = ParseSpecial(parms,'newname');
if present
    newname = ssingle(ps{1});
    if length(ps)>1, notitie = ssingle(ps{2}); end
end
switch cmd
    case 'Event_Clean'
        nmx = size(Meting(1).adc,1);
        bgn = max(1,  round((events.evt.first-panels.zoom.tnul)*Meting(1).ADC.rate/1000));
        lst = min(nmx,round((events.evt.last -panels.zoom.tnul)*Meting(1).ADC.rate/1000));
        if doinvert
            hlp = lst;
            lst = [bgn; nmx];
            bgn = [1; hlp];
        end
        for jj = 1:length(bgn)
            Meting(1).adc(bgn(jj):lst(jj),:) = 0;
        end
    case 'Event_Edit'
        [parms,tijden] = ParseTijd(parms,'edit',1);
        nr = nsingle(parms{1});
        if ~isempty(tijden) && (nr>0) && (nr<=length(events.evt.first))
        	events.evt.first(nr) = tijden(1);
        	events.evt.last(nr)  = tijden(2);
        end
    case 'DACs2Spikes'
        spikes.spktlvl = spikes.trg.trg1;
        spikes.spklvl  = 0 *  spikes.trg.trg1;
        spikes.spktmax = spikes.trg.trg1;
        spikes.spkmax  = 0 *  spikes.trg.trg1;
        spikes.spktmin = spikes.trg.trg2;
        spikes.spkmin  = 0 *  spikes.trg.trg2;
        spikes.adcchan = [1 2];
        spikes.adcdrmp = [0 0];
        spikes.mask    = true(length(spikes.spktlvl),1);
        spikes.maskname{1,1} = 'Include/Exclude';
        spikes.class   = 0*ones(length(spikes.spktlvl),1);
    case 'TRGs2Events'
        if doinvert
            events.evt.first = [spikes.trg.range(1)+margin(1); panels.zoom.tnul + margin(1) + (spikes.trg.trg2 * 1000 / spikes.trg.rate)];
            events.evt.last  = [panels.zoom.tnul + margin(2) + (spikes.trg.trg1 * 1000 / spikes.trg.rate); spikes.trg.range(2)+margin(2)];
        else
            events.evt.first = panels.zoom.tnul + margin(1) + (spikes.trg.trg1 * 1000 / spikes.trg.rate);
            events.evt.last  = panels.zoom.tnul + margin(2) + (spikes.trg.trg2 * 1000 / spikes.trg.rate);
        end
        numtrigs = length(events.evt.first);
        events.evt.kanaal = ones (numtrigs,1,'int16');
        events.evt.ratnr  = ones (numtrigs,1,'int16');
        events.evt.clsnr  = ones (numtrigs,1,'int16');
        spikes.sync   = -margin(1);
        set(DB.nr, 'String','1');
    case 'Spikes2Events'
        hlp = rsingle(parms{1});
        if length(hlp)~=2
            Error('range needs to be a pair ');
            return
        end
        before      = round(-hlp(1)*spikes.adcrate);
        spikes.sync = -hlp(1);
        after       = round( hlp(2)*spikes.adcrate);
        rows        = size(Meting(1).adc,1);
            spktlvl = spikes.spktlvl;
            spklvl  = spikes.spklvl;
            spktmax = spikes.spktmax;
            spkmax  = spikes.spkmax;
            spktmin = spikes.spktmin;
            spkmin  = spikes.spkmin;
            spkclass= spikes.class;
            masks   = spikes.mask;
            mtxt    = 'selected spikes';
        hlp = find((spktlvl>=(before+2)) & (spktlvl<=(rows-after)));
        spikes.spktlvl = spktlvl(hlp);
        spikes.spklvl  = spklvl(hlp);
        spikes.spktmax = spktmax(hlp);
        spikes.spkmax  = spkmax(hlp);
        spikes.spktmin = spktmin(hlp);
        spikes.spkmin  = spkmin(hlp);
        spikes.class   = spkclass(hlp);
        spikes.mask    = masks(hlp,:);
        spikes.maskname{1,1} = mtxt;
        tlen = length(spikes.spktmax);
        events.evt.key    = (1:tlen)';
        events.evt.first  = zeros(tlen,1);
        events.evt.last   = zeros(tlen,1);
        events.evt.kanaal = ones (tlen,1,'int16');
        events.evt.ratnr  = ones (tlen,1,'int16');
        events.evt.clsnr  = ones (tlen,1,'int16');
        for ii = 1:tlen
            events.evt.first(ii,1) = panels.zoom.tnul + (spikes.spktmax(ii)-1-before) * 1000 / spikes.adcrate;
            events.evt.last(ii,1)  = panels.zoom.tnul + (spikes.spktmax(ii)-1+ after) * 1000 / spikes.adcrate;
        end
        set(DB.nr,'String','1');
%         DBsave(false,Memoryset);
        Redraw;
    case {'TRGs2SWPs';'TRGs2Nodes'}
        pbgn = spikes.trg.trg1 + margin(1);
        plst = spikes.trg.trg2 + margin(2);
        Meting(1) = DACexpand(Meting(1));
        [maxadc,maxkan,maxswp] = size(Meting(1).adc);
        ratio = Meting(1).DAC.rate/Meting(1).ADC.rate;
        if strcmp(cmd,'TRGs2SWPs')
            Meting(2)          = Meting(1);
            Meting(2).SEGMENT.name  = [];
            Meting(2).SEGMENT.time  = [];
            Meting(2).SEGMENT.cmt  = [];
            Meting(2).SEGMENT.start = [];
            Meting(2).SEGMENT.eind  = [];
            Meting(2).nodenaam  = newname;
            Meting(2).serienaam = newname;
            Meting(2).reltime  = pbgn / spikes.trg.rate;
            Meting(2).setnr    = true;
            numtrigs      = length(pbgn);
            adcpoints     = plst(1)-pbgn(1)+1;
            Meting(2).adc = zeros(adcpoints,maxkan,numtrigs,'int16');
            Meting(2).EXTRA.MEAN.aver = numtrigs;
            for kk = 1:numtrigs
                if (pbgn(kk)<1)||(plst(kk)>maxadc)
                    Error(sprintf('adc out of range   %d   %d',pbgn(kk),plst(kk)));
                    Meting(2) = [];
                    return
                else
                    Meting(2).adc(:,:,kk) = Meting(1).adc(pbgn(kk):plst(kk),:,1);
                end
            end
            if ~isempty(Meting(1).dac)
                Meting(2).dac = Meting(1).dac(round(pbgn(1)*ratio):round(plst(1)*ratio),:);
            end
        elseif strcmp(cmd,'TRGs2Nodes')
            for kk = 1:length(pbgn)
                adcpoints = plst(kk)-pbgn(kk)+1;
                Meting(kk+1)          = Meting(1);
                if kk>1,Meting(kk+1).setnr = false; end
                Meting(kk+1).SEGMENT.name  = [];
                Meting(kk+1).SEGMENT.time  = [];
                Meting(kk+1).SEGMENT.cmt  = [];
                Meting(kk+1).SEGMENT.start = [];
                Meting(kk+1).SEGMENT.eind  = [];
                Meting(kk+1).nodenaam  = newname;
                Meting(kk+1).serienaam = newname;
                Meting(kk+1).reltime  = pbgn(kk) / spikes.trg.rate;
                Meting(kk+1).adc      = zeros(adcpoints,maxkan,'int16');
                if (pbgn(kk)<1)||(plst(kk)>maxadc)
                    Error(sprintf('adc out of range   %d   %d',pbgn(kk),plst(kk)));
                    Meting(2:end) = [];
                    return
                else
                    Meting(kk+1).adc = Meting(1).adc(pbgn(kk):plst(kk),:);
                    if ~isempty(Meting(1).dac)
                        Meting(kk+1).dac = Meting(1).dac(round(pbgn(kk)*ratio):round(plst(kk)*ratio),:);
                    end
                end
            end
        end
        Meting(1) = [];
        panels.zoom.tnul = 0;
        panels.segnr  = 0;
        SpikeIni;
        TriggerIni;
        set(CMD.zoom,'UserData',0) 
        Redraw(1);
    case 'Events2SWPs'
        Meting(2) = Meting(1);
        Meting(2).SEGMENT.name  = [];
        Meting(2).SEGMENT.time  = [];
        Meting(2).SEGMENT.cmt  = [];
        Meting(2).SEGMENT.start = [];
        Meting(2).SEGMENT.eind  = [];
        adcpoints          = round((events.evt.last(1)-events.evt.first(1))*spikes.adcrate/1000);
        numchan            = length(Meting(2).ADC.HWchn);
        numswps            = length(events.evt.first);
        Meting(2).reltime  = events.evt.first / 1000;
        Meting(2).adc      = zeros(adcpoints,numchan,numswps,'int16');
        Meting(2).EXTRA.MEAN.aver = numswps;
        Meting(2).nodenaam  = newname;
        Meting(2).serienaam = newname;
        for kk = 1:numswps
            start = 1 + round((events.evt.first(kk) - panels.zoom.tnul)*spikes.adcrate/1000);
            if (start<1)||((start+adcpoints-1)>length(Meting(1).adc)),
                Error('range error'); return;
            else
                Meting(2).adc(:,:,kk) = Meting(1).adc(start:start+adcpoints-1,:,1);
            end
        end
        Meting(1) = DACexpand(Meting(1));
        if ~isempty(Meting(1).dac)
            start = 1 + round((events.evt.first(1) - panels.zoom.tnul) * Meting(1).DAC.rate/1000);
            dacpoints = round((events.evt.last(1) - events.evt.first(1)) * Meting(1).DAC.rate/1000);
            Meting(2).dac = Meting(1).dac(start:start+dacpoints-1,:);
        end
        Meting(1) = [];
        panels.zoom.tnul = 0;
        panels.segnr = 0;
        SpikeIni;
        TriggerIni;
        set(CMD.zoom,'UserData',0);
        Redraw(1);
    case 'Events2Nodes'
        before  = timegain*rsingle(parms{1});
        after   = timegain*rsingle(parms{2});
        mintime = timegain*rsingle(parms{3});
        mcnt = 0;
        for jjjj = 1:max(1,length(Memoryset))
            if length(Memoryset)>1, MemoryUpdate(jjjj,1); end
            adcrate = Meting(1).ADC.rate;
            theclass = 0;
            if ~isempty(class)
                theclass = find(strcmp(events.class.nam,class));
                if isempty(theclass)
                    Error(sprintf('No classname to match %s',class)); return
                end
            end
            for jjj=1:length(events.evt.first)
                if (theclass>0)
                    if (events.evt.clsnr(jjj)~=theclass), continue; end
                end
                if length(before)==2
                    t1 = events.evt.first(jjj) + before(1);
                	t2 = events.evt.first(jjj) + before(2);
                elseif length(after)==2
                    t1 = events.evt.last(jjj) + after(1);
                	t2 = events.evt.last(jjj) + after(2);
                else
                    t1 = events.evt.first(jjj) + before(1);
                	t2 = events.evt.last(jjj)  + after(1);
                end
                start = 1 + round((t1-panels.zoom.tnul) * adcrate / 1000);
                einde =     round((t2-panels.zoom.tnul) * adcrate / 1000);
                if events.evt.first(jjj)==events.evt.last(jjj)
                    fprintf('%s %u, most likely an artefact (start=end)\n',newname,jjjj);
                elseif start<1
                    fprintf('%s %u- %02u, to early only %0.2f (s) before\n',newname,jjjj,jjj,(events.evt.first(jjj)-panels.zoom.tnul)/1000);
                elseif einde>length(Meting(1).adc)
                    fprintf('%s %u- %02u, to late only %0.2f (s) after\n',newname,jjjj,jjj,(length(Meting(1).adc)/adcrate) - (events.evt.first(jjj)-panels.zoom.tnul)/1000);
                elseif (jjj>1) && ((events.evt.first(jjj)-events.evt.first(jjj-1))<mintime)
                    fprintf('%s %u- %02u, to close %0.2f (s)\n',newname,jjjj,jjj,(events.evt.first(jjj)-events.evt.first(jjj-1))/1000);
                else
                    mcnt = mcnt + 1;
                    Tmp(mcnt)         = Meting(1);
                    Tmp(mcnt).abstime = Meting(1).abstime;
                    Tmp(mcnt).reltime = mcnt;
                    Tmp(mcnt).setnr   = false;
                    Tmp(mcnt).adc     = [];
                    Tmp(mcnt).adc     = Meting(1).adc(start:einde,:,:);
                    if isempty(newname)
                        Tmp(mcnt).nodenaam  = sprintf('%s-%s %u',Meting(1).ADC.scale(events.evt.kanaal(jjj)).Name,events.class.nam{events.evt.clsnr(jjj)},jjj);
                        Tmp(mcnt).serienaam = Tmp(mcnt).nodenaam;
                    else
                        Tmp(mcnt).nodenaam  = sprintf('%s-%02u',newname,mcnt);
                        Tmp(mcnt).serienaam = newname;
                    end
                    Tmp(mcnt).EXTRA.note = notitie;
                end
            end
        end
        MemoryUpdate;
        Meting  = Tmp;
        clear Tmp
        Meting(1).setnr = true;
        setdaqpars(panels.zoom.tnul,panels.zoom.tnul + t2-t1)
        if dosave
            if isempty(newname)
                Message('No filename given, cannot save')
            else
                writedir = makenewdir(panels.file.name,'new');
                panels.file.name = fullfile(writedir,newname);
                save(panels.file.name,'Meting','-V6');
            end
        end
        set(CMD.zoom,'UserData',0)
        Redraw(1);
    case 'Set2Nodes'
        if isempty(Memoryset), Error(sprintf('\nNeed a Memoryset for %s', cmd)); return; end
        [~,present,ps] = ParseSpecial(parms,'timing');
        if present, gap = rsingle(ps{1}); else,gap = []; end
        if Error, return; end
        Meting = [];
        starttime = Memoryset{1}.Meting(1).abstime;
        lasttime  = 0;
        newstart  = 0;
        mcnt = 0;
        for nset = 1:length(Memoryset)
            Hlpmet = Memoryset{nset}.Meting;
            if isempty(gap)
                newstart = (Hlpmet(1).abstime - starttime)*(24*60*60);
            else
                newstart = newstart + lasttime + gap;
            end
            lasttime   = 0;
            for nmet = 1:length(Hlpmet)
                lasttime = max([lasttime, max(Hlpmet(nmet).reltime)]);
                mcnt = mcnt + 1;
                if mcnt==1
                    Meting = Hlpmet(nmet);
                else
                    Meting(mcnt)= Hlpmet(nmet);
                end
                Meting(mcnt).abstime = starttime;
                Meting(mcnt).reltime = newstart + Hlpmet(nmet).reltime;
                Meting(mcnt).version = getversion;
                if length(Hlpmet)==1
                    Meting(mcnt).setnr = (nset==1);
                else
                    Meting(mcnt).setnr = (nmet==1);
                end
            end
        end
        MemoryUpdate;
        Meting = DACcompress(Meting);
        if dosave
            if isempty(newname)
                writedir = makenewdir(Memoryset{1}.Meting(1).filename);
                [~,datafile1] = fileparts(Memoryset{1}.Meting(1).filename);
                [~,datafile2,fileext] = fileparts(Memoryset{end}.Meting(1).filename);
                for ii = 1:length(datafile1)
                    if datafile1(ii)~=datafile2(ii)
                        panels.file.name = [writedir datafile1 '_' datafile2(ii:end) fileext];
                        break
                    end
                end
                save(panels.file.name,'Meting','-v6');
            else
                newdir = fileparts(newname);
                [succes,message] = mkdir(newdir);
                if succes
                    panels.file.name = newname;
                    save(panels.file.name,'Meting','-v6');
                else
                    Message(sprintf('%s\n%s',message,newdir));
                end
            end
        end
        NRNtimeline;
    case 'Nodes2Sweeps'
        sets = [find([Meting.setnr]) length(Meting)+1];
        for ii = 1:length(sets)-1
            serie = (sets(ii):(sets(ii+1)-1))';
            for jj = 1:length(serie)
                if jj==1
                    node = serie(1);
                    Meting(node).EXTRA.MEAN.aver = length(serie);
                    Meting(node).reltime = [Meting(node+(1:length(serie))-1).reltime];
                    if ii>1, Meting(node).setnr = false; end
                else
                	Meting(node).adc(:,:,jj)   = Meting(node+jj-1).adc(:,:,1);
                end
            end
        end
        remove = setdiff(1:length(Meting),sets);
        Meting(remove) = [];
        NRNtimeline;
    otherwise
end
%
% ====== The Script ===============================================
%
function Script_Run(scriptname,txt1)
global Memoryset Meting panels events SEL IMG cmdlist p
Error("clear",scriptname);
if iscell(txt1)
    script = txt1;
else
    script = ParseSimple(txt1);
    if Error, return; end
end
if isempty(script)
    Error(sprintf("No command to execute in %s",scriptname));
    return
end
script = string(script);
CMD = getPANEL('CMDpanel');
mm = 0;
while mm<length(script)
    mm = mm + 1;
    panels.last.cmd = strtrim(script{mm});
    Error("line",sprintf("Script cmd: %s\n",panels.last.cmd));
    cmdstr = script(mm);
    drawnow;
    [cmd,parms] = ParseCmd(cmdstr);
    if Error, break; end
    set(gcf,"Name",scriptname+" execute:   "+cmd);
    if contains(string(cmd),"=")
        try  
            eval(cmdstr+";");
        catch
            Error(sprintf("Error in evaluation of\n%s\ndirect MATLAB error",cmdstr)); break;
        end
    else
        [parms,wait] = ParseOne(parms,"wait",0);
        nparms = length(parms);
        switch char(cmd)
            case 'None'
            case {'return';'exit';'Exit'}, break;
            case 'LeaveIfEmpty',if isempty(parms) || isempty(ssingle(parms{1})), break; end
            case 'Stop',        Error("tell",'Script stop command');
            case 'Evalm',       eval(parms{1});
            case 'Evalp',       eval([parms{1} ';']);
            case 'Clearp',      p = [];
            case 'Clear',       WindowClear(parms);
            case 'Timescale',   Timescale(CMD,ssingle(parms{1}));
            case 'Firststim',   panels.firststim = rsingle(parms{1});
            case 'MyBoolean',   set(CMD.MyBoolean,'UserData',ssingle(parms{1}));
            case 'Amplifier',   if (nsingle(parms{1})==2), panels.amplifier= 'AXON2'; else, panels.amplifier= 'AXON1'; end
            case 'StepWise',    set(CMD.scriptstep,'Value',getboolean(parms,true));
            case 'SetWait',     set(CMD.pause,'String',ssingle(parms{1}));
            case 'SkipWait',    set(CMD.scriptwait,'Value',getboolean(parms,true));
            case 'Wait',        if isempty(parms), DoTestwait(parms); else,DoTestwait(rsingle(parms{1})); end
            case 'Block',       set(CMD.bloks,'Value',getboolean(parms,true));
            case 'Fotos',       set(CMD.includefotos,'Value',getboolean(parms,true));
            case 'Autohide',    set(CMD.autohide, 'Value',getboolean(parms,true));
            case 'AutoClear',   set(CMD.autoclear,'Value',getboolean(parms,true));
            case 'Full',        status = getboolean(parms,true);
                                if status, setdaqpars(panels.zoom.tnul,panels.zoom.tend); end
                                set(CMD.autofull,'Value',status);
            case 'Hide',        if getboolean(parms,true), CMD.macro.Visible = 'on'; else, CMD.macro.Visible = 'off'; end
            case 'Redraw',      Redraw;
            case 'Cameras',     panels.video.name   = stringset(parms{1});
                                panels.file.video   = [];
                                panels.video.VLCpos = [];
            case 'FullRedraw',  setmaxpars(Meting(1),'full'); Redraw(1);
            case 'Zoom',        Zoom(CMD,parms)
            case 'ADCoffset',   set(CMD.ADCseparatornum,'String',parms{1}); CMDscale(CMD,CMD.ADCseparatornum);
            case 'ADCgain',     set(CMD.ADCgainnum,     'String',parms{1}); CMDscale(CMD,CMD.ADCgainnum);
            case 'DACoffset',   set(CMD.DACseparatornum,'String',parms{1}); CMDscale(CMD,CMD.DACseparatornum);
            case 'DACgain',     set(CMD.DACgainnum,     'String',parms{1}); CMDscale(CMD,CMD.DACgainnum);
            case 'Deftransform',DoDeftransform(CMD,parms);
            case 'MergeEEG',    DoMergeEEG;
            case 'SWPdelete',   SWPdelete  (parms);
            case 'MEA_protocol',MEAprotocol(parms);
            case 'MEAstimulus', MEAstimulus(parms);
            case 'MEAmean',     MEAmean    (parms);
            case 'MEAunits',    MEAunits   (parms);
            case 'MEAextract',  MEAextract (parms);
            case 'MEAset',      MEAset     (parms);
            case 'SpikesSave',  [filepath,filename] = fileparts(panels.file.name);
                                save(fullfile(filepath,[filename 'spikes.mat']),'spikes');
            case 'Group',       set(CMD.group,'Value',getboolean(parms,true));
            case 'SkipFit',     panels.skipfit = getboolean(parms,true);                
            case 'Skip',        if isempty(parms), SkipOn(CMD); else, SkipOff(CMD,rsingle(parms{1})); end
            case 'Setframe',    hlp = rsingle(parms{1})*timegain;
                                if length(hlp)<2
                                    d1 = panels.zoom.tnul;
                                    d2 = panels.zoom.tend;
                                else
                                    d1 = max(min(hlp),panels.zoom.tnul);
                                    d2 = min(max(hlp),panels.zoom.tend);
                                end
                                setdaqpars(d1,d2);
            case 'PlotModus',sins = ssingle(parms{1});
                             strs = strtrim(get(CMD.mousemode,'String'));
                             deze = find(strcmp(strs,sins));
                             if isempty(deze)
                                 Error(sprintf('Illegal PlotModus:\n\n  |%s|',sins));
                             else
                                set(CMD.mousemode,'Value',deze);
                             end
            case 'REPEAT',   hhlp = script(1:mm);
                             cnt = mm;
                             rps = ParseSimple(ssingle(parms{1}));
                             for j3 = 1:length(rps)
                                 for j4 = 2:length(parms)
                                     cnt = cnt + 1;
                                     hhlp(cnt,1) = ParseSimple(strrep(parms{j4},'REP',rps{j3}));
                                 end
                             end
                             for j3 = (mm+1):length(script)
                                 cnt = cnt + 1;
                                 hhlp(cnt,1) = script(j3);
                             end
                             script = hhlp;
            case 'Chop',        hlp = round(rsingle(parms{1})*timegain*Meting(1).ADC.rate/1000);
                                if length(hlp)==1
                                    hlp(2) = hlp;
                                    hlp(1) = 1;
                                end
                                for jj = 1:length(Meting)
                                    fst = max(hlp(1),1);
                                    lst = min(hlp(2),size(Meting(jj).adc,1));
                                    Meting(jj).adc = Meting(jj).adc(fst:lst,:,:);
                                end
                                setmaxpars(Meting(jj),'full');
                                Redraw;
            case 'DataRoot',    panels.file.root = unifile(ssingle(parms{1}));
            case 'FileLoad',                           loaddata([],parms);
            case 'CellLoad',    parms{end+1} = 'cell'; loaddata([],parms);
            case 'DirLoad',     parms{end+1} = 'dir';  loaddata([],parms);
            case 'Reload',                             loaddata(CMD.Reload,{'reload'});
            case 'Segment',     segnr = nsingle(parms{1});
                                panels.segnr = 0;
                                [parms,present,ps] = ParseSpecial(parms,'range');
                                if present, tt = rsingle(ps{1}); end
                                MemoryUpdate(panels.filenr,segnr);
                                if present
                                    tt = round((tt - Meting.SEGMENT.start(segnr))*Meting(1).ADC.rate );
                                    Meting(1).adc = Meting(1).adc(tt(1):tt(2),:);
                                end
            case 'Memoryset',   doMemoryset(parms);
            case 'Memdelete',   doMem(parms,'delete');
            case 'Memkeep',     doMem(parms,'keep');
            case 'Memload',     doMem(parms,'load');
            case 'Memsave',     doMem(parms,'save');
            case 'Memprint',    doMem(parms,'print');
            case 'Memlabel',    doMem(parms,'label');
                
            case 'Parclear',    doPars(parms,"clear");
            case 'Parbasis',    doPars(parms,"basis");
            case 'Overrule',    doPars(parms,"overrule");
            case 'Parchannel',  doPars(parms,"channel");
            case 'Parget',      doPars(parms,"get");
%             case 'Baspars',     doBaspars(parms);
                
            case 'Export',      DoExport(parms);
            case 'Unravel',     DoUnravel(parms);
            case 'Music',       if isempty(parms), DoMusic(1); else, DoMusic(nsingle(parms{1})); end
            case 'Draw',        DoDraw(parms);
            case 'Drawtimeline',NRNtimeline;
            case 'NoDraw',      set(panels.winval,'Value',0);
            case 'Delete',      if DoDelete(parms), NRNtimeline; end
            case 'ListEmpty',   if isempty(cmdlist{nsingle(parms{1})}), break; end
            case 'List',        [parms,notvc,ps] = ParseSpecial(parms,'leaveonVC');
                                if notvc && ~isempty(ps), ampvc = nsingle(ps{1}); else,ampvc = 1; end
                                [parms,notcc,ps] = ParseSpecial(parms,'leaveonCC');
                                if notcc && ~isempty(ps), ampcc = nsingle(ps{1}); else,ampcc = 1; end
                                [parms,ifempty,ps] = ParseSpecial(parms,'leaveonempty');
                                if ifempty && ~isempty(ps)
                                    hlp = nsingle(ps{1});
                                    if hlp(1)==0, break; end
                                end
                                if isempty(Meting), Error('Meting is empty'); break; end
                                tmplist = DoList(parms);
                                if ifempty && isempty(tmplist), break; end
                                if notvc && strcmp(Meting(tmplist(1,2)).EXTRA.AXON1.pars.mode,'VC'), break; end
                                if notcc && strcmp(Meting(tmplist(1,2)).EXTRA.AXON1.pars.mode,'CC'), break; end
            case 'RemoveEmpty', skip = [];
                                for jj = 1:length(Meting)
                                    if Meting(jj).abstime==0, skip = [skip jj]; end
                                end
                                if ~isempty(skip)
                                    Meting(skip) = [];
                                    NRNtimeline;
                                end
            case 'CorrectADCrate'
                rate = rsingle(parms{1});
                for ii = 1:length(Meting), Meting(ii).ADC.rate = rate; end
            case 'CorrectDACrate'
                rate = rsingle(parms{1});
                for ii = 1:length(Meting), Meting(ii).DAC.rate = rate; end
            case 'Deletefotos'
                IMG.bld = [];
                IMG.nam = [];
                NRNtimeline;
            case 'Logmaster',     DoLogmaster(parms);
            case 'Logger',        DoLogger(CMD,parms);
            case 'Snapshot',      DoSnapshot(parms);
            case 'Colormap',      try
                                      eval(['colormap(' ssingle(parms{1}) ')']);
                                  catch
                                      Error('Unknown colormap'); break;
                                  end
            case 'SetTextFile',   if nparms>0
                                      panels.file.txtmax = rsingle(parms{2});
                                      if nparms>1
                                          panels.file.scale = rsingle(parms{3});
                                          if nparms>2
                                              panels.file.unit = ssingle(parms{4});
                                          end
                                      end
                                  end
            case 'NewName',         DoNewname(parms); NRNtimeline;
            case 'SetNames',        DoSetname(parms); NRNtimeline;
            case 'MetNames',        DoNames(parms,[]);
                                    if ~Error, Redraw(1); end
                                    set(CMD.group,'Value',1);
            case 'Leak',            DoLeak        (parms,CMD);
            case 'LeakTrans',       DoLeakTrans   (parms);
            case 'LeakFraai',       DoLeakFraai   (parms); if ~isempty(Memoryset), MemoryUpdate('refresh'); end
            case 'LeakSub',         DoLeakSub     (parms);
            case 'Clean50Hz',       DoClean50Hz(parms);
            case 'Collaps',         DoCollaps;
            case 'Segment_Split',   DoSegment_Split(parms);
            case 'Merge',           DoMerge(parms);
            case 'Extract',         DoExtract (parms);
            case 'Binding',         DoBinding (parms);
            case 'Shifting',        DoShifting(parms);
            case 'Plottool',        plottools
            case 'Fittool',         cftool([1 2 3 4 5 6 7 8],[1 3 4 6 7 8 9 8]);
            case 'FitXY',           DoFitXY       (parms);
            case 'Markmissers',     if DoMarkmissers(parms), break; end
            case 'Markspikers',     DoMarkspikers(parms);
            case 'Fig',             DoFigparms;
            case {'Zero';'zero'},   Meting = DoZero(parms,Meting);
            case 'Formula',         DoFormula     (parms);
            case 'Filter',          DoFilter      (parms);
            case 'FindDAC',         DoFindDAC     (parms);
            case 'Stim2Swp',        DoStim2Swp    (parms);
            case 'Subtraces',       DoSubtraces   (parms);
            case 'Reorganize',      DoReorg       (parms);
            case 'Elles',           DoElles       (parms);
            case 'Firing',          DoFiring      (parms);
            case 'Spikes',          DoSpikes      (parms);
            case 'Balance',         DoBalance2    (parms);
            case 'PCA',             DoPCA         (parms);
            case 'IMGopen',         DoIMGopen     (parms);
            case 'IMGsave',         DoIMGsave     (parms,IMG,Meting);
            case 'IMGtool',         DoIMGtool     (parms);
            case 'Spike_PSTH',      DoPSTH        (parms);
            case 'Resample',        DoResample    (parms);
            case 'Detect',          DoDetect      (parms);
            case 'Seizure',         DoSeizure     (parms);
            case 'SpikeAnalyser',   DoSpikeAnalyser(parms);
            case 'Dynamic',         DoDynamic     (parms);
            case 'Minis',           DoMinis       (parms);
            case 'Trace',           DoTrace       (parms);
            case 'Return',          DoReturn      (parms);
            case 'Hist',            DoHist        (parms);
            case 'Stat',            DoStat        (parms);
            case 'XY',              DoXY          (parms);
            case 'Stimulation',     DoStimulation (parms);
            case 'Trace_Amplitude', DoAmpHist     (parms);
            case 'Event_Template',  DoTemplate    (parms);
            case 'Concatenate',     DoConcatenate (parms);
            case 'Transfer',        DoTrans       (parms);
            case 'Chirp',           DoChirp       (parms);
            case 'Tamar',           doTamar       (parms);
            case 'DBload',          DBload        (parms);
            case 'DBclass',         DBclass       (parms);
            case 'DBevents',        DBevents      (parms); 
            case 'DBclose',         DBclose;
            case 'DBexcel',         DBexcel       (events);
            case 'OpenMINI',        Openpanel     ('MINIpanel',@MINI_Callback);
            case 'Descriptor',      DBdescriptor  (Meting); DoMusic(0);
            case 'Cache',           set(CMD.cachemax,'String',sprintf('%0.1f',rsingle(parms{1})));
            case 'SELscript',       if ~panels.online && ~isempty(SEL)
                                        set([SEL.stmart,SEL.artrun],'Visible','On');
                                        set(SEL.artrun,'UserData', ssingle(parms{1}));
                end
            case {'DACs2Spikes';...
                  'Set2Nodes';...
                  'Nodes2Sweeps';...
                  'Spikes2Events';...
                  'Spikes2Trigs';...
                  'TRGs2Events';...
                  'TRGs2SWPs';...
                  'TRGs2Nodes';...
                  'Events2SWPs';...
                  'Events2Nodes';...
                  'Event_Clean';...
                  'Event_Edit'},    DoVanAnaarB   (cmd,parms);
            case 'DecomposeDAC',    [parms,present,ps] = ParseSpecial(parms,'channel');   if present, channel = nsingle(ps{1}); else,Error('Need chns'); break; end
                                    [parms,sets,mets,swps] = ParseList(parms);                
                                    splitf   = rsingle(parms{1});
                                    gap      = rsingle(parms{2});
                                    if Error, break; end
                                    for metnr = mets
                                        Meting(metnr) = DACexpand(Meting(metnr));
                                        if ~isempty(Meting(metnr).dac)
                                            sdac = Meting(metnr).DAC.scale(channel).User/Meting(metnr).DAC.ints;
                                            yt   = double(Meting(metnr).dac(:,channel)) * sdac;
                                            xt   = (0:(length(yt)-1))' * 1000 / Meting(metnr).DAC.rate;
                                            DecomposeDAC(xt,yt,sdac,channel,gap,splitf,metnr);
                                            if Error, break; end
                                        end
                                    end
            case 'MakeMean',    [parms,tijden] = ParseTijd(parms,'range',1); if isempty(tijden), tijden = [-inf,inf]; end
                                txt1  = ssingle(parms{1});
                                modus = ssingle(parms{2});
                                list = cmdlist{list}(:,2);
                                nlen = size(list,1);
                                t12  = 1 + round(tijden * Meting(list(1)).ADC.rate/1000);
                                p1 = t12(1);
                                p2 = t12(2);
                                d2 = size(Meting(list(1)).adc,2);
                                data = zeros(p2-p1+1,d2,nlen);
                                for jj = 1:size(list,1)
                                    data(:,:,jj) = double(Meting(list(jj)).adc(p1:p2,:,1));
                                end
                                if strcmp(modus,'median')
                                    dsum = median(data,3);
                                elseif strcmp(modus,'mean')
                                    dsum = mean(data,3);
                                elseif strcmp(modus,'mixed')
                                    if nlen==1
                                        dsum = data;
                                    else
                                        hlp = sort(data,3);
                                        bgn = round(nlen/4);
                                        lst = round(3*nlen/4);
                                        hlp = hlp(:,:,bgn:lst);
                                        dsum = mean(hlp,3);
                                    end
                                else
                                    Error(sprintf('Unknown modus in Makemean %s',modus)); break;
                                end
                                new   = length(Meting)+1;
                                Meting(new)         = Meting(1);
                                Meting(new).reltime = 2*Meting(new-1).reltime - Meting(new-2).reltime;
                                Meting(new).nodenaam  = txt1;
                                Meting(new).serienaam = txt1;
                                Meting(new).EXTRA.note   = modus;
                                NRNtimeline;
                                Meting(new).adc(p1:p2,:,1) = int16(round(dsum));
            case {'Include';'Exclude'}
                                if nparms>0
                                    pp  = round( (rsingle(parms{1})*panels.timegain-panels.zoom.tnul)*Meting(1).ADC.rate/1000);
                                    lst = size(Meting(1).adc,1);
                                    bgn = 1;
                                    if strcmp(cmd,'Include'), pp = [bgn pp lst]; end
                                    for ii = 1:2:length(pp), Meting(1).adc(max(bgn,pp(ii)):min(lst,pp(ii+1)),:,:) = 0; end
                                end
%
% ===== channel manipulations ====================
%
            case 'Downscale'
                [rows,cols,pages]=size(Meting(1).adc);
                channel = nsingle(parms{1});
                gain    = rsingle(parms{2});
                for jjj = 3:nparms
                    range   = rsingle(parms{jjj});
                    pp = round((range * panels.timegain - panels.zoom.tnul)*Meting(1).ADC.rate/1000);
                    pp(1) = max(1,pp(1));
                    pp(2) = min(rows,pp(2));
                    if length(pp)>2
                        offset = mean(double(Meting(1).adc(pp(1):pp(2),channel,1))/gain);
                        offset = mean(double(Meting(1).adc(pp(3):pp(4),channel,1)))-offset;
                    else
                        offset = 0;
                    end
                    Meting(1).adc(pp(1):pp(2),channel,1)= int16 (offset + double(Meting(1).adc(pp(1):pp(2),channel,1))/gain);
                end
            case 'Upscale'
                channel   = rsingle(parms{1});
                gaindata  = rsingle(parms{2});
                gainscale = rsingle(parms{3});
                for ii = 1:length(Meting)
                    if ~isempty(Meting(ii).adc)
                        [pnts,chans,swps] = size(Meting(ii).adc);
                        if gaindata~=1
                            for kk = 1:swps
                                offset = mean(double(Meting(ii).adc(:,channel,kk)));
                                Meting(ii).adc(:,channel,kk)= int16 (gaindata * (double(Meting(ii).adc(:,channel,kk)) - offset));
                            end
                        end
                        Meting(ii).ADC.scale(channel).User = Meting(ii).ADC.scale(channel).User*gainscale/gaindata;
                    end
                end
            case 'ChannelCopy'
                [parms,present,ps] = ParseSpecial(parms,'target');
                if present, target = nsingle(ps{1}); else, Error('Copy needs target'); break; end
                [parms,present,ps] = ParseSpecial(parms,'source');
                if present, source = nsingle(ps{1}); else, Error('Copy needs source'); break; end
                [parms,present,ps] = ParseSpecial(parms,'list');
                if present
                    delist = cmdlist{nsingle(ps{1})};
                    for metnr = delist(1,2)
                        if isempty(Meting(metnr).adc), continue; end
                        for jj = target
                            for swpnr = delist(1,3)
                                Meting(metnr).adc(:,jj,swpnr) = Meting(metnr).adc(:,source,swpnr);
                            end
                            Meting(metnr).ADC.scale(jj) = Meting(metnr).ADC.scale(source);
                            Meting(metnr).ADC.HWchn(jj) = Meting(metnr).ADC.HWchn(source);
                        end
                    end
                end
            case 'ChannelAdd'
                target = nsingle(parms{1});
                tags   = ssingle(parms{2});
                terms  = nsingle(parms{3});
                if nparms>3, nmets = nsingle(parms{4}); else,nmets = 1; end
                if nparms>4, nswps = nsingle(parms{5}); else,nswps = 1; end
                if Error, break; end
                for jjj = nmets
                    if nswps==0, [times,kanalen,sweeps] = size(Meting(jjj).adc); nswps =1:sweeps; end
                    for jj=nswps
                        Meting(jjj).adc(:,target,jj) = Meting(jjj).adc(:,terms(1),jj);
                        for ii=2:length(terms)
                            Meting(jjj).adc(:,target,jj) = Meting(jjj).adc(:,target,jj) + Meting(jjj).adc(:,terms(ii),jj);
                        end
                    end
                    Meting(jjj).ADC.scale(target).Name = tags;
                end
            case 'ChannelSubtract'
                target = nsingle(parms{1});
                tags   = ssingle(parms{2});
                terms  = nsingle(parms{3});
                if nparms>3, nmets = nsingle(parms{4}); else,nmets = 1; end
                if nparms>4, nswps = nsingle(parms{5}); else,nswps = 1; end
                if Error, break; end
                for jjj = nmets
                    if nswps==0, [~,~,sweeps] = size(Meting(jjj).adc); nswps =1:sweeps; end
                    for jj=nswps
                        Meting(jjj).adc(:,target,jj) = Meting(jjj).adc(:,terms(1),jj) - Meting(jjj).adc(:,terms(2),jj);
                    end
                    Meting(jjj).ADC.scale(target).Name = tags;
                end
            case 'Divide'
                target = nsingle(parms{1});
                tags   = ssingle(parms{2});
                terms  = nsingle(parms{3});
                gain   = 32767/rsingle(parms{4});
                if nparms>4, nmets = nsingle(parms{5}); else,nmets = 1; end
                if nparms>5, nswps = nsingle(parms{6}); else,nswps = 1; end
                if Error, break; end
                for jjj = nmets
                    if nswps==0, [~,~,sweeps] = size(Meting(jjj).adc); nswps =1:sweeps; end
                    for jj=nswps
                        Meting(jjj).adc(:,target,jj) = int16(gain * double(Meting(jjj).adc(:,terms(1),jj))./double(Meting(jjj).adc(:,terms(2),jj)));
                    end
                    Meting(jjj).ADC.scale(target).Name = tags;
                end
            case 'ReduceChannels'
                die = nsingle(parms{1});
                Meting(1).ADC.HWchn(die) = [];
                Meting(1).ADC.scale(die) = [];
                Meting(1).adc(:,die,:) = [];
                Redraw(1);
            case 'ExpandChannels'
                die = nsingle(parms{1});
                [duur,kanalen] = size(Meting(1).adc);
                for jj = (kanalen+1):(kanalen+die)
                    Meting(1).ADC.HWchn(jj) = 0;
                    Meting(1).ADC.scale(jj)   = Meting(1).ADC.scale(1);
                end
                Meting(1).adc(1,kanalen+die,1) = 0;
                Redraw(1);
%
% make movie
%
            case 'Movie'
                mets = length(Meting);
                [filepath,filename] = fileparts(panels.file.name);
                mov = avifile(fullfile(filepath,[filename '.avi']),'fps',1,'quality',100);
                X0 = 240;
                Y0 = 0;
                positie = [X0 Y0 ...
                           panels.primair(1)+panels.primair(3)-X0 ...
                           panels.primair(1)+panels.primair(4)-Y0];
                NRNtimeline;
                for jj = 1:mets
                    panels.plotter.metnr = jj;
                    panels.plotter.subnr = 1;
                    NRNshow(Meting);
                    Film = getframe(gcf,positie);
                    mov = addframe(mov,Film);
                end
                close(mov);
% afronden....
%
            otherwise
                if panels.abort || Error, break; end
                [cmd,nxtmacro] = Substitute(cmdstr);
                if Error, break
                elseif isempty(cmd)
                elseif isempty(nxtmacro)
                    Error(sprintf('\nCannot execute\n\n%s',cmdstr));
                else
                    Script_Run(string(cmd),string(nxtmacro));
                end
        end
        drawnow();
        if ~strcmp(get(CMD.pause,'String'),'inf'), DoTestwait(wait(1)); end
        if panels.abort || Error, break; end
    end
    if panels.abort || Error, break; end
end

function run_script(hObject,~)
global panels knobs
Error("clear","run-script "+hObject.Tag);
CMD = getPANEL('CMDpanel');
if KnobIsRed(hObject)
    if panels.alwaysabort
        panels.abort = true;
        KnobGrey(CMD.super);
        KnobGrey(hObject);
        return
    else
        button2 = "Abort";
        button3 = "Always Abort";
        button = questdlg("What to do",sprintf(" %s is already running",hObject.String),"Ignore",button2,button3,button3);
        if (button==button2) || (button==button3)
            panels.abort = true;
            KnobGrey(CMD.super);
            KnobGrey(hObject);
            Waitbar(CMD,"hide");
            if button==button3, panels.alwaysabort = true; end
        end
    end
end
keys = findobj('Tag','SCRIPT');
if KnobIsRed(keys)
    panels.abort = true;
    KnobGrey(keys);
else
    panels.abort = false;
    knobnr = find(strcmp(hObject.String,knobs.knobcmd));
    if isempty(knobs.init)
        macro = knobs.knobtxt{knobnr};
    else
        macro = [knobs.init ',' knobs.knobtxt{knobnr}]; end
    if Error, panels.super.abort = true; end
    panels.amplifier = 'AXON1';
    cmdstackpush;
    KnobRed(hObject);
    if CMD.autohide.Value
        KnobRed(CMD.hide);
        CMD.macro.Visible='Off';
    end
    Script_Run(string(knobs.knobcmd{knobnr}),string(macro));
    if CMD.autohide.Value
        KnobGrey(CMD.hide);
        CMD.macro.Visible='On';
    end
    KnobGrey(hObject);
    cmdstackpull;
    panels.amplifier = 'AXON1';
end
if Error("box")
    panels.super.abort = true;
else
    SetMenu('version');
end
%
% ====== Function for Formula =============================================
%
function tijd = p2t(point)
global Formula
if Formula.noshow, xas = Formula.xas; else, xas = get(Formula.handle,'XData')'; end
tijd = xas(round(point));

function point = t2p(tijd,varargin)
global Formula
if nargin>1, errortxt = varargin{1}; else, errortxt = ''; end
if Formula.noshow, xas = Formula.xas; else, xas = get(Formula.handle,'XData')'; end
point = NaN(length(tijd),1);
if tijd<xas(1)
    Error(sprintf('time %s %0.3f too low  (%0.3f - %0.3f)',errortxt,tijd,xas(1),xas(end)));
elseif tijd>xas(end)
    Error(sprintf('time %s %0.3f too high (%0.3f - %0.3f)',errortxt,tijd,xas(1),xas(end)));
else
    for jj = 1:length(tijd), point(jj) =  find(xas>=tijd(jj),1); end
end
  
function val = xaspoint(p)
val = p2t(p);

function showmarker(x1,y1,color,marker,msize,mwidth)
global Formula
if ~Formula.noshow
    for i1=1:length(x1)
        if length(y1)<length(x1), i2=1; else, i2=i1; end
        line(x1(i1),y1(i2),'Marker',marker,'MarkerSize',msize,'Color',color,'LineWidth',mwidth,'LineStyle','none');
    end
end

function showlines(x1,x2,y1,y2,color,linewidth,linestyle)
global Formula
if ~Formula.noshow
    for i1=1:length(x1)
        if length(y1)<length(x1),i2 = 1; else, i2= i1; end
        line([x1(i1) x2(i1)],[y1(i2) y2(i2)],'Color',color,'LineWidth',linewidth,'LineStyle',linestyle);
    end
end

function showline(x1,y1,color,linewidth,linestyle)
global Formula
if ~Formula.noshow
    if length(x1)==1, x1(2) = x1(1); end
    if length(y1)==1, y1(2) = y1(1); end
    line(x1,y1,'Color',color,'LineWidth',linewidth,'LineStyle',linestyle);
end

function val = lval(xval,x1,y1,x2,y2)
if x1 == x2, val = 0; return; end
a = (y1-y2)/(x1-x2);
val = y1 + a * (xval - x1);

function val = lin(val,varargin)
if ~isempty(val)
    if nargin>1, kleur = varargin{1}; else, kleur = 'r'; end
    if nargin>2, width = varargin{2}; else, width = 1; end
    ylims = get(gca,'YLim');
    for jj=1:length(val)
        showline(val(jj),ylims,kleur,width,':');
    end
end

function val = hlin(x1,x2,val,varargin)
if ~isempty(val)
    if nargin>3, kleur = varargin{1}; else, kleur = 'r'; end
    showline([x1 x2],val,kleur,1,':');
end

function valset = Crossings(yt,lvl,varargin)
valset = [];
if length(lvl)==1
    valset = find(((yt(1:(end-1))<=lvl(1)) & (yt(2:end)>lvl(1)))|((yt(1:(end-1))>=lvl(1)) & (yt(2:end)<lvl(1))));
elseif lvl(2)>lvl(1)
    valset = find( (yt(1:(end-1))<=lvl(1)) & (yt(2:end)>lvl(1)) );
elseif lvl(2)<=lvl(1)
    valset = find( (yt(1:(end-1))>=lvl(1)) & (yt(2:end)<lvl(1)) );
end
if (nargin>2) && strcmp(varargin{1},'interpol')
	valset = valset + double(lvl(1)-yt(valset))./double(yt(valset+1)-yt(valset));
end

function val = threshback(start,varargin)
global Formula
if Formula.noshow
    xas = Formula.xas;
    yas = Formula.yas;
else
    xas = get(Formula.handle,'XData')';
    yas = get(Formula.handle,'YData')';
end
pnt = t2p(start);
for jj = 2:nargin
    drp = yas(pnt) * varargin{jj-1} / 100;
    if yas(pnt)>0
    	doel = find(yas(1:pnt)<=drp,1,'last');
    else
        doel = find(yas(1:pnt)>=drp,1,'last');
    end
    if isempty(doel), time = start; else
        time = p2t(doel) + (xas(2)-xas(1)) * (drp-yas(doel))/(yas(doel+1)-yas(doel));
    end
    showmarker(time,drp,'g','s',9,2);
    val(jj-1) = time;
end

function val = threshforw(start,varargin)
global Formula
if Formula.noshow
    xas = Formula.xas;
    yas = Formula.yas;
else
    xas = get(Formula.handle,'XData')';
    yas = get(Formula.handle,'YData')';
end
pnt = t2p(start);
for jj = 2:nargin
    drp = yas(pnt) * varargin{jj-1} / 100;
    if yas(pnt)>0
    	doel = pnt - 1 + find(yas(pnt:end-1)<=drp,1,'first');
    else
        doel = pnt - 1 + find(yas(pnt:end-1)>=drp,1,'first');
    end
    if isempty(doel), time = start; else
        time = p2t(doel) + (xas(2)-xas(1)) * (drp-yas(doel-1))/(yas(doel)-yas(doel-1));
    end
    showmarker(time,drp,'g','s',9,2);
    val(jj-1) = time;
end

function val = extreme(vct)
[row,col] = size(vct);
if (row==1)||(col==1), val = max(abs(min(vct)),     abs(max(vct))); 
                  else,val = max(abs(min(min(vct))),abs(max(max((vct))))); end

function val = spikewidth(start,drm)
global Formula
if Formula.noshow
    yas = Formula.yas;
else
    yas = get(Formula.handle,'YData')';
end
drm = drm * yas(t2p(start))/100;
res1 = threshback(start,50);
res2 = threshforw(start,50);
val = res2-res1;
showline([res1 res2],drm,'c',2,'--');

function val = MakepA
global Formula
val = 1; 
switch Formula.yunit
    case 'pA'
    case 'nA', val = 1000;
    otherwise, Error(sprintf('\nchannel is not a current: %s',Formula.yunit));
end

function FF = astrocyte(V1,I1,V2,I2,fits)
FF.Rtot  = 1000 * (V1 - V2) / (I1 - I2);    % in MOhm
FF.Vglia = V1 - (I1 * FF.Rtot / 1000);      % in mV
amp = fits(2);
for jj = 3:2:length(fits), amp = amp + fits(jj); end
FF.Re    = 1000 * (V1 - V2) / (I1 - amp);
FF.Rm    = FF.Rtot - FF.Re;
FF.Cm    = 1000 * (fits(4)*(FF.Rm+FF.Re)/(FF.Rm*FF.Re));   % in pF

function volt = Nernst(in,out,varargin)
if nargin>2, valentie = varargin{1}; else,valentie = 1; end
volt = log(out/in)*8.3145*(273+21)/(valentie * 96.485);

function volt = GHK(voltage,in,out,varargin)
% Voltage in mV, in/out concentrations
if nargin>3, valentie = varargin{1}; else,valentie = 1; end 
a = -0.001*96485/(8.3145*(273+21));                               
b =  0.001*valentie*valentie*96.485*96.485*out/(8.3145*(273+21)); % scaled by 10-9
term = exp(a * voltage * valentie);
if abs(voltage)<0.01
    volt = b * (term-(in/out))/(valentie * a);
else
    volt = b * voltage*((in/out)-term)/(1-term);
end

function val = condition(test,negative,nul,positive)
if test==0
    val = nul;
elseif test>0
    val = positive;
elseif test<0
    val = negative;
end

function res = mcc(kanaal)
global Formula Meting
lbuf = get(Formula.handle,'UserData');
hlp = find(Meting(lbuf.wie.met).EXTRA.MCC.chn==kanaal);
if isempty(hlp)
    res = NaN;
else
    res = Meting(lbuf.wie.met).EXTRA.MCC.val(hlp(1));
    TextLeft(get(Formula.handle,'Parent'),sprintf('mcc = %4.1f',res))
end

function val = fun2(t1,t2,cmd,varargin)
global Formula
if Formula.noshow
    yas = Formula.yas;
else
    yas = get(Formula.handle,'YData')';
end
kleur  = 'r';
symbol = 'o';
markersize = 8;
if ~isempty(varargin) && ~isempty(varargin{1})
    hh = varargin{1}; if iscell(hh), hh = hh{1}; end
    tmp = intersect(hh,'P');            if ~isempty(tmp), markersize = 12; end
    tmp = intersect(hh,'rbmkcgy');      if ~isempty(tmp), kleur  = tmp(1); end
    tmp = intersect(hh,'odphx+*s^v><'); if ~isempty(tmp), symbol = tmp(1); end
end
p1 = t2p(t1);
p2 = t2p(t2);
if Error, val = NaN; return; end
if strcmp(cmd,'mintrain')||strcmp(cmd,'maxtrain')
    crossing = Crossings(Formula.dacy,[mean(Formula.dacy) inf]);
    plen = length(crossing)-1;
    xval = zeros(plen,1);
    yval = zeros(plen,1);
    for ii = 1:plen
        p1 = crossing(ii);
        p2 = crossing(ii+1);
        if     strcmp(cmd,'mintrain')
            [val,pres] = min(yas(p1:p2));
        elseif strcmp(cmd,'maxtrain')
            [val,pres] = max(yas(p1:p2));
        end
        xval(ii) = p2t(pres+p1-1);
        yval(ii) = val;
    end
    val(1,1) = mean(yval);
    val(2,1) =  std(yval);
    showline([xval(1) xval(end)],val(1),kleur,2,':');
elseif strcmp(cmd,'pnt')
    yval = yas(p1);
    xval = p2t(p1);
    val = yval;
else
    plen = length(p1);
    xval = zeros(plen,1);
    yval = zeros(plen,1);
    val  = zeros(plen,1);
    for ii = 1:plen
        switch cmd  
            case 'minp',[yval(ii),pres] = min(yas(p1(ii):p2(ii)));
                         xval(ii) = p2t(pres+p1(ii)-1);
                         val(ii) = xval(ii);
            case 'minr',[yval(ii),pres] = min(yas(p1(ii):p2(ii)));
                         xval(ii) = p2t(pres+p1(ii)-1);
                         val(ii) = yval(ii); 
            case 'maxp',[yval(ii),pres] = max(yas(p1(ii):p2(ii)));
                         xval(ii) = p2t(pres+p1(ii)-1);
                         val(ii) = xval(ii);
            case 'maxr',[yval(ii),pres] = max(yas(p1(ii):p2(ii)));
                         xval(ii) = p2t(pres+p1(ii)-1);
                         val(ii) = yval(ii);
            case 'avg',  yval(ii) = mean(yas(p1(ii):p2(ii)));
                         xval(ii) = p2t((p1(ii)+p2(ii))/2);
                         val(ii) = yval(ii);
            case 'std',  yval(ii) = std(yas(p1(ii):p2(ii)));
                         xval(ii) = p2t((p1(ii)+p2(ii))/2);
                         val(ii) = yval(ii);
            case 'med',  yval(ii) = median(yas(p1(ii):p2(ii)));
                         xval(ii) = p2t((p1(ii)+p2(ii))/2); 
                         val(ii) = yval(ii);
            case {'extr','extp'}
                [y1,pr1] = min(yas(p1(ii):p2(ii))); 
                [y2,pr2] = max(yas(p1(ii):p2(ii)));
                 if (abs(y1)>abs(y2))
                     xval(ii) = p2t(pr1+p1(ii)-1);
                     yval(ii) = y1;
                 else
                     xval(ii) = p2t(pr2+p1(ii)-1); 
                     yval(ii) = y2;
                 end
                 if strcmp(cmd,'extr')
                     val(ii) = yval(ii);
                 else
                     val(ii) = xval(ii);
                 end
            otherwise
        end
    end
end
showmarker(xval,yval,kleur,symbol,markersize,2);
val = val(:);

function val = pnt(t1,varargin)
hlp = varargin;
val = fun2(t1,t1,'pnt',hlp);

function val = avg(times,varargin)
hlp = varargin;
[t1,t2,extra] = ParseRange(times,hlp);
val = fun2(t1,t2,'avg',extra);

function val = astd(times,varargin)
hlp = varargin;
[t1,t2,extra] = ParseRange(times,hlp);
val = fun2(t1,t2,'std',extra);

function val = med(times,varargin)
hlp = varargin;
[t1,t2,extra] = ParseRange(times,hlp);
val = fun2(t1,t2,'med',extra);

function val = maxp(times,varargin)
hlp = varargin;
[t1,t2,extra] = ParseRange(times,hlp);
val = fun2(t1 ,t2,'maxp',extra);

function val = maxr(times,varargin)
hlp = varargin;
[t1,t2,extra] = ParseRange(times,hlp);
val = fun2(t1 ,t2,'maxr',extra);

function val = minp(times,varargin)
hlp = varargin;
[t1,t2,extra] = ParseRange(times,hlp);
val = fun2(t1,t2,'minp',extra);

function val = minr(times,varargin)
hlp = varargin;
[t1,t2,extra] = ParseRange(times,hlp);
val = fun2(t1 ,t2,'minr',extra);

function val = extp(times,varargin)
hlp = varargin;
[t1,t2,extra] = ParseRange(times,hlp);
val = fun2(t1 ,t2,'extp',extra);

function val = extr(times,varargin)
hlp = varargin;
[t1,t2,extra] = ParseRange(times,hlp);
val = fun2(t1 ,t2,'extr',extra);

function val = maxmean(times,t3,varargin)
hlp = varargin;
[t1,t2,extra] = ParseRange(times,hlp);
tp  = fun2(t1,t2,'maxp',extra);
val = fun2(tp-t3,tp+t3,'avg',extra);

function val = minmean(times,t3,varargin)
hlp = varargin;
[t1,t2,extra] = ParseRange(times,hlp);
tp  = fun2(t1,t2,'minp',extra);
val = fun2(tp-t3,tp+t3,'avg',extra);

function val = extmean(times,t3,varargin)
hlp = varargin;
[t1,t2,extra] = ParseRange(times,hlp);
tp = fun2(t1,t2,'extp',extra);
val = fun2(tp-t3,tp+t3,'avg',extra);

function val = samples(times,varargin)
global Formula
if Formula.noshow
    xas = Formula.xas;
    yas = Formula.yas;
else
    xas = get(Formula.handle,'XData')';
    yas = get(Formula.handle,'YData')';
end
val = NaN(length(times),1);
for jj = 1:length(times)
    point = find(xas>=times(jj),1);
    val(jj) = yas(point);
end

function FF = akkw(wins,times,varargin)
global graf
hlp = varargin;
FF.amp  = NaN;
FF.fout = NaN;
[t1,t2] = ParseRange(times,hlp);
gbuf = get(graf(graf.window==wins(1)).handle,'UserData');
xas = get(gbuf.handles.trace(1),'XData')';
p1 = find(xas>t1,1,'first');
p2 = find(xas>t2,1,'first');
x  = get(gbuf.handles.trace(1),'YData')';
gbuf = get(graf(graf.window==wins(2)).handle,'UserData');
xas = get(gbuf.handles.trace(1),'XData')';
pa = find(xas>t1,1,'first');
pb = find(xas>t2,1,'first');
y  = get(gbuf.handles.trace(1),'YData')';
if (pb-pa)~=(p2-p1), Error('kkw needs same rsolution'); return; end
FF.amp  = sum(x(p1:p2).*y(p1:p2))/sum(x(p1:p2).*x(p1:p2));
FF.fout = sum(realpow(amp*x(p1:p2)-y(p1:p2),2))/(p2-p1+1);

function FF = Twolines(t0,t1,varargin)
global Formula
FF = struct('x0',NaN,'y0',NaN,'Slope1',NaN,'slope2',NaN,'x1',NaN,'y1',NaN);
if isempty(t0)||isempty(t1), return; end
lbuf = get(Formula.handle,'UserData');
if Formula.noshow
    xas = Formula.xas;
    yas = Formula.yas;
else
    xas = get(Formula.handle,'XData')';
    yas = get(Formula.handle,'YData')';
end
doshow = true; if nargin>2, doshow = varargin{1}; end
p0 = t2p(t0);
t0 = p2t(p0);
p1 = t2p(t1);
if Error, return; end
ytrace1 = yas(p0:p1);
ylen    = length(ytrace1);
xtrace1 = xas(p0:p1)-xas(p0);
errors  = inf(ylen,1);
for iii = 3:ylen-3
    [~,~,r1] = regress(ytrace1(1:iii),[ones(iii,1) xtrace1(1:iii)]);
    [~,~,r2] = regress(ytrace1(iii+1:end),[ones(ylen-iii,1) xtrace1(iii+1:end)]);
    errors(iii,1) = sum(r1.^2)+sum(r2.^2);
end
[~,minpoint] = min(errors);
bb1 = regress(ytrace1(1:minpoint),[ones(minpoint,1) xtrace1(1:minpoint)]);
aa1 = bb1(2);
bb1 = bb1(1);
bb2 = regress(ytrace1(minpoint+1:end),[ones(ylen-minpoint,1) xtrace1(minpoint+1:end)]);
aa2 = bb2(2);
bb2 = bb2(1);
xd = (bb2-bb1)/(aa1-aa2);
yd = aa1*xd+bb1;
x1 = xtrace1(1);
y1 = aa1*x1+bb1;
x2 = xtrace1(end);
y2 = aa2*x2+bb2;
xer = (xtrace1-xd).^2;
yer = (ytrace1-yd).^2;
[~,pmin] = min((xer/sum(xer)) + (yer/sum(yer)));
xd2 = xtrace1(pmin); 
yd2 = ytrace1(pmin);
FF = struct('x0',NaN,'y0',NaN,'Slope1',NaN,'slope2',NaN,'x1',NaN,'y1',NaN);
FF.x0 = t0+xd;
FF.y0 = yd;
FF.x1 = t0+xd2;
FF.y1 = yd2;
FF.slope1 =aa1;
FF.slope2 =aa2;
if ~Formula.noshow
    if isempty(lbuf.twolines)
        lbuf.twolines(1) = line('XData',t0+xd2,'YData',yd2,'Color','b','LineWidth',1,'LineStyle','none','Marker','o','MarkerSize',8);
        if doshow
            lbuf.twolines(2) = line('XData',t0+[x1 xd x2],'YData',[y1 yd y2],'Color','r','LineWidth',1,'LineStyle','--');
            lbuf.twolines(3) = line('XData',t0+xd,        'YData',yd,        'Color','r','LineWidth',1,'LineStyle','none','Marker','o','MarkerSize',6);
        end
        set(Formula.handle,'UserData',lbuf);
    else
        set(lbuf.twolines(1),'XData',t0+xd2,'YData',yd2);
        if doshow
            set(lbuf.twolines(2),'XData',t0+[x1 xd x2],'YData',[y1 yd y2]);
            set(lbuf.twolines(3),'XData',t0+xd,        'YData',yd);
        end
    end
end

function FF = Fourlines(t1,t2,t3,t4)
global Formula
FF = struct('up',NaN,'dwn',NaN,'ratio',NaN,'thresh',NaN);
if (t2<=t1)||(t4<=t3), Error('Range error in Fourlines'); return; end
if Formula.noshow
    xas = Formula.xas;
    yas = Formula.yas;
else
    xas = get(Formula.handle,'XData')';
    yas = get(Formula.handle,'YData')';
end
p1 = t2p(t1);
p2 = t2p(t2);
p3 = t2p(t3);
p4 = t2p(t4);
ytrace  = yas;
xtrace  = (xas(2)-xas(1)) * (0:(length(ytrace)-1))';
ytrace1 = ytrace(p1:p2);
xtrace1 = xtrace(p1:p2);
ylen = length(ytrace1);
errors = zeros(ylen-4,1);
for iii = 3:ylen-2
    yy = detrend(ytrace1,'linear',iii);
    errors(iii-2,1) = sum(yy.^2);
end
[~,minpoint1] = min(errors); 
yy = detrend(ytrace1,'linear',minpoint1+2);
if ~Formula.noshow, line('XData',xtrace1,'YData',ytrace1-yy,'Color','r','LineWidth',2,'LineStyle','--'); end
FF.up     = ((ytrace1(end)-yy(end))-(ytrace1(end-1)-yy(end-1)))/(xas(2)-xas(1));
FF.thresh = ytrace1(minpoint1 + 2) - yy(minpoint1 + 2);
showmarker(p2t(p1 + minpoint1 + 1),val(4),'r','o',10,2);
xtrace1 = xtrace(p3:p4);
ytrace1 = ytrace(p3:p4);
ylen = length(ytrace1);
errors = zeros(ylen-4,1);
for iii = 3:ylen-2, yy = detrend(ytrace1,'linear',iii); errors(iii-2,1) = sum(yy.^2); end
[~,minpoint2] = min(errors);
yy = detrend(ytrace1,'linear',minpoint2+2);
if ~Formula.noshow, line('XData',xtrace1,'YData',ytrace1-yy,'Color','r','LineWidth',2,'LineStyle','--'); end
FF.dwn = ((ytrace1(2)-yy(2))-(ytrace1(1)-yy(1)))/(xas(2)-xas(1));
FF.ratio = -FF.dwn/FF.up;

function FF = templateresult
global spikes panels
cnt = counter;
if isempty(spikes.err)||((cnt<1)||(cnt>length(spikes.err)))
    Error('Run template fit before templateresult ');
    FF.temp_time   = NaN;
    FF.temp_amp    = NaN;
    FF.temp_offset = NaN;
    FF.temp_gain   = NaN;
    FF.temp_factor = NaN;
    FF.temp_error  = NaN;
else
    FF.temp_time   = spikes.spktmax(cnt)*panels.timegain/spikes.adcrate;
    FF.temp_amp    = spikes.spkmax(cnt);
    FF.temp_offset = spikes.off(cnt);
    FF.temp_gain   = spikes.gain(cnt);
    FF.temp_factor = spikes.fact(cnt);
    FF.temp_error  = spikes.err(cnt);
end

function val = train(cmd,varargin)
global Formula
if nargin>1, kleur = varargin{1}; else,kleur = []; end
if Formula.noshow
    yas = Formula.yas;
else
    yas = get(Formula.handle,'YData')';
end
len = length(Formula.trgs)-1;
xval = zeros(len,1);
yval = zeros(len,1);
for ii = 1:len
    p1 = round(Formula.trgs(ii));
    p2 = round(Formula.trgs(ii+1));
    if     strcmp(cmd,'min')
        [val,pres] = min(yas(p1:p2));
    elseif strcmp(cmd,'max')
        [val,pres] = max(yas(p1:p2));
    else
        Error('Unknown train cmd'); return
    end
    xval(ii) = p2t(pres+p1-1);
    yval(ii) = val;
end
val(1,1) = mean(yval);
val(2,1) = std(yval);
if ~isempty(kleur)
    showline([xval(1) xval(end)],val(1),kleur,1,':');
    showmarker(xval,yval,kleur,'o',8,2);
end

function val = getfreq(splitfreq,gap) 
global Formula
if Formula.noshow
    xas = Formula.xas;
    yas = Formula.yas;
else
    xas = get(Formula.handle,'XData')';
    yas = get(Formula.handle,'YData')';
end
val = [];
pp = DecomposeDAC(xas,yas,1,0,gap,splitfreq,0); 
ii = 1;      val(ii,1) = pp.offset;
ii = ii + 1; val(ii,1) = pp.peak1;
ii = ii + 1; val(ii,1) = pp.amp1;
ii = ii + 1; val(ii,1) = pp.amp2;
if splitfreq>0
    ii = ii + 1; val(ii,1) = pp.peak2;
    ii = ii + 1; val(ii,1) = pp.amp3;
    ii = ii + 1; val(ii,1) = pp.amp4;
end
if gap>0
    ii = ii + 1; val(ii,1) = pp.phase;
end

function [singles,bursts] = splits(units,interval)
singles   = [];
bursts    = [];
if isempty(units), return; end
burston   = false;
lastevent = units(1);
for ii = 2:length(units)
    if (units(ii)-lastevent)>interval
        if burston
            bursts(end+1,1) = lastevent;
        else
            singles(end+1,1) = lastevent;
        end
        lastevent = units(ii);
        burston = false;
    else
        burston = true;
    end
end
if burston
    bursts(end+1,1) = lastevent;
else
    singles(end+1,1) = units(end);
end

function val = getsinwaves
global Formula
if Formula.noshow
    yas = Formula.yas;
else
    yas = get(Formula.handle,'YData')';
end
vals = Crossings(yas,[mean(yas) inf],'interpol');
period = round(mean(diff(vals))/16);
if (vals(end)+period)>length(yas), vals(end)=[]; end
Formula.trgs = vals;
val = length(vals);

function val = getpeaks(drempel,gap,t1,t2)
global Formula
if Formula.noshow
    xas = Formula.xas;
    yas = Formula.yas;
else
    xas = get(Formula.handle,'XData')';
    yas = get(Formula.handle,'YData')';
end
p1 = 1;
p2 = length(yas);
trgs = Crossings(yas(p1:p2),drempel(1))+p1-1;
showline([p2t(p1) p2t(p2)],drempel,'r',1,':')
if isempty(trgs)
    p1 = t2p(t1);
    p2 = t2p(t2);
    val = mean(yas(p1:p2));
    showline([p2t(p1) p2t(p2)],val,'m',1,':')
else
    showmarker(xaspoint(trgs(1:2:end)),yas(trgs(1:2:end)),'r','o',8,2);
    showmarker(xaspoint(trgs(2:2:end)),yas(trgs(2:2:end)),'b','o',8,2);
    if length(trgs)==2
        [yval,maxpoint] = max(yas(trgs(1):trgs(2)));
        showmarker(p2t(trgs(1)+maxpoint-1),yval,'m','o',10,3);
        [yval,minpoint] = min(yas((trgs(1)+maxpoint-1):(trgs(1)+maxpoint-1+t2p(gap))));
        showmarker(p2t(trgs(1)+minpoint-1),yval,'g','o',10,3);
        val = yval;
        showline([p2t(trgs(1)+maxpoint-1)  p2t(trgs(1)+maxpoint-1+t2p(gap))],val,'m',1,':')
    else
        spmax = [];
        spmin = [];
        for number=1:2:length(trgs)
            [yval,point] = max(yas(trgs(number):trgs(number+1)));
            showmarker(p2t(trgs(number)+point-1),yval,'m','o',10,3);
            spmax(end+1) = yval;
            if number<(length(trgs)-1)
                [yval,point] = min(yas(trgs(number+1):trgs(number+2)));
                showmarker(p2t(trgs(number+1)+point-1),yval,'g','o',10,3);
                spmin(end+1) = yval;
            end
        end
        val = mean(spmin);
        showline([p2t(trgs(1)) p2t(trgs(end))],val,'g',1,':')
    end
end
drawnow;

function val = getpeak(type,number,drempel)
global Formula
if Formula.noshow
    yas = Formula.yas;
else
    yas = get(Formula.handle,'YData')';
end
p1 = 1;
p2 = length(yas);
trgs = p1-1+Crossings(yas(p1:p2),drempel(1));
showline([p2t(p1) p2t(p2)],drempel,'r',1,':')
if length(trgs)<(2*number)
    val = [];
    return
else
    showmarker(xaspoint(trgs(1:2:end)),yas(trgs(1:2:end)),'r','o',8,2);
    showmarker(xaspoint(trgs(2:2:end)),yas(trgs(2:2:end)),'b','o',8,2);
    [yval,point] = max(yas(trgs(2*number-1):trgs(2*number)));
    showmarker(p2t(trgs(2*number-1)+point-1),yval,'m','o',10,3);
end
if strcmp(type,'amp')
    val = yval;
else
    val = p2t(trgs(2*number-1)+point-1);
end
drawnow;

function val = peakamp(level,number)
val = getpeak('amp',number,level);

function val = peaktime(level,number)
val = getpeak('time',number,level);

function xval = trigger(lvl,varargin)
global Formula
if Formula.noshow
    xas = Formula.xas;
    yas = Formula.yas;
else
    xas = get(Formula.handle,'XData')';
    yas = get(Formula.handle,'YData')';
end
[sxmin,sxmax,symin,symax] = getscales;
if length(lvl)==1, lvl(2) = inf; end
xval    = NaN;
cmd     = 'onzin';
leegval = NaN;
t3      = 0;
parms = varargin;
[parms,present,ps] = ParseSpecial(parms,'range');
if present, range = rsingle(ps{1}); else,range = [xas(1) xas(end)]; end
[parms,present,ps] = ParseSpecial(parms,'empty'); if present, leegval = rsingle(ps{1}); end
[parms,present,ps] = ParseSpecial(parms,'skip');  if present, t3 = rsingle(ps{1}); end
[parms,present,ps] = ParseSpecial(parms,'select');
if present
    cmd = 'select';
    nr = rsingle(ps{1});
else
    [parms,present] = ParseSpecial(parms,'#waves');  if present, cmd = '#waves'; end
    [parms,present] = ParseSpecial(parms,'#spikes'); if present, cmd = '#spikes'; end
    [parms,present] = ParseSpecial(parms,'#bursts'); if present, cmd = '#bursts'; end
    [parms,present] = ParseSpecial(parms,'phases');  if present, cmd = 'phases'; end
    [parms,present] = ParseSpecial(parms,'avgphase');  if present, cmd = 'avgphase'; end
    [~,present,ps]  = ParseSpecial(parms,'dap');
    if present
        cmd = 'dap';
        duur    = rsingle(ps{1});
        dapmode = ssingle(ps{2});
    end
end
trgs = t2p(range(1))-1+Crossings(yas(t2p(range(1)):t2p(range(2))),lvl,'interpol');
if isempty(trgs)
    xval = leegval;
    if ~isnan(xval), showline(xaspoint(xval),[symin symax],'r',3,'--'); end
else
    switch cmd
        case 'select'
            if nr<0, nr = length(trgs)+1+nr; end
            xval = xaspoint(round(trgs(nr)));
            showmarker(xval,yas(round(trgs(nr))),'r','o',8,2);
        case '#waves'
            trgs = round(trgs);
            if (trgs(end)+round(mean(diff(trgs))/16))>length(yas), trgs(end)=[]; end
            showmarker(xaspoint(trgs),yas(trgs),'b','o',6,2);
            xval = length(trgs);
        case '#spikes'
            trgs = round(trgs((trgs>=Formula.trgs(1)) & (trgs<=Formula.trgs(end))));
            singles = splits(trgs,t2p(t3)-1);
            line([sxmin sxmax],[lvl(1) lvl(1)],'Color','r','Linestyle','--')
            showmarker(xaspoint(trgs),   yas(trgs),   'b','o',5,2);
            showmarker(xaspoint(singles),yas(singles),'r','o',12,3);
            xval = length(singles);
        case '#bursts'
            trgs = round(trgs((trgs>=Formula.trgs(1)) & (trgs<=Formula.trgs(end))));
            [~,bursts] = splits(trgs,t2p(t3)-1);
            line([sxmin sxmax],[lvl(1) lvl(1)],'Color','r','Linestyle','--')
            showmarker(xaspoint(trgs),  yas(trgs),'b','o',5,2);
            showmarker(xaspoint(bursts),yas(bursts),'c','o',12,3);
            xval = length(bursts);
        case 'phases'
            trgs = round(trgs((trgs>=Formula.trgs(1)) & (trgs<=Formula.trgs(end))));
            [singles,bursts] = splits(trgs,t2p(t3)-1);
            showmarker(xaspoint(singles),yas(singles),'r','o',12,3);
            showmarker(xaspoint(bursts),yas(bursts),'c','o',12,3);
            showlines(xaspoint(Formula.trgs),xaspoint(Formula.trgs),symin,symax,'m',1,':');
            period = p2t(mean(diff(Formula.trgs)));
            for ii = 1:length(singles)
                die = find(Formula.trgs<singles(ii));
                if ~isempty(die)
                    xval(die(end)) = 360 * p2t(singles(ii)-Formula.trgs(die(end)))/period;
                end
            end
            for ii = 1:length(bursts)
                die = find(Formula.trgs<bursts(ii));
                if ~isempty(die)
                    xval(die(end)) = -360 * p2t(bursts(ii)-Formula.trgs(die(end)))/period;
                end
            end
        case 'avgphase'
            Formula.trgs = round(Formula.trgs);
            trgs         = round(trgs);
            period = p2t(mean(diff(Formula.trgs)));
            showmarker(xaspoint(Formula.trgs),Formula.adcy(Formula.trgs)* 0,'m','o',6,2);
            showlines(xaspoint(Formula.trgs),xaspoint(Formula.trgs),symin,symax,'m',1,':');
            showmarker(xaspoint(trgs),yas(trgs),'r','o',8,2);
            xval = [];
            for ii = 1:length(trgs)
                die = find(Formula.trgs<trgs(ii));
                if ~isempty(die)
                    xval(die(end)) = p2t(trgs(ii)-Formula.trgs(die(end)));
                end
            end
            xval = 360 * mean(xval)/period;
        case 'dap'
            trgs = round(trgs((trgs>=Formula.trgs(1)) & (trgs<=Formula.trgs(end))));
            [singles,bursts] = splits(trgs,t2p(t3)-1);
            points = [];
            vmin   = NaN;
            vmax   = NaN;
            for ii = 1:length(singles)
                die = find(Formula.trgs<singles(ii));
                die = die(end);
                px = singles(ii);
                [vmin1,pmin] = min(yas(px:(px+t2p(duur(1))-1)));
                pmin = pmin - 1;
                showmarker(xaspoint(px+pmin),yas(px+pmin),'c','o',8,2);
                [vmax1,pmax] = max(yas((px+pmin):(px+pmin+t2p(duur(2))-1)));
                pmax = pmax - 1;
                showmarker(xaspoint(px + pmin + pmax),yas(px + pmin + pmax),'r','o',8,2);
                xval(die)  = vmax1 - vmin1;
                vmin(die)  = vmin1;
                vmax(die)  = vmax1;
                points(ii) = pmin + pmax;
            end
            if ~isempty(points)
                points = round(mean(points));
                for ii = 1:length(bursts)
                    die = find(Formula.trgs<bursts(ii));
                    die = die(end);
                    px = bursts(ii);
                    [vmin2,pmin] = min(yas(px:(px+t2p(duur(1))-1)));
                    pmin = pmin - 1;
                    showmarker(xaspoint(px+pmin),yas(px+pmin),'c','o',8,2);
                    vmax2 = yas(px + points);
                    showmarker(xaspoint(px + pmin + pmax),yas(px + pmin + pmax),'r','o',8,2);
                    xval(die) = vmax2 - vmin2;
                    vmin(die) = vmin2;
                    vmax(die) = vmax2;
                end
            end
            switch dapmode
                case 'all'
                case 'amin', xval = vmin;
                case 'amax', xval = vmax;
                otherwise
                    Error('unknown dapmode'); return;
            end
        otherwise
            Error('trigger cmd unknown');
    end
end
%
% --- Field potential analysis
%
function F = fEPSP(ins) 
global panels Formula
parms = ins(4:end);
hlp = startsWith(parms,"p."); for jj = find(hlp)', parms{jj} = ssingle(parms{jj}); end
if Error, return; end
Nspk   = 1;
maxdgr = 10;
[parms,domulti,ps] = ParseSpecial(parms,'multi');
if domulti
    dopos = true;
    doneg = false;
    Nspk = nsingle(ps{1});
    if length(ps)>1, maxdgr = nsingle(ps{2}); end
else
    [parms,dopos] = ParseSpecial(parms,'pos');
    [parms,doneg] = ParseSpecial(parms,'neg');
end
F = struct('EPbgn',NaN,'EPt2p',NaN,'EPamp',0,'EPs2p',NaN,'EPslp',NaN,'EPsr2',NaN,'EPcli',NaN);
for jj = 1:Nspk
    F.(sprintf('PS%utim',jj)) = NaN;
    F.(sprintf('PS%uamp',jj)) = 0;
    F.(sprintf('PS%uwid',jj)) = NaN;
    F.(sprintf('PS%usrf',jj)) = 0;
end
if ins{1}==0, return; end
t0 = ins{2};
tt = ins{3};
if length(tt)~=2, Error("par 3 in EPSP needs start and end time"); return; end
doshow = ~Formula.noshow;
if Formula.noshow 
    xas = Formula.xas;
    yas = Formula.yas;
else
    xas = get(Formula.handle,'XData')';
    yas = get(Formula.handle,'YData')';
end
dt = (xas(2)-xas(1))/panels.timegain;
if (tt(2)<tt(1)), Error('t1, t2 need to be in ascending order and positive'); return; end
% p0 = t2p(lin(t0,      'g',1), 'stim time'); if Error, return; end
p1 = t2p(lin(t0+tt(1),'r',1),'start time'); if Error, return; end
p2 = t2p(lin(t0+tt(2),'r',1),  'end time'); if Error, return; end
[parms,minep] = ParseOne(parms,'minep',0.1);
minps  = 0.1;
pwid   = round(0.5/dt);
dpeak  = round(1.5/dt);
pdiff  = round(0.5/dt);
pslope = round(0.25/dt);
[parms,present,ps] = ParseSpecial(parms,'minps');
if present
    minps = rsingle(ps{1});
    if length(ps)>1, pwid = round(rsingle(ps{2})/dt); end
end
[parms,present,ps] = ParseSpecial(parms,'times');
if present
    dpeak = round(rsingle(ps{1})/dt);
    if length(ps)>1, pdiff  = round(rsingle(ps{2})/dt); end
    if length(ps)>2, pslope = round(rsingle(ps{3})/dt); end
end
phalf = round(pdiff/2); 
pdiff = 2*phalf+1;
ydf  = zeros(size(yas));
ydf((pdiff:end)-phalf+1) = (yas(pdiff:end)-yas(1:(end-pdiff+1)))/(pdiff*dt);
xas = xas(p1:p2);
yas = yas(p1:p2);
ydf = ydf(p1:p2);
ylen = length(yas);
if ~dopos && ~doneg
    yhlp = yas(1:round(ylen/2));
    dopos = sum(yhlp(yhlp>0).^2) > sum(yhlp(yhlp<0).^2);
end
if doneg
    [ampval,peakpnt] = min(yas);
    ampval = min(0,ampval);
else
    [ampval,peakpnt] = max(yas);
    ampval = max(0,ampval);
end
showlines(xas(1),xas(end),minep*sign(ampval),minep*sign(ampval),'b',0.5,'--');
if (abs(ampval)<minep) || (peakpnt<pwid) || (peakpnt>ylen-pwid), return; end
F.EPamp = abs(ampval);
F.EPt2p = xas(peakpnt)-t0;
F.EPs2p = F.EPamp/F.EPt2p;
line('XData',xas,'YData',ydf,'Color','m','LineWidth',0.5);
if doneg
    showmarker(xas(peakpnt),ampval,'b','o',10,1);
    [~,pmid] = min(ydf(1:peakpnt));
    showmarker(xas(pmid),yas(pmid),'c','s',6,2);
else
    showmarker(xas(peakpnt),ampval,'r','o',10,1);
    F.EPcli = sum(abs(diff(yas)))/(ylen*dt);
    ptop = find(islocalmax(yas,'MinSeparation',dpeak,'MinProminence',minps));
%     prom = prom(ptop);
%     ptop = find(ptop);
    if isempty(ptop), ptop = peakpnt; end
    [~,pmid] = max(ydf(1:ptop(1)));
    if length(ptop)>1
        pbot = zeros(length(ptop)-1,1);
        adif = zeros(length(ptop)-1,1);
        for jj = 1:length(ptop)-1
            p1 = ptop(jj);
            p2 = ptop(jj+1);
            ygrens = yas(p1) + (yas(p2)-yas(p1))*(0:(p2-p1))/(p2-p1);
            [adif(jj),p3] = max(ygrens'-yas(p1:p2));
            pbot(jj) = p3+p1-1;
        end
        showmarker(xas(ptop), yas(ptop),'r','s',6,1);
        showmarker(xas(pbot), yas(pbot),'b','s',6,1);
        [~,index] = max(adif);
        pspike = pbot(index); 
        pmax1  = ptop(index);
        pmax2  = ptop(index+1);
        if domulti
            if maxdgr<2
                yhlp = yas(ptop(1):ptop(end));
                for jj = 1:length(ptop)-1
                    pp1 = ptop(jj)-ptop(1)+1;
                    pp2 = ptop(jj+1)-ptop(1);
                    yhlp(pp1:pp2) = yhlp(pp1)+(0:pp2-pp1)*(yhlp(pp2)-yhlp(pp1))/(pp2-pp1);
                end
                line(xas(ptop(1):ptop(end)),yhlp,'Color','r');
                verschil = yas(ptop(1):ptop(end))-yhlp;
                pp1 = ptop(1)-pwid;
            else
                pp1 = ptop(1)-pwid;
                pp2 = ptop(end)+pwid;
                xhlp = xas(pp1:pp2);
                yhlp = yas(pp1:pp2);
                bx = xhlp(1); ax = xhlp(end)-bx;
                by = yhlp(1); ay = yhlp(end)-by;
                xhlp = (xhlp-bx)/ax;
                yhlp = (yhlp-by)/ay;
                rand = 2;
                mask = false(length(xhlp),1); 
                mask(1:pwid+rand)       = true;
                mask(end-pwid-rand:end) = true;
                for jj = 2:length(ptop)-1, mask(ptop(jj)-pp1+1+[-rand:rand]) = true; end
                fitres = polyfit(xhlp(mask),yhlp(mask),min(3+length(ptop),maxdgr));
                yres   = polyval(fitres,xhlp);
                xxx = xhlp;
                xxx(~mask) = NaN;
                line(bx+ax*xxx, by+ay*yhlp,'Color','c', 'LineWidth',2);
                line(bx+ax*xhlp,by+ay*yres,'Color','r');
                verschil = ay*(yhlp-yres);
                verschil = verschil(pwid:end-pwid);
            end
            verschil(verschil>0) = 0;
            for jj = 1:length(ptop)-1
                pa = ptop(jj)-ptop(1)+1;
                pb = ptop(jj+1)-ptop(1)+1;
                [amin,pmin] = min(verschil(pa:pb));
                range = verschil(pa:pb)<=0.5*amin;
                pc = pa+find(range,1);
                pd = pa+find(range,1,'last');
                F.(sprintf('PS%uamp',jj)) = abs(amin);
                F.(sprintf('PS%utim',jj)) = xas(pmin+pp1+pa-2);
                F.(sprintf('PS%uwid',jj)) = dt*sum(verschil(pa:pb)<=(0.5*amin));
                F.(sprintf('PS%usrf',jj)) = dt*abs(sum(verschil(pa:pb)));
                patch(xas(pp1+pwid+[pa:pb,pa]),verschil([pa:pb,pa]),spkcolor(jj),'EdgeColor','k','LineStyle','-');
                line(xas(pp1+pwid+pa+pmin-1)*[1,1],[0,verschil(pmin+pa-1)],'Color','r','LineStyle',':','LineWidth',1);
                line(xas(pp1+pwid+[pc,pd]-1),-abs(amin)*0.5*[1,1],'Color','r','LineStyle',':','LineWidth',1);
            end
        elseif dopos
            cnt = 0;
            plim1 = max(pmax1-pwid,1);
            plim2 = min(pmax2+pwid,length(yas));
            while true
                aa = (yas(pmax2)-yas(pmax1))/(xas(pmax2)-xas(pmax1));
                bb =  yas(pmax1) - aa*xas(pmax1);
                lijn = bb + aa*xas;
                verschil = yas - lijn;
                [amp,index] = min(verschil(pmax1:pmax2));
                pspike    = pmax1-1+index;
                [~,index] = max(verschil(plim1:pspike));
                pnew1     = plim1-1+index;
                [~,index] = max(verschil(pspike:plim2));
                pnew2     = pspike-1+index;
                if ((pnew1==pmax1) && (pnew2==pmax2)) || (cnt>5), break; end
                pmax1 = pnew1;
                pmax2 = pnew2;
                cnt = cnt + 1;
            end
            range    = verschil(pmax1:pmax2)<=0.5*amp;
            F.PS1amp = abs(amp);
            F.PS1tim = xas(pspike)-t0;
            F.PS1srf = abs(sum(verschil))*dt;
            F.PS1wid = dt*sum(range);
            if doshow
                showmarker(xas(pspike),yas(pspike),'b','o',10,2);
                line(xas([1,end]),lijn([1,end]),'Color','k','LineWidth',0.5,'LineStyle','-');
                patch(xas([pmax1:pmax2,pmax1]),yas([pmax1:pmax2,pmax1]),[0.8 0.95 0.95],'EdgeColor','k','LineStyle','-');
                line('XData',[xas([pmax1,pmax2])',NaN,xas(pspike),xas(pspike)],...
                     'YData',[yas([pmax1,pmax2])',NaN,lijn(pspike),yas(pspike)],...
                     'Color','b', 'Linestyle',':', 'Linewidth',1.5);
                pa = pmax1-1+find(range,1);
                pb = pmax1-1+find(range,1,'last');
                showlines(xas(pa),xas(pb),yas(pa),yas(pb),'r',1.5,':');
            end
        end
    end
end
if ~isempty(pmid) && (pmid>pslope)
    p1 = pmid-pslope;
    p2 = pmid+pslope;
    [bbb,~,~,~,stats] = regress(yas(p1:p2),[ones(length(xas(p1:p2)),1) xas(p1:p2)]);
    F.EPslp = bbb(2);
    F.EPsr2 = stats(1);
    F.EPbgn = -bbb(1)/bbb(2)-t0;
    showmarker(xas([p1,p2]),yas([p1,p2]),'c','o',6,1.5);
    showlines(xas(1),xas(peakpnt)+2,bbb(1)+bbb(2)*xas(1),bbb(1)+bbb(2)*(xas(peakpnt)+2),'c',1,':')
end
if doshow, correctorder(gca); end
%
% ====== filtering ========================================================
%
function yas = FilterTrace(yas,filters,rate,varargin)
global panels
if nargin>3, xas  = varargin{1}; dt = xas(2)-xas(1); else, xas  = []; end
if nargin>4, gain = varargin{2}; else, gain = []; end
for jj = 1:length(filters)
    mid = -5;
    [cmd,parms]        = ParseCmd(filters{jj});
    [parms,present,ps] = ParseSpecial(parms,'orde');  if present, orde  = nsingle(ps{1}); else, orde = 1; end
    [parms,present,ps] = ParseSpecial(parms,'width'); if present, width = rsingle(ps{1})*rate/1000; end
    [parms,present,ps] = ParseSpecial(parms,'freq');  if present, freq1 = rsingle(ps{1}); if length(ps)>1, freq2 = rsingle(ps{2}); end; end
    [parms,donul]      = ParseSpecial(parms,'nul');
    [parms,dointer,ps] = ParseSpecial(parms,'inter'); if dointer && ~isempty(ps), mid = rsingle(ps{1}); end
    [parms,dokeep, ps] = ParseSpecial(parms,'keep');  if dokeep  && ~isempty(ps), mid = rsingle(ps{1}); end
    [parms,dolimit,ps] = ParseSpecial(parms,'limit'); if dolimit, maxmin = rsingle(ps{1})/gain; end
    parm1 = [];
    parm2 = [];
    if ~isempty(parms)
        parm1 = rsingle(parms{1});
        nparm = round(parm1);
        nlen2 = floor(round(parm1*rate/1000)/2); npnts = 2*nlen2+1;
        if length(parms)>1, parm2 = rsingle(parms{2}); end
    end
    switch cmd
        case {'zero';'Zero'}
        case 'offset',  yas = yas - mean(yas);
     
        case 'abs',     yas = abs(yas);
        case 'art',     if isempty(parm2), Error('art needs startpoint(s) & range'); return; end
                        if length(parm2)==1, parm2 = [0 parm2]; end
                        for ii = 1:length(parm1)
                            pnts = find((xas>=(parm1(ii)+parm2(1)) & (xas<=(parm1(ii)+parm2(2)))));
                            if isempty(pnts), continue; else
                                bgn = pnts(1); 
                                lst = pnts(end);
                            end
                            if ~donul && ~dokeep, dointer = true; end
                            if donul
                                yas(pnts) = 0;
                            else
                                if mid<0, hhh = abs(mid); else,hhh = round(mid/(dt*panels.timegain)); end
                                if ((bgn-hhh)<1) || ((lst+hhh)>length(yas)), continue; end
                                val0 = mean(yas((bgn-hhh):(bgn-1)));
                                val1 = mean(yas((lst+1):(lst+hhh)));
                                if dolimit
                                    upper = 0.5*(val0+val1) + maxmin; yas(pnts(yas(pnts)>upper)) = upper;
                                    lower = 0.5*(val0+val1) - maxmin; yas(pnts(yas(pnts)<lower)) = lower;
                                elseif dointer
                                    yas(pnts) = val0 + (pnts-pnts(1)) * (val1-val0)/length(pnts);
                                end
                            end
                        end
        case 'add',     yas = yas + rsingle(parms{1})/gain;
        case 'detrend', yas = detrend(yas);
        case 'sqr',     yas = (yas.^2)/max(yas);
        case 'limit',   if isempty(parm2), yas(yas>parm1)=parm1; else,yas(yas<parm1)=parm1; yas(yas>parm2)=parm2; end
        case 'tdiff',   yas = [0*yas(1:nlen2); (yas(npnts:end)-yas(1:(end-npnts+1))); 0*yas((end-nlen2+1):end)];
        case 'tdiff2',  yas = [0*yas(1:nlen2); (yas(npnts:end)-yas(1:(end-npnts+1))); 0*yas((end-nlen2+1):end)];
                        yas = [0*yas(1:nlen2); (yas(npnts:end)-yas(1:(end-npnts+1))); 0*yas((end-nlen2+1):end)];
        case 'submean', off = mean(yas); for keer = 1:nparm, off = mean(yas(yas<off)); end; yas = yas - off;
        case 'cli',     yas = cumsum([0; abs(diff(yas))]); yas = [0*yas(1:nlen2); (yas(npnts:end)-yas(1:(end-npnts+1)))/npnts; 0*yas((end-nlen2+1):end)];
        case 'mavg',    yas = cumsum(yas); yas = [0*yas(1:nlen2); (yas(npnts:end)-yas(1:(end-npnts+1)))/npnts; 0*yas((end-nlen2+1):end)];
        case 'mpass',   yas = medfilt1(yas,nparm);
        case 'mstop',   yas = yas - medfilt1(yas,nparm);
        case 'apass',   tmp = ones(npnts,1); yas = conv(yas,tmp/sum(tmp),'same');
        case 'astop',   tmp = ones(npnts,1); yas = yas - conv(yas,tmp/sum(tmp),'same');
        case 'fft',     df = rate/length(yas); 
                        centers = ceil(freq1/df);
                        width = ceil(0.5*width/df);
                        hoog  = 0*ceil(freq2/df);
                        if width>0
                            off = mean(yas);
                            yas = fft(yas-off);
                            for kk = centers
                                yas((kk-width):(kk+width)) = 0;
                                yas(end -((kk-width):(kk+width))) = 0;
                            end
                            if hoog>0, yas(hoog:(end-hoog)) = 0; end
                            yas = off + real(ifft(yas));
                        end
        otherwise
            if strcmp(cmd,'bstop') || strcmp(cmd,'bpass')
                if freq2>freq1
                    FF1 = 2*freq1/rate;
                    FF2 = 2*freq2/rate;
                else
                    FF1 = 2*(freq1-0.5*freq2)/rate;
                    FF2 = 2*(freq1+0.5*freq2)/rate;
                end
            else
                try
                    FF1 = 2*freq1/rate;
                catch
                    disp(['error in filtring with  ' cmd]);
                end
            end
            if (FF1>0.000005)&&(FF1<0.9995)
                    switch cmd
                        case 'hpass', [facB,facA] = butter(orde, FF1,'high');
                        case 'lpass', [facB,facA] = butter(orde, FF1,'low');
                        case 'bpass', [facB,facA] = butter(orde,[FF1 FF2],'bandpass');
                        case 'bstop', [facB,facA] = butter(orde,[FF1 FF2],'stop');
                        otherwise, facA = [];
                    end
                if ~isempty(facA), yas = filtfilt(facB,facA,yas); end
            end
    end
end

function DoFilter(parms)
global Meting
[parms,sets,mets,swps]  = ParseList(parms);
[parms,present,ps] = ParseSpecial(parms,'extract');
if present
    dt = 1000/Meting(1).ADC.rate;
    [ps,dosec] = ParseSpecial(ps,'sec'); if dosec, dt = dt/1000; end
    bgn = 1+round(rsingle(ps{1})/dt);
    lst = min(size(Meting(1).adc,1),round(rsingle(ps{2})/dt));
    for jj = unique(mets)
        Meting(jj).adc = Meting(jj).adc(bgn:lst,:,:);
    end
end
setmaxpars(Meting(1),'adc');
[parms,present,ps] = ParseSpecial(parms,'in');  if present, chnin  = nsingle(ps{1}); else,chnin  = 1; end
[parms,present,ps] = ParseSpecial(parms,'out'); if present, chnout = nsingle(ps{1}); else,chnout = chnin; end
if length(chnout)~=length(chnin), Error('nr in and out channels must be the same'); return; end
[~,filter] = ParseFilter(parms);
if Error || isempty(filter), return; end
nmax = length(mets)*length(chnin);
cnt = 0;
for mm = 1:length(mets)
    metnr = mets(mm);
    swpnr = swps(mm);
    if isempty(Meting(metnr).adc), continue; end
    adcrate = Meting(metnr).ADC.rate;
    for jj = 1:length(chnin)
        kanin  = chnin(jj);
        kanout = chnout(jj);
        scale = Meting(metnr).ADC.scale(kanin).User/Meting(metnr).ADC.ints;
        yas = FilterTrace(scale * double(Meting(metnr).adc(:,kanin,swpnr)),filter,adcrate);
        Meting(metnr).adc(:,kanout,swpnr) = int16(round(yas/scale));
        Meting(metnr).ADC.scale(kanout)   = Meting(metnr).ADC.scale(kanin);
        cnt = cnt + 1;
        Waitbar(CMD,'show',cnt/nmax,sprintf('filter: met %u swp %u chan %u',metnr,swpnr,kanin));
    end
end
Waitbar(CMD,'hide');

function [out,filters] = ParseFilter(parms)
out = [];
filters = [];
if ~isempty(parms)
    filtercmds = {'art';'abs';'sqr';'offset';'zero';'Zero';'limit';'mpass';'mstop';'mavg';'cli';'add';...
                  'tdiff';'tdiff2';'detrend';'submean';'lpass';'hpass';'bpass';'bstop';'apass';'astop';'fft'};
    doetmee = true(length(parms),1);
    for jj = 1:length(parms)
        [cmd,~] = ParseCmd(parms{jj});
        if find(strcmp(cmd,filtercmds),1)
            filters{end+1,1} = parms{jj};
            doetmee(jj) = false;
        end
    end
    out = parms(doetmee);
end
%
% ====== Moving around in zoom mode =======================================
%
function showdaqpars
global panels
CMD = getPANEL('CMDpanel');
duur    = panels.zoom.tlst - panels.zoom.tbgn;
maxduur = panels.zoom.tend-panels.zoom.tnul;
if duur<0
    duur = maxduur;
    panels.zoom.tbgn = panels.zoom.tnul;
    panels.zoom.tlst = panels.zoom.tbgn + maxduur;
end
if panels.zoom.rate>=1000, rate = sprintf('%0.1f kHz',panels.zoom.rate/1000); else,rate = sprintf('%0.0f Hz',panels.zoom.rate); end
set(CMD.zoomstart,'String', sprintf(panels.timefrmt, panels.zoom.tbgn / panels.timegain));
set(CMD.zoomeind, 'String', sprintf(panels.timefrmt, panels.zoom.tlst / panels.timegain));
set(CMD.zoomduur, 'String', sprintf(panels.timefrmt, duur / panels.timegain));
set(CMD.punten,   'String', sprintf('%u pnts', 1+round(duur * panels.zoom.rate / 1000)));
set(CMD.adctime,  'String', sprintf([panels.timefrmt ' ' panels.timetxt], maxduur/panels.timegain));
set(CMD.adcpnts,  'String', sprintf('%u pnts',panels.zoom.pnts));
set(CMD.adcrate,  'String', rate);
if duur>=maxduur
    set(CMD.zoomslider,'Value',0,'SliderStep',[0 inf],'BackgroundColor',[1 0 0]);
else
    fraction  = duur/(maxduur-duur);
    sliderval = (panels.zoom.tbgn-panels.zoom.tnul)/(maxduur-duur);
    step2 = max(0.00001, min(1,fraction));
    step1 = min(step2, 0.25*fraction);
    set(CMD.zoomslider,'Value',max(0,min(1,sliderval)),'SliderStep',[step1 step2],'BackgroundColor',[1 0 0]);
end
drawnow();

function setmaxpars(Mets,varargin)
global panels
mode   = [];
dofull = false;
if nargin>1
    mode = varargin{1};
    if strcmp(mode,'full')
        dofull = true;
        mode = [];
    else
        doadc = contains(mode,'adc') || contains(mode,'swp') || contains(mode,'avg');
        dodac = contains(mode,'dac');
    end
end
if isempty(mode)
    doadc = ~isempty(Mets.adc);
    dodac = ~isempty(Mets.dac) || ~isempty(Mets.cdac);
end
if doadc
    panels.zoom.pnts = size(Mets.adc,1);
    panels.zoom.rate = Mets.ADC.rate;
elseif dodac
    Mets = DACexpand(Mets);
    panels.zoom.pnts = size(Mets.dac,1);
    panels.zoom.rate = Mets.DAC.rate;
else
    return
end
if isempty(panels.zoom.pnts), return; end
if isempty(Mets.SEGMENT.start)
    panels.zoom.tnul = 0;
    panels.zoom.tend = (panels.zoom.pnts-1) * 1000 / panels.zoom.rate;
else
    offset = panels.zoom.tbgn - panels.zoom.tnul;
    duur   = panels.zoom.tlst - panels.zoom.tnul;
    panels.zoom.tnul = Mets.SEGMENT.start(panels.segnr) * 1000;
    panels.zoom.tend = panels.zoom.tnul + (panels.zoom.pnts-1) * 1000 / panels.zoom.rate;
    panels.zoom.tlst = min(panels.zoom.tend,panels.zoom.tnul + duur);
    if offset>(panels.zoom.tend-panels.zoom.tnul)
        panels.zoom.tbgn = panels.zoom.tnul;
    else
        panels.zoom.tbgn = panels.zoom.tnul + offset;
    end
end
if dofull
    panels.zoom.tbgn = panels.zoom.tnul;
    panels.zoom.tlst = panels.zoom.tend;
end
showdaqpars;

function [start,eind] = getdaqpars
global panels
if panels.zoom.tlst<=panels.zoom.tbgn
    panels.zoom.tbgn = panels.zoom.tnul;
    panels.zoom.tlst = panels.zoom.tend;
    showdaqpars;
    drawnow();
end
start = panels.zoom.tbgn;
eind  = panels.zoom.tlst;

function setdaqpars(tstart,teinde) 
global panels
maxduur = panels.zoom.tend - panels.zoom.tnul;
newduur = min(maxduur,teinde-tstart);
if (teinde<tstart) || (tstart>panels.zoom.tend)
    tstart = panels.zoom.tnul;
    teinde = panels.zoom.tend;
elseif (tstart~=panels.zoom.tbgn) || (teinde~=panels.zoom.tlst)
    if tstart<panels.zoom.tnul
        tstart = panels.zoom.tnul;
        teinde = panels.zoom.tbgn + newduur;
    end
    if teinde>panels.zoom.tend
        teinde = panels.zoom.tend;
        tstart = panels.zoom.tend - newduur;
    end
else
    newduur = min([newduur,maxduur]);
    teinde = min(panels.zoom.tend, panels.zoom.tbgn + newduur);
    tstart = teinde - newduur;
end
panels.zoom.tbgn = tstart;
panels.zoom.tlst = teinde;
showdaqpars;
drawnow();

function Zoomstackclear(CMD)
global spots
spots = [];
set(CMD.zoomrestore,'String','Restore');
drawnow

function Zoomstack(CMD)
global spots
[start,finish] = getdaqpars;
spot.start   = start;
spot.finish  = finish;
spots{end+1} = spot;
if length(spots)>100, spots{1} = []; end
set(CMD.zoomrestore,'String',sprintf('stk %02u',length(spots)));
%
% ====== Events ==================================================
%
function showevents(channels,offsets)
global panels events
DB = getPANEL('DBpanel');
if isempty(DB) || ~get(DB.showall,'Value'), return; end
xlims = get(gca,'XLim')*panels.timegain;
ylims = get(gca,'YLim');
evtbgn = find( (events.evt.filenr'==panels.filenr) & (events.evt.first'>=xlims(1)) & (events.evt.first'<=xlims(2)));
evtend = find( (events.evt.filenr'==panels.filenr) & (events.evt.last' >=xlims(1)) & (events.evt.last' <=xlims(2)));
if isempty(evtbgn) && isempty(evtend), return; end
evts = unique([evtbgn, evtend]);
dy = abs(offsets(2)-offsets(1));
for jj = 1:min(50,length(evts))
    nr = evts(jj);
    t1 = max(xlims(1), events.evt.first(nr))/panels.timegain;
    t2 = min(xlims(2), events.evt.last (nr))/panels.timegain;
    kannr = events.evt.kanaal(nr);
    filnr = events.evt.filenr(nr);
    ratnr = events.evt.ratnr(nr);
    clsnr = events.evt.clsnr(nr); if ~events.class.dsp(clsnr), continue; end
    amp = dy*(0.15 + clsnr * 0.05);
    if events.class.grp(clsnr)
        kans  = find(events.rats.index(filnr,:)==ratnr);
        [C,IA,IB] = intersect(kans,channels);
        if isempty(IB), continue; end
        yys = offsets(IB);
        y1 = max(yys)+amp;
        y2 = min(yys)-amp;
    else
        IB = find(channels==kannr);
        if isempty(IB), continue; end
        y1 = offsets(IB)+amp;
        y2 = offsets(IB)-amp;
    end
    kleur = events.class.clr(clsnr,1:3);
    waar = 'middle';
    switch events.class.mod(clsnr)
        case 1    % modus is 1 line t1 t2
            line([t1 t1],[y1 y2],'Color',kleur,'LineStyle','-','LineWidth',2.0,'ButtonDownFcn',{@Eventklik,nr});
        case 2    % modus is two lines
            line([t1 t1 NaN t2 t2 NaN t1 t2],[y1 y2 NaN y1 y2 NaN 0.5*(y1+y2)*[1 1]],'Color',kleur,'LineStyle','-','LineWidth',1.0,'ButtonDownFcn',{@Eventklik,nr});
        case 3    % modus is patch
            patch([t1 t1 t2 t2 t1],[y1 y2 y2 y1 y1],kleur,'edgecolor',[0 0 0],'lIneWidth',0.5,'ButtonDownFcn',{@Eventklik,nr});
            waar = 'bottom';
    end
    text(t1,y1,sprintf(' %u',events.evt.key(nr)),'Interpreter','none','VerticalAlignment',waar,'Color','b','FontSize',10,'Fontname','Courier');
end
correctorder(gca);

function showeventdata(DB,eventnr)
global panels events
if eventnr>length(events.evt.first), return; end
set(DB.nr,   'String', sprintf('%u',eventnr));
set(DB.key,  'String', sprintf('%u', events.evt.key(eventnr)));
set(DB.left, 'String', sprintf('%0.2f', events.evt.first(eventnr)/panels.timegain), 'Value', events.evt.first(eventnr),'Visible','On');
set(DB.right,'String', sprintf('%0.2f', events.evt.last(eventnr) /panels.timegain), 'Value', events.evt.last(eventnr), 'Visible','On');
set(DB.segnr,'String', sprintf('%u', panels.segnr));
set(DB.grp,  'String', sprintf('%s', events.rats.name{events.evt.ratnr(eventnr)}));
set(DB.chn,  'String', sprintf('%u', events.evt.kanaal(eventnr)));
set(DB.filnr,'String', sprintf('%u', events.evt.filenr(eventnr)));
DB.select.Value = find(DB.select.UserData==events.evt.ratnr(eventnr));
clsnr = events.evt.clsnr(eventnr);
if events.class.mod(clsnr)==3
    set(DB.class,'Value',clsnr, 'ForegroundColor','k','BackgroundColor',events.class.clr(clsnr,:));
else
    set(DB.class,'Value',clsnr, 'ForegroundColor',events.class.clr(clsnr,:),'BackgroundColor','w');
end
if isnan(events.evt.amp(eventnr))
    set([DB.partxt,DB.parval],'Visible','Off');
else
    set([DB.partxt,DB.parval],'Visible','On');
    set(DB.parval,'String', sprintf('%4.2f', events.evt.amp(eventnr)));
    set(DB.partxt,'String',events.class.txt{clsnr});
end
hlp = datevec(events.files.time(events.evt.filenr(eventnr),1) + events.evt.first(eventnr) / (24*60*60*1000));
CMD = getPANEL('CMDpanel');
set(CMD.clock,'String',sprintf('%02u-%02u-%02u %02u:%02u:%0.3f',hlp(1)-2000,hlp(2),hlp(3),hlp(4),hlp(5),hlp(6)));

function EventShow(varargin)
global SEL events
if isempty(events.evt.first), return; end
eventmax = length(events.evt.first);
DB = getPANEL('DBpanel');
if nargin>0
    eventnr = min(eventmax,max(1,varargin{1}));
    set(DB.nr,'String',sprintf('%u',eventnr));
else
    eventnr = min(eventmax,max(1,str2double(get(DB.nr,'String'))));
end
if (eventnr<1)||(eventnr>eventmax), return; end
showeventdata(DB,eventnr);
filetime = events.evt.first(eventnr);
filenr   = events.evt.filenr(eventnr);
segments = find(events.sgmt.filenr == filenr);
segnr    = find((events.sgmt.start(segments)<=filetime) & (events.sgmt.eind(segments)>=filetime));
MemoryUpdate(filenr,segnr);
if Error, return; end
NRNtimeline;
if KnobIsRed(SEL.follow)
    set(SEL.sth,'Value',0);
    ratnr = events.evt.ratnr(eventnr);
    set(SEL.sth(ratnr),'Value',1);
end
delta = events.evt.last(eventnr)-events.evt.first(eventnr);
txt = DB.marlft.String;
loc = strfind(txt,'%');
if isempty(loc)
    bgn = events.evt.first(eventnr) - DB.marlft.Value;
else
    txt(loc) = [];
    bgn = events.evt.first(eventnr) - 0.01 * str2double(txt) * delta;
end
txt = get(DB.marrgt,'String');
loc = strfind(txt,'%');
if isempty(loc)
    lst = events.evt.last(eventnr) + DB.marrgt.Value;
else
    txt(loc) = [];
    lst = events.evt.last(eventnr) + 0.01 * str2double(txt) * delta;
end
setdaqpars(bgn,lst);
Redraw;

function Eventklik(~,~,eventnr)
EventShow(eventnr);
%
% ====== Convert data formats moved to mysubs   ===================================
%
function [writedir,readdir] = makenewdir(filename,varargin)
if nargin==2, dirtxt = varargin{1}; else,dirtxt = 'new'; end
filedir  = fileparts(filename);
readdir  = [filedir filesep];
writedir = [filedir filesep dirtxt];
[succes,message] = mkdir(writedir);
if succes
    writedir = [writedir filesep];
else
    Error(sprintf('%s\n%s',message,writedir));
end

function definechannel(daq, met, chn, unitrange, units, cname, group, color)
global DAQ Meting
Meting(met).ADC.scale(chn).Units = units;
Meting(met).ADC.scale(chn).User  = unitrange;
if isempty(cname)
    if isempty(DAQ)
        cname = sprintf('chn-%u',chn);
    else
        cname = DAQ(daq).ADC.scale(chn).Name;
    end
end
if isempty(color)
    if isempty(DAQ)
        color = 'k';
    else
        color = DAQ(daq).ADC.scale(chn).Color;
    end
end
grp    = 0;
subgrp = 0;
if ~isempty(group)
    grp = group(1);
    if length(group)>1, subgrp = group(2); else,subgrp = 1; end
elseif ~isempty(DAQ)
    grp = DAQ(daq).ADC.scale(chn).Group;
    subgrp = DAQ(daq).ADC.scale(chn).Subgroup;
end
Meting(met).ADC.scale(chn).Name     = cname;
Meting(met).ADC.scale(chn).Group    = grp;
Meting(met).ADC.scale(chn).Subgroup = subgrp;
Meting(met).ADC.scale(chn).Color    = color;

function convertceline
global Meting panels events 
events.class.nam = {'none';'artefact';'long seizure';'short seizure'};
writedir = makenewdir(panels.file.name,'convert');
if Error, return; end
[~,filename] = fileparts(panels.file.name);
Waitbar(CMD,'show',0,sprintf('Convert: %s',filename));
seps1  = strfind(filename,'&');
seps2  = strfind(filename,'_');
seps   = [0 seps1 seps2(1)];
groups = [];
color  = [];
removes = [];
kleur  ='rbmcgyk';
numchannels = 0;
panels.zoom.tnul = 0;
for jj = 1:length(seps)-1
    txt = filename((seps(jj)+1):(seps(jj+1)-1));
    if ~contains(txt,'FS0')
        chname{numchannels+1} = [txt(1:end-4) '-' txt(end-3:end-2)];
        chname{numchannels+2} = [txt(1:end-4) '-' txt(end-1:end)];
    else
        removes = [removes numchannels+1 numchannels+2];
        chname{numchannels+1} = 'xx';
        chname{numchannels+2} = 'xx';
    end
    groups = [groups jj jj];
    color  = [color kleur(jj) kleur(jj)];
    numchannels = numchannels + 2;
end
Meting = MetingIni([],'Celine-converted','eegs');
[fid,message] = fopen(panels.file.name);
if ~isempty(message), Error(sprintf('%s\n%s',message,panel.file.name)); return; end
TAB    = char(9);
while true
    S = fgetl(fid); 
    if (S == -1), break; end
    Daar = strfind(S,TAB);
    if contains(S,'Interval')
        Meting(1).ADC.rate = 1/str2double(S((Daar(1)+1):(end-1)));
    elseif contains(S,'ExcelDateTime')
        Meting(1).abstime = datenum(S((Daar(2)+1):end));        
    elseif contains(S,'TimeFormat')

    elseif contains(S,'ChannelTitle')
        if length(Daar)~=numchannels
            Message('Incorrect # channels');
            numchannels = length(Daar);
            removes(removes>numchannels) = [];
        end
    elseif contains(S,'Range')
        Meting(1).ADC.HWchn = 1:numchannels;
        formats = '%*s';
        for chn=1:numchannels
            formats = [formats '%f'];
            definechannel(1,1,chn,panels.file.scale,panels.file.unit,chname{chn},groups(chn),color(chn));
        end
        formats = [formats '%s'];
        Meting(1).dac = [];
        Waitbar(CMD,'show',0.25);
        ss = textscan(fid,formats,'delimiter',TAB);
        Waitbar(CMD,'show',0.50);
        Meting(1).adc = zeros(length(ss{1,2}),numchannels,'int16');
        for ii = 1:numchannels
            if strcmp(chname{ii}(end-1:end),'oo'), ts = 0; else,ts = 32767/panels.file.scale; end
            Meting(1).adc(:,ii)= int16(round(ss{1,ii}*ts));
        end
        commentlines = find(strcmp(ss{1,numchannels+1},'')==0);
        for ii = 1:length(commentlines)
            delijn = commentlines(ii);
            comment = ss{1,numchannels+1}{delijn};
            hlp =strfind(comment,'#');
            chnl = 0;
            grps = 0;
            if ~isempty(hlp) && ~isnan(str2double(comment(hlp(1)+1)))
                chnl = nsingle(comment(hlp(1)+1));
                grps = groups(chnl);
            end
            events.evt.first(ii,1)  = delijn*1000/Meting(1).ADC.rate;
            events.evt.last(ii,1)   = delijn*1000/Meting(1).ADC.rate;
            events.evt.kanaal(ii,1) = chnl;
            events.evt.ratnr(ii,1)  = grps;
            events.evt.clsnr(ii,1)  = 1;
        end
        Waitbar(CMD,'show',0.75);
        break;
    else
        break;
    end
end
fclose(fid);
if ~isempty(removes)
    for jj=1:length(Meting)
        Meting(jj).adc(:,removes)      = [];
        Meting(jj).ADC.HWchn(removes) = [];
        Meting(jj).ADC.scale(removes)   = [];
    end
end
Waitbar(CMD,'show',0.9);
panels.file.name = fullfile(writedir,[filename '.mat']);
save(panels.file.name,'Meting','-V6');
[filepath,filename] = fileparts(panels.file.name);
save(fullfile(filepath,[filename '-Celine-event.mat']),'events');
Waitbar(CMD,'hide');
%
% ====== Klok / sheduler management =======================================
%
function Clock_Show(CMD,tijd,maxval)
if maxval == 0
    T0 = datevec(tijd);
else
    T0 = datevec(maxval-tijd);
end
set(CMD.ClockTime,'String',sprintf('%02u:%02u:%05.2f',T0(4),T0(5),T0(6)));

function Clock_tik(~,~,CMD)
Clock_Show(CMD,now()-get(CMD.ClockTime,'UserData'),0)

function Clock_Start(CMD)
set(CMD.ClockTime,'ForegroundColor','k','UserData',now());

function Clock_Stop(CMD)
set(CMD.ClockTime,'ForegroundColor','k','UserData',0);

function Clock_Callback(hObject,~)
global panels
if hObject==CMD.ClockKnob
    if get(CMD.ClockTime,'UserData')==0
        detimer = timer('TimerFcn',     {@Clock_tik,CMD},...
                        'ExecutionMode','fixedRate',...
                        'BusyMode',     'drop',...
                        'Name',         'Schermklok',...
                        'Tag',          'MYKLOK',...
                        'Period',       0.1,...
                        'Startdelay',   panels.timer.delay);
        Clock_Start(CMD)
        start(detimer);
    else
        Clock_Stop(CMD)
        hObject = timerfind('Tag','MYKLOK');
        stop(hObject);
        delete(hObject);
        naam = get(hObject,'Tag');
        clear naam
    end
end

function DoSegment_Split(parms)
global Meting panels events
segmin = nsingle(parms{1});
[~,newname,extstr] = fileparts(panels.file.name);
kk       = strfind(panels.file.name,filesep);
readdir  = panels.file.name(1:kk(end));
writedir = [readdir 'new'];
[succes,message] = mkdir(writedir);
if ~succes, Error(sprintf('%s\n%s',message,writedir)); return; end
writedir = [writedir filesep];
newname = newname(1:end-4);
segcnt  = 1;
seglen  = length(Meting(1).SEGMENT.name);
srate   = Meting(1).ADC.rate;
splitlist = sort([events.evt.first events.evt.last Meting(1).SEGMENT.start' Meting(1).SEGMENT.eind'])';
ButtonName = questdlg(sprintf('Split this file in %u segments >%4.1f s',length(splitlist),segmin),'Confirm Split','Yes','No','No');
if strcmp(ButtonName,'No'), return; end
for jj = 1:seglen
    MemoryUpdate(panels.filenr,jj);
    splits  = (splitlist>Meting(1).SEGMENT.start(panels.segnr)) & (splitlist<Meting(1).SEGMENT.eind(panels.segnr));
    kk = [Meting(1).SEGMENT.start(panels.segnr); splitlist(splits); Meting(1).SEGMENT.eind(panels.segnr)];
    numseg = length(kk);
    if numseg>2
        for jj = 1:(numseg-1)
            Waitbar(CMD,'show',jj/(numseg-1),sprintf('Splitting nr %u of %u in segment %u',jj,numseg,panels.segnr));
            if (kk(jj+1)-kk(jj))>segmin
                filestart = 1+round((kk(jj)  -panels.zoom.tnul)*srate);
                fileeind  = 1+round((kk(jj+1)-panels.zoom.tnul)*srate);
                filename  = sprintf('%s%04u',newname,segcnt);
                hlp.SEGMENT.cmt {segcnt,1}  = Meting(1).SEGMENT.cmt{1,1};
                hlp.SEGMENT.name {segcnt,1} = [filename '.SEG'];
                hlp.SEGMENT.time (segcnt,1) = Meting(1).SEGMENT.time(1) + (kk(jj)/(24*60*60));
                hlp.SEGMENT.start(segcnt,1) = kk(jj);
                hlp.SEGMENT.eind (segcnt,1) = kk(jj+1);
                segcnt = segcnt + 1;
                [fid,message] = fopen([writedir filename '.SEG'],'w');
                if ~isempty(message), Error(sprintf('%s\n%s',message,filename)); return; end
                fwrite(fid, Meting(1).adc(filestart:fileeind,:)','integer*2');
                fclose(fid);
            end
        end
    end
    Waitbar(CMD,'hide');
end
Meting(1).SEGMENT.cmt   = [];
Meting(1).SEGMENT.cmt   = hlp.SEGMENT.cmt;
Meting(1).SEGMENT.name  = [];
Meting(1).SEGMENT.name  = hlp.SEGMENT.name;
Meting(1).SEGMENT.time  = [];
Meting(1).SEGMENT.time  = hlp.SEGMENT.time;
Meting(1).SEGMENT.start = [];
Meting(1).SEGMENT.start = hlp.SEGMENT.start;
Meting(1).SEGMENT.eind  = [];
Meting(1).SEGMENT.eind  = hlp.SEGMENT.eind;
panels.file.name = [writedir newname '0000' extstr];
save(panels.file.name,'Meting','-v6');
panels.segnr = 1;
Redraw(1)
%
% ====== run a superset of tests (my long stretch) ======================== 
%
function superanswer(~,~,answer)
global panels
panels.position = get(gcf,'Position'); 
if isempty(panels.wh)||(nargin<3)||(answer==0)
    panels.super.ans = 0;
    panels.wh=[];
    delete(gcf);
    uiresume();
else
    panels.super.ans = answer;
    uiresume();
    if isempty(intersect([0 1 2],answer))
        panels.wh=[];
        delete(gcf);
    end
end

function supercmd(stxt)
global panels
if isempty(panels.wh)
    if isempty(panels.position)
        daaro = [round(panels.primair(1)+panels.primair(3)/2) round(panels.primair(2)+panels.primair(4)/2) 640 60];
    else
        daaro = panels.position;
    end
    panels.wh(1) = figure('Toolbar','none','IntegerHandle','off','Menubar','none','NumberTitle','Off','Position',daaro,...
                          'CloseRequestFcn',{@superanswer,0},'Resize','Off','Name','  Define flow in Superset');
    panels.wh(2) = uicontrol('String', stxt,        'Units','pixels','Position',[10 35 620 20],'Style','text');
    panels.wh(3) = uicontrol('String','Abort',      'Units','pixels','Position',[010 5 70 25],'Callback',{@superanswer,0});
    panels.wh(4) = uicontrol('String','Choose',     'Units','pixels','Position',[085 5 70 25],'Callback',{@superanswer,1});
    panels.wh(5) = uicontrol('String','Run-All',    'Units','pixels','Position',[175 5 70 25],'Callback',{@superanswer,2});
    panels.wh(10)= uicontrol('String','Continue',   'Units','pixels','Position',[250 5 70 25],'Callback',{@superanswer,7});
    panels.wh(8) = uicontrol('String','Run-to-Ask', 'Units','pixels','Position',[325 5 70 25],'Callback',{@superanswer,5});
    panels.wh(9) = uicontrol('String','Skip-to-Ask','Units','pixels','Position',[400 5 70 25],'Callback',{@superanswer,6});
    panels.wh(6) = uicontrol('String','Step-1',     'Units','pixels','Position',[485 5 70 25],'Callback',{@superanswer,3});
    panels.wh(7) = uicontrol('String','Skip-1',     'Units','pixels','Position',[560 5 70 25],'Callback',{@superanswer,4});
else
    figure(panels.wh(1));
    set(panels.wh(2),'String',stxt);
end
DoMusic(2);
uiwait(panels.wh(1));
figure(panels.root);

function superchoice(hObject,~)
global panels
panels.super.ans = 0;
if strcmp(get(hObject,'Type'),'figure')
    handle = hObject;
else
    panels.super.ans = get(hObject,'Value');
    handle = get(hObject,'Parent');
end
try delete(handle); catch, end
uiresume();

function Select3(parms)
global SEL
set(SEL.select3,'String',ssingle(parms{1})); 

function SuperSet(hObject)
global panels knobs p Memoryset Meting SEL
CMD = getPANEL('CMDpanel');
Error("clear","Super");
supername = 'C:\wytse\MatLab\mfiles\Neuron\SuperScript.txt';
fid = fopen(supername,'r');
if fid<0
    [filename,filepath] = uigetfile('*.txt','Select a super file','');
    if filename==0, return; end
    supername = fullfile(filepath,filename);
    [fid,message] = fopen(supername,'r');
    if ~isempty(message), Error(sprintf("%s\n%s",message,supername)); return; end
end
Memoryset = [];
Meting    = [];
NRNtimeline;
super = textscan(fid,'%s','delimiter','\n','whitespace','');
super = super{1,1};
useAsk  = true;
nextask = false;
doskip  = false;
protocolroot = [cd filesep 'protocols' filesep];
scriptroot   = [cd filesep 'scripts' filesep];
ii=0;
while ii<length(super)
    ii = ii + 1;
    panels.last.cmd = super{ii};
    drawnow;
    SetMenu(super{ii});
	if ~syntax(super{ii}), break; end
    [cmd,parms]=ParseCmd(super{ii});
    nparms = length(parms);
    if (strcmp(cmd,'Ask') || nextask) && useAsk
        supercmd(panels.last.cmd);
        nextask = false;
        doskip  = false; 
        switch panels.super.ans
            case 0, break
            case 1, cmd = 'Choose'; nparms = 0;
            case 2, useAsk = false;
            case 3, nextask = true;
            case 4, nextask = true;  doskip = true;                
            case 6, doskip = true;
            case 7, useAsk = false;
            otherwise
        end
    end
    if doskip || isempty(cmd)|| strcmp(cmd(1),'!'), continue; end
    switch cmd
        case {'';'Ask'}
        case 'Done',        break;
        case 'Hold',        DoMusic(5); uiwait(msgbox('CONTINUE','modal'));
        case 'SetWait',     CMD.pause.String = ssingle(parms{1});
        case 'SkipWait',    CMD.scriptwait.Value = getboolean(parms,true);
        case 'Fast',        CMD.noshow.Value = 1; KnobRed(CMD.noshow);
        case 'Wait',        if isempty(parms), DoTestwait(parms); else, DoTestwait(rsingle(parms{1})); end            
        case 'Offline',     Setonlinemode(false);
        case 'Online',      if panels.online
                                Setonlinemode(true);
                            else
                                Error('You need to be online for this command');
                                panels.super.abort = true;
                            end
        case 'Skip',        if isempty(parms), SkipOn(CMD); else, SkipOff(CMD,rsingle(parms{1})); end
        case 'Autohide',    CMD.autohide.Value = getboolean(parms,true);
        case 'SysClear',    panels.NRNabort         = false;
                            panels.NRNbusy          = false;
                            panels.stacker          = [];
                            panels.stacker(1).win   = {'9';'0';'0';'0'};
                            panels.stacker(1).txt   = {'adc';'adc';'dac';'dac'};
                            panels.stacker(1).valid = {1; 1; 1; 1;};
                            cmdstackpull;
                            IMGini(true);
                            p = [];
                            Meting = [];
                            ClosePanel('MEApanel','STATpanel','SELpanel','DBpanel','STMpanel');
                            MemoryUpdate;
                            WindowClear;
                            Waitbar(CMD,'hide');
        case 'Select3',     if ~isempty(SEL), Select3(parms); end
        case 'RunSelect1',  panels.run.select1 = nsingle(parms{1});
        case 'RunSelect2',  panels.run.select2 = nsingle(parms{1});
        case 'ProtocolRoot',protocolroot = unifile(ssingle(parms{1}));
        case 'ProtocolLoad',panels.file.proto = fullfile(protocolroot,unifile(ssingle(parms{1})));
                            CMDonline(CMD,CMD.ProtocolLoad,true);
        case 'ScriptLoad',  panels.file.script = fullfile(scriptroot,unifile(ssingle(parms{1})));
                            CMDoffline(CMD,CMD.ScriptLoad,true);
        case 'ScriptRoot',  scriptroot = unifile(ssingle(parms{1}));
        case 'DataRoot',    panels.file.root = unifile(ssingle(parms{1}));
        case 'FileLoad',    loaddata([],parms);
        case 'CellLoad',    parms{end+1} = 'cell'; loaddata([],parms);
        case 'DirLoad',     parms{end+1} = 'dir';  loaddata([],parms);
        case 'Filenr',      fileindex = nsingle(parms{1}); MemoryUpdate(fileindex,1);
                            [~,hlpname] = fileparts(Memoryset{fileindex}.Meting(1).filename);
                            SetMenu(sprintf('File: %s',hlpname));
                            Redraw(1);
        case 'DirSave',     if nparms>0
                                panels.file.savepath = unifile(ssingle(parms{1}));
                            else
                                panels.file.savepath = [];
                            end
                            Checksavedirectory;
                            set(CMD.Autosave,'Value',1);
                            KnobGrey(CMD.Savedata);
                            set(CMD.Savedata,'Visible','off');
        case 'Panel',       notdone = true;
                            while notdone && ~isempty(parms)
                                notdone = false;
                                [parms,present,ps] = ParseSpecial(parms,'close');
                                if present
                                    notdone = true;
                                    hh1 = get(gcf,'Children');
                                    hh2 = find(strcmp(get(hh1,'tag'),ssingle(ps{1})));
                                    if ~isempty(hh2), delete(hh1(hh2)); end
                                end
                            end
        case 'Choose',      mainfig  = gcbf;
                            vraag = [];
                            index = [];
                            for jj=1:length(super)
                                if strfind(super{jj},'Ask')
                                    vraag{end+1} = super{jj};
                                    index = [index jj];
                                end
                            end
                            index = [index length(super)];
                            brd   =  8 * 60;
                            hgt   = 15 * length(vraag); 
                            post  = [round(panels.primair(1)+(panels.primair(3)-brd-16)/2) ...
                                     round(panels.primair(2)+(panels.primair(4)-hgt-44)/2) ...
                                     brd+8 hgt+8];
                            handle = figure('Toolbar','none','IntegerHandle','off','Menubar','none','NumberTitle','Off','Position',post,...
                                            'CloseRequestFcn',{@superchoice},'Resize','Off','Name','  Choose one');
                            uicontrol('Style','Listbox','String',vraag,'Fontsize',10,'Fontname','Courier',...
                                      'Units','pixels','Position',[4 4 brd hgt],'Callback',{@superchoice});
                            uiwait(handle);
                            figure(panels.root);
                            if panels.super.ans>0
                                ii = (index(panels.super.ans));
                                nextask = false;
                                doskip = false;
                            else
                                break;
                            end
        case 'Runall',      useAsk  = false;
                            nextask = false;
                            doskip  = false;
        case 'Run',         demacro = ssingle(parms{1});
                            knoppen = find(strcmp(knobs.knobcmd,demacro));
                            if isempty(knoppen), Error(sprintf('Cmd %s does not exist',demacro)); break; end
                            for knop = knoppen
                                if panels.super.abort, break; end
                                if KnobIsRed(hObject)
                                    SetMenu(sprintf('run script: %s',demacro));
                                    run_script(CMD.keys(knop),[]);
                                    KnobGrey(CMD.keys(knop));
                                end
                            end
        otherwise
            if strcmp(questdlg(sprintf('Command\n %s\n does not exist',cmd),'Break Super','Ignore','Exit','Ignore'),'Exit')
                break;
            end
    end
    if panels.abort || panels.super.abort || ~KnobIsRed(hObject) || Error, break; end 
end
SetMenu("version");
if ~isempty(panels.wh)
    figure(panels.wh(1));
    panels.wh = [];
    delete(gcf);
end
Error("box");
KnobGrey(hObject);

% function steps = RoundSteps(minval,maxval,numstep)
% if numstep==1
%     steps = minval;
% elseif (maxval==minval)
%     steps = minval*ones(numstep,1);
% else
%     steps = round(minval + [0:1/(numstep-1):1] *(maxval-minval));
% end

% function ampset = MakeAmps(set1,set2,varargin)
% dosort = false;
% if nargin>2
%     hlp = varargin;
%     [hlp, dosort] = ParseSpecial(hlp,'sort');
% end
% ampset = [];
% EP = getPANEL('EPpanel');
% if ~isempty(EP)
%     amin = EP.stim.min(1);
%     for jj = 1:length(set1)
%         ampset(end+1,1) = max(0,min(EP.stim.full(1),amin + set1(jj)*(EP.stim.max(1)-amin)/100));
%     end
%     amin = EP.stim.min(2);
%     for jj = 1:length(set2)
%         ampset(end+1,1) = max(0,min(EP.stim.full(2),amin + set2(jj)*(EP.stim.max(2)-amin)/100));
%     end
%     if dosort
%         ampset = sort(ampset);
%     end
% end

% function doExecute(macros)
% global p
% if ~isempty(macros)
%     macros = string(macros);
%     for jj = 1:length(macros)
%         [cmd,~]  = ParseCmd(macros(jj));
%         if contains(string(cmd),"=")
%             try  
%                 eval(macros(jj)+";");
%             catch
%                 Error(sprintf("Cannot evaluate of\n%s\nmemory set error",macros(jj)+";")); break;
%             end
%         else
%             Script_Run("Mem set string",macros(jj));
%         end
%     end
% end

% function evaluate(terms)
% global p
% for jj = 1:length(terms)
%     try  
%         eval([terms{jj} ';']);
%     catch
%         Error(sprintf('Error in evaluation of\n%s\ndirect MATLAB error',terms{jj})); break;
%     end
% end

% function doBaspars(parms)
% global panels
% filename = ssingle(parms{1});
% parameters = CmdFile(filename,[],true);   pas op!
% if Error, return; end
% [parameters,present] = ParseSpecial(parameters,'Defclear');
% if present, panels.pars = struct('basis',[],'overule',[],'channel',[]); end
% [parameters,present,panels.pars.basis]= ParseSpecial(parameters,'Defbasis');
% evaluate(panels.pars.basis);
% present = true;
% while present
%     [parameters,present,ps] = ParseSpecial(parameters,'Defchannel');
%     if present
%         channel = nsingle(ps{1});
%         for jj = 2:length(ps), panels.pars.channel{channel,jj-1} = ps{jj}; end
%     end
% end
% if length(parms)>1
%     channel = nsingle(parms{2});
%     if (channel<=size(panels.pars.channel,1)) && ~isempty(panels.pars.channel{channel,1})
%         evaluate(panels.pars.channel(channel,:));
%     end
% end
